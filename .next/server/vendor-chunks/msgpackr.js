"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(rsc)/./node_modules/msgpackr/iterators.js":
/*!********************************************!*\
  !*** ./node_modules/msgpackr/iterators.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeIter: () => (/* binding */ decodeIter),\n/* harmony export */   encodeIter: () => (/* binding */ encodeIter),\n/* harmony export */   packIter: () => (/* binding */ packIter),\n/* harmony export */   unpackIter: () => (/* binding */ unpackIter)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/msgpackr/unpack.js\");\n\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */ function packIter(objectIterator, options = {}) {\n    if (!objectIterator || typeof objectIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable\");\n    } else if (typeof objectIterator[Symbol.iterator] === \"function\") {\n        return packIterSync(objectIterator, options);\n    } else if (typeof objectIterator.then === \"function\" || typeof objectIterator[Symbol.asyncIterator] === \"function\") {\n        return packIterAsync(objectIterator, options);\n    } else {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise\");\n    }\n}\nfunction* packIterSync(objectIterator, options) {\n    const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options);\n    for (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\nasync function* packIterAsync(objectIterator, options) {\n    const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options);\n    for await (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */ function unpackIter(bufferIterator, options = {}) {\n    if (!bufferIterator || typeof bufferIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise\");\n    }\n    const unpackr = new _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr(options);\n    let incomplete;\n    const parser = (chunk)=>{\n        let yields;\n        // if there's incomplete data from previous chunk, concatinate and try again\n        if (incomplete) {\n            chunk = Buffer.concat([\n                incomplete,\n                chunk\n            ]);\n            incomplete = undefined;\n        }\n        try {\n            yields = unpackr.unpackMultiple(chunk);\n        } catch (err) {\n            if (err.incomplete) {\n                incomplete = chunk.slice(err.lastPosition);\n                yields = err.values;\n            } else {\n                throw err;\n            }\n        }\n        return yields;\n    };\n    if (typeof bufferIterator[Symbol.iterator] === \"function\") {\n        return function* iter() {\n            for (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    } else if (typeof bufferIterator[Symbol.asyncIterator] === \"function\") {\n        return async function* iter() {\n            for await (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    }\n}\nconst decodeIter = unpackIter;\nconst encodeIter = packIter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3IvaXRlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUNJO0FBRXJDOzs7Ozs7Q0FNQyxHQUNNLFNBQVNFLFNBQVVDLGNBQWMsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDRCxrQkFBa0IsT0FBT0EsbUJBQW1CLFVBQVU7UUFDekQsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCLE9BQU8sSUFBSSxPQUFPRixjQUFjLENBQUNHLE9BQU9DLFFBQVEsQ0FBQyxLQUFLLFlBQVk7UUFDaEUsT0FBT0MsYUFBYUwsZ0JBQWdCQztJQUN0QyxPQUFPLElBQUksT0FBT0QsZUFBZU0sSUFBSSxLQUFLLGNBQWMsT0FBT04sY0FBYyxDQUFDRyxPQUFPSSxhQUFhLENBQUMsS0FBSyxZQUFZO1FBQ2xILE9BQU9DLGNBQWNSLGdCQUFnQkM7SUFDdkMsT0FBTztRQUNMLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtBQUNGO0FBRUEsVUFBV0csYUFBY0wsY0FBYyxFQUFFQyxPQUFPO0lBQzlDLE1BQU1RLFFBQVEsSUFBSVosMkNBQUtBLENBQUNJO0lBQ3hCLEtBQUssTUFBTVMsU0FBU1YsZUFBZ0I7UUFDbEMsTUFBTVMsTUFBTUUsSUFBSSxDQUFDRDtJQUNuQjtBQUNGO0FBRUEsZ0JBQWlCRixjQUFlUixjQUFjLEVBQUVDLE9BQU87SUFDckQsTUFBTVEsUUFBUSxJQUFJWiwyQ0FBS0EsQ0FBQ0k7SUFDeEIsV0FBVyxNQUFNUyxTQUFTVixlQUFnQjtRQUN4QyxNQUFNUyxNQUFNRSxJQUFJLENBQUNEO0lBQ25CO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTRSxXQUFZQyxjQUFjLEVBQUVaLFVBQVUsQ0FBQyxDQUFDO0lBQ3RELElBQUksQ0FBQ1ksa0JBQWtCLE9BQU9BLG1CQUFtQixVQUFVO1FBQ3pELE1BQU0sSUFBSVgsTUFBTTtJQUNsQjtJQUVBLE1BQU1ZLFVBQVUsSUFBSWhCLCtDQUFPQSxDQUFDRztJQUM1QixJQUFJYztJQUNKLE1BQU1DLFNBQVMsQ0FBQ0M7UUFDZCxJQUFJQztRQUNKLDRFQUE0RTtRQUM1RSxJQUFJSCxZQUFZO1lBQ2RFLFFBQVFFLE9BQU9DLE1BQU0sQ0FBQztnQkFBQ0w7Z0JBQVlFO2FBQU07WUFDekNGLGFBQWFNO1FBQ2Y7UUFFQSxJQUFJO1lBQ0ZILFNBQVNKLFFBQVFRLGNBQWMsQ0FBQ0w7UUFDbEMsRUFBRSxPQUFPTSxLQUFLO1lBQ1osSUFBSUEsSUFBSVIsVUFBVSxFQUFFO2dCQUNsQkEsYUFBYUUsTUFBTU8sS0FBSyxDQUFDRCxJQUFJRSxZQUFZO2dCQUN6Q1AsU0FBU0ssSUFBSUcsTUFBTTtZQUNyQixPQUFPO2dCQUNMLE1BQU1IO1lBQ1I7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFFQSxJQUFJLE9BQU9MLGNBQWMsQ0FBQ1YsT0FBT0MsUUFBUSxDQUFDLEtBQUssWUFBWTtRQUN6RCxPQUFPLFVBQVl1QjtZQUNqQixLQUFLLE1BQU1qQixTQUFTRyxlQUFnQjtnQkFDbEMsT0FBUUcsT0FBT047WUFDakI7UUFDRjtJQUNGLE9BQU8sSUFBSSxPQUFPRyxjQUFjLENBQUNWLE9BQU9JLGFBQWEsQ0FBQyxLQUFLLFlBQVk7UUFDckUsT0FBTyxnQkFBa0JvQjtZQUN2QixXQUFXLE1BQU1qQixTQUFTRyxlQUFnQjtnQkFDeEMsT0FBUUcsT0FBT047WUFDakI7UUFDRjtJQUNGO0FBQ0Y7QUFDTyxNQUFNa0IsYUFBYWhCLFdBQVU7QUFDN0IsTUFBTWlCLGFBQWE5QixTQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9tc2dwYWNrci9pdGVyYXRvcnMuanM/ZWFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWNrciB9IGZyb20gJy4vcGFjay5qcydcbmltcG9ydCB7IFVucGFja3IgfSBmcm9tICcuL3VucGFjay5qcydcblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZSBmaXJzdCBhcmd1bWVudCwgcmV0dXJucyBhbiBJdGVyYWJsZSB3aGVyZSBlYWNoIHZhbHVlIGlzIHBhY2tlZCBhcyBhIEJ1ZmZlclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG9ubHkgQXN5bmMgSXRlcmFibGUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBBc3luYyBJdGVyYWJsZS5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhdG9yfSBvYmplY3RJdGVyYXRvciAtIGl0ZXJhYmxlIHNvdXJjZSwgbGlrZSBhIFJlYWRhYmxlIG9iamVjdCBzdHJlYW0sIGFuIGFycmF5LCBTZXQsIG9yIGN1c3RvbSBvYmplY3RcbiAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIC0gbXNncGFja3IgcGFjayBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3I+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja0l0ZXIgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFvYmplY3RJdGVyYXRvciB8fCB0eXBlb2Ygb2JqZWN0SXRlcmF0b3IgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgb3IgYSBQcm9taXNlIGZvciBhbiBBc3luYyBJdGVyYWJsZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJTeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RJdGVyYXRvci50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJBc3luYyhvYmplY3RJdGVyYXRvciwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgUHJvbWlzZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gKiBwYWNrSXRlclN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpXG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqZWN0SXRlcmF0b3IpIHtcbiAgICB5aWVsZCBwYWNrci5wYWNrKHZhbHVlKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uICogcGFja0l0ZXJBc3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucylcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpXG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZS9JdGVyYXRvciBpbnB1dCB3aGljaCB5aWVsZHMgYnVmZmVycywgcmV0dXJucyBhbiBJdGVyYWJsZUl0ZXJhdG9yIHdoaWNoIHlpZWxkcyBzeW5jIGRlY29kZWQgb2JqZWN0c1xuICogT3IsIGdpdmVuIGFuIEFzeW5jIEl0ZXJhYmxlL0l0ZXJhdG9yIHdoaWNoIHlpZWxkcyBwcm9taXNlcyByZXNvbHZpbmcgaW4gYnVmZmVycywgcmV0dXJucyBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3IuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfSBidWZmZXJJdGVyYXRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIHVucGFja3Igb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrSXRlciAoYnVmZmVySXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWJ1ZmZlckl0ZXJhdG9yIHx8IHR5cGVvZiBidWZmZXJJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgcHJvbWlzZScpXG4gIH1cblxuICBjb25zdCB1bnBhY2tyID0gbmV3IFVucGFja3Iob3B0aW9ucylcbiAgbGV0IGluY29tcGxldGVcbiAgY29uc3QgcGFyc2VyID0gKGNodW5rKSA9PiB7XG4gICAgbGV0IHlpZWxkc1xuICAgIC8vIGlmIHRoZXJlJ3MgaW5jb21wbGV0ZSBkYXRhIGZyb20gcHJldmlvdXMgY2h1bmssIGNvbmNhdGluYXRlIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFtpbmNvbXBsZXRlLCBjaHVua10pXG4gICAgICBpbmNvbXBsZXRlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkcyA9IHVucGFja3IudW5wYWNrTXVsdGlwbGUoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmluY29tcGxldGUpIHtcbiAgICAgICAgaW5jb21wbGV0ZSA9IGNodW5rLnNsaWNlKGVyci5sYXN0UG9zaXRpb24pXG4gICAgICAgIHlpZWxkcyA9IGVyci52YWx1ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geWllbGRzXG4gIH1cblxuICBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgIH0pKClcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAqIGl0ZXIgKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBidWZmZXJJdGVyYXRvcikge1xuICAgICAgICB5aWVsZCAqIHBhcnNlcih2YWx1ZSlcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cbn1cbmV4cG9ydCBjb25zdCBkZWNvZGVJdGVyID0gdW5wYWNrSXRlclxuZXhwb3J0IGNvbnN0IGVuY29kZUl0ZXIgPSBwYWNrSXRlciJdLCJuYW1lcyI6WyJQYWNrciIsIlVucGFja3IiLCJwYWNrSXRlciIsIm9iamVjdEl0ZXJhdG9yIiwib3B0aW9ucyIsIkVycm9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwYWNrSXRlclN5bmMiLCJ0aGVuIiwiYXN5bmNJdGVyYXRvciIsInBhY2tJdGVyQXN5bmMiLCJwYWNrciIsInZhbHVlIiwicGFjayIsInVucGFja0l0ZXIiLCJidWZmZXJJdGVyYXRvciIsInVucGFja3IiLCJpbmNvbXBsZXRlIiwicGFyc2VyIiwiY2h1bmsiLCJ5aWVsZHMiLCJCdWZmZXIiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJ1bnBhY2tNdWx0aXBsZSIsImVyciIsInNsaWNlIiwibGFzdFBvc2l0aW9uIiwidmFsdWVzIiwiaXRlciIsImRlY29kZUl0ZXIiLCJlbmNvZGVJdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/iterators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/msgpackr/node-index.js":
/*!*********************************************!*\
  !*** ./node_modules/msgpackr/node-index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.ALWAYS),\n/* harmony export */   C1: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.C1),\n/* harmony export */   DECIMAL_FIT: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_ROUND),\n/* harmony export */   Decoder: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Decoder),\n/* harmony export */   DecoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   Encoder: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Encoder),\n/* harmony export */   EncoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.NEVER),\n/* harmony export */   Packr: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr),\n/* harmony export */   PackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   Unpackr: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr),\n/* harmony export */   UnpackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   addExtension: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension),\n/* harmony export */   clearSource: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.clearSource),\n/* harmony export */   decode: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   decodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.decodeIter),\n/* harmony export */   encode: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.encode),\n/* harmony export */   encodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.encodeIter),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.isNativeAccelerationEnabled),\n/* harmony export */   mapsAsObjects: () => (/* binding */ mapsAsObjects),\n/* harmony export */   pack: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.pack),\n/* harmony export */   roundFloat32: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.roundFloat32),\n/* harmony export */   unpack: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpack),\n/* harmony export */   unpackMultiple: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpackMultiple),\n/* harmony export */   useRecords: () => (/* binding */ useRecords)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/msgpackr/unpack.js\");\n/* harmony import */ var _struct_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./struct.js */ \"(rsc)/./node_modules/msgpackr/struct.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ \"(rsc)/./node_modules/msgpackr/stream.js\");\n/* harmony import */ var _iterators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iterators.js */ \"(rsc)/./node_modules/msgpackr/iterators.js\");\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! module */ \"module\");\n\n\n\n\n\nconst useRecords = false;\nconst mapsAsObjects = true;\n\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === \"true\";\nif (!nativeAccelerationDisabled) {\n    let extractor;\n    try {\n        if (typeof require == \"function\") extractor = require(\"msgpackr-extract\");\n        else extractor = (0,module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///D:/Web%20dev.%20projects/Travel_Planer/travel_planer/node_modules/msgpackr/node-index.js\")(\"msgpackr-extract\");\n        if (extractor) (0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setExtractor)(extractor.extractStrings);\n    } catch (error) {\n    // native module is optional\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3Ivbm9kZS1pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUg7QUFDMEM7QUFDdkk7QUFDa0c7QUFDL0Q7QUFDaEQsTUFBTXlCLGFBQWEsTUFBSztBQUN4QixNQUFNQyxnQkFBZ0IsS0FBSTtBQUNTO0FBQ0o7QUFFdEMsTUFBTUcsNkJBQTZCQyxRQUFRQyxHQUFHLENBQUNDLHFDQUFxQyxLQUFLQyxhQUFhSCxRQUFRQyxHQUFHLENBQUNDLHFDQUFxQyxDQUFDRSxXQUFXLE9BQU87QUFFMUssSUFBSSxDQUFDTCw0QkFBNEI7SUFDaEMsSUFBSU07SUFDSixJQUFJO1FBQ0gsSUFBSSxPQUFPQyxXQUFXLFlBQ3JCRCxZQUFZQyxRQUFRO2FBRXBCRCxZQUFZUCxxREFBYUEsQ0FBQyxrR0FBZSxFQUFFO1FBQzVDLElBQUlPLFdBQ0hSLHdEQUFZQSxDQUFDUSxVQUFVRyxjQUFjO0lBQ3ZDLEVBQUUsT0FBT0MsT0FBTztJQUNmLDRCQUE0QjtJQUM3QjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9tc2dwYWNrci9ub2RlLWluZGV4LmpzPzg4OTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgUGFja3IsIEVuY29kZXIsIGFkZEV4dGVuc2lvbiwgcGFjaywgZW5jb2RlLCBORVZFUiwgQUxXQVlTLCBERUNJTUFMX1JPVU5ELCBERUNJTUFMX0ZJVCB9IGZyb20gJy4vcGFjay5qcydcbmV4cG9ydCB7IFVucGFja3IsIERlY29kZXIsIEMxLCB1bnBhY2ssIHVucGFja011bHRpcGxlLCBkZWNvZGUsIEZMT0FUMzJfT1BUSU9OUywgY2xlYXJTb3VyY2UsIHJvdW5kRmxvYXQzMiwgaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkIH0gZnJvbSAnLi91bnBhY2suanMnXG5pbXBvcnQgJy4vc3RydWN0LmpzJ1xuZXhwb3J0IHsgUGFja3JTdHJlYW0sIFVucGFja3JTdHJlYW0sIFBhY2tyU3RyZWFtIGFzIEVuY29kZXJTdHJlYW0sIFVucGFja3JTdHJlYW0gYXMgRGVjb2RlclN0cmVhbSB9IGZyb20gJy4vc3RyZWFtLmpzJ1xuZXhwb3J0IHsgZGVjb2RlSXRlciwgZW5jb2RlSXRlciB9IGZyb20gJy4vaXRlcmF0b3JzLmpzJ1xuZXhwb3J0IGNvbnN0IHVzZVJlY29yZHMgPSBmYWxzZVxuZXhwb3J0IGNvbnN0IG1hcHNBc09iamVjdHMgPSB0cnVlXG5pbXBvcnQgeyBzZXRFeHRyYWN0b3IgfSBmcm9tICcuL3VucGFjay5qcydcbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdtb2R1bGUnXG5cbmNvbnN0IG5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkID0gcHJvY2Vzcy5lbnYuTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRCAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuXG5pZiAoIW5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkKSB7XG5cdGxldCBleHRyYWN0b3Jcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJylcblx0XHRcdGV4dHJhY3RvciA9IHJlcXVpcmUoJ21zZ3BhY2tyLWV4dHJhY3QnKVxuXHRcdGVsc2Vcblx0XHRcdGV4dHJhY3RvciA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKSgnbXNncGFja3ItZXh0cmFjdCcpXG5cdFx0aWYgKGV4dHJhY3Rvcilcblx0XHRcdHNldEV4dHJhY3RvcihleHRyYWN0b3IuZXh0cmFjdFN0cmluZ3MpXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gbmF0aXZlIG1vZHVsZSBpcyBvcHRpb25hbFxuXHR9XG59Il0sIm5hbWVzIjpbIlBhY2tyIiwiRW5jb2RlciIsImFkZEV4dGVuc2lvbiIsInBhY2siLCJlbmNvZGUiLCJORVZFUiIsIkFMV0FZUyIsIkRFQ0lNQUxfUk9VTkQiLCJERUNJTUFMX0ZJVCIsIlVucGFja3IiLCJEZWNvZGVyIiwiQzEiLCJ1bnBhY2siLCJ1bnBhY2tNdWx0aXBsZSIsImRlY29kZSIsIkZMT0FUMzJfT1BUSU9OUyIsImNsZWFyU291cmNlIiwicm91bmRGbG9hdDMyIiwiaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkIiwiUGFja3JTdHJlYW0iLCJVbnBhY2tyU3RyZWFtIiwiRW5jb2RlclN0cmVhbSIsIkRlY29kZXJTdHJlYW0iLCJkZWNvZGVJdGVyIiwiZW5jb2RlSXRlciIsInVzZVJlY29yZHMiLCJtYXBzQXNPYmplY3RzIiwic2V0RXh0cmFjdG9yIiwiY3JlYXRlUmVxdWlyZSIsIm5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkIiwicHJvY2VzcyIsImVudiIsIk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsImV4dHJhY3RvciIsInJlcXVpcmUiLCJ1cmwiLCJleHRyYWN0U3RyaW5ncyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/node-index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/msgpackr/pack.js":
/*!***************************************!*\
  !*** ./node_modules/msgpackr/pack.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* binding */ ALWAYS),\n/* harmony export */   DECIMAL_FIT: () => (/* binding */ DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* binding */ DECIMAL_ROUND),\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   Packr: () => (/* binding */ Packr),\n/* harmony export */   RECORD_SYMBOL: () => (/* binding */ RECORD_SYMBOL),\n/* harmony export */   RESERVE_START_SPACE: () => (/* binding */ RESERVE_START_SPACE),\n/* harmony export */   RESET_BUFFER_MODE: () => (/* binding */ RESET_BUFFER_MODE),\n/* harmony export */   REUSE_BUFFER_MODE: () => (/* binding */ REUSE_BUFFER_MODE),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   setWriteStructSlots: () => (/* binding */ setWriteStructSlots)\n/* harmony export */ });\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/msgpackr/unpack.js\");\n\nlet textEncoder;\ntry {\n    textEncoder = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst hasNodeBuffer = typeof Buffer !== \"undefined\";\nconst ByteArrayAllocate = hasNodeBuffer ? function(length) {\n    return Buffer.allocUnsafeSlow(length);\n} : Uint8Array;\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array;\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;\nlet target, keysTarget;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nlet writeStructSlots;\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\n;\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol(\"record-id\");\nclass Packr extends _unpack_js__WEBPACK_IMPORTED_MODULE_0__.Unpackr {\n    constructor(options){\n        super(options);\n        this.offset = 0;\n        let typeBuffer;\n        let start;\n        let hasSharedUpdate;\n        let structures;\n        let referenceMap;\n        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n            return target.utf8Write(string, position, 0xffffffff);\n        } : textEncoder && textEncoder.encodeInto ? function(string, position) {\n            return textEncoder.encodeInto(string, target.subarray(position)).written;\n        } : false;\n        let packr = this;\n        if (!options) options = {};\n        let isSequential = options && options.sequential;\n        let hasSharedStructures = options.structures || options.saveStructures;\n        let maxSharedStructures = options.maxSharedStructures;\n        if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 32 : 0;\n        if (maxSharedStructures > 8160) throw new Error(\"Maximum maxSharedStructure is 8160\");\n        if (options.structuredClone && options.moreTypes == undefined) {\n            this.moreTypes = true;\n        }\n        let maxOwnStructures = options.maxOwnStructures;\n        if (maxOwnStructures == null) maxOwnStructures = hasSharedStructures ? 32 : 64;\n        if (!this.structures && options.useRecords != false) this.structures = [];\n        // two byte record ids for shared structures\n        let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;\n        let sharedLimitId = maxSharedStructures + 0x40;\n        let maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n        if (maxStructureId > 8256) {\n            throw new Error(\"Maximum maxSharedStructure + maxOwnStructure is 8192\");\n        }\n        let recordIdsToRemove = [];\n        let transitionsCount = 0;\n        let serializationsSinceTransitionRebuild = 0;\n        this.pack = this.encode = function(value, encodeOptions) {\n            if (!target) {\n                target = new ByteArrayAllocate(8192);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n                position = 0;\n            }\n            safeEnd = target.length - 10;\n            if (safeEnd - position < 0x800) {\n                // don't start too close to the end, \n                target = new ByteArrayAllocate(target.length);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n                safeEnd = target.length - 10;\n                position = 0;\n            } else position = position + 7 & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n            ;\n            start = position;\n            if (encodeOptions & RESERVE_START_SPACE) position += encodeOptions & 0xff;\n            referenceMap = packr.structuredClone ? new Map() : null;\n            if (packr.bundleStrings && typeof value !== \"string\") {\n                bundledStrings = [];\n                bundledStrings.size = Infinity // force a new bundle start on first string\n                ;\n            } else bundledStrings = null;\n            structures = packr.structures;\n            if (structures) {\n                if (structures.uninitialized) structures = packr._mergeStructures(packr.getStructures());\n                let sharedLength = structures.sharedLength || 0;\n                if (sharedLength > maxSharedStructures) {\n                    //if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n                    throw new Error(\"Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to \" + structures.sharedLength);\n                }\n                if (!structures.transitions) {\n                    // rebuild our structure transitions\n                    structures.transitions = Object.create(null);\n                    for(let i = 0; i < sharedLength; i++){\n                        let keys = structures[i];\n                        if (!keys) continue;\n                        let nextTransition, transition = structures.transitions;\n                        for(let j = 0, l = keys.length; j < l; j++){\n                            let key = keys[j];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                            }\n                            transition = nextTransition;\n                        }\n                        transition[RECORD_SYMBOL] = i + 0x40;\n                    }\n                    this.lastNamedStructuresLength = sharedLength;\n                }\n                if (!isSequential) {\n                    structures.nextId = sharedLength + 0x40;\n                }\n            }\n            if (hasSharedUpdate) hasSharedUpdate = false;\n            let encodingError;\n            try {\n                if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object) writeStruct(value);\n                else pack(value);\n                let lastBundle = bundledStrings;\n                if (bundledStrings) writeBundles(start, pack, 0);\n                if (referenceMap && referenceMap.idsToInsert) {\n                    let idsToInsert = referenceMap.idsToInsert.sort((a, b)=>a.offset > b.offset ? 1 : -1);\n                    let i = idsToInsert.length;\n                    let incrementPosition = -1;\n                    while(lastBundle && i > 0){\n                        let insertionPoint = idsToInsert[--i].offset + start;\n                        if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1) incrementPosition = 0;\n                        if (insertionPoint > lastBundle.position + start) {\n                            if (incrementPosition >= 0) incrementPosition += 6;\n                        } else {\n                            if (incrementPosition >= 0) {\n                                // update the bundle reference now\n                                targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                                incrementPosition = -1; // reset\n                            }\n                            lastBundle = lastBundle.previous;\n                            i++;\n                        }\n                    }\n                    if (incrementPosition >= 0 && lastBundle) {\n                        // update the bundle reference now\n                        targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                    }\n                    position += idsToInsert.length * 6;\n                    if (position > safeEnd) makeRoom(position);\n                    packr.offset = position;\n                    let serialized = insertIds(target.subarray(start, position), idsToInsert);\n                    referenceMap = null;\n                    return serialized;\n                }\n                packr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n                ;\n                if (encodeOptions & REUSE_BUFFER_MODE) {\n                    target.start = start;\n                    target.end = position;\n                    return target;\n                }\n                return target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n                ;\n            } catch (error) {\n                encodingError = error;\n                throw error;\n            } finally{\n                if (structures) {\n                    resetStructures();\n                    if (hasSharedUpdate && packr.saveStructures) {\n                        let sharedLength = structures.sharedLength || 0;\n                        // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n                        let returnBuffer = target.subarray(start, position);\n                        let newSharedData = prepareStructures(structures, packr);\n                        if (!encodingError) {\n                            if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n                                // get updated structures and try again if the update failed\n                                return packr.pack(value, encodeOptions);\n                            }\n                            packr.lastNamedStructuresLength = sharedLength;\n                            return returnBuffer;\n                        }\n                    }\n                }\n                if (encodeOptions & RESET_BUFFER_MODE) position = start;\n            }\n        };\n        const resetStructures = ()=>{\n            if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;\n            let sharedLength = structures.sharedLength || 0;\n            if (structures.length > sharedLength && !isSequential) structures.length = sharedLength;\n            if (transitionsCount > 10000) {\n                // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n                structures.transitions = null;\n                serializationsSinceTransitionRebuild = 0;\n                transitionsCount = 0;\n                if (recordIdsToRemove.length > 0) recordIdsToRemove = [];\n            } else if (recordIdsToRemove.length > 0 && !isSequential) {\n                for(let i = 0, l = recordIdsToRemove.length; i < l; i++){\n                    recordIdsToRemove[i][RECORD_SYMBOL] = 0;\n                }\n                recordIdsToRemove = [];\n            }\n        };\n        const packArray = (value)=>{\n            var length = value.length;\n            if (length < 0x10) {\n                target[position++] = 0x90 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xdc;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdd;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            for(let i = 0; i < length; i++){\n                pack(value[i]);\n            }\n        };\n        const pack = (value)=>{\n            if (position > safeEnd) target = makeRoom(position);\n            var type = typeof value;\n            var length;\n            if (type === \"string\") {\n                let strLength = value.length;\n                if (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n                    if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n                        let extStart;\n                        let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n                        if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                        let lastBundle;\n                        if (bundledStrings.position) {\n                            lastBundle = bundledStrings;\n                            target[position] = 0xc8 // ext 16\n                            ;\n                            position += 3 // reserve for the writing bundle size\n                            ;\n                            target[position++] = 0x62 // 'b'\n                            ;\n                            extStart = position - start;\n                            position += 4 // reserve for writing bundle reference\n                            ;\n                            writeBundles(start, pack, 0) // write the last bundles\n                            ;\n                            targetView.setUint16(extStart + start - 3, position - start - extStart);\n                        } else {\n                            target[position++] = 0xd6 // fixext 4\n                            ;\n                            target[position++] = 0x62 // 'b'\n                            ;\n                            extStart = position - start;\n                            position += 4 // reserve for writing bundle reference\n                            ;\n                        }\n                        bundledStrings = [\n                            \"\",\n                            \"\"\n                        ] // create new ones\n                        ;\n                        bundledStrings.previous = lastBundle;\n                        bundledStrings.size = 0;\n                        bundledStrings.position = extStart;\n                    }\n                    let twoByte = hasNonLatin.test(value);\n                    bundledStrings[twoByte ? 0 : 1] += value;\n                    target[position++] = 0xc1;\n                    pack(twoByte ? -strLength : strLength);\n                    return;\n                }\n                let headerSize;\n                // first we estimate the header size, so we can write to the correct location\n                if (strLength < 0x20) {\n                    headerSize = 1;\n                } else if (strLength < 0x100) {\n                    headerSize = 2;\n                } else if (strLength < 0x10000) {\n                    headerSize = 3;\n                } else {\n                    headerSize = 5;\n                }\n                let maxBytes = strLength * 3;\n                if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                if (strLength < 0x40 || !encodeUtf8) {\n                    let i, c1, c2, strPosition = position + headerSize;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[strPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            target[strPosition++] = c1 >> 6 | 0xc0;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[strPosition++] = c1 >> 18 | 0xf0;\n                            target[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            target[strPosition++] = c1 >> 12 | 0xe0;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                    length = strPosition - position - headerSize;\n                } else {\n                    length = encodeUtf8(value, position + headerSize);\n                }\n                if (length < 0x20) {\n                    target[position++] = 0xa0 | length;\n                } else if (length < 0x100) {\n                    if (headerSize < 2) {\n                        target.copyWithin(position + 2, position + 1, position + 1 + length);\n                    }\n                    target[position++] = 0xd9;\n                    target[position++] = length;\n                } else if (length < 0x10000) {\n                    if (headerSize < 3) {\n                        target.copyWithin(position + 3, position + 2, position + 2 + length);\n                    }\n                    target[position++] = 0xda;\n                    target[position++] = length >> 8;\n                    target[position++] = length & 0xff;\n                } else {\n                    if (headerSize < 5) {\n                        target.copyWithin(position + 5, position + 3, position + 3 + length);\n                    }\n                    target[position++] = 0xdb;\n                    targetView.setUint32(position, length);\n                    position += 4;\n                }\n                position += length;\n            } else if (type === \"number\") {\n                if (value >>> 0 === value) {\n                    // positive uint\n                    if (value < 0x20 || value < 0x80 && this.useRecords === false || value < 0x40 && !this.randomAccessStructure) {\n                        target[position++] = value;\n                    } else if (value < 0x100) {\n                        target[position++] = 0xcc;\n                        target[position++] = value;\n                    } else if (value < 0x10000) {\n                        target[position++] = 0xcd;\n                        target[position++] = value >> 8;\n                        target[position++] = value & 0xff;\n                    } else {\n                        target[position++] = 0xce;\n                        targetView.setUint32(position, value);\n                        position += 4;\n                    }\n                } else if (value >> 0 === value) {\n                    if (value >= -0x20) {\n                        target[position++] = 0x100 + value;\n                    } else if (value >= -0x80) {\n                        target[position++] = 0xd0;\n                        target[position++] = value + 0x100;\n                    } else if (value >= -0x8000) {\n                        target[position++] = 0xd1;\n                        targetView.setInt16(position, value);\n                        position += 2;\n                    } else {\n                        target[position++] = 0xd2;\n                        targetView.setInt32(position, value);\n                        position += 4;\n                    }\n                } else {\n                    let useFloat32;\n                    if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n                        target[position++] = 0xca;\n                        targetView.setFloat32(position, value);\n                        let xShifted;\n                        if (useFloat32 < 4 || (xShifted = value * _unpack_js__WEBPACK_IMPORTED_MODULE_0__.mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {\n                            position += 4;\n                            return;\n                        } else position-- // move back into position for writing a double\n                        ;\n                    }\n                    target[position++] = 0xcb;\n                    targetView.setFloat64(position, value);\n                    position += 8;\n                }\n            } else if (type === \"object\" || type === \"function\") {\n                if (!value) target[position++] = 0xc0;\n                else {\n                    if (referenceMap) {\n                        let referee = referenceMap.get(value);\n                        if (referee) {\n                            if (!referee.id) {\n                                let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n                                referee.id = idsToInsert.push(referee);\n                            }\n                            target[position++] = 0xd6 // fixext 4\n                            ;\n                            target[position++] = 0x70 // \"p\" for pointer\n                            ;\n                            targetView.setUint32(position, referee.id);\n                            position += 4;\n                            return;\n                        } else referenceMap.set(value, {\n                            offset: position - start\n                        });\n                    }\n                    let constructor = value.constructor;\n                    if (constructor === Object) {\n                        writeObject(value, true);\n                    } else if (constructor === Array) {\n                        packArray(value);\n                    } else if (constructor === Map) {\n                        if (this.mapAsEmptyObject) target[position++] = 0x80;\n                        else {\n                            length = value.size;\n                            if (length < 0x10) {\n                                target[position++] = 0x80 | length;\n                            } else if (length < 0x10000) {\n                                target[position++] = 0xde;\n                                target[position++] = length >> 8;\n                                target[position++] = length & 0xff;\n                            } else {\n                                target[position++] = 0xdf;\n                                targetView.setUint32(position, length);\n                                position += 4;\n                            }\n                            for (let [key, entryValue] of value){\n                                pack(key);\n                                pack(entryValue);\n                            }\n                        }\n                    } else {\n                        for(let i = 0, l = extensions.length; i < l; i++){\n                            let extensionClass = extensionClasses[i];\n                            if (value instanceof extensionClass) {\n                                let extension = extensions[i];\n                                if (extension.write) {\n                                    if (extension.type) {\n                                        target[position++] = 0xd4 // one byte \"tag\" extension\n                                        ;\n                                        target[position++] = extension.type;\n                                        target[position++] = 0;\n                                    }\n                                    let writeResult = extension.write.call(this, value);\n                                    if (writeResult === value) {\n                                        if (Array.isArray(value)) {\n                                            packArray(value);\n                                        } else {\n                                            writeObject(value);\n                                        }\n                                    } else {\n                                        pack(writeResult);\n                                    }\n                                    return;\n                                }\n                                let currentTarget = target;\n                                let currentTargetView = targetView;\n                                let currentPosition = position;\n                                target = null;\n                                let result;\n                                try {\n                                    result = extension.pack.call(this, value, (size)=>{\n                                        // restore target and use it\n                                        target = currentTarget;\n                                        currentTarget = null;\n                                        position += size;\n                                        if (position > safeEnd) makeRoom(position);\n                                        return {\n                                            target,\n                                            targetView,\n                                            position: position - size\n                                        };\n                                    }, pack);\n                                } finally{\n                                    // restore current target information (unless already restored)\n                                    if (currentTarget) {\n                                        target = currentTarget;\n                                        targetView = currentTargetView;\n                                        position = currentPosition;\n                                        safeEnd = target.length - 10;\n                                    }\n                                }\n                                if (result) {\n                                    if (result.length + position > safeEnd) makeRoom(result.length + position);\n                                    position = writeExtensionData(result, target, position, extension.type);\n                                }\n                                return;\n                            }\n                        }\n                        // check isArray after extensions, because extensions can extend Array\n                        if (Array.isArray(value)) {\n                            packArray(value);\n                        } else {\n                            // use this as an alternate mechanism for expressing how to serialize\n                            if (value.toJSON) {\n                                const json = value.toJSON();\n                                // if for some reason value.toJSON returns itself it'll loop forever\n                                if (json !== value) return pack(json);\n                            }\n                            // if there is a writeFunction, use it, otherwise just encode as undefined\n                            if (type === \"function\") return pack(this.writeFunction && this.writeFunction(value));\n                            // no extension found, write as object\n                            writeObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n                            ;\n                        }\n                    }\n                }\n            } else if (type === \"boolean\") {\n                target[position++] = value ? 0xc3 : 0xc2;\n            } else if (type === \"bigint\") {\n                if (value < BigInt(1) << BigInt(63) && value >= -(BigInt(1) << BigInt(63))) {\n                    // use a signed int as long as it fits\n                    target[position++] = 0xd3;\n                    targetView.setBigInt64(position, value);\n                } else if (value < BigInt(1) << BigInt(64) && value > 0) {\n                    // if we can fit an unsigned int, use that\n                    target[position++] = 0xcf;\n                    targetView.setBigUint64(position, value);\n                } else {\n                    // overflow\n                    if (this.largeBigIntToFloat) {\n                        target[position++] = 0xcb;\n                        targetView.setFloat64(position, Number(value));\n                    } else if (this.useBigIntExtension && value < 2n ** 1023n && value > -(2n ** 1023n)) {\n                        target[position++] = 0xc7;\n                        position++;\n                        target[position++] = 0x42 // \"B\" for BigInt\n                        ;\n                        let bytes = [];\n                        let alignedSign;\n                        do {\n                            let byte = value & 0xffn;\n                            alignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n                            bytes.push(byte);\n                            value >>= 8n;\n                        }while (!((value === 0n || value === -1n) && alignedSign));\n                        target[position - 2] = bytes.length;\n                        for(let i = bytes.length; i > 0;){\n                            target[position++] = Number(bytes[--i]);\n                        }\n                        return;\n                    } else {\n                        throw new RangeError(value + \" was too large to fit in MessagePack 64-bit integer format, use\" + \" useBigIntExtension or set largeBigIntToFloat to convert to float-64\");\n                    }\n                }\n                position += 8;\n            } else if (type === \"undefined\") {\n                if (this.encodeUndefinedAsNil) target[position++] = 0xc0;\n                else {\n                    target[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n                    ;\n                    target[position++] = 0;\n                    target[position++] = 0;\n                }\n            } else {\n                throw new Error(\"Unknown type: \" + type);\n            }\n        };\n        const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber ? (object)=>{\n            // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n            let keys = Object.keys(object);\n            let length = keys.length;\n            if (length < 0x10) {\n                target[position++] = 0x80 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xde;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdf;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            let key;\n            if (this.coercibleKeyAsNumber) {\n                for(let i = 0; i < length; i++){\n                    key = keys[i];\n                    let num = Number(key);\n                    pack(isNaN(num) ? key : num);\n                    pack(object[key]);\n                }\n            } else {\n                for(let i = 0; i < length; i++){\n                    pack(key = keys[i]);\n                    pack(object[key]);\n                }\n            }\n        } : (object, safePrototype)=>{\n            target[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n            ;\n            let objectOffset = position - start;\n            position += 2;\n            let size = 0;\n            for(let key in object){\n                if (safePrototype || object.hasOwnProperty(key)) {\n                    pack(key);\n                    pack(object[key]);\n                    size++;\n                }\n            }\n            target[objectOffset++ + start] = size >> 8;\n            target[objectOffset + start] = size & 0xff;\n        };\n        const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (object, safePrototype)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let objectOffset = position++ - start;\n            let wroteKeys;\n            for(let key in object){\n                if (safePrototype || object.hasOwnProperty(key)) {\n                    nextTransition = transition[key];\n                    if (nextTransition) transition = nextTransition;\n                    else {\n                        // record doesn't exist, create full new record and insert it\n                        let keys = Object.keys(object);\n                        let lastTransition = transition;\n                        transition = structures.transitions;\n                        let newTransitions = 0;\n                        for(let i = 0, l = keys.length; i < l; i++){\n                            let key = keys[i];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                                newTransitions++;\n                            }\n                            transition = nextTransition;\n                        }\n                        if (objectOffset + start + 1 == position) {\n                            // first key, so we don't need to insert, we can just write record directly\n                            position--;\n                            newRecord(transition, keys, newTransitions);\n                        } else insertNewRecord(transition, keys, objectOffset, newTransitions);\n                        wroteKeys = true;\n                        transition = lastTransition[key];\n                    }\n                    pack(object[key]);\n                }\n            }\n            if (!wroteKeys) {\n                let recordId = transition[RECORD_SYMBOL];\n                if (recordId) target[objectOffset + start] = recordId;\n                else insertNewRecord(transition, Object.keys(object), objectOffset, 0);\n            }\n        } : (object, safePrototype)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let newTransitions = 0;\n            for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {\n                nextTransition = transition[key];\n                if (!nextTransition) {\n                    nextTransition = transition[key] = Object.create(null);\n                    newTransitions++;\n                }\n                transition = nextTransition;\n            }\n            let recordId = transition[RECORD_SYMBOL];\n            if (recordId) {\n                if (recordId >= 0x60 && useTwoByteRecords) {\n                    target[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n                    target[position++] = recordId >> 5;\n                } else target[position++] = recordId;\n            } else {\n                newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n            }\n            // now write the values\n            for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {\n                pack(object[key]);\n            }\n        };\n        // craete reference to useRecords if useRecords is a function\n        const checkUseRecords = typeof this.useRecords == \"function\" && this.useRecords;\n        const writeObject = checkUseRecords ? (object, safePrototype)=>{\n            checkUseRecords(object) ? writeRecord(object, safePrototype) : writePlainObject(object, safePrototype);\n        } : writeRecord;\n        const makeRoom = (end)=>{\n            let newSize;\n            if (end > 0x1000000) {\n                // special handling for really large buffers\n                if (end - start > MAX_BUFFER_SIZE) throw new Error(\"Packed buffer would be larger than maximum buffer size\");\n                newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n            } else newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;\n            let newBuffer = new ByteArrayAllocate(newSize);\n            targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n            end = Math.min(end, target.length);\n            if (target.copy) target.copy(newBuffer, 0, start, end);\n            else newBuffer.set(target.slice(start, end));\n            position -= start;\n            start = 0;\n            safeEnd = newBuffer.length - 10;\n            return target = newBuffer;\n        };\n        const newRecord = (transition, keys, newTransitions)=>{\n            let recordId = structures.nextId;\n            if (!recordId) recordId = 0x40;\n            if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n                recordId = structures.nextOwnId;\n                if (!(recordId < maxStructureId)) recordId = sharedLimitId;\n                structures.nextOwnId = recordId + 1;\n            } else {\n                if (recordId >= maxStructureId) recordId = sharedLimitId;\n                structures.nextId = recordId + 1;\n            }\n            let highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? recordId - 0x60 >> 5 : -1;\n            transition[RECORD_SYMBOL] = recordId;\n            transition.__keys__ = keys;\n            structures[recordId - 0x40] = keys;\n            if (recordId < sharedLimitId) {\n                keys.isShared = true;\n                structures.sharedLength = recordId - 0x3f;\n                hasSharedUpdate = true;\n                if (highByte >= 0) {\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = recordId;\n                }\n            } else {\n                if (highByte >= 0) {\n                    target[position++] = 0xd5 // fixext 2\n                    ;\n                    target[position++] = 0x72 // \"r\" record defintion extension type\n                    ;\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = 0xd4 // fixext 1\n                    ;\n                    target[position++] = 0x72 // \"r\" record defintion extension type\n                    ;\n                    target[position++] = recordId;\n                }\n                if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n                // record the removal of the id, we can maintain our shared structure\n                if (recordIdsToRemove.length >= maxOwnStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n                ;\n                recordIdsToRemove.push(transition);\n                pack(keys);\n            }\n        };\n        const insertNewRecord = (transition, keys, insertionOffset, newTransitions)=>{\n            let mainTarget = target;\n            let mainPosition = position;\n            let mainSafeEnd = safeEnd;\n            let mainStart = start;\n            target = keysTarget;\n            position = 0;\n            start = 0;\n            if (!target) keysTarget = target = new ByteArrayAllocate(8192);\n            safeEnd = target.length - 10;\n            newRecord(transition, keys, newTransitions);\n            keysTarget = target;\n            let keysPosition = position;\n            target = mainTarget;\n            position = mainPosition;\n            safeEnd = mainSafeEnd;\n            start = mainStart;\n            if (keysPosition > 1) {\n                let newEnd = position + keysPosition - 1;\n                if (newEnd > safeEnd) makeRoom(newEnd);\n                let insertionPosition = insertionOffset + start;\n                target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n                target.set(keysTarget.slice(0, keysPosition), insertionPosition);\n                position = newEnd;\n            } else {\n                target[insertionOffset + start] = keysTarget[0];\n            }\n        };\n        const writeStruct = (object, safePrototype)=>{\n            let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate)=>{\n                if (notifySharedUpdate) return hasSharedUpdate = true;\n                position = newPosition;\n                let startTarget = target;\n                pack(value);\n                resetStructures();\n                if (startTarget !== target) {\n                    return {\n                        position,\n                        targetView,\n                        target\n                    }; // indicate the buffer was re-allocated\n                }\n                return position;\n            }, this);\n            if (newPosition === 0) return writeObject(object, true);\n            position = newPosition;\n        };\n    }\n    useBuffer(buffer) {\n        // this means we are finished using our own buffer and we can write over it safely\n        target = buffer;\n        targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);\n        position = 0;\n    }\n    clearSharedData() {\n        if (this.structures) this.structures = [];\n        if (this.typedStructs) this.typedStructs = [];\n    }\n}\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n    while(offset < endOffset){\n        target[targetOffset++] = source[offset++];\n    }\n}\nextensionClasses = [\n    Date,\n    Set,\n    Error,\n    RegExp,\n    ArrayBuffer,\n    Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/ ,\n    _unpack_js__WEBPACK_IMPORTED_MODULE_0__.C1Type\n];\nextensions = [\n    {\n        pack (date, allocateForWrite, pack) {\n            let seconds = date.getTime() / 1000;\n            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n                // Timestamp 32\n                let { target, targetView, position } = allocateForWrite(6);\n                target[position++] = 0xd6;\n                target[position++] = 0xff;\n                targetView.setUint32(position, seconds);\n            } else if (seconds > 0 && seconds < 0x100000000) {\n                // Timestamp 64\n                let { target, targetView, position } = allocateForWrite(10);\n                target[position++] = 0xd7;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 4000000 + (seconds / 1000 / 0x100000000 >> 0));\n                targetView.setUint32(position + 4, seconds);\n            } else if (isNaN(seconds)) {\n                if (this.onInvalidDate) {\n                    allocateForWrite(0);\n                    return pack(this.onInvalidDate());\n                }\n                // Intentionally invalid timestamp\n                let { target, targetView, position } = allocateForWrite(3);\n                target[position++] = 0xd4;\n                target[position++] = 0xff;\n                target[position++] = 0xff;\n            } else {\n                // Timestamp 96\n                let { target, targetView, position } = allocateForWrite(15);\n                target[position++] = 0xc7;\n                target[position++] = 12;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 1000000);\n                targetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n            }\n        }\n    },\n    {\n        pack (set, allocateForWrite, pack) {\n            if (this.setAsEmptyObject) {\n                allocateForWrite(0);\n                return pack({});\n            }\n            let array = Array.from(set);\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x73 // 's' for Set\n                ;\n                target[position++] = 0;\n            }\n            pack(array);\n        }\n    },\n    {\n        pack (error, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x65 // 'e' for error\n                ;\n                target[position++] = 0;\n            }\n            pack([\n                error.name,\n                error.message\n            ]);\n        }\n    },\n    {\n        pack (regex, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x78 // 'x' for regeXp\n                ;\n                target[position++] = 0;\n            }\n            pack([\n                regex.source,\n                regex.flags\n            ]);\n        }\n    },\n    {\n        pack (arrayBuffer, allocateForWrite) {\n            if (this.moreTypes) writeExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n            else writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n        }\n    },\n    {\n        pack (typedArray, allocateForWrite) {\n            let constructor = typedArray.constructor;\n            if (constructor !== ByteArray && this.moreTypes) writeExtBuffer(typedArray, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.typedArrays.indexOf(constructor.name), allocateForWrite);\n            else writeBuffer(typedArray, allocateForWrite);\n        }\n    },\n    {\n        pack (c1, allocateForWrite) {\n            let { target, position } = allocateForWrite(1);\n            target[position] = 0xc1;\n        }\n    }\n];\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n    let length = typedArray.byteLength;\n    if (length + 1 < 0x100) {\n        var { target, position } = allocateForWrite(4 + length);\n        target[position++] = 0xc7;\n        target[position++] = length + 1;\n    } else if (length + 1 < 0x10000) {\n        var { target, position } = allocateForWrite(5 + length);\n        target[position++] = 0xc8;\n        target[position++] = length + 1 >> 8;\n        target[position++] = length + 1 & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(7 + length);\n        target[position++] = 0xc9;\n        targetView.setUint32(position, length + 1) // plus one for the type byte\n        ;\n        position += 4;\n    }\n    target[position++] = 0x74 // \"t\" for typed array\n    ;\n    target[position++] = type;\n    target.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n    let length = buffer.byteLength;\n    var target, position;\n    if (length < 0x100) {\n        var { target, position } = allocateForWrite(length + 2);\n        target[position++] = 0xc4;\n        target[position++] = length;\n    } else if (length < 0x10000) {\n        var { target, position } = allocateForWrite(length + 3);\n        target[position++] = 0xc5;\n        target[position++] = length >> 8;\n        target[position++] = length & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(length + 5);\n        target[position++] = 0xc6;\n        targetView.setUint32(position, length);\n        position += 4;\n    }\n    target.set(buffer, position);\n}\nfunction writeExtensionData(result, target, position, type) {\n    let length = result.length;\n    switch(length){\n        case 1:\n            target[position++] = 0xd4;\n            break;\n        case 2:\n            target[position++] = 0xd5;\n            break;\n        case 4:\n            target[position++] = 0xd6;\n            break;\n        case 8:\n            target[position++] = 0xd7;\n            break;\n        case 16:\n            target[position++] = 0xd8;\n            break;\n        default:\n            if (length < 0x100) {\n                target[position++] = 0xc7;\n                target[position++] = length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xc8;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xc9;\n                target[position++] = length >> 24;\n                target[position++] = length >> 16 & 0xff;\n                target[position++] = length >> 8 & 0xff;\n                target[position++] = length & 0xff;\n            }\n    }\n    target[position++] = type;\n    target.set(result, position);\n    position += length;\n    return position;\n}\nfunction insertIds(serialized, idsToInsert) {\n    // insert the ids that need to be referenced for structured clones\n    let nextId;\n    let distanceToMove = idsToInsert.length * 6;\n    let lastEnd = serialized.length - distanceToMove;\n    while(nextId = idsToInsert.pop()){\n        let offset = nextId.offset;\n        let id = nextId.id;\n        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n        distanceToMove -= 6;\n        let position = offset + distanceToMove;\n        serialized[position++] = 0xd6;\n        serialized[position++] = 0x69 // 'i'\n        ;\n        serialized[position++] = id >> 24;\n        serialized[position++] = id >> 16 & 0xff;\n        serialized[position++] = id >> 8 & 0xff;\n        serialized[position++] = id & 0xff;\n        lastEnd = offset;\n    }\n    return serialized;\n}\nfunction writeBundles(start, pack, incrementPosition) {\n    if (bundledStrings.length > 0) {\n        targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n        bundledStrings.stringsPosition = position - start;\n        let writeStrings = bundledStrings;\n        bundledStrings = null;\n        pack(writeStrings[0]);\n        pack(writeStrings[1]);\n    }\n}\nfunction addExtension(extension) {\n    if (extension.Class) {\n        if (!extension.pack && !extension.write) throw new Error(\"Extension has no pack or write function\");\n        if (extension.pack && !extension.type) throw new Error(\"Extension has no type (numeric code to identify the extension)\");\n        extensionClasses.unshift(extension.Class);\n        extensions.unshift(extension);\n    }\n    (0,_unpack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension)(extension);\n}\nfunction prepareStructures(structures, packr) {\n    structures.isCompatible = (existingStructures)=>{\n        let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;\n        if (!compatible) packr._mergeStructures(existingStructures);\n        return compatible;\n    };\n    return structures;\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n    writeStructSlots = writeSlots;\n    prepareStructures = makeStructures;\n}\nlet defaultPackr = new Packr({\n    useRecords: false\n});\nconst pack = defaultPackr.pack;\nconst encode = defaultPackr.pack;\nconst Encoder = Packr;\n\n\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst RESERVE_START_SPACE = 2048;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QytJO0FBQ3BCO0FBQ0EsU0FBU2pDLGtCQUFrQjlFLFVBQVUsRUFBRVMsS0FBSztJQUMzQ1QsV0FBVytFLFlBQVksR0FBRyxDQUFDMkk7UUFDMUIsSUFBSUMsYUFBYSxDQUFDRCxzQkFBdUIsQ0FBQ2pOLE1BQU00Qyx5QkFBeUIsSUFBSSxPQUFPcUssbUJBQW1CalAsTUFBTTtRQUM3RyxJQUFJLENBQUNrUCxZQUNKbE4sTUFBTStCLGdCQUFnQixDQUFDa0w7UUFDeEIsT0FBT0M7SUFDUjtJQUNBLE9BQU8zTjtBQUNSO0FBQ08sU0FBUzROLG9CQUFvQkMsVUFBVSxFQUFFQyxjQUFjO0lBQzdEMU8sbUJBQW1CeU87SUFDbkIvSSxvQkFBb0JnSjtBQUNyQjtBQUVBLElBQUlDLGVBQWUsSUFBSXRPLE1BQU07SUFBRTJCLFlBQVk7QUFBTTtBQUMxQyxNQUFNTyxPQUFPb00sYUFBYXBNLElBQUk7QUFDOUIsTUFBTUMsU0FBU21NLGFBQWFwTSxJQUFJO0FBQ2hDLE1BQU1xTSxVQUFVdk8sTUFBSztBQUNpQjtBQUNBO0FBQ3RDLE1BQU0sRUFBRXlPLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFdBQVcsRUFBRSxHQUFHSix1REFBZUEsQ0FBQTtBQUNyRSxNQUFNeEosb0JBQW9CLElBQUc7QUFDN0IsTUFBTU8sb0JBQW9CLEtBQUk7QUFDOUIsTUFBTTlDLHNCQUFzQixLQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9tc2dwYWNrci9wYWNrLmpzPzdlMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5wYWNrciwgbXVsdDEwLCBDMVR5cGUsIHR5cGVkQXJyYXlzLCBhZGRFeHRlbnNpb24gYXMgdW5wYWNrQWRkRXh0ZW5zaW9uIH0gZnJvbSAnLi91bnBhY2suanMnXG5sZXQgdGV4dEVuY29kZXJcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXNcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuY29uc3QgQnl0ZUFycmF5QWxsb2NhdGUgPSBoYXNOb2RlQnVmZmVyID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXlcbmNvbnN0IEJ5dGVBcnJheSA9IGhhc05vZGVCdWZmZXIgPyBCdWZmZXIgOiBVaW50OEFycmF5XG5jb25zdCBNQVhfQlVGRkVSX1NJWkUgPSBoYXNOb2RlQnVmZmVyID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwXG5sZXQgdGFyZ2V0LCBrZXlzVGFyZ2V0XG5sZXQgdGFyZ2V0Vmlld1xubGV0IHBvc2l0aW9uID0gMFxubGV0IHNhZmVFbmRcbmxldCBidW5kbGVkU3RyaW5ncyA9IG51bGxcbmxldCB3cml0ZVN0cnVjdFNsb3RzXG5jb25zdCBNQVhfQlVORExFX1NJWkUgPSAweDU1MDAgLy8gbWF4aW11bSBjaGFyYWN0ZXJzIHN1Y2ggdGhhdCB0aGUgZW5jb2RlZCBieXRlcyBmaXRzIGluIDE2IGJpdHMuXG5jb25zdCBoYXNOb25MYXRpbiA9IC9bXFx1MDA4MC1cXHVGRkZGXS9cbmV4cG9ydCBjb25zdCBSRUNPUkRfU1lNQk9MID0gU3ltYm9sKCdyZWNvcmQtaWQnKVxuZXhwb3J0IGNsYXNzIFBhY2tyIGV4dGVuZHMgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKVxuXHRcdHRoaXMub2Zmc2V0ID0gMFxuXHRcdGxldCB0eXBlQnVmZmVyXG5cdFx0bGV0IHN0YXJ0XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZVxuXHRcdGxldCBzdHJ1Y3R1cmVzXG5cdFx0bGV0IHJlZmVyZW5jZU1hcFxuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCAweGZmZmZmZmZmKVxuXHRcdH0gOiAodGV4dEVuY29kZXIgJiYgdGV4dEVuY29kZXIuZW5jb2RlSW50bykgP1xuXHRcdFx0ZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZVxuXG5cdFx0bGV0IHBhY2tyID0gdGhpc1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbFxuXHRcdGxldCBoYXNTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5zdHJ1Y3R1cmVzIHx8IG9wdGlvbnMuc2F2ZVN0cnVjdHVyZXNcblx0XHRsZXQgbWF4U2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlc1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMFxuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gODE2MClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgaXMgODE2MCcpXG5cdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlZENsb25lICYmIG9wdGlvbnMubW9yZVR5cGVzID09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JlVHlwZXMgPSB0cnVlXG5cdFx0fVxuXHRcdGxldCBtYXhPd25TdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhPd25TdHJ1Y3R1cmVzXG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NFxuXHRcdGlmICghdGhpcy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSlcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0Ly8gdHdvIGJ5dGUgcmVjb3JkIGlkcyBmb3Igc2hhcmVkIHN0cnVjdHVyZXNcblx0XHRsZXQgdXNlVHdvQnl0ZVJlY29yZHMgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gMzIgfHwgKG1heE93blN0cnVjdHVyZXMgKyBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gNjQpXHRcdFxuXHRcdGxldCBzaGFyZWRMaW1pdElkID0gbWF4U2hhcmVkU3RydWN0dXJlcyArIDB4NDBcblx0XHRsZXQgbWF4U3RydWN0dXJlSWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgbWF4T3duU3RydWN0dXJlcyArIDB4NDBcblx0XHRpZiAobWF4U3RydWN0dXJlSWQgPiA4MjU2KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gbWF4U2hhcmVkU3RydWN0dXJlICsgbWF4T3duU3RydWN0dXJlIGlzIDgxOTInKVxuXHRcdH1cblx0XHRsZXQgcmVjb3JkSWRzVG9SZW1vdmUgPSBbXVxuXHRcdGxldCB0cmFuc2l0aW9uc0NvdW50ID0gMFxuXHRcdGxldCBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwXG5cblx0XHR0aGlzLnBhY2sgPSB0aGlzLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGVPcHRpb25zKSB7XG5cdFx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Milcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIDgxOTIpKVxuXHRcdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdH1cblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdGlmIChzYWZlRW5kIC0gcG9zaXRpb24gPCAweDgwMCkge1xuXHRcdFx0XHQvLyBkb24ndCBzdGFydCB0b28gY2xvc2UgdG8gdGhlIGVuZCwgXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSh0YXJnZXQubGVuZ3RoKVxuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgdGFyZ2V0Lmxlbmd0aCkpXG5cdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gKyA3KSAmIDB4N2ZmZmZmZjggLy8gV29yZCBhbGlnbiB0byBtYWtlIGFueSBmdXR1cmUgY29weWluZyBvZiB0aGlzIGJ1ZmZlciBmYXN0ZXJcblx0XHRcdHN0YXJ0ID0gcG9zaXRpb25cblx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVTRVJWRV9TVEFSVF9TUEFDRSkgcG9zaXRpb24gKz0gKGVuY29kZU9wdGlvbnMgJiAweGZmKVxuXHRcdFx0cmVmZXJlbmNlTWFwID0gcGFja3Iuc3RydWN0dXJlZENsb25lID8gbmV3IE1hcCgpIDogbnVsbFxuXHRcdFx0aWYgKHBhY2tyLmJ1bmRsZVN0cmluZ3MgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFtdXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSBJbmZpbml0eSAvLyBmb3JjZSBhIG5ldyBidW5kbGUgc3RhcnQgb24gZmlyc3Qgc3RyaW5nXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3Iuc3RydWN0dXJlc1xuXHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMudW5pbml0aWFsaXplZClcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3IuX21lcmdlU3RydWN0dXJlcyhwYWNrci5nZXRTdHJ1Y3R1cmVzKCkpXG5cdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRcdGlmIChzaGFyZWRMZW5ndGggPiBtYXhTaGFyZWRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0Ly9pZiAobWF4U2hhcmVkU3RydWN0dXJlcyA8PSAzMiAmJiBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA+IDMyKSAvLyBUT0RPOiBjb3VsZCBzdXBwb3J0IHRoaXMsIGJ1dCB3b3VsZCBuZWVkIHRvIHVwZGF0ZSB0aGUgbGltaXQgaWRzXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaGFyZWQgc3RydWN0dXJlcyBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHNoYXJlZCBzdHJ1Y3R1cmVzLCB0cnkgaW5jcmVhc2luZyBtYXhTaGFyZWRTdHJ1Y3R1cmVzIHRvICcgKyBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0cnVjdHVyZXMudHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHQvLyByZWJ1aWxkIG91ciBzdHJ1Y3R1cmUgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcmVkTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGxldCBrZXlzID0gc3RydWN0dXJlc1tpXVxuXHRcdFx0XHRcdFx0aWYgKCFrZXlzKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tqXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaSArIDB4NDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHNoYXJlZExlbmd0aCArIDB4NDBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1NoYXJlZFVwZGF0ZSlcblx0XHRcdFx0aGFzU2hhcmVkVXBkYXRlID0gZmFsc2Vcblx0XHRcdGxldCBlbmNvZGluZ0Vycm9yO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdFx0XHRcdHdyaXRlU3RydWN0KHZhbHVlKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBhY2sodmFsdWUpXG5cdFx0XHRcdGxldCBsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3M7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncylcblx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApXG5cdFx0XHRcdGlmIChyZWZlcmVuY2VNYXAgJiYgcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0KSB7XG5cdFx0XHRcdFx0bGV0IGlkc1RvSW5zZXJ0ID0gcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0LnNvcnQoKGEsIGIpID0+IGEub2Zmc2V0ID4gYi5vZmZzZXQgPyAxIDogLTEpO1xuXHRcdFx0XHRcdGxldCBpID0gaWRzVG9JbnNlcnQubGVuZ3RoO1xuXHRcdFx0XHRcdGxldCBpbmNyZW1lbnRQb3NpdGlvbiA9IC0xO1xuXHRcdFx0XHRcdHdoaWxlIChsYXN0QnVuZGxlICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9pbnQgPSBpZHNUb0luc2VydFstLWldLm9mZnNldCArIHN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50IDwgKGxhc3RCdW5kbGUuc3RyaW5nc1Bvc2l0aW9uICsgc3RhcnQpICYmIGluY3JlbWVudFBvc2l0aW9uID09PSAtMSlcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50ID4gKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDApXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gKz0gNjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBidW5kbGUgcmVmZXJlbmNlIG5vd1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnRQb3NpdGlvbiA9IC0xOyAvLyByZXNldFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBsYXN0QnVuZGxlLnByZXZpb3VzO1xuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwICYmIGxhc3RCdW5kbGUpIHtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5nZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0KSArIGluY3JlbWVudFBvc2l0aW9uKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbilcblx0XHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvblxuXHRcdFx0XHRcdGxldCBzZXJpYWxpemVkID0gaW5zZXJ0SWRzKHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pLCBpZHNUb0luc2VydClcblx0XHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdFx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvbiAvLyB1cGRhdGUgdGhlIG9mZnNldCBzbyBuZXh0IHNlcmlhbGl6YXRpb24gZG9lc24ndCB3cml0ZSBvdmVyIG91ciBidWZmZXIsIGJ1dCBjYW4gY29udGludWUgd3JpdGluZyB0byBzYW1lIGJ1ZmZlciBzZXF1ZW50aWFsbHlcblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVVTRV9CVUZGRVJfTU9ERSkge1xuXHRcdFx0XHRcdHRhcmdldC5zdGFydCA9IHN0YXJ0XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZCA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0cmV0dXJuIHRhcmdldFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSAvLyBwb3NpdGlvbiBjYW4gY2hhbmdlIGlmIHdlIGNhbGwgcGFjayBhZ2FpbiBpbiBzYXZlU3RydWN0dXJlcywgc28gd2UgZ2V0IHRoZSBidWZmZXIgbm93XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGVuY29kaW5nRXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoc3RydWN0dXJlcykge1xuXHRcdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUgJiYgcGFja3Iuc2F2ZVN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRcdFx0XHQvLyB3ZSBjYW4ndCByZWx5IG9uIHN0YXJ0L2VuZCB3aXRoIFJFVVNFX0JVRkZFUl9NT0RFIHNpbmNlIHRoZXkgd2lsbCAocHJvYmFibHkpIGNoYW5nZSB3aGVuIHdlIHNhdmVcblx0XHRcdFx0XHRcdGxldCByZXR1cm5CdWZmZXIgPSB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0bGV0IG5ld1NoYXJlZERhdGEgPSBwcmVwYXJlU3RydWN0dXJlcyhzdHJ1Y3R1cmVzLCBwYWNrcik7XG5cdFx0XHRcdFx0XHRpZiAoIWVuY29kaW5nRXJyb3IpIHsgLy8gVE9ETzogSWYgdGhlcmUgaXMgYW4gZW5jb2RpbmcgZXJyb3IsIHNob3VsZCBtYWtlIHRoZSBzdHJ1Y3R1cmVzIGFzIHVuaW5pdGlhbGl6ZWQgc28gdGhleSBnZXQgcmVidWlsdCBuZXh0IHRpbWVcblx0XHRcdFx0XHRcdFx0aWYgKHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKG5ld1NoYXJlZERhdGEsIG5ld1NoYXJlZERhdGEuaXNDb21wYXRpYmxlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBnZXQgdXBkYXRlZCBzdHJ1Y3R1cmVzIGFuZCB0cnkgYWdhaW4gaWYgdGhlIHVwZGF0ZSBmYWlsZWRcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFja3IucGFjayh2YWx1ZSwgZW5jb2RlT3B0aW9ucylcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5CdWZmZXJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVNFVF9CVUZGRVJfTU9ERSlcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHN0YXJ0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHJlc2V0U3RydWN0dXJlcyA9ICgpID0+IHtcblx0XHRcdGlmIChzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPCAxMClcblx0XHRcdFx0c2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkKytcblx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRpZiAoc3RydWN0dXJlcy5sZW5ndGggPiBzaGFyZWRMZW5ndGggJiYgIWlzU2VxdWVudGlhbClcblx0XHRcdFx0c3RydWN0dXJlcy5sZW5ndGggPSBzaGFyZWRMZW5ndGhcblx0XHRcdGlmICh0cmFuc2l0aW9uc0NvdW50ID4gMTAwMDApIHtcblx0XHRcdFx0Ly8gZm9yY2UgYSByZWJ1aWxkIG9jY2FzaW9uYWxseSBhZnRlciBhIGxvdCBvZiB0cmFuc2l0aW9ucyBzbyBpdCBjYW4gZ2V0IGNsZWFuZWQgdXBcblx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IG51bGxcblx0XHRcdFx0c2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkID0gMFxuXHRcdFx0XHR0cmFuc2l0aW9uc0NvdW50ID0gMFxuXHRcdFx0XHRpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMClcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZSA9IFtdXG5cdFx0XHR9IGVsc2UgaWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+IDAgJiYgIWlzU2VxdWVudGlhbCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlW2ldW1JFQ09SRF9TWU1CT0xdID0gMFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW11cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcGFja0FycmF5ID0gKHZhbHVlKSA9PiB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDkwIHwgbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkY1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRkXG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cGFjayh2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcGFjayA9ICh2YWx1ZSkgPT4ge1xuXHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pXG5cblx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlXG5cdFx0XHR2YXIgbGVuZ3RoXG5cdFx0XHRpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bGV0IHN0ckxlbmd0aCA9IHZhbHVlLmxlbmd0aFxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MgJiYgc3RyTGVuZ3RoID49IDQgJiYgc3RyTGVuZ3RoIDwgMHgxMDAwKSB7XG5cdFx0XHRcdFx0aWYgKChidW5kbGVkU3RyaW5ncy5zaXplICs9IHN0ckxlbmd0aCkgPiBNQVhfQlVORExFX1NJWkUpIHtcblx0XHRcdFx0XHRcdGxldCBleHRTdGFydFxuXHRcdFx0XHRcdFx0bGV0IG1heEJ5dGVzID0gKGJ1bmRsZWRTdHJpbmdzWzBdID8gYnVuZGxlZFN0cmluZ3NbMF0ubGVuZ3RoICogMyArIGJ1bmRsZWRTdHJpbmdzWzFdLmxlbmd0aCA6IDApICsgMTBcblx0XHRcdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyBtYXhCeXRlcylcblx0XHRcdFx0XHRcdGxldCBsYXN0QnVuZGxlXG5cdFx0XHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24pIHsgLy8gaGVyZSB3ZSB1c2UgdGhlIDB4NjIgZXh0ZW5zaW9uIHRvIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZSBhbmQgcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIHJlZmVyZW5jZSBwb2ludGVyIHRvIHRoZSBuZXh0L2N1cnJlbnQgYnVuZGxlXG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBidW5kbGVkU3RyaW5nc1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjOCAvLyBleHQgMTZcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gMyAvLyByZXNlcnZlIGZvciB0aGUgd3JpdGluZyBidW5kbGUgc2l6ZVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyIC8vICdiJ1xuXHRcdFx0XHRcdFx0XHRleHRTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnRcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNCAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKSAvLyB3cml0ZSB0aGUgbGFzdCBidW5kbGVzXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KGV4dFN0YXJ0ICsgc3RhcnQgLSAzLCBwb3NpdGlvbiAtIHN0YXJ0IC0gZXh0U3RhcnQpXG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24ganVzdCB0byByZXNlcnZlIHRoZSBzcGFjZSBmb3IgdGhlIHJlZmVyZW5jZSBwb2ludGVyIHRvIHRoZSBidW5kbGUgKHdpbGwgYmUgdXBkYXRlZCBvbmNlIHRoZSBidW5kbGUgaXMgd3JpdHRlbilcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNiAvLyBmaXhleHQgNFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyIC8vICdiJ1xuXHRcdFx0XHRcdFx0XHRleHRTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnRcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNCAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gWycnLCAnJ10gLy8gY3JlYXRlIG5ldyBvbmVzXG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wcmV2aW91cyA9IGxhc3RCdW5kbGU7XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gMFxuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MucG9zaXRpb24gPSBleHRTdGFydFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgdHdvQnl0ZSA9IGhhc05vbkxhdGluLnRlc3QodmFsdWUpXG5cdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3NbdHdvQnl0ZSA/IDAgOiAxXSArPSB2YWx1ZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzFcblx0XHRcdFx0XHRwYWNrKHR3b0J5dGUgPyAtc3RyTGVuZ3RoIDogc3RyTGVuZ3RoKTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaGVhZGVyU2l6ZVxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBlc3RpbWF0ZSB0aGUgaGVhZGVyIHNpemUsIHNvIHdlIGNhbiB3cml0ZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvblxuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAxXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMlxuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ckxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gM1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSA1XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG1heEJ5dGVzID0gc3RyTGVuZ3RoICogM1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyBtYXhCeXRlcylcblxuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHg0MCB8fCAhZW5jb2RlVXRmOCkge1xuXHRcdFx0XHRcdGxldCBpLCBjMSwgYzIsIHN0clBvc2l0aW9uID0gcG9zaXRpb24gKyBoZWFkZXJTaXplXG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzFcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYzEgPCAweDgwMCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2IHwgMHhjMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHQoYzEgJiAweGZjMDApID09PSAweGQ4MDAgJiZcblx0XHRcdFx0XHRcdFx0KChjMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZilcblx0XHRcdFx0XHRcdFx0aSsrXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDE4IHwgMHhmMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoID0gc3RyUG9zaXRpb24gLSBwb3NpdGlvbiAtIGhlYWRlclNpemVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZW5ndGggPSBlbmNvZGVVdGY4KHZhbHVlLCBwb3NpdGlvbiArIGhlYWRlclNpemUpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YTAgfCBsZW5ndGhcblx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMikge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDEsIHBvc2l0aW9uICsgMSArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkOVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aFxuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDMpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDIgKyBsZW5ndGgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDUpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgNSwgcG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDMgKyBsZW5ndGgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGJcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSBsZW5ndGhcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0aWYgKHZhbHVlID4+PiAwID09PSB2YWx1ZSkgey8vIHBvc2l0aXZlIGludGVnZXIsIDMyLWJpdCBvciBsZXNzXG5cdFx0XHRcdFx0Ly8gcG9zaXRpdmUgdWludFxuXHRcdFx0XHRcdGlmICh2YWx1ZSA8IDB4MjAgfHwgKHZhbHVlIDwgMHg4MCAmJiB0aGlzLnVzZVJlY29yZHMgPT09IGZhbHNlKSB8fCAodmFsdWUgPCAweDQwICYmICF0aGlzLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNjXG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNkXG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA+PiA4XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSAmIDB4ZmZcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjZVxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PiAwID09PSB2YWx1ZSkgeyAvLyBuZWdhdGl2ZSBpbnRlZ2VyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID49IC0weDIwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDEwMCArIHZhbHVlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMFxuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgKyAweDEwMFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMVxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDJcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0SW50MzIocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgdXNlRmxvYXQzMlxuXHRcdFx0XHRcdGlmICgodXNlRmxvYXQzMiA9IHRoaXMudXNlRmxvYXQzMikgPiAwICYmIHZhbHVlIDwgMHgxMDAwMDAwMDAgJiYgdmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Fcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWRcblx0XHRcdFx0XHRcdGlmICh1c2VGbG9hdDMyIDwgNCB8fFxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgY2hlY2tzIGZvciByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0XHQoKHhTaGlmdGVkID0gdmFsdWUgKiBtdWx0MTBbKCh0YXJnZXRbcG9zaXRpb25dICYgMHg3ZikgPDwgMSkgfCAodGFyZ2V0W3Bvc2l0aW9uICsgMV0gPj4gNyldKSA+PiAwKSA9PT0geFNoaWZ0ZWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi0tIC8vIG1vdmUgYmFjayBpbnRvIHBvc2l0aW9uIGZvciB3cml0aW5nIGEgZG91YmxlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Jcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmICghdmFsdWUpXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMFxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwKSB7XG5cdFx0XHRcdFx0XHRsZXQgcmVmZXJlZSA9IHJlZmVyZW5jZU1hcC5nZXQodmFsdWUpXG5cdFx0XHRcdFx0XHRpZiAocmVmZXJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXJlZmVyZWUuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgaWRzVG9JbnNlcnQgPSByZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQgfHwgKHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCA9IFtdKVxuXHRcdFx0XHRcdFx0XHRcdHJlZmVyZWUuaWQgPSBpZHNUb0luc2VydC5wdXNoKHJlZmVyZWUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNiAvLyBmaXhleHQgNFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcwIC8vIFwicFwiIGZvciBwb2ludGVyXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCByZWZlcmVlLmlkKVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlIFxuXHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VNYXAuc2V0KHZhbHVlLCB7IG9mZnNldDogcG9zaXRpb24gLSBzdGFydCB9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvclxuXHRcdFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSwgdHJ1ZSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuXHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT09IE1hcCkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWFwQXNFbXB0eU9iamVjdCkgdGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MFxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IHZhbHVlLnNpemVcblx0XHRcdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGVcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgW2tleSwgZW50cnlWYWx1ZV0gb2YgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGtleSlcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGVudHJ5VmFsdWUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1x0XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb25DbGFzcyA9IGV4dGVuc2lvbkNsYXNzZXNbaV1cblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgZXh0ZW5zaW9uQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tpXVxuXHRcdFx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24ud3JpdGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24udHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0IC8vIG9uZSBieXRlIFwidGFnXCIgZXh0ZW5zaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGV4dGVuc2lvbi50eXBlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGxldCB3cml0ZVJlc3VsdCA9IGV4dGVuc2lvbi53cml0ZS5jYWxsKHRoaXMsIHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdyaXRlUmVzdWx0ID09PSB2YWx1ZSkgeyAvLyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrKHdyaXRlUmVzdWx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXRWaWV3ID0gdGFyZ2V0Vmlld1xuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50UG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IG51bGxcblx0XHRcdFx0XHRcdFx0XHRsZXQgcmVzdWx0XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IGV4dGVuc2lvbi5wYWNrLmNhbGwodGhpcywgdmFsdWUsIChzaXplKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgdGFyZ2V0IGFuZCB1c2UgaXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gY3VycmVudFRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSBzaXplXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbjogcG9zaXRpb24gLSBzaXplXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sIHBhY2spXG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgY3VycmVudCB0YXJnZXQgaW5mb3JtYXRpb24gKHVubGVzcyBhbHJlYWR5IHJlc3RvcmVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRUYXJnZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gY3VycmVudFRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3ID0gY3VycmVudFRhcmdldFZpZXdcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCArIHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWFrZVJvb20ocmVzdWx0Lmxlbmd0aCArIHBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gPSB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCBleHRlbnNpb24udHlwZSlcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlzQXJyYXkgYWZ0ZXIgZXh0ZW5zaW9ucywgYmVjYXVzZSBleHRlbnNpb25zIGNhbiBleHRlbmQgQXJyYXlcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgdGhpcyBhcyBhbiBhbHRlcm5hdGUgbWVjaGFuaXNtIGZvciBleHByZXNzaW5nIGhvdyB0byBzZXJpYWxpemVcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLnRvSlNPTikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGpzb24gPSB2YWx1ZS50b0pTT04oKVxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIGZvciBzb21lIHJlYXNvbiB2YWx1ZS50b0pTT04gcmV0dXJucyBpdHNlbGYgaXQnbGwgbG9vcCBmb3JldmVyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGpzb24gIT09IHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2soanNvbilcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gbm8gZXh0ZW5zaW9uIGZvdW5kLCB3cml0ZSBhcyBvYmplY3Rcblx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUsICF2YWx1ZS5oYXNPd25Qcm9wZXJ0eSkgLy8gaWYgaXQgZG9lc24ndCBoYXZlIGhhc093blByb3BlcnR5LCBkb24ndCBkbyBoYXNPd25Qcm9wZXJ0eSBjaGVja3Ncblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhjMyA6IDB4YzJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcblx0XHRcdFx0aWYgKHZhbHVlIDwgKEJpZ0ludCgxKTw8QmlnSW50KDYzKSkgJiYgdmFsdWUgPj0gLShCaWdJbnQoMSk8PEJpZ0ludCg2MykpKSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGEgc2lnbmVkIGludCBhcyBsb25nIGFzIGl0IGZpdHNcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQzXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdJbnQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAoQmlnSW50KDEpPDxCaWdJbnQoNjQpKSAmJiB2YWx1ZSA+IDApIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjYW4gZml0IGFuIHVuc2lnbmVkIGludCwgdXNlIHRoYXRcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNmXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdVaW50NjQocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG92ZXJmbG93XG5cdFx0XHRcdFx0aWYgKHRoaXMubGFyZ2VCaWdJbnRUb0Zsb2F0KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNiXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE51bWJlcih2YWx1ZSkpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnVzZUJpZ0ludEV4dGVuc2lvbiAmJiB2YWx1ZSA8IDJuKiooMTAyM24pICYmIHZhbHVlID4gLSgybioqKDEwMjNuKSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0XHRcdHBvc2l0aW9uKys7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDQyIC8vIFwiQlwiIGZvciBCaWdJbnRcblx0XHRcdFx0XHRcdGxldCBieXRlcyA9IFtdO1xuXHRcdFx0XHRcdFx0bGV0IGFsaWduZWRTaWduO1xuXHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHZhbHVlICYgMHhmZm47XG5cdFx0XHRcdFx0XHRcdGFsaWduZWRTaWduID0gKGJ5dGUgJiAweDgwbikgPT09ICh2YWx1ZSA8IDBuID8gMHg4MG4gOiAwbik7XG5cdFx0XHRcdFx0XHRcdGJ5dGVzLnB1c2goYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID4+PSA4bjtcblx0XHRcdFx0XHRcdH0gd2hpbGUgKCEoKHZhbHVlID09PSAwbiB8fCB2YWx1ZSA9PT0gLTFuKSAmJiBhbGlnbmVkU2lnbikpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uLTJdID0gYnl0ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aDsgaSA+IDA7KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IE51bWJlcihieXRlc1stLWldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcih2YWx1ZSArICcgd2FzIHRvbyBsYXJnZSB0byBmaXQgaW4gTWVzc2FnZVBhY2sgNjQtYml0IGludGVnZXIgZm9ybWF0LCB1c2UnICtcblx0XHRcdFx0XHRcdFx0JyB1c2VCaWdJbnRFeHRlbnNpb24gb3Igc2V0IGxhcmdlQmlnSW50VG9GbG9hdCB0byBjb252ZXJ0IHRvIGZsb2F0LTY0Jylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gYSBudW1iZXIgb2YgaW1wbGVtZW50YXRpb25zIHVzZSBmaXhleHQxIHdpdGggdHlwZSAwLCBkYXRhIDAgdG8gZGVub3RlIHVuZGVmaW5lZCwgc28gd2UgZm9sbG93IHN1aXRlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUGxhaW5PYmplY3QgPSAodGhpcy52YXJpYWJsZU1hcFNpemUgfHwgdGhpcy5jb2VyY2libGVLZXlBc051bWJlcikgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBzbG93ZXIsIGJ1dCBnZW5lcmF0ZXMgXCJwcmVmZXJyZWQgc2VyaWFsaXphdGlvblwiIChvcHRpbWFsbHkgc21hbGwgZm9yIHNtYWxsZXIgb2JqZWN0cylcblx0XHRcdGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuXHRcdFx0bGV0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZVxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmXG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdH1cblx0XHRcdGxldCBrZXlcblx0XHRcdGlmICh0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldXG5cdFx0XHRcdFx0bGV0IG51bSA9IE51bWJlcihrZXkpXG5cdFx0XHRcdFx0cGFjayhpc05hTihudW0pID8ga2V5IDogbnVtKVxuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhY2soa2V5ID0ga2V5c1tpXSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCwgc2FmZVByb3RvdHlwZSkgPT4ge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZSAvLyBhbHdheXMgdXNpbmcgbWFwIDE2LCBzbyB3ZSBjYW4gcHJlYWxsb2NhdGUgYW5kIHNldCB0aGUgbGVuZ3RoIGFmdGVyd2FyZHNcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbiAtIHN0YXJ0XG5cdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRsZXQgc2l6ZSA9IDBcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHNhZmVQcm90b3R5cGUgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRwYWNrKGtleSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHRcdHNpemUrK1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDhcblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSBzaXplICYgMHhmZlxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0LCBzYWZlUHJvdG90eXBlKSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbisrIC0gc3RhcnRcblx0XHRcdGxldCB3cm90ZUtleXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHNhZmVQcm90b3R5cGUgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbilcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBmdWxsIG5ldyByZWNvcmQgYW5kIGluc2VydCBpdFxuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdE9mZnNldCArIHN0YXJ0ICsgMSA9PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXksIHNvIHdlIGRvbid0IG5lZWQgdG8gaW5zZXJ0LCB3ZSBjYW4ganVzdCB3cml0ZSByZWNvcmQgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLVxuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR9IGVsc2UgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSByZWNvcmQsIG1vdmluZyBleGlzdGluZyBkYXRhIGFmdGVyIHRoZSByZWNvcmRcblx0XHRcdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG9iamVjdE9mZnNldCwgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR3cm90ZUtleXMgPSB0cnVlXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXdyb3RlS2V5cykge1xuXHRcdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdXG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBPYmplY3Qua2V5cyhvYmplY3QpLCBvYmplY3RPZmZzZXQsIDApXG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCwgc2FmZVByb3RvdHlwZSkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpXG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBpZiAoc2FmZVByb3RvdHlwZSB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0fVxuXHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXVxuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkID4+IDVcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdyaXRlIHRoZSB2YWx1ZXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpXG5cdFx0XHRcdGlmIChzYWZlUHJvdG90eXBlIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyYWV0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXHRcdFxuXHRcdGNvbnN0IHdyaXRlT2JqZWN0ID0gY2hlY2tVc2VSZWNvcmRzID8gKG9iamVjdCwgc2FmZVByb3RvdHlwZSkgPT4ge1xuXHRcdFx0Y2hlY2tVc2VSZWNvcmRzKG9iamVjdCkgPyB3cml0ZVJlY29yZChvYmplY3Qsc2FmZVByb3RvdHlwZSkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdCxzYWZlUHJvdG90eXBlKVxuXHRcdH0gOiB3cml0ZVJlY29yZFxuXG5cdFx0Y29uc3QgbWFrZVJvb20gPSAoZW5kKSA9PiB7XG5cdFx0XHRsZXQgbmV3U2l6ZVxuXHRcdFx0aWYgKGVuZCA+IDB4MTAwMDAwMCkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciByZWFsbHkgbGFyZ2UgYnVmZmVyc1xuXHRcdFx0XHRpZiAoKGVuZCAtIHN0YXJ0KSA+IE1BWF9CVUZGRVJfU0laRSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBidWZmZXIgd291bGQgYmUgbGFyZ2VyIHRoYW4gbWF4aW11bSBidWZmZXIgc2l6ZScpXG5cdFx0XHRcdG5ld1NpemUgPSBNYXRoLm1pbihNQVhfQlVGRkVSX1NJWkUsXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChNYXRoLm1heCgoZW5kIC0gc3RhcnQpICogKGVuZCA+IDB4NDAwMDAwMCA/IDEuMjUgOiAyKSwgMHg0MDAwMDApIC8gMHgxMDAwKSAqIDB4MTAwMClcblx0XHRcdH0gZWxzZSAvLyBmYXN0ZXIgaGFuZGxpbmcgZm9yIHNtYWxsZXIgYnVmZmVyc1xuXHRcdFx0XHRuZXdTaXplID0gKChNYXRoLm1heCgoZW5kIC0gc3RhcnQpIDw8IDIsIHRhcmdldC5sZW5ndGggLSAxKSA+PiAxMikgKyAxKSA8PCAxMlxuXHRcdFx0bGV0IG5ld0J1ZmZlciA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZShuZXdTaXplKVxuXHRcdFx0dGFyZ2V0VmlldyA9IG5ld0J1ZmZlci5kYXRhVmlldyB8fCAobmV3QnVmZmVyLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG5ld0J1ZmZlci5idWZmZXIsIDAsIG5ld1NpemUpKVxuXHRcdFx0ZW5kID0gTWF0aC5taW4oZW5kLCB0YXJnZXQubGVuZ3RoKVxuXHRcdFx0aWYgKHRhcmdldC5jb3B5KVxuXHRcdFx0XHR0YXJnZXQuY29weShuZXdCdWZmZXIsIDAsIHN0YXJ0LCBlbmQpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG5ld0J1ZmZlci5zZXQodGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpKVxuXHRcdFx0cG9zaXRpb24gLT0gc3RhcnRcblx0XHRcdHN0YXJ0ID0gMFxuXHRcdFx0c2FmZUVuZCA9IG5ld0J1ZmZlci5sZW5ndGggLSAxMFxuXHRcdFx0cmV0dXJuIHRhcmdldCA9IG5ld0J1ZmZlclxuXHRcdH1cblx0XHRjb25zdCBuZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCByZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dElkXG5cdFx0XHRpZiAoIXJlY29yZElkKVxuXHRcdFx0XHRyZWNvcmRJZCA9IDB4NDBcblx0XHRcdGlmIChyZWNvcmRJZCA8IHNoYXJlZExpbWl0SWQgJiYgdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZSAmJiAhdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZShrZXlzKSkge1xuXHRcdFx0XHRyZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dE93bklkXG5cdFx0XHRcdGlmICghKHJlY29yZElkIDwgbWF4U3RydWN0dXJlSWQpKVxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRPd25JZCA9IHJlY29yZElkICsgMVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlY29yZElkID49IG1heFN0cnVjdHVyZUlkKS8vIGN5Y2xlIGJhY2sgYXJvdW5kXG5cdFx0XHRcdFx0cmVjb3JkSWQgPSBzaGFyZWRMaW1pdElkXG5cdFx0XHRcdHN0cnVjdHVyZXMubmV4dElkID0gcmVjb3JkSWQgKyAxXG5cdFx0XHR9XG5cdFx0XHRsZXQgaGlnaEJ5dGUgPSBrZXlzLmhpZ2hCeXRlID0gcmVjb3JkSWQgPj0gMHg2MCAmJiB1c2VUd29CeXRlUmVjb3JkcyA/IChyZWNvcmRJZCAtIDB4NjApID4+IDUgOiAtMVxuXHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkXG5cdFx0XHR0cmFuc2l0aW9uLl9fa2V5c19fID0ga2V5c1xuXHRcdFx0c3RydWN0dXJlc1tyZWNvcmRJZCAtIDB4NDBdID0ga2V5c1xuXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkKSB7XG5cdFx0XHRcdGtleXMuaXNTaGFyZWQgPSB0cnVlXG5cdFx0XHRcdHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gcmVjb3JkSWQgLSAweDNmXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IHRydWVcblx0XHRcdFx0aWYgKGhpZ2hCeXRlID49IDApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjBcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNSAvLyBmaXhleHQgMlxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzIgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChyZWNvcmRJZCAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGhpZ2hCeXRlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNCAvLyBmaXhleHQgMVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzIgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCArPSBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgKiBuZXdUcmFuc2l0aW9uc1xuXHRcdFx0XHQvLyByZWNvcmQgdGhlIHJlbW92YWwgb2YgdGhlIGlkLCB3ZSBjYW4gbWFpbnRhaW4gb3VyIHNoYXJlZCBzdHJ1Y3R1cmVcblx0XHRcdFx0aWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+PSBtYXhPd25TdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnNoaWZ0KClbUkVDT1JEX1NZTUJPTF0gPSAwIC8vIHdlIGFyZSBjeWNsaW5nIGJhY2sgdGhyb3VnaCwgYW5kIGhhdmUgdG8gcmVtb3ZlIG9sZCBvbmVzXG5cdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnB1c2godHJhbnNpdGlvbilcblx0XHRcdFx0cGFjayhrZXlzKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBpbnNlcnROZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgaW5zZXJ0aW9uT2Zmc2V0LCBuZXdUcmFuc2l0aW9ucykgPT4ge1xuXHRcdFx0bGV0IG1haW5UYXJnZXQgPSB0YXJnZXRcblx0XHRcdGxldCBtYWluUG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0bGV0IG1haW5TYWZlRW5kID0gc2FmZUVuZFxuXHRcdFx0bGV0IG1haW5TdGFydCA9IHN0YXJ0XG5cdFx0XHR0YXJnZXQgPSBrZXlzVGFyZ2V0XG5cdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdHN0YXJ0ID0gMFxuXHRcdFx0aWYgKCF0YXJnZXQpXG5cdFx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Milcblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucylcblx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXRcblx0XHRcdGxldCBrZXlzUG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0dGFyZ2V0ID0gbWFpblRhcmdldFxuXHRcdFx0cG9zaXRpb24gPSBtYWluUG9zaXRpb25cblx0XHRcdHNhZmVFbmQgPSBtYWluU2FmZUVuZFxuXHRcdFx0c3RhcnQgPSBtYWluU3RhcnRcblx0XHRcdGlmIChrZXlzUG9zaXRpb24gPiAxKSB7XG5cdFx0XHRcdGxldCBuZXdFbmQgPSBwb3NpdGlvbiArIGtleXNQb3NpdGlvbiAtIDFcblx0XHRcdFx0aWYgKG5ld0VuZCA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0bWFrZVJvb20obmV3RW5kKVxuXHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9zaXRpb24gPSBpbnNlcnRpb25PZmZzZXQgKyBzdGFydFxuXHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihpbnNlcnRpb25Qb3NpdGlvbiArIGtleXNQb3NpdGlvbiwgaW5zZXJ0aW9uUG9zaXRpb24gKyAxLCBwb3NpdGlvbilcblx0XHRcdFx0dGFyZ2V0LnNldChrZXlzVGFyZ2V0LnNsaWNlKDAsIGtleXNQb3NpdGlvbiksIGluc2VydGlvblBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiA9IG5ld0VuZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W2luc2VydGlvbk9mZnNldCArIHN0YXJ0XSA9IGtleXNUYXJnZXRbMF1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3Qgd3JpdGVTdHJ1Y3QgPSAob2JqZWN0LCBzYWZlUHJvdG90eXBlKSA9PiB7XG5cdFx0XHRsZXQgbmV3UG9zaXRpb24gPSB3cml0ZVN0cnVjdFNsb3RzKG9iamVjdCwgdGFyZ2V0LCBzdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCAodmFsdWUsIG5ld1Bvc2l0aW9uLCBub3RpZnlTaGFyZWRVcGRhdGUpID0+IHtcblx0XHRcdFx0aWYgKG5vdGlmeVNoYXJlZFVwZGF0ZSlcblx0XHRcdFx0XHRyZXR1cm4gaGFzU2hhcmVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdFx0bGV0IHN0YXJ0VGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRwYWNrKHZhbHVlKTtcblx0XHRcdFx0cmVzZXRTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRcdGlmIChzdGFydFRhcmdldCAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcG9zaXRpb24sIHRhcmdldFZpZXcsIHRhcmdldCB9OyAvLyBpbmRpY2F0ZSB0aGUgYnVmZmVyIHdhcyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcG9zaXRpb247XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdGlmIChuZXdQb3NpdGlvbiA9PT0gMCkgLy8gYmFpbCBhbmQgZ28gdG8gYSBtc2dwYWNrIG9iamVjdFxuXHRcdFx0XHRyZXR1cm4gd3JpdGVPYmplY3Qob2JqZWN0LCB0cnVlKTtcblx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0fVxuXHR9XG5cdHVzZUJ1ZmZlcihidWZmZXIpIHtcblx0XHQvLyB0aGlzIG1lYW5zIHdlIGFyZSBmaW5pc2hlZCB1c2luZyBvdXIgb3duIGJ1ZmZlciBhbmQgd2UgY2FuIHdyaXRlIG92ZXIgaXQgc2FmZWx5XG5cdFx0dGFyZ2V0ID0gYnVmZmVyXG5cdFx0dGFyZ2V0VmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG5cdFx0cG9zaXRpb24gPSAwXG5cdH1cblx0Y2xlYXJTaGFyZWREYXRhKCkge1xuXHRcdGlmICh0aGlzLnN0cnVjdHVyZXMpXG5cdFx0XHR0aGlzLnN0cnVjdHVyZXMgPSBbXVxuXHRcdGlmICh0aGlzLnR5cGVkU3RydWN0cylcblx0XHRcdHRoaXMudHlwZWRTdHJ1Y3RzID0gW11cblx0fVxufVxuXG5mdW5jdGlvbiBjb3B5QmluYXJ5KHNvdXJjZSwgdGFyZ2V0LCB0YXJnZXRPZmZzZXQsIG9mZnNldCwgZW5kT2Zmc2V0KSB7XG5cdHdoaWxlIChvZmZzZXQgPCBlbmRPZmZzZXQpIHtcblx0XHR0YXJnZXRbdGFyZ2V0T2Zmc2V0KytdID0gc291cmNlW29mZnNldCsrXVxuXHR9XG59XG5cbmV4dGVuc2lvbkNsYXNzZXMgPSBbIERhdGUsIFNldCwgRXJyb3IsIFJlZ0V4cCwgQXJyYXlCdWZmZXIsIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSkuY29uc3RydWN0b3IgLypUeXBlZEFycmF5Ki8sIEMxVHlwZSBdXG5leHRlbnNpb25zID0gW3tcblx0cGFjayhkYXRlLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHNlY29uZHMgPSBkYXRlLmdldFRpbWUoKSAvIDEwMDBcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNilcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKVxuXHRcdH0gZWxzZSBpZiAoc2Vjb25kcyA+IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgNjRcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxMClcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDdcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogNDAwMDAwMCArICgoc2Vjb25kcyAvIDEwMDAgLyAweDEwMDAwMDAwMCkgPj4gMCkpXG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiArIDQsIHNlY29uZHMpXG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApXG5cdFx0XHRcdHJldHVybiBwYWNrKHRoaXMub25JbnZhbGlkRGF0ZSgpKVxuXHRcdFx0fVxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBpbnZhbGlkIHRpbWVzdGFtcFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDMpXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA5NlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDE1KVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjN1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMTJcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMClcblx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24gKyA0LCBCaWdJbnQoTWF0aC5mbG9vcihzZWNvbmRzKSkpXG5cdFx0fVxuXHR9XG59LCB7XG5cdHBhY2soc2V0LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0aWYgKHRoaXMuc2V0QXNFbXB0eU9iamVjdCkge1xuXHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdHJldHVybiBwYWNrKHt9KVxuXHRcdH1cblx0XHRsZXQgYXJyYXkgPSBBcnJheS5mcm9tKHNldClcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMClcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzMgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhhcnJheSlcblx0fVxufSwge1xuXHRwYWNrKGVycm9yLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDY1IC8vICdlJyBmb3IgZXJyb3Jcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UgXSlcblx0fVxufSwge1xuXHRwYWNrKHJlZ2V4LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc4IC8vICd4JyBmb3IgcmVnZVhwXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwXG5cdFx0fVxuXHRcdHBhY2soWyByZWdleC5zb3VyY2UsIHJlZ2V4LmZsYWdzIF0pXG5cdH1cbn0sIHtcblx0cGFjayhhcnJheUJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKGFycmF5QnVmZmVyLCAweDEwLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHRcdGVsc2Vcblx0XHRcdHdyaXRlQnVmZmVyKGhhc05vZGVCdWZmZXIgPyBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIGFsbG9jYXRlRm9yV3JpdGUpXG5cdH1cbn0sIHtcblx0cGFjayh0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdFx0bGV0IGNvbnN0cnVjdG9yID0gdHlwZWRBcnJheS5jb25zdHJ1Y3RvclxuXHRcdGlmIChjb25zdHJ1Y3RvciAhPT0gQnl0ZUFycmF5ICYmIHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZWRBcnJheXMuaW5kZXhPZihjb25zdHJ1Y3Rvci5uYW1lKSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcih0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2soYzEsIGFsbG9jYXRlRm9yV3JpdGUpIHsgLy8gc3BlY2lmaWMgMHhDMSBvYmplY3Rcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMSlcblx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjMVxuXHR9XG59XVxuXG5mdW5jdGlvbiB3cml0ZUV4dEJ1ZmZlcih0eXBlZEFycmF5LCB0eXBlLCBhbGxvY2F0ZUZvcldyaXRlLCBlbmNvZGUpIHtcblx0bGV0IGxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuXHRpZiAobGVuZ3RoICsgMSA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg0ICsgbGVuZ3RoKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggKyAxXG5cdH0gZWxzZSBpZiAobGVuZ3RoICsgMSA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDUgKyBsZW5ndGgpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggKyAxKSA+PiA4XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpICYgMHhmZlxuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUoNyArIGxlbmd0aClcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCArIDEpIC8vIHBsdXMgb25lIGZvciB0aGUgdHlwZSBieXRlXG5cdFx0cG9zaXRpb24gKz0gNFxuXHR9XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzQgLy8gXCJ0XCIgZm9yIHR5cGVkIGFycmF5XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGVcblx0dGFyZ2V0LnNldChuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpLCBwb3NpdGlvbilcbn1cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRsZXQgbGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGhcblx0dmFyIHRhcmdldCwgcG9zaXRpb25cblx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAyKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzRcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGhcblx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAzKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzVcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDUpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNlxuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0cG9zaXRpb24gKz0gNFxuXHR9XG5cdHRhcmdldC5zZXQoYnVmZmVyLCBwb3NpdGlvbilcbn1cblxuZnVuY3Rpb24gd3JpdGVFeHRlbnNpb25EYXRhKHJlc3VsdCwgdGFyZ2V0LCBwb3NpdGlvbiwgdHlwZSkge1xuXHRsZXQgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aFxuXHRzd2l0Y2ggKGxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAyOlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDQ6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgODpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDdcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAxNjpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDhcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOVxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gMjRcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiAxNikgJiAweGZmXG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggPj4gOCkgJiAweGZmXG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdH1cblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlXG5cdHRhcmdldC5zZXQocmVzdWx0LCBwb3NpdGlvbilcblx0cG9zaXRpb24gKz0gbGVuZ3RoXG5cdHJldHVybiBwb3NpdGlvblxufVxuXG5mdW5jdGlvbiBpbnNlcnRJZHMoc2VyaWFsaXplZCwgaWRzVG9JbnNlcnQpIHtcblx0Ly8gaW5zZXJ0IHRoZSBpZHMgdGhhdCBuZWVkIHRvIGJlIHJlZmVyZW5jZWQgZm9yIHN0cnVjdHVyZWQgY2xvbmVzXG5cdGxldCBuZXh0SWRcblx0bGV0IGRpc3RhbmNlVG9Nb3ZlID0gaWRzVG9JbnNlcnQubGVuZ3RoICogNlxuXHRsZXQgbGFzdEVuZCA9IHNlcmlhbGl6ZWQubGVuZ3RoIC0gZGlzdGFuY2VUb01vdmVcblx0d2hpbGUgKG5leHRJZCA9IGlkc1RvSW5zZXJ0LnBvcCgpKSB7XG5cdFx0bGV0IG9mZnNldCA9IG5leHRJZC5vZmZzZXRcblx0XHRsZXQgaWQgPSBuZXh0SWQuaWRcblx0XHRzZXJpYWxpemVkLmNvcHlXaXRoaW4ob2Zmc2V0ICsgZGlzdGFuY2VUb01vdmUsIG9mZnNldCwgbGFzdEVuZClcblx0XHRkaXN0YW5jZVRvTW92ZSAtPSA2XG5cdFx0bGV0IHBvc2l0aW9uID0gb2Zmc2V0ICsgZGlzdGFuY2VUb01vdmVcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHhkNlxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweDY5IC8vICdpJ1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSBpZCA+PiAyNFxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gMTYpICYgMHhmZlxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gOCkgJiAweGZmXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkICYgMHhmZlxuXHRcdGxhc3RFbmQgPSBvZmZzZXRcblx0fVxuXHRyZXR1cm4gc2VyaWFsaXplZFxufVxuXG5mdW5jdGlvbiB3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIGluY3JlbWVudFBvc2l0aW9uKSB7XG5cdGlmIChidW5kbGVkU3RyaW5ncy5sZW5ndGggPiAwKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gKyBzdGFydCwgcG9zaXRpb24gKyBpbmNyZW1lbnRQb3NpdGlvbiAtIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uIC0gc3RhcnQpXG5cdFx0YnVuZGxlZFN0cmluZ3Muc3RyaW5nc1Bvc2l0aW9uID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRsZXQgd3JpdGVTdHJpbmdzID0gYnVuZGxlZFN0cmluZ3Ncblx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGxcblx0XHRwYWNrKHdyaXRlU3RyaW5nc1swXSlcblx0XHRwYWNrKHdyaXRlU3RyaW5nc1sxXSlcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXh0ZW5zaW9uKGV4dGVuc2lvbikge1xuXHRpZiAoZXh0ZW5zaW9uLkNsYXNzKSB7XG5cdFx0aWYgKCFleHRlbnNpb24ucGFjayAmJiAhZXh0ZW5zaW9uLndyaXRlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gaGFzIG5vIHBhY2sgb3Igd3JpdGUgZnVuY3Rpb24nKVxuXHRcdGlmIChleHRlbnNpb24ucGFjayAmJiAhZXh0ZW5zaW9uLnR5cGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gdHlwZSAobnVtZXJpYyBjb2RlIHRvIGlkZW50aWZ5IHRoZSBleHRlbnNpb24pJylcblx0XHRleHRlbnNpb25DbGFzc2VzLnVuc2hpZnQoZXh0ZW5zaW9uLkNsYXNzKVxuXHRcdGV4dGVuc2lvbnMudW5zaGlmdChleHRlbnNpb24pXG5cdH1cblx0dW5wYWNrQWRkRXh0ZW5zaW9uKGV4dGVuc2lvbilcbn1cbmZ1bmN0aW9uIHByZXBhcmVTdHJ1Y3R1cmVzKHN0cnVjdHVyZXMsIHBhY2tyKSB7XG5cdHN0cnVjdHVyZXMuaXNDb21wYXRpYmxlID0gKGV4aXN0aW5nU3RydWN0dXJlcykgPT4ge1xuXHRcdGxldCBjb21wYXRpYmxlID0gIWV4aXN0aW5nU3RydWN0dXJlcyB8fCAoKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkgPT09IGV4aXN0aW5nU3RydWN0dXJlcy5sZW5ndGgpXG5cdFx0aWYgKCFjb21wYXRpYmxlKSAvLyB3ZSB3YW50IHRvIG1lcmdlIHRoZXNlIGV4aXN0aW5nIHN0cnVjdHVyZXMgaW1tZWRpYXRlbHkgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIGl0IGFuZCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IHRyYW5zYWN0aW9uXG5cdFx0XHRwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGV4aXN0aW5nU3RydWN0dXJlcyk7XG5cdFx0cmV0dXJuIGNvbXBhdGlibGU7XG5cdH1cblx0cmV0dXJuIHN0cnVjdHVyZXNcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU2xvdHMsIG1ha2VTdHJ1Y3R1cmVzKSB7XG5cdHdyaXRlU3RydWN0U2xvdHMgPSB3cml0ZVNsb3RzO1xuXHRwcmVwYXJlU3RydWN0dXJlcyA9IG1ha2VTdHJ1Y3R1cmVzO1xufVxuXG5sZXQgZGVmYXVsdFBhY2tyID0gbmV3IFBhY2tyKHsgdXNlUmVjb3JkczogZmFsc2UgfSlcbmV4cG9ydCBjb25zdCBwYWNrID0gZGVmYXVsdFBhY2tyLnBhY2tcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBkZWZhdWx0UGFja3IucGFja1xuZXhwb3J0IGNvbnN0IEVuY29kZXIgPSBQYWNrclxuZXhwb3J0IHsgRkxPQVQzMl9PUFRJT05TIH0gZnJvbSAnLi91bnBhY2suanMnXG5pbXBvcnQgeyBGTE9BVDMyX09QVElPTlMgfSBmcm9tICcuL3VucGFjay5qcydcbmV4cG9ydCBjb25zdCB7IE5FVkVSLCBBTFdBWVMsIERFQ0lNQUxfUk9VTkQsIERFQ0lNQUxfRklUIH0gPSBGTE9BVDMyX09QVElPTlNcbmV4cG9ydCBjb25zdCBSRVVTRV9CVUZGRVJfTU9ERSA9IDUxMlxuZXhwb3J0IGNvbnN0IFJFU0VUX0JVRkZFUl9NT0RFID0gMTAyNFxuZXhwb3J0IGNvbnN0IFJFU0VSVkVfU1RBUlRfU1BBQ0UgPSAyMDQ4Il0sIm5hbWVzIjpbIlVucGFja3IiLCJtdWx0MTAiLCJDMVR5cGUiLCJ0eXBlZEFycmF5cyIsImFkZEV4dGVuc2lvbiIsInVucGFja0FkZEV4dGVuc2lvbiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlcnJvciIsImV4dGVuc2lvbnMiLCJleHRlbnNpb25DbGFzc2VzIiwiaGFzTm9kZUJ1ZmZlciIsIkJ1ZmZlciIsIkJ5dGVBcnJheUFsbG9jYXRlIiwibGVuZ3RoIiwiYWxsb2NVbnNhZmVTbG93IiwiVWludDhBcnJheSIsIkJ5dGVBcnJheSIsIk1BWF9CVUZGRVJfU0laRSIsInRhcmdldCIsImtleXNUYXJnZXQiLCJ0YXJnZXRWaWV3IiwicG9zaXRpb24iLCJzYWZlRW5kIiwiYnVuZGxlZFN0cmluZ3MiLCJ3cml0ZVN0cnVjdFNsb3RzIiwiTUFYX0JVTkRMRV9TSVpFIiwiaGFzTm9uTGF0aW4iLCJSRUNPUkRfU1lNQk9MIiwiU3ltYm9sIiwiUGFja3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJvZmZzZXQiLCJ0eXBlQnVmZmVyIiwic3RhcnQiLCJoYXNTaGFyZWRVcGRhdGUiLCJzdHJ1Y3R1cmVzIiwicmVmZXJlbmNlTWFwIiwiZW5jb2RlVXRmOCIsInByb3RvdHlwZSIsInV0ZjhXcml0ZSIsInN0cmluZyIsImVuY29kZUludG8iLCJzdWJhcnJheSIsIndyaXR0ZW4iLCJwYWNrciIsImlzU2VxdWVudGlhbCIsInNlcXVlbnRpYWwiLCJoYXNTaGFyZWRTdHJ1Y3R1cmVzIiwic2F2ZVN0cnVjdHVyZXMiLCJtYXhTaGFyZWRTdHJ1Y3R1cmVzIiwiRXJyb3IiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJtb3JlVHlwZXMiLCJ1bmRlZmluZWQiLCJtYXhPd25TdHJ1Y3R1cmVzIiwidXNlUmVjb3JkcyIsInVzZVR3b0J5dGVSZWNvcmRzIiwic2hhcmVkTGltaXRJZCIsIm1heFN0cnVjdHVyZUlkIiwicmVjb3JkSWRzVG9SZW1vdmUiLCJ0cmFuc2l0aW9uc0NvdW50Iiwic2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkIiwicGFjayIsImVuY29kZSIsInZhbHVlIiwiZW5jb2RlT3B0aW9ucyIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJSRVNFUlZFX1NUQVJUX1NQQUNFIiwiTWFwIiwiYnVuZGxlU3RyaW5ncyIsInNpemUiLCJJbmZpbml0eSIsInVuaW5pdGlhbGl6ZWQiLCJfbWVyZ2VTdHJ1Y3R1cmVzIiwiZ2V0U3RydWN0dXJlcyIsInNoYXJlZExlbmd0aCIsInRyYW5zaXRpb25zIiwiT2JqZWN0IiwiY3JlYXRlIiwiaSIsImtleXMiLCJuZXh0VHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJqIiwibCIsImtleSIsImxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGgiLCJuZXh0SWQiLCJlbmNvZGluZ0Vycm9yIiwicmFuZG9tQWNjZXNzU3RydWN0dXJlIiwid3JpdGVTdHJ1Y3QiLCJsYXN0QnVuZGxlIiwid3JpdGVCdW5kbGVzIiwiaWRzVG9JbnNlcnQiLCJzb3J0IiwiYSIsImIiLCJpbmNyZW1lbnRQb3NpdGlvbiIsImluc2VydGlvblBvaW50Iiwic3RyaW5nc1Bvc2l0aW9uIiwic2V0VWludDMyIiwiZ2V0VWludDMyIiwicHJldmlvdXMiLCJtYWtlUm9vbSIsInNlcmlhbGl6ZWQiLCJpbnNlcnRJZHMiLCJSRVVTRV9CVUZGRVJfTU9ERSIsImVuZCIsInJlc2V0U3RydWN0dXJlcyIsInJldHVybkJ1ZmZlciIsIm5ld1NoYXJlZERhdGEiLCJwcmVwYXJlU3RydWN0dXJlcyIsImlzQ29tcGF0aWJsZSIsIlJFU0VUX0JVRkZFUl9NT0RFIiwicGFja0FycmF5IiwidHlwZSIsInN0ckxlbmd0aCIsImV4dFN0YXJ0IiwibWF4Qnl0ZXMiLCJzZXRVaW50MTYiLCJ0d29CeXRlIiwidGVzdCIsImhlYWRlclNpemUiLCJjMSIsImMyIiwic3RyUG9zaXRpb24iLCJjaGFyQ29kZUF0IiwiY29weVdpdGhpbiIsInNldEludDE2Iiwic2V0SW50MzIiLCJ1c2VGbG9hdDMyIiwic2V0RmxvYXQzMiIsInhTaGlmdGVkIiwic2V0RmxvYXQ2NCIsInJlZmVyZWUiLCJnZXQiLCJpZCIsInB1c2giLCJzZXQiLCJ3cml0ZU9iamVjdCIsIkFycmF5IiwibWFwQXNFbXB0eU9iamVjdCIsImVudHJ5VmFsdWUiLCJleHRlbnNpb25DbGFzcyIsImV4dGVuc2lvbiIsIndyaXRlIiwid3JpdGVSZXN1bHQiLCJjYWxsIiwiaXNBcnJheSIsImN1cnJlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0VmlldyIsImN1cnJlbnRQb3NpdGlvbiIsInJlc3VsdCIsIndyaXRlRXh0ZW5zaW9uRGF0YSIsInRvSlNPTiIsImpzb24iLCJ3cml0ZUZ1bmN0aW9uIiwiaGFzT3duUHJvcGVydHkiLCJCaWdJbnQiLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsImxhcmdlQmlnSW50VG9GbG9hdCIsIk51bWJlciIsInVzZUJpZ0ludEV4dGVuc2lvbiIsImJ5dGVzIiwiYWxpZ25lZFNpZ24iLCJieXRlIiwiUmFuZ2VFcnJvciIsImVuY29kZVVuZGVmaW5lZEFzTmlsIiwid3JpdGVQbGFpbk9iamVjdCIsInZhcmlhYmxlTWFwU2l6ZSIsImNvZXJjaWJsZUtleUFzTnVtYmVyIiwib2JqZWN0IiwibnVtIiwiaXNOYU4iLCJzYWZlUHJvdG90eXBlIiwib2JqZWN0T2Zmc2V0Iiwid3JpdGVSZWNvcmQiLCJwcm9ncmVzc2l2ZVJlY29yZHMiLCJ3cm90ZUtleXMiLCJsYXN0VHJhbnNpdGlvbiIsIm5ld1RyYW5zaXRpb25zIiwibmV3UmVjb3JkIiwiaW5zZXJ0TmV3UmVjb3JkIiwicmVjb3JkSWQiLCJfX2tleXNfXyIsImNoZWNrVXNlUmVjb3JkcyIsIm5ld1NpemUiLCJNYXRoIiwibWluIiwicm91bmQiLCJtYXgiLCJuZXdCdWZmZXIiLCJjb3B5Iiwic2xpY2UiLCJzaG91bGRTaGFyZVN0cnVjdHVyZSIsIm5leHRPd25JZCIsImhpZ2hCeXRlIiwiaXNTaGFyZWQiLCJzaGlmdCIsImluc2VydGlvbk9mZnNldCIsIm1haW5UYXJnZXQiLCJtYWluUG9zaXRpb24iLCJtYWluU2FmZUVuZCIsIm1haW5TdGFydCIsImtleXNQb3NpdGlvbiIsIm5ld0VuZCIsImluc2VydGlvblBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJub3RpZnlTaGFyZWRVcGRhdGUiLCJzdGFydFRhcmdldCIsInVzZUJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiY2xlYXJTaGFyZWREYXRhIiwidHlwZWRTdHJ1Y3RzIiwiY29weUJpbmFyeSIsInNvdXJjZSIsInRhcmdldE9mZnNldCIsImVuZE9mZnNldCIsIkRhdGUiLCJTZXQiLCJSZWdFeHAiLCJBcnJheUJ1ZmZlciIsImdldFByb3RvdHlwZU9mIiwiZGF0ZSIsImFsbG9jYXRlRm9yV3JpdGUiLCJzZWNvbmRzIiwiZ2V0VGltZSIsInVzZVRpbWVzdGFtcDMyIiwiZ2V0TWlsbGlzZWNvbmRzIiwib25JbnZhbGlkRGF0ZSIsImZsb29yIiwic2V0QXNFbXB0eU9iamVjdCIsImFycmF5IiwiZnJvbSIsIm5hbWUiLCJtZXNzYWdlIiwicmVnZXgiLCJmbGFncyIsImFycmF5QnVmZmVyIiwid3JpdGVFeHRCdWZmZXIiLCJ3cml0ZUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJpbmRleE9mIiwiZGlzdGFuY2VUb01vdmUiLCJsYXN0RW5kIiwicG9wIiwid3JpdGVTdHJpbmdzIiwiQ2xhc3MiLCJ1bnNoaWZ0IiwiZXhpc3RpbmdTdHJ1Y3R1cmVzIiwiY29tcGF0aWJsZSIsInNldFdyaXRlU3RydWN0U2xvdHMiLCJ3cml0ZVNsb3RzIiwibWFrZVN0cnVjdHVyZXMiLCJkZWZhdWx0UGFja3IiLCJFbmNvZGVyIiwiRkxPQVQzMl9PUFRJT05TIiwiTkVWRVIiLCJBTFdBWVMiLCJERUNJTUFMX1JPVU5EIiwiREVDSU1BTF9GSVQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/pack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/msgpackr/stream.js":
/*!*****************************************!*\
  !*** ./node_modules/msgpackr/stream.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PackrStream: () => (/* binding */ PackrStream),\n/* harmony export */   UnpackrStream: () => (/* binding */ UnpackrStream)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/msgpackr/unpack.js\");\n\n\n\nvar DEFAULT_OPTIONS = {\n    objectMode: true\n};\nclass PackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.writableObjectMode = true;\n        super(options);\n        options.sequential = true;\n        this.packr = options.packr || new _pack_js__WEBPACK_IMPORTED_MODULE_1__.Packr(options);\n    }\n    _transform(value, encoding, callback) {\n        this.push(this.packr.pack(value));\n        callback();\n    }\n}\nclass UnpackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.objectMode = true;\n        super(options);\n        options.structures = [];\n        this.unpackr = options.unpackr || new _unpack_js__WEBPACK_IMPORTED_MODULE_2__.Unpackr(options);\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.incompleteBuffer) {\n            chunk = Buffer.concat([\n                this.incompleteBuffer,\n                chunk\n            ]);\n            this.incompleteBuffer = null;\n        }\n        let values;\n        try {\n            values = this.unpackr.unpackMultiple(chunk);\n        } catch (error) {\n            if (error.incomplete) {\n                this.incompleteBuffer = chunk.slice(error.lastPosition);\n                values = error.values;\n            } else throw error;\n        } finally{\n            for (let value of values || []){\n                if (value === null) value = this.getNullValue();\n                this.push(value);\n            }\n        }\n        if (callback) callback();\n    }\n    getNullValue() {\n        return Symbol.for(null);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3Ivc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtDO0FBQ0Q7QUFDSTtBQUNyQyxJQUFJRyxrQkFBa0I7SUFBQ0MsWUFBWTtBQUFJO0FBRWhDLE1BQU1DLG9CQUFvQkwsNkNBQVNBO0lBQ3pDTSxZQUFZQyxPQUFPLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxTQUNKQSxVQUFVLENBQUM7UUFDWkEsUUFBUUMsa0JBQWtCLEdBQUc7UUFDN0IsS0FBSyxDQUFDRDtRQUNOQSxRQUFRRSxVQUFVLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxLQUFLLEdBQUdILFFBQVFHLEtBQUssSUFBSSxJQUFJVCwyQ0FBS0EsQ0FBQ007SUFDekM7SUFDQUksV0FBV0MsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRTtRQUNyQyxJQUFJLENBQUNDLElBQUksQ0FBQyxJQUFJLENBQUNMLEtBQUssQ0FBQ00sSUFBSSxDQUFDSjtRQUMxQkU7SUFDRDtBQUNEO0FBRU8sTUFBTUcsc0JBQXNCakIsNkNBQVNBO0lBQzNDTSxZQUFZQyxPQUFPLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxTQUNKQSxVQUFVLENBQUM7UUFDWkEsUUFBUUgsVUFBVSxHQUFHO1FBQ3JCLEtBQUssQ0FBQ0c7UUFDTkEsUUFBUVcsVUFBVSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdaLFFBQVFZLE9BQU8sSUFBSSxJQUFJakIsK0NBQU9BLENBQUNLO0lBQy9DO0lBQ0FJLFdBQVdTLEtBQUssRUFBRVAsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDckMsSUFBSSxJQUFJLENBQUNPLGdCQUFnQixFQUFFO1lBQzFCRCxRQUFRRSxPQUFPQyxNQUFNLENBQUM7Z0JBQUMsSUFBSSxDQUFDRixnQkFBZ0I7Z0JBQUVEO2FBQU07WUFDcEQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN6QjtRQUNBLElBQUlHO1FBQ0osSUFBSTtZQUNIQSxTQUFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxjQUFjLENBQUNMO1FBQ3RDLEVBQUUsT0FBTU0sT0FBTztZQUNkLElBQUlBLE1BQU1DLFVBQVUsRUFBRTtnQkFDckIsSUFBSSxDQUFDTixnQkFBZ0IsR0FBR0QsTUFBTVEsS0FBSyxDQUFDRixNQUFNRyxZQUFZO2dCQUN0REwsU0FBU0UsTUFBTUYsTUFBTTtZQUN0QixPQUVDLE1BQU1FO1FBQ1IsU0FBVTtZQUNULEtBQUssSUFBSWQsU0FBU1ksVUFBVSxFQUFFLENBQUU7Z0JBQy9CLElBQUlaLFVBQVUsTUFDYkEsUUFBUSxJQUFJLENBQUNrQixZQUFZO2dCQUMxQixJQUFJLENBQUNmLElBQUksQ0FBQ0g7WUFDWDtRQUNEO1FBQ0EsSUFBSUUsVUFBVUE7SUFDZjtJQUNBZ0IsZUFBZTtRQUNkLE9BQU9DLE9BQU9DLEdBQUcsQ0FBQztJQUNuQjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9tc2dwYWNrci9zdHJlYW0uanM/MjZmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdzdHJlYW0nXG5pbXBvcnQgeyBQYWNrciB9IGZyb20gJy4vcGFjay5qcydcbmltcG9ydCB7IFVucGFja3IgfSBmcm9tICcuL3VucGFjay5qcydcbnZhciBERUZBVUxUX09QVElPTlMgPSB7b2JqZWN0TW9kZTogdHJ1ZX1cblxuZXhwb3J0IGNsYXNzIFBhY2tyU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlID0gdHJ1ZVxuXHRcdHN1cGVyKG9wdGlvbnMpXG5cdFx0b3B0aW9ucy5zZXF1ZW50aWFsID0gdHJ1ZVxuXHRcdHRoaXMucGFja3IgPSBvcHRpb25zLnBhY2tyIHx8IG5ldyBQYWNrcihvcHRpb25zKVxuXHR9XG5cdF90cmFuc2Zvcm0odmFsdWUsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucHVzaCh0aGlzLnBhY2tyLnBhY2sodmFsdWUpKVxuXHRcdGNhbGxiYWNrKClcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVW5wYWNrclN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge31cblx0XHRvcHRpb25zLm9iamVjdE1vZGUgPSB0cnVlXG5cdFx0c3VwZXIob3B0aW9ucylcblx0XHRvcHRpb25zLnN0cnVjdHVyZXMgPSBbXVxuXHRcdHRoaXMudW5wYWNrciA9IG9wdGlvbnMudW5wYWNrciB8fCBuZXcgVW5wYWNrcihvcHRpb25zKVxuXHR9XG5cdF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdGlmICh0aGlzLmluY29tcGxldGVCdWZmZXIpIHtcblx0XHRcdGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5pbmNvbXBsZXRlQnVmZmVyLCBjaHVua10pXG5cdFx0XHR0aGlzLmluY29tcGxldGVCdWZmZXIgPSBudWxsXG5cdFx0fVxuXHRcdGxldCB2YWx1ZXNcblx0XHR0cnkge1xuXHRcdFx0dmFsdWVzID0gdGhpcy51bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKVxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdGlmIChlcnJvci5pbmNvbXBsZXRlKSB7XG5cdFx0XHRcdHRoaXMuaW5jb21wbGV0ZUJ1ZmZlciA9IGNodW5rLnNsaWNlKGVycm9yLmxhc3RQb3NpdGlvbilcblx0XHRcdFx0dmFsdWVzID0gZXJyb3IudmFsdWVzXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcyB8fCBbXSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldE51bGxWYWx1ZSgpXG5cdFx0XHRcdHRoaXMucHVzaCh2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXG5cdH1cblx0Z2V0TnVsbFZhbHVlKCkge1xuXHRcdHJldHVybiBTeW1ib2wuZm9yKG51bGwpXG5cdH1cbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJQYWNrciIsIlVucGFja3IiLCJERUZBVUxUX09QVElPTlMiLCJvYmplY3RNb2RlIiwiUGFja3JTdHJlYW0iLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJzZXF1ZW50aWFsIiwicGFja3IiLCJfdHJhbnNmb3JtIiwidmFsdWUiLCJlbmNvZGluZyIsImNhbGxiYWNrIiwicHVzaCIsInBhY2siLCJVbnBhY2tyU3RyZWFtIiwic3RydWN0dXJlcyIsInVucGFja3IiLCJjaHVuayIsImluY29tcGxldGVCdWZmZXIiLCJCdWZmZXIiLCJjb25jYXQiLCJ2YWx1ZXMiLCJ1bnBhY2tNdWx0aXBsZSIsImVycm9yIiwiaW5jb21wbGV0ZSIsInNsaWNlIiwibGFzdFBvc2l0aW9uIiwiZ2V0TnVsbFZhbHVlIiwiU3ltYm9sIiwiZm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/msgpackr/struct.js":
/*!*****************************************!*\
  !*** ./node_modules/msgpackr/struct.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(rsc)/./node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(rsc)/./node_modules/msgpackr/unpack.js\");\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/ \n\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = [\n    \"num\",\n    \"object\",\n    \"string\",\n    \"ascii\"\n];\nTYPE_NAMES[DATE] = \"date\";\nconst float32Headers = [\n    false,\n    true,\n    true,\n    false,\n    false,\n    true,\n    true,\n    false\n];\nlet evalSupported;\ntry {\n    new Function(\"\");\n    evalSupported = true;\n} catch (error) {\n// if eval variants are not supported, do not create inline object readers ever\n}\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== \"undefined\";\nlet textEncoder, currentSource;\ntry {\n    textEncoder = new TextEncoder();\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n    return target.utf8Write(string, position, 0xffffffff);\n} : textEncoder && textEncoder.encodeInto ? function(target, string, position) {\n    return textEncoder.encodeInto(string, target.subarray(position)).written;\n} : false;\nconst TYPE = Symbol(\"type\");\nconst PARENT = Symbol(\"parent\");\n(0,_pack_js__WEBPACK_IMPORTED_MODULE_0__.setWriteStructSlots)(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n    let typedStructs = packr.typedStructs || (packr.typedStructs = []);\n    // note that we rely on pack.js to load stored structures before we get to this point\n    let targetView = target.dataView;\n    let refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n    let safeEnd = target.length - 10;\n    let start = position;\n    if (position > safeEnd) {\n        target = makeRoom(position);\n        targetView = target.dataView;\n        position -= encodingStart;\n        start -= encodingStart;\n        refsStartPosition -= encodingStart;\n        encodingStart = 0;\n        safeEnd = target.length - 10;\n    }\n    let refOffset, refPosition = refsStartPosition;\n    let transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n    let nextId = typedStructs.nextId || typedStructs.length;\n    let headerSize = nextId < 0xf ? 1 : nextId < 0xf0 ? 2 : nextId < 0xf000 ? 3 : nextId < 0xf00000 ? 4 : 0;\n    if (headerSize === 0) return 0;\n    position += headerSize;\n    let queuedReferences = [];\n    let usedAscii0;\n    let keyIndex = 0;\n    for(let key in object){\n        let value = object[key];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: 0,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null,\n                date64: null\n            };\n        }\n        if (position > safeEnd) {\n            target = makeRoom(position);\n            targetView = target.dataView;\n            position -= encodingStart;\n            start -= encodingStart;\n            refsStartPosition -= encodingStart;\n            refPosition -= encodingStart;\n            encodingStart = 0;\n            safeEnd = target.length - 10;\n        }\n        switch(typeof value){\n            case \"number\":\n                let number = value;\n                // first check to see if we are using a lot of ids and should default to wide/common format\n                if (nextId < 200 || !nextTransition.num64) {\n                    if (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n                        if (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n                            transition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n                            target[position++] = number;\n                        } else {\n                            transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                            targetView.setUint32(position, number, true);\n                            position += 4;\n                        }\n                        break;\n                    } else if (number < 0x100000000 && number >= -0x80000000) {\n                        targetView.setFloat32(position, number, true);\n                        if (float32Headers[target[position + 3] >>> 5]) {\n                            let xShifted;\n                            // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                            if ((xShifted = number * _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[(target[position + 3] & 0x7f) << 1 | target[position + 2] >> 7]) >> 0 === xShifted) {\n                                transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                                position += 4;\n                                break;\n                            }\n                        }\n                    }\n                }\n                transition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n                targetView.setFloat64(position, number, true);\n                position += 8;\n                break;\n            case \"string\":\n                let strLength = value.length;\n                refOffset = refPosition - refsStartPosition;\n                if ((strLength << 2) + refPosition > safeEnd) {\n                    target = makeRoom((strLength << 2) + refPosition);\n                    targetView = target.dataView;\n                    position -= encodingStart;\n                    start -= encodingStart;\n                    refsStartPosition -= encodingStart;\n                    refPosition -= encodingStart;\n                    encodingStart = 0;\n                    safeEnd = target.length - 10;\n                }\n                if (strLength > 0xff00 + refOffset >> 2) {\n                    queuedReferences.push(key, value, position - start);\n                    break;\n                }\n                let isNotAscii;\n                let strStart = refPosition;\n                if (strLength < 0x40) {\n                    let i, c1, c2;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[refPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 6 | 0xc0;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            isNotAscii = true;\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[refPosition++] = c1 >> 18 | 0xf0;\n                            target[refPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 12 | 0xe0;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                } else {\n                    refPosition += encodeUtf8(target, value, refPosition);\n                    isNotAscii = refPosition - strStart > strLength;\n                }\n                if (refOffset < 0xa0 || refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8)) {\n                    // short strings\n                    if (isNotAscii) {\n                        if (!(transition = nextTransition.string8)) {\n                            if (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n                                // we can safely change ascii to utf8 in place since they are compatible\n                                transition.__type = UTF8;\n                                nextTransition.ascii8 = null;\n                                nextTransition.string8 = transition;\n                                pack(null, 0, true); // special call to notify that structures have been updated\n                            } else {\n                                transition = createTypeTransition(nextTransition, UTF8, 1);\n                            }\n                        }\n                    } else if (refOffset === 0 && !usedAscii0) {\n                        usedAscii0 = true;\n                        transition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n                        break; // don't increment position\n                    } else if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8))) transition = createTypeTransition(nextTransition, ASCII, 1);\n                    target[position++] = refOffset;\n                } else {\n                    // TODO: Enable ascii16 at some point, but get the logic right\n                    //if (isNotAscii)\n                    transition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n                    //else\n                    //transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n                    targetView.setUint16(position, refOffset, true);\n                    position += 2;\n                }\n                break;\n            case \"object\":\n                if (value) {\n                    if (value.constructor === Date) {\n                        transition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n                        targetView.setFloat64(position, value.getTime(), true);\n                        position += 8;\n                    } else {\n                        queuedReferences.push(key, value, keyIndex);\n                    }\n                    break;\n                } else {\n                    nextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n                    if (nextTransition) {\n                        transition = nextTransition;\n                        position = updatedPosition;\n                    } else queuedReferences.push(key, value, keyIndex);\n                }\n                break;\n            case \"boolean\":\n                transition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n                target[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n                break;\n            case \"undefined\":\n                nextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n                if (nextTransition) {\n                    transition = nextTransition;\n                    position = updatedPosition;\n                } else queuedReferences.push(key, value, keyIndex);\n                break;\n            default:\n                queuedReferences.push(key, value, keyIndex);\n        }\n        keyIndex++;\n    }\n    for(let i = 0, l = queuedReferences.length; i < l;){\n        let key = queuedReferences[i++];\n        let value = queuedReferences[i++];\n        let propertyIndex = queuedReferences[i++];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: propertyIndex - keyIndex,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null\n            };\n        }\n        let newPosition;\n        if (value) {\n            /*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */ let size;\n            refOffset = refPosition - refsStartPosition;\n            if (refOffset < 0xff00) {\n                transition = nextTransition.object16;\n                if (transition) size = 2;\n                else if (transition = nextTransition.object32) size = 4;\n                else {\n                    transition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n                    size = 2;\n                }\n            } else {\n                transition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n                size = 4;\n            }\n            newPosition = pack(value, refPosition);\n            //}\n            if (typeof newPosition === \"object\") {\n                // re-allocated\n                refPosition = newPosition.position;\n                targetView = newPosition.targetView;\n                target = newPosition.target;\n                refsStartPosition -= encodingStart;\n                position -= encodingStart;\n                start -= encodingStart;\n                encodingStart = 0;\n            } else refPosition = newPosition;\n            if (size === 2) {\n                targetView.setUint16(position, refOffset, true);\n                position += 2;\n            } else {\n                targetView.setUint32(position, refOffset, true);\n                position += 4;\n            }\n        } else {\n            transition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n            targetView.setInt16(position, value === null ? -10 : -9, true);\n            position += 2;\n        }\n        keyIndex++;\n    }\n    let recordId = transition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL];\n    if (recordId == null) {\n        recordId = packr.typedStructs.length;\n        let structure = [];\n        let nextTransition = transition;\n        let key, type;\n        while((type = nextTransition.__type) !== undefined){\n            let size = nextTransition.__size;\n            nextTransition = nextTransition.__parent;\n            key = nextTransition.key;\n            let property = [\n                type,\n                size,\n                key\n            ];\n            if (nextTransition.enumerationOffset) property.push(nextTransition.enumerationOffset);\n            structure.push(property);\n            nextTransition = nextTransition.parent;\n        }\n        structure.reverse();\n        transition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = recordId;\n        packr.typedStructs[recordId] = structure;\n        pack(null, 0, true); // special call to notify that structures have been updated\n    }\n    switch(headerSize){\n        case 1:\n            if (recordId >= 0x10) return 0;\n            target[start] = recordId + 0x20;\n            break;\n        case 2:\n            if (recordId >= 0x100) return 0;\n            target[start] = 0x38;\n            target[start + 1] = recordId;\n            break;\n        case 3:\n            if (recordId >= 0x10000) return 0;\n            target[start] = 0x39;\n            targetView.setUint16(start + 1, recordId, true);\n            break;\n        case 4:\n            if (recordId >= 0x1000000) return 0;\n            targetView.setUint32(start, (recordId << 8) + 0x3a, true);\n            break;\n    }\n    if (position < refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        // adjust positioning\n        target.copyWithin(position, refsStartPosition, refPosition);\n        refPosition += position - refsStartPosition;\n        typedStructs.lastStringStart = position - start;\n    } else if (position > refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        typedStructs.lastStringStart = position - start;\n        return writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n    }\n    return refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n    let nextTransition;\n    if (nextTransition = transition.ascii8 || transition.num8) {\n        targetView.setInt8(position, value, true);\n        updatedPosition = position + 1;\n        return nextTransition;\n    }\n    if (nextTransition = transition.string16 || transition.object16) {\n        targetView.setInt16(position, value, true);\n        updatedPosition = position + 2;\n        return nextTransition;\n    }\n    if (nextTransition = transition.num32) {\n        targetView.setUint32(position, 0xe0000100 + value, true);\n        updatedPosition = position + 4;\n        return nextTransition;\n    }\n    // transition.float64\n    if (nextTransition = transition.num64) {\n        targetView.setFloat64(position, NaN, true);\n        targetView.setInt8(position, value);\n        updatedPosition = position + 8;\n        return nextTransition;\n    }\n    updatedPosition = position;\n    // TODO: can we do an \"any\" type where we defer the decision?\n    return;\n}\nfunction createTypeTransition(transition, type, size) {\n    let typeName = TYPE_NAMES[type] + (size << 3);\n    let newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n    newTransition.__type = type;\n    newTransition.__size = size;\n    newTransition.__parent = transition;\n    return newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n    if (!(sharedData instanceof Map)) return sharedData;\n    let typed = sharedData.get(\"typed\") || [];\n    if (Object.isFrozen(typed)) typed = typed.map((structure)=>structure.slice(0));\n    let named = sharedData.get(\"named\");\n    let transitions = Object.create(null);\n    for(let i = 0, l = typed.length; i < l; i++){\n        let structure = typed[i];\n        let transition = transitions;\n        for (let [type, size, key] of structure){\n            let nextTransition = transition[key];\n            if (!nextTransition) {\n                transition[key] = nextTransition = {\n                    key,\n                    parent: transition,\n                    enumerationOffset: 0,\n                    ascii0: null,\n                    ascii8: null,\n                    num8: null,\n                    string16: null,\n                    object16: null,\n                    num32: null,\n                    float64: null,\n                    date64: null\n                };\n            }\n            transition = createTypeTransition(nextTransition, type, size);\n        }\n        transition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = i;\n    }\n    typed.transitions = transitions;\n    this.typedStructs = typed;\n    this.lastTypedStructuresLength = typed.length;\n    return named;\n}\nvar sourceSymbol = Symbol.for(\"source\");\nfunction readStruct(src, position, srcEnd, unpackr) {\n    let recordId = src[position++] - 0x20;\n    if (recordId >= 24) {\n        switch(recordId){\n            case 24:\n                recordId = src[position++];\n                break;\n            // little endian:\n            case 25:\n                recordId = src[position++] + (src[position++] << 8);\n                break;\n            case 26:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16);\n                break;\n            case 27:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24);\n                break;\n        }\n    }\n    let structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n    if (!structure) {\n        // copy src buffer because getStructures will override it\n        src = Uint8Array.prototype.slice.call(src, position, srcEnd);\n        srcEnd -= position;\n        position = 0;\n        unpackr._mergeStructures(unpackr.getStructures());\n        if (!unpackr.typedStructs) throw new Error(\"Could not find any shared typed structures\");\n        unpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n        structure = unpackr.typedStructs[recordId];\n        if (!structure) throw new Error(\"Could not find typed structure \" + recordId);\n    }\n    var construct = structure.construct;\n    if (!construct) {\n        construct = structure.construct = function LazyObject() {};\n        var prototype = construct.prototype;\n        let properties = [];\n        let currentOffset = 0;\n        let lastRefProperty;\n        for(let i = 0, l = structure.length; i < l; i++){\n            let definition = structure[i];\n            let [type, size, key, enumerationOffset] = definition;\n            if (key === \"__proto__\") key = \"__proto_\";\n            let property = {\n                key,\n                offset: currentOffset\n            };\n            if (enumerationOffset) properties.splice(i + enumerationOffset, 0, property);\n            else properties.push(property);\n            let getRef;\n            switch(size){\n                case 0:\n                    getRef = ()=>0;\n                    break;\n                case 1:\n                    getRef = (source, position)=>{\n                        let ref = source.bytes[position + property.offset];\n                        return ref >= 0xf6 ? toConstant(ref) : ref;\n                    };\n                    break;\n                case 2:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint16(position + property.offset, true);\n                        return ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n                case 4:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint32(position + property.offset, true);\n                        return ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n            }\n            property.getRef = getRef;\n            currentOffset += size;\n            let get;\n            switch(type){\n                case ASCII:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    property.multiGetCount = 0;\n                    get = function(source) {\n                        let src = source.bytes;\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (source.srcString) {\n                            return source.srcString.slice(ref, end);\n                        }\n                        /*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/ return (0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.readString)(src, ref + refStart, end - ref);\n                    //return src.toString('latin1', ref + refStart, end + refStart);\n                    };\n                    break;\n                case UTF8:\n                case OBJECT_DATA:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    get = function(source) {\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let src = source.bytes;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (type === UTF8) {\n                            return src.toString(\"utf8\", ref + refStart, end + refStart);\n                        } else {\n                            currentSource = source;\n                            try {\n                                return unpackr.unpack(src, {\n                                    start: ref + refStart,\n                                    end: end + refStart\n                                });\n                            } finally{\n                                currentSource = null;\n                            }\n                        }\n                    };\n                    break;\n                case NUMBER:\n                    switch(size){\n                        case 4:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let position = source.position + property.offset;\n                                let value = dataView.getInt32(position, true);\n                                if (value < 0x20000000) {\n                                    if (value > -0x1f000000) return value;\n                                    if (value > -0x20000000) return toConstant(value & 0xff);\n                                }\n                                let fValue = dataView.getFloat32(position, true);\n                                // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                                let multiplier = _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[(src[position + 3] & 0x7f) << 1 | src[position + 2] >> 7];\n                                return (multiplier * fValue + (fValue > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                            };\n                            break;\n                        case 8:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let value = dataView.getFloat64(source.position + property.offset, true);\n                                if (isNaN(value)) {\n                                    let byte = src[source.position + property.offset];\n                                    if (byte >= 0xf6) return toConstant(byte);\n                                }\n                                return value;\n                            };\n                            break;\n                        case 1:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let value = src[source.position + property.offset];\n                                return value < 0xf6 ? value : toConstant(value);\n                            };\n                            break;\n                    }\n                    break;\n                case DATE:\n                    get = function(source) {\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        return new Date(dataView.getFloat64(source.position + property.offset, true));\n                    };\n                    break;\n            }\n            property.get = get;\n        }\n        // TODO: load the srcString for faster string decoding on toJSON\n        if (evalSupported) {\n            let objectLiteralProperties = [];\n            let args = [];\n            let i = 0;\n            let hasInheritedProperties;\n            for (let property of properties){\n                if (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n                    // these properties are not eagerly evaluated and this can be used for creating properties\n                    // that are not serialized as JSON\n                    hasInheritedProperties = true;\n                    continue;\n                }\n                Object.defineProperty(prototype, property.key, {\n                    get: withSource(property.get),\n                    enumerable: true\n                });\n                let valueFunction = \"v\" + i++;\n                args.push(valueFunction);\n                objectLiteralProperties.push(\"[\" + JSON.stringify(property.key) + \"]:\" + valueFunction + \"(s)\");\n            }\n            if (hasInheritedProperties) {\n                objectLiteralProperties.push(\"__proto__:this\");\n            }\n            let toObject = new Function(...args, \"return function(s){return{\" + objectLiteralProperties.join(\",\") + \"}}\").apply(null, properties.map((prop)=>prop.get));\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    return toObject.call(this, this[sourceSymbol]);\n                }\n            });\n        } else {\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    // return an enumerable object with own properties to JSON stringify\n                    let resolved = {};\n                    for(let i = 0, l = properties.length; i < l; i++){\n                        // TODO: check alwaysLazyProperty\n                        let key = properties[i].key;\n                        resolved[key] = this[key];\n                    }\n                    return resolved;\n                }\n            });\n        }\n    }\n    var instance = new construct();\n    instance[sourceSymbol] = {\n        bytes: src,\n        position,\n        srcString: \"\",\n        bytesEnd: srcEnd\n    };\n    return instance;\n}\nfunction toConstant(code) {\n    switch(code){\n        case 0xf6:\n            return null;\n        case 0xf7:\n            return undefined;\n        case 0xf8:\n            return false;\n        case 0xf9:\n            return true;\n    }\n    throw new Error(\"Unknown constant\");\n}\nfunction withSource(get) {\n    return function() {\n        return get(this[sourceSymbol]);\n    };\n}\nfunction saveState() {\n    if (currentSource) {\n        currentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n        currentSource.position = 0;\n        currentSource.bytesEnd = currentSource.bytes.length;\n    }\n}\nfunction prepareStructures(structures, packr) {\n    if (packr.typedStructs) {\n        let structMap = new Map();\n        structMap.set(\"named\", structures);\n        structMap.set(\"typed\", packr.typedStructs);\n        structures = structMap;\n    }\n    let lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n    structures.isCompatible = (existing)=>{\n        let compatible = true;\n        if (existing instanceof Map) {\n            let named = existing.get(\"named\") || [];\n            if (named.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n            let typed = existing.get(\"typed\") || [];\n            if (typed.length !== lastTypedStructuresLength) compatible = false;\n        } else if (existing instanceof Array || Array.isArray(existing)) {\n            if (existing.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n        }\n        if (!compatible) packr._mergeStructures(existing);\n        return compatible;\n    };\n    packr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n    return structures;\n}\n(0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setReadStruct)(readStruct, onLoadedStructures, saveState);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y3QuanM/YzdmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG5cbkZvciBcImFueS1kYXRhXCI6XG4zMi01NSAtIHJlY29yZCB3aXRoIHJlY29yZCBpZHMgKC0zMilcbjU2IC0gOC1iaXQgcmVjb3JkIGlkc1xuNTcgLSAxNi1iaXQgcmVjb3JkIGlkc1xuNTggLSAyNC1iaXQgcmVjb3JkIGlkc1xuNTkgLSAzMi1iaXQgcmVjb3JkIGlkc1xuMjUwLTI1NSAtIGZvbGxvd2VkIGJ5IHR5cGVkIGZpeGVkIHdpZHRoIHZhbHVlc1xuNjQtMjUwIG1zZ3BhY2tyL2Nib3IvcGFpcmVkIGRhdGFcbmFycmF5cyBhbmQgc3RyaW5ncyB3aXRoaW4gYXJyYXlzIGFyZSBoYW5kbGVkIGJ5IHBhaXJlZCBlbmNvZGluZ1xuXG5TdHJ1Y3R1cmUgZW5jb2Rpbmc6XG4odHlwZSAtIHN0cmluZyAodXNpbmcgcGFpcmVkIGVuY29kaW5nKSkrXG5cblR5cGUgZW5jb2RpbmdcbmVuY29kaW5nIGJ5dGUgLSBmaXhlZCB3aWR0aCBieXRlIC0gbmV4dCByZWZlcmVuY2UrXG5cbkVuY29kaW5nIGJ5dGU6XG5maXJzdCBiaXQ6XG5cdDAgLSBpbmxpbmVcblx0MSAtIHJlZmVyZW5jZVxuc2Vjb25kIGJpdDpcblx0MCAtIGRhdGEgb3IgbnVtYmVyXG5cdDEgLSBzdHJpbmdcblxucmVtYWluaW5nIGJpdHM6XG5cdGNoYXJhY3RlciBlbmNvZGluZyAtIElTTy04ODU5LXhcblxuXG5udWxsICgweGZmKSsgMHhmNlxubnVsbCAoMHhmZikrIDB4ZjdcblxuKi9cblxuXG5pbXBvcnQge3NldFdyaXRlU3RydWN0U2xvdHMsIFJFQ09SRF9TWU1CT0wsIGFkZEV4dGVuc2lvbn0gZnJvbSAnLi9wYWNrLmpzJ1xuaW1wb3J0IHtzZXRSZWFkU3RydWN0LCBtdWx0MTAsIHJlYWRTdHJpbmd9IGZyb20gJy4vdW5wYWNrLmpzJztcbmNvbnN0IEFTQ0lJID0gMzsgLy8gdGhlIE1JQmVudW0gZnJvbSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9jaGFyYWN0ZXItc2V0cy9jaGFyYWN0ZXItc2V0cy54aHRtbCAoYW5kIG90aGVyIGNoYXJhY3RlciBlbmNvZGluZ3MgY291bGQgYmUgcmVmZXJlbmNlZCBieSBNSUJlbnVtKVxuY29uc3QgTlVNQkVSID0gMDtcbmNvbnN0IFVURjggPSAyO1xuY29uc3QgT0JKRUNUX0RBVEEgPSAxO1xuY29uc3QgREFURSA9IDE2O1xuY29uc3QgVFlQRV9OQU1FUyA9IFsnbnVtJywgJ29iamVjdCcsICdzdHJpbmcnLCAnYXNjaWknXTtcblRZUEVfTkFNRVNbREFURV0gPSAnZGF0ZSc7XG5jb25zdCBmbG9hdDMySGVhZGVycyA9IFtmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZV07XG5sZXQgZXZhbFN1cHBvcnRlZDtcbnRyeSB7XG5cdG5ldyBGdW5jdGlvbignJyk7XG5cdGV2YWxTdXBwb3J0ZWQgPSB0cnVlO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG59XG5cbmxldCB1cGRhdGVkUG9zaXRpb247XG5jb25zdCBoYXNOb2RlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbmxldCB0ZXh0RW5jb2RlciwgY3VycmVudFNvdXJjZTtcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbn0gY2F0Y2ggKGVycm9yKSB7fVxuY29uc3QgZW5jb2RlVXRmOCA9IGhhc05vZGVCdWZmZXIgPyBmdW5jdGlvbih0YXJnZXQsIHN0cmluZywgcG9zaXRpb24pIHtcblx0cmV0dXJuIHRhcmdldC51dGY4V3JpdGUoc3RyaW5nLCBwb3NpdGlvbiwgMHhmZmZmZmZmZilcbn0gOiAodGV4dEVuY29kZXIgJiYgdGV4dEVuY29kZXIuZW5jb2RlSW50bykgP1xuXHRmdW5jdGlvbih0YXJnZXQsIHN0cmluZywgcG9zaXRpb24pIHtcblx0XHRyZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0fSA6IGZhbHNlXG5cbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKTtcbmNvbnN0IFBBUkVOVCA9IFN5bWJvbCgncGFyZW50Jyk7XG5zZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU3RydWN0LCBwcmVwYXJlU3RydWN0dXJlcyk7XG5mdW5jdGlvbiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcikge1xuXHRsZXQgdHlwZWRTdHJ1Y3RzID0gcGFja3IudHlwZWRTdHJ1Y3RzIHx8IChwYWNrci50eXBlZFN0cnVjdHMgPSBbXSk7XG5cdC8vIG5vdGUgdGhhdCB3ZSByZWx5IG9uIHBhY2suanMgdG8gbG9hZCBzdG9yZWQgc3RydWN0dXJlcyBiZWZvcmUgd2UgZ2V0IHRvIHRoaXMgcG9pbnRcblx0bGV0IHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdGxldCByZWZzU3RhcnRQb3NpdGlvbiA9ICh0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0IHx8IDEwMCkgKyBwb3NpdGlvbjtcblx0bGV0IHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uO1xuXHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0fVxuXG5cdGxldCByZWZPZmZzZXQsIHJlZlBvc2l0aW9uID0gcmVmc1N0YXJ0UG9zaXRpb247XG5cblx0bGV0IHRyYW5zaXRpb24gPSB0eXBlZFN0cnVjdHMudHJhbnNpdGlvbnMgfHwgKHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRsZXQgbmV4dElkID0gdHlwZWRTdHJ1Y3RzLm5leHRJZCB8fCB0eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRsZXQgaGVhZGVyU2l6ZSA9XG5cdFx0bmV4dElkIDwgMHhmID8gMSA6XG5cdFx0XHRuZXh0SWQgPCAweGYwID8gMiA6XG5cdFx0XHRcdG5leHRJZCA8IDB4ZjAwMCA/IDMgOlxuXHRcdFx0XHRcdG5leHRJZCA8IDB4ZjAwMDAwID8gNCA6IDA7XG5cdGlmIChoZWFkZXJTaXplID09PSAwKVxuXHRcdHJldHVybiAwO1xuXHRwb3NpdGlvbiArPSBoZWFkZXJTaXplO1xuXHRsZXQgcXVldWVkUmVmZXJlbmNlcyA9IFtdO1xuXHRsZXQgdXNlZEFzY2lpMDtcblx0bGV0IGtleUluZGV4ID0gMDtcblx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiAwLFxuXHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0bnVtODogbnVsbCxcblx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRudW0zMjogbnVsbCxcblx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0ZGF0ZTY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuXHRcdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdFx0bGV0IG51bWJlciA9IHZhbHVlO1xuXHRcdFx0XHQvLyBmaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIHVzaW5nIGEgbG90IG9mIGlkcyBhbmQgc2hvdWxkIGRlZmF1bHQgdG8gd2lkZS9jb21tb24gZm9ybWF0XG5cdFx0XHRcdGlmIChuZXh0SWQgPCAyMDAgfHwgIW5leHRUcmFuc2l0aW9uLm51bTY0KSB7XG5cdFx0XHRcdFx0aWYgKG51bWJlciA+PiAwID09PSBudW1iZXIgJiYgbnVtYmVyIDwgMHgyMDAwMDAwMCAmJiBudW1iZXIgPiAtMHgxZjAwMDAwMCkge1xuXHRcdFx0XHRcdFx0aWYgKG51bWJlciA8IDB4ZjYgJiYgbnVtYmVyID49IDAgJiYgKG5leHRUcmFuc2l0aW9uLm51bTggJiYgIShuZXh0SWQgPiAyMDAgJiYgbmV4dFRyYW5zaXRpb24ubnVtMzIpIHx8IG51bWJlciA8IDB4MjAgJiYgIW5leHRUcmFuc2l0aW9uLm51bTMyKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCAxKTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbnVtYmVyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAgJiYgbnVtYmVyID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoZmxvYXQzMkhlYWRlcnNbdGFyZ2V0W3Bvc2l0aW9uICsgM10gPj4+IDVdKSB7XG5cdFx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZFxuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGNoZWNrcyBmb3Igcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdGlmICgoKHhTaGlmdGVkID0gbnVtYmVyICogbXVsdDEwWygodGFyZ2V0W3Bvc2l0aW9uICsgM10gJiAweDdmKSA8PCAxKSB8ICh0YXJnZXRbcG9zaXRpb24gKyAyXSA+PiA3KV0pID4+IDApID09PSB4U2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW0zMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCA0KTtcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW02NCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCA4KTtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCBudW1iZXIsIHRydWUpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdGxldCBzdHJMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHJlZk9mZnNldCA9IHJlZlBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0XHRcdGlmICgoc3RyTGVuZ3RoIDw8IDIpICsgcmVmUG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20oKHN0ckxlbmd0aCA8PCAyKSArIHJlZlBvc2l0aW9uKTtcblx0XHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHJlZlBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPiAoKDB4ZmYwMCArIHJlZk9mZnNldCkgPj4gMikpIHtcblx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwgcG9zaXRpb24gLSBzdGFydCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGlzTm90QXNjaWlcblx0XHRcdFx0bGV0IHN0clN0YXJ0ID0gcmVmUG9zaXRpb247XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwKSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMjtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXHRcdFx0XHRcdFx0aWYgKGMxIDwgMHg4MCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2IHwgMHhjMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHQoYzEgJiAweGZjMDApID09PSAweGQ4MDAgJiZcblx0XHRcdFx0XHRcdFx0KChjMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpXG5cdFx0XHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxOCB8IDB4ZjBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTIgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDEyIHwgMHhlMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWZQb3NpdGlvbiArPSBlbmNvZGVVdGY4KHRhcmdldCwgdmFsdWUsIHJlZlBvc2l0aW9uKTtcblx0XHRcdFx0XHRpc05vdEFzY2lpID0gcmVmUG9zaXRpb24gLSBzdHJTdGFydCA+IHN0ckxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVmT2Zmc2V0IDwgMHhhMCB8fCAocmVmT2Zmc2V0IDwgMHhmNiAmJiAobmV4dFRyYW5zaXRpb24uYXNjaWk4IHx8IG5leHRUcmFuc2l0aW9uLnN0cmluZzgpKSkge1xuXHRcdFx0XHRcdC8vIHNob3J0IHN0cmluZ3Ncblx0XHRcdFx0XHRpZiAoaXNOb3RBc2NpaSkge1xuXHRcdFx0XHRcdFx0aWYgKCEodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnN0cmluZzgpKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlZFN0cnVjdHMubGVuZ3RoID4gMTAgJiYgKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgY2FuIHNhZmVseSBjaGFuZ2UgYXNjaWkgdG8gdXRmOCBpbiBwbGFjZSBzaW5jZSB0aGV5IGFyZSBjb21wYXRpYmxlXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbi5fX3R5cGUgPSBVVEY4O1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uLmFzY2lpOCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24uc3RyaW5nOCA9IHRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhudWxsLCAwLCB0cnVlKTsgLy8gc3BlY2lhbCBjYWxsIHRvIG5vdGlmeSB0aGF0IHN0cnVjdHVyZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIFVURjgsIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyZWZPZmZzZXQgPT09IDAgJiYgIXVzZWRBc2NpaTApIHtcblx0XHRcdFx0XHRcdHVzZWRBc2NpaTAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpMCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDApO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGRvbid0IGluY3JlbWVudCBwb3NpdGlvblxuXHRcdFx0XHRcdH0vLyBlbHNlIGFzY2lpOlxuXHRcdFx0XHRcdGVsc2UgaWYgKCEodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpOCkgJiYgISh0eXBlZFN0cnVjdHMubGVuZ3RoID4gMTAgJiYgKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkpXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIEFTQ0lJLCAxKTtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWZPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogRW5hYmxlIGFzY2lpMTYgYXQgc29tZSBwb2ludCwgYnV0IGdldCB0aGUgbG9naWMgcmlnaHRcblx0XHRcdFx0XHQvL2lmIChpc05vdEFzY2lpKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnN0cmluZzE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBVVEY4LCAyKTtcblx0XHRcdFx0XHQvL2Vsc2Vcblx0XHRcdFx0XHRcdC8vdHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpMTYgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIEFTQ0lJLCAyKTtcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihwb3NpdGlvbiwgcmVmT2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBEYXRlKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uZGF0ZTY0IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBEQVRFLCA4KTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgdmFsdWUuZ2V0VGltZSgpLCB0cnVlKTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBudWxsXG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSBhbnlUeXBlKG5leHRUcmFuc2l0aW9uLCBwb3NpdGlvbiwgdGFyZ2V0VmlldywgLTEwKTsgLy8gbWF0Y2ggQ0JPUiB3aXRoIHRoaXNcblx0XHRcdFx0XHRpZiAobmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdHBvc2l0aW9uID0gdXBkYXRlZFBvc2l0aW9uO1xuXHRcdFx0XHRcdH0gZWxzZSBxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYm9vbGVhbic6XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW04IHx8IG5leHRUcmFuc2l0aW9uLmFzY2lpOCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCAxKTtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPyAweGY5IDogMHhmODsgLy8gbWF0Y2ggQ0JPUiB3aXRoIHRoZXNlXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndW5kZWZpbmVkJzpcblx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSBhbnlUeXBlKG5leHRUcmFuc2l0aW9uLCBwb3NpdGlvbiwgdGFyZ2V0VmlldywgLTkpOyAvLyBtYXRjaCBDQk9SIHdpdGggdGhpc1xuXHRcdFx0XHRpZiAobmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0cG9zaXRpb24gPSB1cGRhdGVkUG9zaXRpb247XG5cdFx0XHRcdH0gZWxzZSBxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0fVxuXHRcdGtleUluZGV4Kys7XG5cdH1cblxuXHRmb3IgKGxldCBpID0gMCwgbCA9IHF1ZXVlZFJlZmVyZW5jZXMubGVuZ3RoOyBpIDwgbDspIHtcblx0XHRsZXQga2V5ID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCB2YWx1ZSA9IHF1ZXVlZFJlZmVyZW5jZXNbaSsrXTtcblx0XHRsZXQgcHJvcGVydHlJbmRleCA9IHF1ZXVlZFJlZmVyZW5jZXNbaSsrXTtcblx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0dHJhbnNpdGlvbltrZXldID0gbmV4dFRyYW5zaXRpb24gPSB7XG5cdFx0XHRcdGtleSxcblx0XHRcdFx0cGFyZW50OiB0cmFuc2l0aW9uLFxuXHRcdFx0XHRlbnVtZXJhdGlvbk9mZnNldDogcHJvcGVydHlJbmRleCAtIGtleUluZGV4LFxuXHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0bnVtODogbnVsbCxcblx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRudW0zMjogbnVsbCxcblx0XHRcdFx0ZmxvYXQ2NDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0bGV0IG5ld1Bvc2l0aW9uO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0LyppZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyAvLyBUT0RPOiB3ZSBjb3VsZCByZS1lbmFibGUgbG9uZyBzdHJpbmdzXG5cdFx0XHRcdGlmIChwb3NpdGlvbiArIHZhbHVlLmxlbmd0aCAqIDMgPiBzYWZlRW5kKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyB2YWx1ZS5sZW5ndGggKiAzKTtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSBzdGFydDtcblx0XHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdFx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdQb3NpdGlvbiA9IHBvc2l0aW9uICsgdGFyZ2V0LnV0ZjhXcml0ZSh2YWx1ZSwgcG9zaXRpb24sIDB4ZmZmZmZmZmYpO1xuXHRcdFx0fSBlbHNlIHsgKi9cblx0XHRcdGxldCBzaXplO1xuXHRcdFx0cmVmT2Zmc2V0ID0gcmVmUG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHRcdGlmIChyZWZPZmZzZXQgPCAweGZmMDApIHtcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDE2O1xuXHRcdFx0XHRpZiAodHJhbnNpdGlvbilcblx0XHRcdFx0XHRzaXplID0gMjtcblx0XHRcdFx0ZWxzZSBpZiAoKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QzMikpXG5cdFx0XHRcdFx0c2l6ZSA9IDQ7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDIpO1xuXHRcdFx0XHRcdHNpemUgPSAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MzIgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE9CSkVDVF9EQVRBLCA0KTtcblx0XHRcdFx0c2l6ZSA9IDQ7XG5cdFx0XHR9XG5cdFx0XHRuZXdQb3NpdGlvbiA9IHBhY2sodmFsdWUsIHJlZlBvc2l0aW9uKTtcblx0XHRcdC8vfVxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQb3NpdGlvbiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gcmUtYWxsb2NhdGVkXG5cdFx0XHRcdHJlZlBvc2l0aW9uID0gbmV3UG9zaXRpb24ucG9zaXRpb247XG5cdFx0XHRcdHRhcmdldFZpZXcgPSBuZXdQb3NpdGlvbi50YXJnZXRWaWV3O1xuXHRcdFx0XHR0YXJnZXQgPSBuZXdQb3NpdGlvbi50YXJnZXQ7XG5cdFx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdHBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHJlZlBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHRpZiAoc2l6ZSA9PT0gMikge1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihwb3NpdGlvbiwgcmVmT2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIG51bGwgb3IgdW5kZWZpbmVkXG5cdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MTYgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE9CSkVDVF9EQVRBLCAyKTtcblx0XHRcdHRhcmdldFZpZXcuc2V0SW50MTYocG9zaXRpb24sIHZhbHVlID09PSBudWxsID8gLTEwIDogLTksIHRydWUpO1xuXHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHR9XG5cdFx0a2V5SW5kZXgrKztcblx0fVxuXG5cblx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXTtcblx0aWYgKHJlY29yZElkID09IG51bGwpIHtcblx0XHRyZWNvcmRJZCA9IHBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IFtdO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdFx0bGV0IGtleSwgdHlwZTtcblx0XHR3aGlsZSAoKHR5cGUgPSBuZXh0VHJhbnNpdGlvbi5fX3R5cGUpICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxldCBzaXplID0gbmV4dFRyYW5zaXRpb24uX19zaXplO1xuXHRcdFx0bmV4dFRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5fX3BhcmVudDtcblx0XHRcdGtleSA9IG5leHRUcmFuc2l0aW9uLmtleTtcblx0XHRcdGxldCBwcm9wZXJ0eSA9IFt0eXBlLCBzaXplLCBrZXldO1xuXHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uLmVudW1lcmF0aW9uT2Zmc2V0KVxuXHRcdFx0XHRwcm9wZXJ0eS5wdXNoKG5leHRUcmFuc2l0aW9uLmVudW1lcmF0aW9uT2Zmc2V0KTtcblx0XHRcdHN0cnVjdHVyZS5wdXNoKHByb3BlcnR5KTtcblx0XHRcdG5leHRUcmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ucGFyZW50O1xuXHRcdH1cblx0XHRzdHJ1Y3R1cmUucmV2ZXJzZSgpO1xuXHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSByZWNvcmRJZDtcblx0XHRwYWNrci50eXBlZFN0cnVjdHNbcmVjb3JkSWRdID0gc3RydWN0dXJlO1xuXHRcdHBhY2sobnVsbCwgMCwgdHJ1ZSk7IC8vIHNwZWNpYWwgY2FsbCB0byBub3RpZnkgdGhhdCBzdHJ1Y3R1cmVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdH1cblxuXG5cdHN3aXRjaCAoaGVhZGVyU2l6ZSkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSByZWNvcmRJZCArIDB4MjA7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0W3N0YXJ0XSA9IDB4Mzg7XG5cdFx0XHR0YXJnZXRbc3RhcnQgKyAxXSA9IHJlY29yZElkO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwMDApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0W3N0YXJ0XSA9IDB4Mzk7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihzdGFydCArIDEsIHJlY29yZElkLCB0cnVlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNDpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMDAwMDApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIoc3RhcnQsIChyZWNvcmRJZCA8PCA4KSArIDB4M2EsIHRydWUpO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRpZiAocG9zaXRpb24gPCByZWZzU3RhcnRQb3NpdGlvbikge1xuXHRcdGlmIChyZWZzU3RhcnRQb3NpdGlvbiA9PT0gcmVmUG9zaXRpb24pXG5cdFx0XHRyZXR1cm4gcG9zaXRpb247IC8vIG5vIHJlZnNcblx0XHQvLyBhZGp1c3QgcG9zaXRpb25pbmdcblx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiwgcmVmc1N0YXJ0UG9zaXRpb24sIHJlZlBvc2l0aW9uKTtcblx0XHRyZWZQb3NpdGlvbiArPSBwb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHR9IGVsc2UgaWYgKHBvc2l0aW9uID4gcmVmc1N0YXJ0UG9zaXRpb24pIHtcblx0XHRpZiAocmVmc1N0YXJ0UG9zaXRpb24gPT09IHJlZlBvc2l0aW9uKVxuXHRcdFx0cmV0dXJuIHBvc2l0aW9uOyAvLyBubyByZWZzXG5cdFx0dHlwZWRTdHJ1Y3RzLmxhc3RTdHJpbmdTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0cmV0dXJuIHdyaXRlU3RydWN0KG9iamVjdCwgdGFyZ2V0LCBlbmNvZGluZ1N0YXJ0LCBzdGFydCwgc3RydWN0dXJlcywgbWFrZVJvb20sIHBhY2ssIHBhY2tyKTtcblx0fVxuXHRyZXR1cm4gcmVmUG9zaXRpb247XG59XG5mdW5jdGlvbiBhbnlUeXBlKHRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCB2YWx1ZSkge1xuXHRsZXQgbmV4dFRyYW5zaXRpb247XG5cdGlmICgobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLmFzY2lpOCB8fCB0cmFuc2l0aW9uLm51bTgpKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQ4KHBvc2l0aW9uLCB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHRpZiAoKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5zdHJpbmcxNiB8fCB0cmFuc2l0aW9uLm9iamVjdDE2KSkge1xuXHRcdHRhcmdldFZpZXcuc2V0SW50MTYocG9zaXRpb24sIHZhbHVlLCB0cnVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDI7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdGlmIChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24ubnVtMzIpIHtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgMHhlMDAwMDEwMCArIHZhbHVlLCB0cnVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDQ7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdC8vIHRyYW5zaXRpb24uZmxvYXQ2NFxuXHRpZiAobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLm51bTY0KSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCBOYU4sIHRydWUpO1xuXHRcdHRhcmdldFZpZXcuc2V0SW50OChwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgODtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb247XG5cdC8vIFRPRE86IGNhbiB3ZSBkbyBhbiBcImFueVwiIHR5cGUgd2hlcmUgd2UgZGVmZXIgdGhlIGRlY2lzaW9uP1xuXHRyZXR1cm47XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCB0eXBlLCBzaXplKSB7XG5cdGxldCB0eXBlTmFtZSA9IFRZUEVfTkFNRVNbdHlwZV0gKyAoc2l6ZSA8PCAzKTtcblx0bGV0IG5ld1RyYW5zaXRpb24gPSB0cmFuc2l0aW9uW3R5cGVOYW1lXSB8fCAodHJhbnNpdGlvblt0eXBlTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblx0bmV3VHJhbnNpdGlvbi5fX3R5cGUgPSB0eXBlO1xuXHRuZXdUcmFuc2l0aW9uLl9fc2l6ZSA9IHNpemU7XG5cdG5ld1RyYW5zaXRpb24uX19wYXJlbnQgPSB0cmFuc2l0aW9uO1xuXHRyZXR1cm4gbmV3VHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIG9uTG9hZGVkU3RydWN0dXJlcyhzaGFyZWREYXRhKSB7XG5cdGlmICghKHNoYXJlZERhdGEgaW5zdGFuY2VvZiBNYXApKVxuXHRcdHJldHVybiBzaGFyZWREYXRhO1xuXHRsZXQgdHlwZWQgPSBzaGFyZWREYXRhLmdldCgndHlwZWQnKSB8fCBbXTtcblx0aWYgKE9iamVjdC5pc0Zyb3plbih0eXBlZCkpXG5cdFx0dHlwZWQgPSB0eXBlZC5tYXAoc3RydWN0dXJlID0+IHN0cnVjdHVyZS5zbGljZSgwKSk7XG5cdGxldCBuYW1lZCA9IHNoYXJlZERhdGEuZ2V0KCduYW1lZCcpO1xuXHRsZXQgdHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRmb3IgKGxldCBpID0gMCwgbCA9IHR5cGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGxldCBzdHJ1Y3R1cmUgPSB0eXBlZFtpXTtcblx0XHRsZXQgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zO1xuXHRcdGZvciAobGV0IFt0eXBlLCBzaXplLCBrZXldIG9mIHN0cnVjdHVyZSkge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0cGFyZW50OiB0cmFuc2l0aW9uLFxuXHRcdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiAwLFxuXHRcdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0XHRhc2NpaTg6IG51bGwsXG5cdFx0XHRcdFx0bnVtODogbnVsbCxcblx0XHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0XHRvYmplY3QxNjogbnVsbCxcblx0XHRcdFx0XHRudW0zMjogbnVsbCxcblx0XHRcdFx0XHRmbG9hdDY0OiBudWxsLFxuXHRcdFx0XHRcdGRhdGU2NDogbnVsbCxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgdHlwZSwgc2l6ZSk7XG5cdFx0fVxuXHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSBpO1xuXHR9XG5cdHR5cGVkLnRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnM7XG5cdHRoaXMudHlwZWRTdHJ1Y3RzID0gdHlwZWQ7XG5cdHRoaXMubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHR5cGVkLmxlbmd0aDtcblx0cmV0dXJuIG5hbWVkO1xufVxudmFyIHNvdXJjZVN5bWJvbCA9IFN5bWJvbC5mb3IoJ3NvdXJjZScpXG5mdW5jdGlvbiByZWFkU3RydWN0KHNyYywgcG9zaXRpb24sIHNyY0VuZCwgdW5wYWNrcikge1xuXHRsZXQgcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gLSAweDIwO1xuXHRpZiAocmVjb3JkSWQgPj0gMjQpIHtcblx0XHRzd2l0Y2gocmVjb3JkSWQpIHtcblx0XHRcdGNhc2UgMjQ6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdOyBicmVhaztcblx0XHRcdC8vIGxpdHRsZSBlbmRpYW46XG5cdFx0XHRjYXNlIDI1OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCk7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNjogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNik7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNzogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNikgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDI0KTsgYnJlYWs7XG5cdFx0fVxuXHR9XG5cdGxldCBzdHJ1Y3R1cmUgPSB1bnBhY2tyLnR5cGVkU3RydWN0cyAmJiB1bnBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF07XG5cdGlmICghc3RydWN0dXJlKSB7XG5cdFx0Ly8gY29weSBzcmMgYnVmZmVyIGJlY2F1c2UgZ2V0U3RydWN0dXJlcyB3aWxsIG92ZXJyaWRlIGl0XG5cdFx0c3JjID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uLCBzcmNFbmQpO1xuXHRcdHNyY0VuZCAtPSBwb3NpdGlvbjtcblx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0dW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKHVucGFja3IuZ2V0U3RydWN0dXJlcygpKTtcblx0XHRpZiAoIXVucGFja3IudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhbnkgc2hhcmVkIHR5cGVkIHN0cnVjdHVyZXMnKTtcblx0XHR1bnBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSB1bnBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdFx0c3RydWN0dXJlID0gdW5wYWNrci50eXBlZFN0cnVjdHNbcmVjb3JkSWRdO1xuXHRcdGlmICghc3RydWN0dXJlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBzdHJ1Y3R1cmUgJyArIHJlY29yZElkKTtcblx0fVxuXHR2YXIgY29uc3RydWN0ID0gc3RydWN0dXJlLmNvbnN0cnVjdDtcblx0aWYgKCFjb25zdHJ1Y3QpIHtcblx0XHRjb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuY29uc3RydWN0ID0gZnVuY3Rpb24gTGF6eU9iamVjdCgpIHtcblx0XHR9XG5cdFx0dmFyIHByb3RvdHlwZSA9IGNvbnN0cnVjdC5wcm90b3R5cGU7XG5cdFx0bGV0IHByb3BlcnRpZXMgPSBbXTtcblx0XHRsZXQgY3VycmVudE9mZnNldCA9IDA7XG5cdFx0bGV0IGxhc3RSZWZQcm9wZXJ0eTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN0cnVjdHVyZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBkZWZpbml0aW9uID0gc3RydWN0dXJlW2ldO1xuXHRcdFx0bGV0IFsgdHlwZSwgc2l6ZSwga2V5LCBlbnVtZXJhdGlvbk9mZnNldCBdID0gZGVmaW5pdGlvbjtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0bGV0IHByb3BlcnR5ID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdG9mZnNldDogY3VycmVudE9mZnNldCxcblx0XHRcdH1cblx0XHRcdGlmIChlbnVtZXJhdGlvbk9mZnNldClcblx0XHRcdFx0cHJvcGVydGllcy5zcGxpY2UoaSArIGVudW1lcmF0aW9uT2Zmc2V0LCAwLCBwcm9wZXJ0eSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHRsZXQgZ2V0UmVmO1xuXHRcdFx0c3dpdGNoKHNpemUpIHsgLy8gVE9ETzogTW92ZSBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb25cblx0XHRcdFx0Y2FzZSAwOiBnZXRSZWYgPSAoKSA9PiAwOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gc291cmNlLmJ5dGVzW3Bvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmNiA/IHRvQ29uc3RhbnQocmVmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGZmMDAgPyB0b0NvbnN0YW50KHJlZiAmIDB4ZmYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZmZmZmZmMDAgPyB0b0NvbnN0YW50KHJlZiAmIDB4ZmYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwcm9wZXJ0eS5nZXRSZWYgPSBnZXRSZWY7XG5cdFx0XHRjdXJyZW50T2Zmc2V0ICs9IHNpemU7XG5cdFx0XHRsZXQgZ2V0O1xuXHRcdFx0c3dpdGNoKHR5cGUpIHtcblx0XHRcdFx0Y2FzZSBBU0NJSTpcblx0XHRcdFx0XHRpZiAobGFzdFJlZlByb3BlcnR5ICYmICFsYXN0UmVmUHJvcGVydHkubmV4dClcblx0XHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eS5uZXh0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0cHJvcGVydHkubXVsdGlHZXRDb3VudCA9IDA7XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZlN0YXJ0ID0gY3VycmVudE9mZnNldCArIHBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcmVmICE9PSAnbnVtYmVyJykgcmV0dXJuIHJlZjtcblxuXHRcdFx0XHRcdFx0bGV0IGVuZCwgbmV4dCA9IHByb3BlcnR5Lm5leHQ7XG5cdFx0XHRcdFx0XHR3aGlsZShuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IG5leHQuZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydDtcblx0XHRcdFx0XHRcdGlmIChzb3VyY2Uuc3JjU3RyaW5nKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3VyY2Uuc3JjU3RyaW5nLnNsaWNlKHJlZiwgZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qaWYgKHByb3BlcnR5Lm11bHRpR2V0Q291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBhc2NpaUVuZDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IGZpcnN0UmVmUHJvcGVydHk7XG5cdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBkYXRhVmlldy5nZXRVaW50MTYoc291cmNlLnBvc2l0aW9uICsgbmV4dC5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhc2NpaUVuZCA8IDB4ZmYwMClcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fSB3aGlsZSgobmV4dCA9IG5leHQubmV4dCkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXNjaWlFbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5zcmNTdHJpbmcgPSBzcmMudG9TdHJpbmcoJ2xhdGluMScsIHJlZlN0YXJ0LCByZWZTdGFydCArIGFzY2lpRW5kKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvdXJjZS5zcmNTdHJpbmcuc2xpY2UocmVmLCBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5wcmV2U3RyaW5nR2V0KSB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5wcmV2U3RyaW5nR2V0Lm11bHRpR2V0Q291bnQgKz0gMjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5wcmV2U3RyaW5nR2V0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5Lm11bHRpR2V0Q291bnQtLTtcblx0XHRcdFx0XHRcdH0qL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmcoc3JjLCByZWYgKyByZWZTdGFydCwgZW5kIC0gcmVmKTtcblx0XHRcdFx0XHRcdC8vcmV0dXJuIHNyYy50b1N0cmluZygnbGF0aW4xJywgcmVmICsgcmVmU3RhcnQsIGVuZCArIHJlZlN0YXJ0KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFVURjg6IGNhc2UgT0JKRUNUX0RBVEE6XG5cdFx0XHRcdFx0aWYgKGxhc3RSZWZQcm9wZXJ0eSAmJiAhbGFzdFJlZlByb3BlcnR5Lm5leHQpXG5cdFx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkubmV4dCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZlN0YXJ0ID0gY3VycmVudE9mZnNldCArIHBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcmVmICE9PSAnbnVtYmVyJykgcmV0dXJuIHJlZjtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZW5kLCBuZXh0ID0gcHJvcGVydHkubmV4dDtcblx0XHRcdFx0XHRcdHdoaWxlKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gbmV4dC5nZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJylcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09IFVURjgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNyYy50b1N0cmluZygndXRmOCcsIHJlZiArIHJlZlN0YXJ0LCBlbmQgKyByZWZTdGFydCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50U291cmNlID0gc291cmNlO1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1bnBhY2tyLnVucGFjayhzcmMsIHsgc3RhcnQ6IHJlZiArIHJlZlN0YXJ0LCBlbmQ6IGVuZCArIHJlZlN0YXJ0IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRTb3VyY2UgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBOVU1CRVI6XG5cdFx0XHRcdFx0c3dpdGNoKHNpemUpIHtcblx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEludDMyKHBvc2l0aW9uLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA8IDB4MjAwMDAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+IC0weDFmMDAwMDAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPiAtMHgyMDAwMDAwMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvQ29uc3RhbnQodmFsdWUgJiAweGZmKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGZWYWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbiArIDNdICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uICsgMl0gPj4gNyldXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIGZWYWx1ZSArIChmVmFsdWUgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllcjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQoc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGJ5dGUgPj0gMHhmNilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvQ29uc3RhbnQoYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA8IDB4ZjYgPyB2YWx1ZSA6IHRvQ29uc3RhbnQodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgREFURTpcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoZGF0YVZpZXcuZ2V0RmxvYXQ2NChzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0XHRwcm9wZXJ0eS5nZXQgPSBnZXQ7XG5cdFx0fVxuXHRcdC8vIFRPRE86IGxvYWQgdGhlIHNyY1N0cmluZyBmb3IgZmFzdGVyIHN0cmluZyBkZWNvZGluZyBvbiB0b0pTT05cblx0XHRpZiAoZXZhbFN1cHBvcnRlZCkge1xuXHRcdFx0bGV0IG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0bGV0IGhhc0luaGVyaXRlZFByb3BlcnRpZXM7XG5cdFx0XHRmb3IgKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7IC8vIGFzc2lnbiBpbiBlbnVtZXJhdGlvbiBvcmRlclxuXHRcdFx0XHRpZiAodW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkgJiYgdW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuXHRcdFx0XHRcdC8vIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBlYWdlcmx5IGV2YWx1YXRlZCBhbmQgdGhpcyBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgcHJvcGVydGllc1xuXHRcdFx0XHRcdC8vIHRoYXQgYXJlIG5vdCBzZXJpYWxpemVkIGFzIEpTT05cblx0XHRcdFx0XHRoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wZXJ0eS5rZXksIHsgZ2V0OiB3aXRoU291cmNlKHByb3BlcnR5LmdldCksIGVudW1lcmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGxldCB2YWx1ZUZ1bmN0aW9uID0gJ3YnICsgaSsrO1xuXHRcdFx0XHRhcmdzLnB1c2godmFsdWVGdW5jdGlvbik7XG5cdFx0XHRcdG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLnB1c2goJ1snICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkua2V5KSArICddOicgKyB2YWx1ZUZ1bmN0aW9uICsgJyhzKScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0luaGVyaXRlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnX19wcm90b19fOnRoaXMnKTtcblx0XHRcdH1cblx0XHRcdGxldCB0b09iamVjdCA9IChuZXcgRnVuY3Rpb24oLi4uYXJncywgJ3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm57JyArIG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLmpvaW4oJywnKSArICd9fScpKS5hcHBseShudWxsLCBwcm9wZXJ0aWVzLm1hcChwcm9wID0+IHByb3AuZ2V0KSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAndG9KU09OJywge1xuXHRcdFx0XHR2YWx1ZShvbWl0VW5kZXJzY29yZWRQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvT2JqZWN0LmNhbGwodGhpcywgdGhpc1tzb3VyY2VTeW1ib2xdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHQvLyByZXR1cm4gYW4gZW51bWVyYWJsZSBvYmplY3Qgd2l0aCBvd24gcHJvcGVydGllcyB0byBKU09OIHN0cmluZ2lmeVxuXHRcdFx0XHRcdGxldCByZXNvbHZlZCA9IHt9O1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGNoZWNrIGFsd2F5c0xhenlQcm9wZXJ0eVxuXHRcdFx0XHRcdFx0bGV0IGtleSA9IHByb3BlcnRpZXNbaV0ua2V5O1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlZFtrZXldID0gdGhpc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIG5vdCBlbnVtZXJhYmxlIG9yIGFueXRoaW5nXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0dmFyIGluc3RhbmNlID0gbmV3IGNvbnN0cnVjdCgpO1xuXHRpbnN0YW5jZVtzb3VyY2VTeW1ib2xdID0ge1xuXHRcdGJ5dGVzOiBzcmMsXG5cdFx0cG9zaXRpb24sXG5cdFx0c3JjU3RyaW5nOiAnJyxcblx0XHRieXRlc0VuZDogc3JjRW5kXG5cdH1cblx0cmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdG9Db25zdGFudChjb2RlKSB7XG5cdHN3aXRjaChjb2RlKSB7XG5cdFx0Y2FzZSAweGY2OiByZXR1cm4gbnVsbDtcblx0XHRjYXNlIDB4Zjc6IHJldHVybiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSAweGY4OiByZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSAweGY5OiByZXR1cm4gdHJ1ZTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29uc3RhbnQnKTtcbn1cbmZ1bmN0aW9uIHdpdGhTb3VyY2UoZ2V0KSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0KHRoaXNbc291cmNlU3ltYm9sXSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKCkge1xuXHRpZiAoY3VycmVudFNvdXJjZSkge1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJlbnRTb3VyY2UuYnl0ZXMsIGN1cnJlbnRTb3VyY2UucG9zaXRpb24sIGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQpO1xuXHRcdGN1cnJlbnRTb3VyY2UucG9zaXRpb24gPSAwO1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQgPSBjdXJyZW50U291cmNlLmJ5dGVzLmxlbmd0aDtcblx0fVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0aWYgKHBhY2tyLnR5cGVkU3RydWN0cykge1xuXHRcdGxldCBzdHJ1Y3RNYXAgPSBuZXcgTWFwKCk7XG5cdFx0c3RydWN0TWFwLnNldCgnbmFtZWQnLCBzdHJ1Y3R1cmVzKTtcblx0XHRzdHJ1Y3RNYXAuc2V0KCd0eXBlZCcsIHBhY2tyLnR5cGVkU3RydWN0cyk7XG5cdFx0c3RydWN0dXJlcyA9IHN0cnVjdE1hcDtcblx0fVxuXHRsZXQgbGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggfHwgMDtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSBleGlzdGluZyA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSB0cnVlO1xuXHRcdGlmIChleGlzdGluZyBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0bGV0IG5hbWVkID0gZXhpc3RpbmcuZ2V0KCduYW1lZCcpIHx8IFtdO1xuXHRcdFx0aWYgKG5hbWVkLmxlbmd0aCAhPT0gKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHRcdGxldCB0eXBlZCA9IGV4aXN0aW5nLmdldCgndHlwZWQnKSB8fCBbXTtcblx0XHRcdGlmICh0eXBlZC5sZW5ndGggIT09IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGgpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcblx0XHRcdGlmIChleGlzdGluZy5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghY29tcGF0aWJsZSlcblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmcpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gcGFja3IudHlwZWRTdHJ1Y3RzICYmIHBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdHJldHVybiBzdHJ1Y3R1cmVzO1xufVxuXG5zZXRSZWFkU3RydWN0KHJlYWRTdHJ1Y3QsIG9uTG9hZGVkU3RydWN0dXJlcywgc2F2ZVN0YXRlKTtcblxuIl0sIm5hbWVzIjpbInNldFdyaXRlU3RydWN0U2xvdHMiLCJSRUNPUkRfU1lNQk9MIiwiYWRkRXh0ZW5zaW9uIiwic2V0UmVhZFN0cnVjdCIsIm11bHQxMCIsInJlYWRTdHJpbmciLCJBU0NJSSIsIk5VTUJFUiIsIlVURjgiLCJPQkpFQ1RfREFUQSIsIkRBVEUiLCJUWVBFX05BTUVTIiwiZmxvYXQzMkhlYWRlcnMiLCJldmFsU3VwcG9ydGVkIiwiRnVuY3Rpb24iLCJlcnJvciIsInVwZGF0ZWRQb3NpdGlvbiIsImhhc05vZGVCdWZmZXIiLCJCdWZmZXIiLCJ0ZXh0RW5jb2RlciIsImN1cnJlbnRTb3VyY2UiLCJUZXh0RW5jb2RlciIsImVuY29kZVV0ZjgiLCJ0YXJnZXQiLCJzdHJpbmciLCJwb3NpdGlvbiIsInV0ZjhXcml0ZSIsImVuY29kZUludG8iLCJzdWJhcnJheSIsIndyaXR0ZW4iLCJUWVBFIiwiU3ltYm9sIiwiUEFSRU5UIiwid3JpdGVTdHJ1Y3QiLCJwcmVwYXJlU3RydWN0dXJlcyIsIm9iamVjdCIsImVuY29kaW5nU3RhcnQiLCJzdHJ1Y3R1cmVzIiwibWFrZVJvb20iLCJwYWNrIiwicGFja3IiLCJ0eXBlZFN0cnVjdHMiLCJ0YXJnZXRWaWV3IiwiZGF0YVZpZXciLCJyZWZzU3RhcnRQb3NpdGlvbiIsImxhc3RTdHJpbmdTdGFydCIsInNhZmVFbmQiLCJsZW5ndGgiLCJzdGFydCIsInJlZk9mZnNldCIsInJlZlBvc2l0aW9uIiwidHJhbnNpdGlvbiIsInRyYW5zaXRpb25zIiwiT2JqZWN0IiwiY3JlYXRlIiwibmV4dElkIiwiaGVhZGVyU2l6ZSIsInF1ZXVlZFJlZmVyZW5jZXMiLCJ1c2VkQXNjaWkwIiwia2V5SW5kZXgiLCJrZXkiLCJ2YWx1ZSIsIm5leHRUcmFuc2l0aW9uIiwicGFyZW50IiwiZW51bWVyYXRpb25PZmZzZXQiLCJhc2NpaTAiLCJhc2NpaTgiLCJudW04Iiwic3RyaW5nMTYiLCJvYmplY3QxNiIsIm51bTMyIiwiZmxvYXQ2NCIsImRhdGU2NCIsIm51bWJlciIsIm51bTY0IiwiY3JlYXRlVHlwZVRyYW5zaXRpb24iLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwieFNoaWZ0ZWQiLCJzZXRGbG9hdDY0Iiwic3RyTGVuZ3RoIiwicHVzaCIsImlzTm90QXNjaWkiLCJzdHJTdGFydCIsImkiLCJjMSIsImMyIiwiY2hhckNvZGVBdCIsInN0cmluZzgiLCJfX3R5cGUiLCJzZXRVaW50MTYiLCJjb25zdHJ1Y3RvciIsIkRhdGUiLCJnZXRUaW1lIiwiYW55VHlwZSIsImwiLCJwcm9wZXJ0eUluZGV4IiwibmV3UG9zaXRpb24iLCJzaXplIiwib2JqZWN0MzIiLCJzZXRJbnQxNiIsInJlY29yZElkIiwic3RydWN0dXJlIiwidHlwZSIsInVuZGVmaW5lZCIsIl9fc2l6ZSIsIl9fcGFyZW50IiwicHJvcGVydHkiLCJyZXZlcnNlIiwiY29weVdpdGhpbiIsInNldEludDgiLCJOYU4iLCJ0eXBlTmFtZSIsIm5ld1RyYW5zaXRpb24iLCJvbkxvYWRlZFN0cnVjdHVyZXMiLCJzaGFyZWREYXRhIiwiTWFwIiwidHlwZWQiLCJnZXQiLCJpc0Zyb3plbiIsIm1hcCIsInNsaWNlIiwibmFtZWQiLCJsYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoIiwic291cmNlU3ltYm9sIiwiZm9yIiwicmVhZFN0cnVjdCIsInNyYyIsInNyY0VuZCIsInVucGFja3IiLCJVaW50OEFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsIl9tZXJnZVN0cnVjdHVyZXMiLCJnZXRTdHJ1Y3R1cmVzIiwiRXJyb3IiLCJjb25zdHJ1Y3QiLCJMYXp5T2JqZWN0IiwicHJvcGVydGllcyIsImN1cnJlbnRPZmZzZXQiLCJsYXN0UmVmUHJvcGVydHkiLCJkZWZpbml0aW9uIiwib2Zmc2V0Iiwic3BsaWNlIiwiZ2V0UmVmIiwic291cmNlIiwicmVmIiwiYnl0ZXMiLCJ0b0NvbnN0YW50IiwiRGF0YVZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImdldFVpbnQxNiIsImdldFVpbnQzMiIsIm5leHQiLCJtdWx0aUdldENvdW50IiwicmVmU3RhcnQiLCJlbmQiLCJieXRlc0VuZCIsInNyY1N0cmluZyIsInRvU3RyaW5nIiwidW5wYWNrIiwiZ2V0SW50MzIiLCJmVmFsdWUiLCJnZXRGbG9hdDMyIiwibXVsdGlwbGllciIsImdldEZsb2F0NjQiLCJpc05hTiIsImJ5dGUiLCJvYmplY3RMaXRlcmFsUHJvcGVydGllcyIsImFyZ3MiLCJoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzIiwiYWx3YXlzTGF6eVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJ3aXRoU291cmNlIiwiZW51bWVyYWJsZSIsInZhbHVlRnVuY3Rpb24iLCJKU09OIiwic3RyaW5naWZ5IiwidG9PYmplY3QiLCJqb2luIiwiYXBwbHkiLCJwcm9wIiwib21pdFVuZGVyc2NvcmVkUHJvcGVydGllcyIsInJlc29sdmVkIiwiaW5zdGFuY2UiLCJjb2RlIiwic2F2ZVN0YXRlIiwic3RydWN0TWFwIiwic2V0IiwiaXNDb21wYXRpYmxlIiwiZXhpc3RpbmciLCJjb21wYXRpYmxlIiwibGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/struct.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/msgpackr/unpack.js":
/*!*****************************************!*\
  !*** ./node_modules/msgpackr/unpack.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C1: () => (/* binding */ C1),\n/* harmony export */   C1Type: () => (/* binding */ C1Type),\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* binding */ FLOAT32_OPTIONS),\n/* harmony export */   Unpackr: () => (/* binding */ Unpackr),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   checkedRead: () => (/* binding */ checkedRead),\n/* harmony export */   clearSource: () => (/* binding */ clearSource),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   getPosition: () => (/* binding */ getPosition),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* binding */ isNativeAccelerationEnabled),\n/* harmony export */   loadStructures: () => (/* binding */ loadStructures),\n/* harmony export */   mult10: () => (/* binding */ mult10),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readString: () => (/* binding */ readString),\n/* harmony export */   roundFloat32: () => (/* binding */ roundFloat32),\n/* harmony export */   setExtractor: () => (/* binding */ setExtractor),\n/* harmony export */   setReadStruct: () => (/* binding */ setReadStruct),\n/* harmony export */   typedArrays: () => (/* binding */ typedArrays),\n/* harmony export */   unpack: () => (/* binding */ unpack),\n/* harmony export */   unpackMultiple: () => (/* binding */ unpackMultiple)\n/* harmony export */ });\nvar decoder;\ntry {\n    decoder = new TextDecoder();\n} catch (error) {}\nvar src;\nvar srcEnd;\nvar position = 0;\nvar alreadySet;\nconst EMPTY_ARRAY = [];\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentUnpackr = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings;\nvar referenceMap;\nvar currentExtensions = [];\nvar dataView;\nvar defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true\n};\nclass C1Type {\n}\nconst C1 = new C1Type();\nC1.name = \"MessagePack 0xC1\";\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\nvar readStruct, onLoadedStructures, onSaveState;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n;\n// no-eval build\ntry {\n    new Function(\"\");\n} catch (error) {\n    // if eval variants are not supported, do not create inline object readers ever\n    inlineObjectReadThreshold = Infinity;\n}\nclass Unpackr {\n    constructor(options){\n        if (options) {\n            if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;\n            if (options.sequential && options.trusted !== false) {\n                options.trusted = true;\n                if (!options.structures && options.useRecords != false) {\n                    options.structures = [];\n                    if (!options.maxSharedStructures) options.maxSharedStructures = 0;\n                }\n            }\n            if (options.structures) options.structures.sharedLength = options.structures.length;\n            else if (options.getStructures) {\n                (options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n                ;\n                options.structures.sharedLength = 0;\n            }\n            if (options.int64AsNumber) {\n                options.int64AsType = \"number\";\n            }\n        }\n        Object.assign(this, options);\n    }\n    unpack(source, options) {\n        if (src) {\n            // re-entrant execution, save the state and restore it after we do this unpack\n            return saveState(()=>{\n                clearSource();\n                return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options);\n            });\n        }\n        if (!source.buffer && source.constructor === ArrayBuffer) source = typeof Buffer !== \"undefined\" ? Buffer.from(source) : new Uint8Array(source);\n        if (typeof options === \"object\") {\n            srcEnd = options.end || source.length;\n            position = options.start || 0;\n        } else {\n            position = 0;\n            srcEnd = options > -1 ? options : source.length;\n        }\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        } catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) throw error;\n            throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source == \"object\" ? source.constructor.name : typeof source));\n        }\n        if (this instanceof Unpackr) {\n            currentUnpackr = this;\n            if (this.structures) {\n                currentStructures = this.structures;\n                return checkedRead(options);\n            } else if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        } else {\n            currentUnpackr = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) currentStructures = [];\n        }\n        return checkedRead(options);\n    }\n    unpackMultiple(source, forEach) {\n        let values, lastPosition = 0;\n        try {\n            sequentialMode = true;\n            let size = source.length;\n            let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n            if (forEach) {\n                if (forEach(value, lastPosition, position) === false) return;\n                while(position < size){\n                    lastPosition = position;\n                    if (forEach(checkedRead(), lastPosition, position) === false) {\n                        return;\n                    }\n                }\n            } else {\n                values = [\n                    value\n                ];\n                while(position < size){\n                    lastPosition = position;\n                    values.push(checkedRead());\n                }\n                return values;\n            }\n        } catch (error) {\n            error.lastPosition = lastPosition;\n            error.values = values;\n            throw error;\n        } finally{\n            sequentialMode = false;\n            clearSource();\n        }\n    }\n    _mergeStructures(loadedStructures, existingStructures) {\n        if (onLoadedStructures) loadedStructures = onLoadedStructures.call(this, loadedStructures);\n        loadedStructures = loadedStructures || [];\n        if (Object.isFrozen(loadedStructures)) loadedStructures = loadedStructures.map((structure)=>structure.slice(0));\n        for(let i = 0, l = loadedStructures.length; i < l; i++){\n            let structure = loadedStructures[i];\n            if (structure) {\n                structure.isShared = true;\n                if (i >= 32) structure.highByte = i - 32 >> 5;\n            }\n        }\n        loadedStructures.sharedLength = loadedStructures.length;\n        for(let id in existingStructures || []){\n            if (id >= 0) {\n                let structure = loadedStructures[id];\n                let existing = existingStructures[id];\n                if (existing) {\n                    if (structure) (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n                    loadedStructures[id] = existing;\n                }\n            }\n        }\n        return this.structures = loadedStructures;\n    }\n    decode(source, options) {\n        return this.unpack(source, options);\n    }\n}\nfunction getPosition() {\n    return position;\n}\nfunction checkedRead(options) {\n    try {\n        if (!currentUnpackr.trusted && !sequentialMode) {\n            let sharedLength = currentStructures.sharedLength || 0;\n            if (sharedLength < currentStructures.length) currentStructures.length = sharedLength;\n        }\n        let result;\n        if (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n            result = readStruct(src, position, srcEnd, currentUnpackr);\n            src = null // dispose of this so that recursive unpack calls don't save state\n            ;\n            if (!(options && options.lazy) && result) result = result.toJSON();\n            position = srcEnd;\n        } else result = read();\n        if (bundledStrings) {\n            position = bundledStrings.postBundlePosition;\n            bundledStrings = null;\n        }\n        if (sequentialMode) // we only need to restore the structures if there was an error, but if we completed a read,\n        // we can clear this out and keep the structures we read\n        currentStructures.restoreStructures = null;\n        if (position == srcEnd) {\n            // finished reading this source, cleanup references\n            if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n            currentStructures = null;\n            src = null;\n            if (referenceMap) referenceMap = null;\n        } else if (position > srcEnd) {\n            // over read\n            throw new Error(\"Unexpected end of MessagePack data\");\n        } else if (!sequentialMode) {\n            let jsonView;\n            try {\n                jsonView = JSON.stringify(result, (_, value)=>typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n            } catch (error) {\n                jsonView = \"(JSON view not available \" + error + \")\";\n            }\n            throw new Error(\"Data read, but end of buffer not reached \" + jsonView);\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    } catch (error) {\n        if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n        clearSource();\n        if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\") || position > srcEnd) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction restoreStructures() {\n    for(let id in currentStructures.restoreStructures){\n        currentStructures[id] = currentStructures.restoreStructures[id];\n    }\n    currentStructures.restoreStructures = null;\n}\nfunction read() {\n    let token = src[position++];\n    if (token < 0xa0) {\n        if (token < 0x80) {\n            if (token < 0x40) return token;\n            else {\n                let structure = currentStructures[token & 0x3f] || currentUnpackr.getStructures && loadStructures()[token & 0x3f];\n                if (structure) {\n                    if (!structure.read) {\n                        structure.read = createStructureReader(structure, token & 0x3f);\n                    }\n                    return structure.read();\n                } else return token;\n            }\n        } else if (token < 0x90) {\n            // map\n            token -= 0x80;\n            if (currentUnpackr.mapsAsObjects) {\n                let object = {};\n                for(let i = 0; i < token; i++){\n                    let key = readKey();\n                    if (key === \"__proto__\") key = \"__proto_\";\n                    object[key] = read();\n                }\n                return object;\n            } else {\n                let map = new Map();\n                for(let i = 0; i < token; i++){\n                    map.set(read(), read());\n                }\n                return map;\n            }\n        } else {\n            token -= 0x90;\n            let array = new Array(token);\n            for(let i = 0; i < token; i++){\n                array[i] = read();\n            }\n            if (currentUnpackr.freezeData) return Object.freeze(array);\n            return array;\n        }\n    } else if (token < 0xc0) {\n        // fixstr\n        let length = token - 0xa0;\n        if (srcStringEnd >= position) {\n            return srcString.slice(position - srcStringStart, (position += length) - srcStringStart);\n        }\n        if (srcStringEnd == 0 && srcEnd < 140) {\n            // for small blocks, avoiding the overhead of the extract call is helpful\n            let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n            if (string != null) return string;\n        }\n        return readFixedString(length);\n    } else {\n        let value;\n        switch(token){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                if (bundledStrings) {\n                    value = read() // followed by the length of the string in characters (not bytes!)\n                    ;\n                    if (value > 0) return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n                    else return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value);\n                }\n                return C1; // \"never-used\", return special object to denote that\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xc4:\n                // bin 8\n                value = src[position++];\n                if (value === undefined) throw new Error(\"Unexpected end of buffer\");\n                return readBin(value);\n            case 0xc5:\n                // bin 16\n                value = dataView.getUint16(position);\n                position += 2;\n                return readBin(value);\n            case 0xc6:\n                // bin 32\n                value = dataView.getUint32(position);\n                position += 4;\n                return readBin(value);\n            case 0xc7:\n                // ext 8\n                return readExt(src[position++]);\n            case 0xc8:\n                // ext 16\n                value = dataView.getUint16(position);\n                position += 2;\n                return readExt(value);\n            case 0xc9:\n                // ext 32\n                value = dataView.getUint32(position);\n                position += 4;\n                return readExt(value);\n            case 0xca:\n                value = dataView.getFloat32(position);\n                if (currentUnpackr.useFloat32 > 2) {\n                    // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                    let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];\n                    position += 4;\n                    return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                }\n                position += 4;\n                return value;\n            case 0xcb:\n                value = dataView.getFloat64(position);\n                position += 8;\n                return value;\n            // uint handlers\n            case 0xcc:\n                return src[position++];\n            case 0xcd:\n                value = dataView.getUint16(position);\n                position += 2;\n                return value;\n            case 0xce:\n                value = dataView.getUint32(position);\n                position += 4;\n                return value;\n            case 0xcf:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getUint32(position) * 0x100000000;\n                    value += dataView.getUint32(position + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigUint64(position).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigUint64(position);\n                    if (value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigUint64(position);\n                position += 8;\n                return value;\n            // int handlers\n            case 0xd0:\n                return dataView.getInt8(position++);\n            case 0xd1:\n                value = dataView.getInt16(position);\n                position += 2;\n                return value;\n            case 0xd2:\n                value = dataView.getInt32(position);\n                position += 4;\n                return value;\n            case 0xd3:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getInt32(position) * 0x100000000;\n                    value += dataView.getUint32(position + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigInt64(position).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigInt64(position);\n                    if (value >= BigInt(-2) << BigInt(52) && value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigInt64(position);\n                position += 8;\n                return value;\n            case 0xd4:\n                // fixext 1\n                value = src[position++];\n                if (value == 0x72) {\n                    return recordDefinition(src[position++] & 0x3f);\n                } else {\n                    let extension = currentExtensions[value];\n                    if (extension) {\n                        if (extension.read) {\n                            position++ // skip filler byte\n                            ;\n                            return extension.read(read());\n                        } else if (extension.noBuffer) {\n                            position++ // skip filler byte\n                            ;\n                            return extension();\n                        } else return extension(src.subarray(position, ++position));\n                    } else throw new Error(\"Unknown extension \" + value);\n                }\n            case 0xd5:\n                // fixext 2\n                value = src[position];\n                if (value == 0x72) {\n                    position++;\n                    return recordDefinition(src[position++] & 0x3f, src[position++]);\n                } else return readExt(2);\n            case 0xd6:\n                // fixext 4\n                return readExt(4);\n            case 0xd7:\n                // fixext 8\n                return readExt(8);\n            case 0xd8:\n                // fixext 16\n                return readExt(16);\n            case 0xd9:\n                // str 8\n                value = src[position++];\n                if (srcStringEnd >= position) {\n                    return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);\n                }\n                return readString8(value);\n            case 0xda:\n                // str 16\n                value = dataView.getUint16(position);\n                position += 2;\n                if (srcStringEnd >= position) {\n                    return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);\n                }\n                return readString16(value);\n            case 0xdb:\n                // str 32\n                value = dataView.getUint32(position);\n                position += 4;\n                if (srcStringEnd >= position) {\n                    return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);\n                }\n                return readString32(value);\n            case 0xdc:\n                // array 16\n                value = dataView.getUint16(position);\n                position += 2;\n                return readArray(value);\n            case 0xdd:\n                // array 32\n                value = dataView.getUint32(position);\n                position += 4;\n                return readArray(value);\n            case 0xde:\n                // map 16\n                value = dataView.getUint16(position);\n                position += 2;\n                return readMap(value);\n            case 0xdf:\n                // map 32\n                value = dataView.getUint32(position);\n                position += 4;\n                return readMap(value);\n            default:\n                if (token >= 0xe0) return token - 0x100;\n                if (token === undefined) {\n                    let error = new Error(\"Unexpected end of MessagePack data\");\n                    error.incomplete = true;\n                    throw error;\n                }\n                throw new Error(\"Unknown MessagePack token \" + token);\n        }\n    }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure, firstId) {\n    function readObject() {\n        // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n        if (readObject.count++ > inlineObjectReadThreshold) {\n            let readObject = structure.read = new Function(\"r\", \"return function(){return \" + (currentUnpackr.freezeData ? \"Object.freeze\" : \"\") + \"({\" + structure.map((key)=>key === \"__proto__\" ? \"__proto_:r()\" : validName.test(key) ? key + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"})}\")(read);\n            if (structure.highByte === 0) structure.read = createSecondByteReader(firstId, structure.read);\n            return readObject() // second byte is already read, if there is one so immediately read object\n            ;\n        }\n        let object = {};\n        for(let i = 0, l = structure.length; i < l; i++){\n            let key = structure[i];\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        if (currentUnpackr.freezeData) return Object.freeze(object);\n        return object;\n    }\n    readObject.count = 0;\n    if (structure.highByte === 0) {\n        return createSecondByteReader(firstId, readObject);\n    }\n    return readObject;\n}\nconst createSecondByteReader = (firstId, read0)=>{\n    return function() {\n        let highByte = src[position++];\n        if (highByte === 0) return read0();\n        let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n        let structure = currentStructures[id] || loadStructures()[id];\n        if (!structure) {\n            throw new Error(\"Record id is not defined for \" + id);\n        }\n        if (!structure.read) structure.read = createStructureReader(structure, firstId);\n        return structure.read();\n    };\n};\nfunction loadStructures() {\n    let loadedStructures = saveState(()=>{\n        // save the state in case getStructures modifies our buffer\n        src = null;\n        return currentUnpackr.getStructures();\n    });\n    return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);\n}\nvar readFixedString = readStringJS;\nvar readString8 = readStringJS;\nvar readString16 = readStringJS;\nvar readString32 = readStringJS;\nlet isNativeAccelerationEnabled = false;\nfunction setExtractor(extractStrings) {\n    isNativeAccelerationEnabled = true;\n    readFixedString = readString(1);\n    readString8 = readString(2);\n    readString16 = readString(3);\n    readString32 = readString(5);\n    function readString(headerLength) {\n        return function readString(length) {\n            let string = strings[stringPosition++];\n            if (string == null) {\n                if (bundledStrings) return readStringJS(length);\n                let byteOffset = src.byteOffset;\n                let extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);\n                if (typeof extraction == \"string\") {\n                    string = extraction;\n                    strings = EMPTY_ARRAY;\n                } else {\n                    strings = extraction;\n                    stringPosition = 1;\n                    srcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n                    ;\n                    string = strings[0];\n                    if (string === undefined) throw new Error(\"Unexpected end of buffer\");\n                }\n            }\n            let srcStringLength = string.length;\n            if (srcStringLength <= length) {\n                position += length;\n                return string;\n            }\n            srcString = string;\n            srcStringStart = position;\n            srcStringEnd = position + srcStringLength;\n            position += length;\n            return string.slice(0, length) // we know we just want the beginning\n            ;\n        };\n    }\n}\nfunction readStringJS(length) {\n    let result;\n    if (length < 16) {\n        if (result = shortStringInJS(length)) return result;\n    }\n    if (length > 64 && decoder) return decoder.decode(src.subarray(position, position += length));\n    const end = position + length;\n    const units = [];\n    result = \"\";\n    while(position < end){\n        const byte1 = src[position++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        } else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position++] & 0x3f;\n            units.push((byte1 & 0x1f) << 6 | byte2);\n        } else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n        } else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            const byte4 = src[position++] & 0x3f;\n            let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(unit >>> 10 & 0x3ff | 0xd800);\n                unit = 0xdc00 | unit & 0x3ff;\n            }\n            units.push(unit);\n        } else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nfunction readString(source, start, length) {\n    let existingSrc = src;\n    src = source;\n    position = start;\n    try {\n        return readStringJS(length);\n    } finally{\n        src = existingSrc;\n    }\n}\nfunction readArray(length) {\n    let array = new Array(length);\n    for(let i = 0; i < length; i++){\n        array[i] = read();\n    }\n    if (currentUnpackr.freezeData) return Object.freeze(array);\n    return array;\n}\nfunction readMap(length) {\n    if (currentUnpackr.mapsAsObjects) {\n        let object = {};\n        for(let i = 0; i < length; i++){\n            let key = readKey();\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        return object;\n    } else {\n        let map = new Map();\n        for(let i = 0; i < length; i++){\n            map.set(read(), read());\n        }\n        return map;\n    }\n}\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    let start = position;\n    let bytes = new Array(length);\n    for(let i = 0; i < length; i++){\n        const byte = src[position++];\n        if ((byte & 0x80) > 0) {\n            position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) return \"\";\n            else {\n                let a = src[position++];\n                if ((a & 0x80) > 1) {\n                    position -= 1;\n                    return;\n                }\n                return fromCharCode(a);\n            }\n        } else {\n            let a = src[position++];\n            let b = src[position++];\n            if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n                position -= 2;\n                return;\n            }\n            if (length < 3) return fromCharCode(a, b);\n            let c = src[position++];\n            if ((c & 0x80) > 0) {\n                position -= 3;\n                return;\n            }\n            return fromCharCode(a, b, c);\n        }\n    } else {\n        let a = src[position++];\n        let b = src[position++];\n        let c = src[position++];\n        let d = src[position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n            position -= 4;\n            return;\n        }\n        if (length < 6) {\n            if (length === 4) return fromCharCode(a, b, c, d);\n            else {\n                let e = src[position++];\n                if ((e & 0x80) > 0) {\n                    position -= 5;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e);\n            }\n        } else if (length < 8) {\n            let e = src[position++];\n            let f = src[position++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n                position -= 6;\n                return;\n            }\n            if (length < 7) return fromCharCode(a, b, c, d, e, f);\n            let g = src[position++];\n            if ((g & 0x80) > 0) {\n                position -= 7;\n                return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g);\n        } else {\n            let e = src[position++];\n            let f = src[position++];\n            let g = src[position++];\n            let h = src[position++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n                position -= 8;\n                return;\n            }\n            if (length < 10) {\n                if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);\n                else {\n                    let i = src[position++];\n                    if ((i & 0x80) > 0) {\n                        position -= 9;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i);\n                }\n            } else if (length < 12) {\n                let i = src[position++];\n                let j = src[position++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n                    position -= 10;\n                    return;\n                }\n                if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n                let k = src[position++];\n                if ((k & 0x80) > 0) {\n                    position -= 11;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n            } else {\n                let i = src[position++];\n                let j = src[position++];\n                let k = src[position++];\n                let l = src[position++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n                    position -= 12;\n                    return;\n                }\n                if (length < 14) {\n                    if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n                    else {\n                        let m = src[position++];\n                        if ((m & 0x80) > 0) {\n                            position -= 13;\n                            return;\n                        }\n                        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n                    }\n                } else {\n                    let m = src[position++];\n                    let n = src[position++];\n                    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n                        position -= 14;\n                        return;\n                    }\n                    if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n                    let o = src[position++];\n                    if ((o & 0x80) > 0) {\n                        position -= 15;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n                }\n            }\n        }\n    }\n}\nfunction readOnlyJSString() {\n    let token = src[position++];\n    let length;\n    if (token < 0xc0) {\n        // fixstr\n        length = token - 0xa0;\n    } else {\n        switch(token){\n            case 0xd9:\n                // str 8\n                length = src[position++];\n                break;\n            case 0xda:\n                // str 16\n                length = dataView.getUint16(position);\n                position += 2;\n                break;\n            case 0xdb:\n                // str 32\n                length = dataView.getUint32(position);\n                position += 4;\n                break;\n            default:\n                throw new Error(\"Expected string\");\n        }\n    }\n    return readStringJS(length);\n}\nfunction readBin(length) {\n    return currentUnpackr.copyBuffers ? // specifically use the copying slice (not the node one)\n    Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nfunction readExt(length) {\n    let type = src[position++];\n    if (currentExtensions[type]) {\n        let end;\n        return currentExtensions[type](src.subarray(position, end = position += length), (readPosition)=>{\n            position = readPosition;\n            try {\n                return read();\n            } finally{\n                position = end;\n            }\n        });\n    } else throw new Error(\"Unknown extension type \" + type);\n}\nvar keyCache = new Array(4096);\nfunction readKey() {\n    let length = src[position++];\n    if (length >= 0xa0 && length < 0xc0) {\n        // fixstr, potentially use key cache\n        length = length - 0xa0;\n        if (srcStringEnd >= position) return srcString.slice(position - srcStringStart, (position += length) - srcStringStart);\n        else if (!(srcStringEnd == 0 && srcEnd < 180)) return readFixedString(length);\n    } else {\n        position--;\n        return asSafeString(read());\n    }\n    let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff;\n    let entry = keyCache[key];\n    let checkPosition = position;\n    let end = position + length - 3;\n    let chunk;\n    let i = 0;\n    if (entry && entry.bytes == length) {\n        while(checkPosition < end){\n            chunk = dataView.getUint32(checkPosition);\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n            checkPosition += 4;\n        }\n        end += 3;\n        while(checkPosition < end){\n            chunk = src[checkPosition++];\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n        }\n        if (checkPosition === end) {\n            position = checkPosition;\n            return entry.string;\n        }\n        end -= 3;\n        checkPosition = position;\n    }\n    entry = [];\n    keyCache[key] = entry;\n    entry.bytes = length;\n    while(checkPosition < end){\n        chunk = dataView.getUint32(checkPosition);\n        entry.push(chunk);\n        checkPosition += 4;\n    }\n    end += 3;\n    while(checkPosition < end){\n        chunk = src[checkPosition++];\n        entry.push(chunk);\n    }\n    // for small blocks, avoiding the overhead of the extract call is helpful\n    let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n    if (string != null) return entry.string = string;\n    return entry.string = readFixedString(length);\n}\nfunction asSafeString(property) {\n    if (typeof property === \"string\") return property;\n    if (typeof property === \"number\") return property.toString();\n    throw new Error(\"Invalid property type for record\", typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte)=>{\n    let structure = read().map(asSafeString) // ensure that all keys are strings and\n    ;\n    // that the array is mutable\n    let firstByte = id;\n    if (highByte !== undefined) {\n        id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;\n        structure.highByte = highByte;\n    }\n    let existingStructure = currentStructures[id];\n    // If it is a shared structure, we need to restore any changes after reading.\n    // Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n    // to the state prior to an incomplete read in order to properly resume.\n    if (existingStructure && (existingStructure.isShared || sequentialMode)) {\n        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n    }\n    currentStructures[id] = structure;\n    structure.read = createStructureReader(structure, firstByte);\n    return structure.read();\n};\ncurrentExtensions[0] = ()=>{} // notepack defines extension 0 to mean undefined, so use that as the default here\n;\ncurrentExtensions[0].noBuffer = true;\ncurrentExtensions[0x42] = (data)=>{\n    // decode bigint\n    let length = data.length;\n    let value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n    for(let i = 1; i < length; i++){\n        value <<= 8n;\n        value += BigInt(data[i]);\n    }\n    return value;\n};\nlet errors = {\n    Error,\n    TypeError,\n    ReferenceError\n};\ncurrentExtensions[0x65] = ()=>{\n    let data = read();\n    return (errors[data[0]] || Error)(data[1]);\n};\ncurrentExtensions[0x69] = (data)=>{\n    // id extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position - 4);\n    if (!referenceMap) referenceMap = new Map();\n    let token = src[position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd) target = [];\n    else target = {};\n    let refEntry = {\n        target\n    } // a placeholder object\n    ;\n    referenceMap.set(id, refEntry);\n    let targetProperties = read() // read the next value as the target object to id\n    ;\n    if (refEntry.used) return Object.assign(target, targetProperties);\n    refEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n    ;\n    return targetProperties // no cycle, can just use the returned read object\n    ;\n};\ncurrentExtensions[0x70] = (data)=>{\n    // pointer extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position - 4);\n    let refEntry = referenceMap.get(id);\n    refEntry.used = true;\n    return refEntry.target;\n};\ncurrentExtensions[0x73] = ()=>new Set(read());\nconst typedArrays = [\n    \"Int8\",\n    \"Uint8\",\n    \"Uint8Clamped\",\n    \"Int16\",\n    \"Uint16\",\n    \"Int32\",\n    \"Uint32\",\n    \"Float32\",\n    \"Float64\",\n    \"BigInt64\",\n    \"BigUint64\"\n].map((type)=>type + \"Array\");\nlet glbl = typeof globalThis === \"object\" ? globalThis : window;\ncurrentExtensions[0x74] = (data)=>{\n    let typeCode = data[0];\n    let typedArrayName = typedArrays[typeCode];\n    if (!typedArrayName) throw new Error(\"Could not find typed array for code \" + typeCode);\n    // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n    return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer);\n};\ncurrentExtensions[0x78] = ()=>{\n    let data = read();\n    return new RegExp(data[0], data[1]);\n};\nconst TEMP_BUNDLE = [];\ncurrentExtensions[0x62] = (data)=>{\n    let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n    let dataPosition = position;\n    position += dataSize - data.length;\n    bundledStrings = TEMP_BUNDLE;\n    bundledStrings = [\n        readOnlyJSString(),\n        readOnlyJSString()\n    ];\n    bundledStrings.position0 = 0;\n    bundledStrings.position1 = 0;\n    bundledStrings.postBundlePosition = position;\n    position = dataPosition;\n    return read();\n};\ncurrentExtensions[0xff] = (data)=>{\n    // 32-bit date extension\n    if (data.length == 4) return new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000);\n    else if (data.length == 8) return new Date(((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 + ((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000);\n    else if (data.length == 12) return new Date(((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 + ((data[4] & 0x80 ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000);\n    else return new Date(\"invalid\");\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n;\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\nfunction saveState(callback) {\n    if (onSaveState) onSaveState();\n    let savedSrcEnd = srcEnd;\n    let savedPosition = position;\n    let savedStringPosition = stringPosition;\n    let savedSrcStringStart = srcStringStart;\n    let savedSrcStringEnd = srcStringEnd;\n    let savedSrcString = srcString;\n    let savedStrings = strings;\n    let savedReferenceMap = referenceMap;\n    let savedBundledStrings = bundledStrings;\n    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n    let savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n    ;\n    let savedStructures = currentStructures;\n    let savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n    let savedPackr = currentUnpackr;\n    let savedSequentialMode = sequentialMode;\n    let value = callback();\n    srcEnd = savedSrcEnd;\n    position = savedPosition;\n    stringPosition = savedStringPosition;\n    srcStringStart = savedSrcStringStart;\n    srcStringEnd = savedSrcStringEnd;\n    srcString = savedSrcString;\n    strings = savedStrings;\n    referenceMap = savedReferenceMap;\n    bundledStrings = savedBundledStrings;\n    src = savedSrc;\n    sequentialMode = savedSequentialMode;\n    currentStructures = savedStructures;\n    currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n    currentUnpackr = savedPackr;\n    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n    return value;\n}\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nfunction addExtension(extension) {\n    if (extension.unpack) currentExtensions[extension.type] = extension.unpack;\n    else currentExtensions[extension.type] = extension;\n}\nconst mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\n;\nfor(let i = 0; i < 256; i++){\n    mult10[i] = +(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst Decoder = Unpackr;\nvar defaultUnpackr = new Unpackr({\n    useRecords: false\n});\nconst unpack = defaultUnpackr.unpack;\nconst unpackMultiple = defaultUnpackr.unpackMultiple;\nconst decode = defaultUnpackr.unpack;\nconst FLOAT32_OPTIONS = {\n    NEVER: 0,\n    ALWAYS: 1,\n    DECIMAL_ROUND: 3,\n    DECIMAL_FIT: 4\n};\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction roundFloat32(float32Number) {\n    f32Array[0] = float32Number;\n    let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];\n    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n    readStruct = updatedReadStruct;\n    onLoadedStructures = loadedStructs;\n    onSaveState = saveState;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGdCQUFpQkEsQ0FBQUEsZ0JBQWdCLElBQUksTUFBTSxDQUFDLEdBQUUsS0FBTyxLQUFLNUg7QUFDakY7QUFDTyxTQUFTNkgsY0FBY0MsaUJBQWlCLEVBQUVDLGFBQWEsRUFBRTdNLFNBQVM7SUFDeEV4QixhQUFhb087SUFDYm5PLHFCQUFxQm9PO0lBQ3JCbk8sY0FBY3NCO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL21zZ3BhY2tyL3VucGFjay5qcz84YjI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWNvZGVyXG50cnkge1xuXHRkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjXG52YXIgc3JjRW5kXG52YXIgcG9zaXRpb24gPSAwXG52YXIgYWxyZWFkeVNldFxuY29uc3QgRU1QVFlfQVJSQVkgPSBbXVxudmFyIHN0cmluZ3MgPSBFTVBUWV9BUlJBWVxudmFyIHN0cmluZ1Bvc2l0aW9uID0gMFxudmFyIGN1cnJlbnRVbnBhY2tyID0ge31cbnZhciBjdXJyZW50U3RydWN0dXJlc1xudmFyIHNyY1N0cmluZ1xudmFyIHNyY1N0cmluZ1N0YXJ0ID0gMFxudmFyIHNyY1N0cmluZ0VuZCA9IDBcbnZhciBidW5kbGVkU3RyaW5nc1xudmFyIHJlZmVyZW5jZU1hcFxudmFyIGN1cnJlbnRFeHRlbnNpb25zID0gW11cbnZhciBkYXRhVmlld1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufVxuZXhwb3J0IGNsYXNzIEMxVHlwZSB7fVxuZXhwb3J0IGNvbnN0IEMxID0gbmV3IEMxVHlwZSgpXG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnXG52YXIgc2VxdWVudGlhbE1vZGUgPSBmYWxzZVxudmFyIGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSAyXG52YXIgcmVhZFN0cnVjdCwgb25Mb2FkZWRTdHJ1Y3R1cmVzLCBvblNhdmVTdGF0ZVxudmFyIEJsb2NrZWRGdW5jdGlvbiAvLyB3ZSB1c2Ugc2VhcmNoIGFuZCByZXBsYWNlIHRvIGNoYW5nZSB0aGUgbmV4dCBjYWxsIHRvIEJsb2NrZWRGdW5jdGlvbiB0byBhdm9pZCBDU1AgaXNzdWVzIGZvclxuLy8gbm8tZXZhbCBidWlsZFxudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKVxufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eVxufVxuXG5leHBvcnQgY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWVcblx0XHRcdGlmIChvcHRpb25zLnNlcXVlbnRpYWwgJiYgb3B0aW9ucy50cnVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRvcHRpb25zLnRydXN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMuc3RydWN0dXJlcyAmJiBvcHRpb25zLnVzZVJlY29yZHMgIT0gZmFsc2UpIHtcblx0XHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzID0gMFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aFxuXHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5nZXRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdChvcHRpb25zLnN0cnVjdHVyZXMgPSBbXSkudW5pbml0aWFsaXplZCA9IHRydWUgLy8gdGhpcyBpcyB3aGF0IHdlIHVzZSB0byBkZW5vdGUgYW4gdW5pbml0aWFsaXplZCBzdHJ1Y3R1cmVzXG5cdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSAwXG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJ1xuXHRcdFx0fVxuXHRcdH1cblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIHJlLWVudHJhbnQgZXhlY3V0aW9uLCBzYXZlIHRoZSBzdGF0ZSBhbmQgcmVzdG9yZSBpdCBhZnRlciB3ZSBkbyB0aGlzIHVucGFja1xuXHRcdFx0cmV0dXJuIHNhdmVTdGF0ZSgoKSA9PiB7XG5cdFx0XHRcdGNsZWFyU291cmNlKClcblx0XHRcdFx0cmV0dXJuIHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIG9wdGlvbnMpIDogVW5wYWNrci5wcm90b3R5cGUudW5wYWNrLmNhbGwoZGVmYXVsdE9wdGlvbnMsIHNvdXJjZSwgb3B0aW9ucylcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGlmICghc291cmNlLmJ1ZmZlciAmJiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuXHRcdFx0c291cmNlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXIuZnJvbShzb3VyY2UpIDogbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zLmVuZCB8fCBzb3VyY2UubGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiA9IG9wdGlvbnMuc3RhcnQgfHwgMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoXG5cdFx0fVxuXHRcdHN0cmluZ1Bvc2l0aW9uID0gMFxuXHRcdHNyY1N0cmluZ0VuZCA9IDBcblx0XHRzcmNTdHJpbmcgPSBudWxsXG5cdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0c3JjID0gc291cmNlXG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpXG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBoYXZlIGEgYnVmZmVyLCBtYXliZSBpdCBpcyB0aGUgd3JvbmcgdHlwZSBvZiBvYmplY3Rcblx0XHRcdHNyYyA9IG51bGxcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGJ1dCB3YXMgYSAnICsgKChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgPyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBzb3VyY2UpKVxuXHRcdH1cblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIFVucGFja3IpIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gdGhpc1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlc1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tlZFJlYWQob3B0aW9ucylcblx0XHRcdH0gZWxzZSBpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VW5wYWNrciA9IGRlZmF1bHRPcHRpb25zXG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW11cblx0XHR9XG5cdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrTXVsdGlwbGUoc291cmNlLCBmb3JFYWNoKSB7XG5cdFx0bGV0IHZhbHVlcywgbGFzdFBvc2l0aW9uID0gMFxuXHRcdHRyeSB7XG5cdFx0XHRzZXF1ZW50aWFsTW9kZSA9IHRydWVcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aFxuXHRcdFx0bGV0IHZhbHVlID0gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgc2l6ZSkgOiBkZWZhdWx0VW5wYWNrci51bnBhY2soc291cmNlLCBzaXplKVxuXHRcdFx0aWYgKGZvckVhY2gpIHtcblx0XHRcdFx0aWYgKGZvckVhY2godmFsdWUsIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0XHR3aGlsZShwb3NpdGlvbiA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFsdWVzID0gWyB2YWx1ZSBdXG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uIDwgc2l6ZSkge1xuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goY2hlY2tlZFJlYWQoKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uXG5cdFx0XHRlcnJvci52YWx1ZXMgPSB2YWx1ZXNcblx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gZmFsc2Vcblx0XHRcdGNsZWFyU291cmNlKClcblx0XHR9XG5cdH1cblx0X21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBleGlzdGluZ1N0cnVjdHVyZXMpIHtcblx0XHRpZiAob25Mb2FkZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcy5jYWxsKHRoaXMsIGxvYWRlZFN0cnVjdHVyZXMpO1xuXHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzIHx8IFtdXG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gbG9hZGVkU3RydWN0dXJlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2ldXG5cdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdHN0cnVjdHVyZS5pc1NoYXJlZCA9IHRydWVcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNVxuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2FkZWRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoXG5cdFx0Zm9yIChsZXQgaWQgaW4gZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8IFtdKSB7XG5cdFx0XHRpZiAoaWQgPj0gMCkge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpZF1cblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXVxuXHRcdFx0XHRpZiAoZXhpc3RpbmcpIHtcblx0XHRcdFx0XHRpZiAoc3RydWN0dXJlKVxuXHRcdFx0XHRcdFx0KGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgfHwgKGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IHN0cnVjdHVyZVxuXHRcdFx0XHRcdGxvYWRlZFN0cnVjdHVyZXNbaWRdID0gZXhpc3Rpbmdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG5cdHJldHVybiBwb3NpdGlvblxufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZWRSZWFkKG9wdGlvbnMpIHtcblx0dHJ5IHtcblx0XHRpZiAoIWN1cnJlbnRVbnBhY2tyLnRydXN0ZWQgJiYgIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gY3VycmVudFN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzaGFyZWRMZW5ndGggPCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdH1cblx0XHRsZXQgcmVzdWx0XG5cdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiBzcmNbcG9zaXRpb25dIDwgMHg0MCAmJiBzcmNbcG9zaXRpb25dID49IDB4MjAgJiYgcmVhZFN0cnVjdCkge1xuXHRcdFx0cmVzdWx0ID0gcmVhZFN0cnVjdChzcmMsIHBvc2l0aW9uLCBzcmNFbmQsIGN1cnJlbnRVbnBhY2tyKVxuXHRcdFx0c3JjID0gbnVsbCAvLyBkaXNwb3NlIG9mIHRoaXMgc28gdGhhdCByZWN1cnNpdmUgdW5wYWNrIGNhbGxzIGRvbid0IHNhdmUgc3RhdGVcblx0XHRcdGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5sYXp5KSAmJiByZXN1bHQpXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC50b0pTT04oKVxuXHRcdFx0cG9zaXRpb24gPSBzcmNFbmRcblx0XHR9IGVsc2Vcblx0XHRcdHJlc3VsdCA9IHJlYWQoKVxuXHRcdGlmIChidW5kbGVkU3RyaW5ncykgeyAvLyBidW5kbGVkIHN0cmluZ3MgdG8gc2tpcCBwYXN0XG5cdFx0XHRwb3NpdGlvbiA9IGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvblxuXHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0fVxuXHRcdGlmIChzZXF1ZW50aWFsTW9kZSlcblx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byByZXN0b3JlIHRoZSBzdHJ1Y3R1cmVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciwgYnV0IGlmIHdlIGNvbXBsZXRlZCBhIHJlYWQsXG5cdFx0XHQvLyB3ZSBjYW4gY2xlYXIgdGhpcyBvdXQgYW5kIGtlZXAgdGhlIHN0cnVjdHVyZXMgd2UgcmVhZFxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG5cblx0XHRpZiAocG9zaXRpb24gPT0gc3JjRW5kKSB7XG5cdFx0XHQvLyBmaW5pc2hlZCByZWFkaW5nIHRoaXMgc291cmNlLCBjbGVhbnVwIHJlZmVyZW5jZXNcblx0XHRcdGlmIChjdXJyZW50U3RydWN0dXJlcyAmJiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcylcblx0XHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsXG5cdFx0XHRzcmMgPSBudWxsXG5cdFx0XHRpZiAocmVmZXJlbmNlTWFwKVxuXHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHNyY0VuZCkge1xuXHRcdFx0Ly8gb3ZlciByZWFkXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdH0gZWxzZSBpZiAoIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQganNvblZpZXc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uVmlldyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgKF8sIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyBgJHt2YWx1ZX1uYCA6IHZhbHVlKS5zbGljZSgwLCAxMDApXG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gJyhKU09OIHZpZXcgbm90IGF2YWlsYWJsZSAnICsgZXJyb3IgKyAnKSdcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdGNsZWFyU291cmNlKClcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJykgfHwgcG9zaXRpb24gPiBzcmNFbmQpIHtcblx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0fVxuXHRcdHRocm93IGVycm9yXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0cnVjdHVyZXMoKSB7XG5cdGZvciAobGV0IGlkIGluIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKSB7XG5cdFx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXNbaWRdXG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl1cblx0XHRcdFx0aWYgKHN0cnVjdHVyZSkge1xuXHRcdFx0XHRcdGlmICghc3RydWN0dXJlLnJlYWQpIHtcblx0XHRcdFx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgdG9rZW4gJiAweDNmKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRva2VuIDwgMHg5MCkge1xuXHRcdFx0Ly8gbWFwXG5cdFx0XHR0b2tlbiAtPSAweDgwXG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGtleSA9IHJlYWRLZXkoKVxuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJ1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IG1hcCA9IG5ldyBNYXAoKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MFxuXHRcdFx0bGV0IGFycmF5ID0gbmV3IEFycmF5KHRva2VuKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdGFycmF5W2ldID0gcmVhZCgpXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMFxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHR9XG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE0MCkge1xuXHRcdFx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRcdFx0bGV0IHN0cmluZyA9IGxlbmd0aCA8IDE2ID8gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkgOiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpXG5cdFx0XHRpZiAoc3RyaW5nICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiBzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG5cdH0gZWxzZSB7XG5cdFx0bGV0IHZhbHVlXG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJlYWQoKSAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzWzFdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSwgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5nc1swXS5zbGljZShidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAsIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24rK10pXG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdC8vIGV4dCAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhjOTpcblx0XHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24pXG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci51c2VGbG9hdDMyID4gMikge1xuXHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAxXSA+PiA3KV1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIHZhbHVlICsgKHZhbHVlID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXJcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHQvLyB1aW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4Y2M6XG5cdFx0XHRcdHJldHVybiBzcmNbcG9zaXRpb24rK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKS50b1N0cmluZygpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXG5cdFx0XHQvLyBpbnQgaGFuZGxlcnNcblx0XHRcdGNhc2UgMHhkMDpcblx0XHRcdFx0cmV0dXJuIGRhdGFWaWV3LmdldEludDgocG9zaXRpb24rKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24pLnRvU3RyaW5nKClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Y2FzZSAweGQ0OlxuXHRcdFx0XHQvLyBmaXhleHQgMVxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHJldHVybiByZWNvcmREZWZpbml0aW9uKHNyY1twb3NpdGlvbisrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXVxuXHRcdFx0XHRcdGlmIChleHRlbnNpb24pIHtcblx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24ucmVhZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbisrIC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5yZWFkKHJlYWQoKSlcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXh0ZW5zaW9uLm5vQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uKysgLy8gc2tpcCBmaWxsZXIgYnl0ZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKClcblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgKytwb3NpdGlvbikpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uICcgKyB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAweGQ1OlxuXHRcdFx0XHQvLyBmaXhleHQgMlxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbl1cblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRwb3NpdGlvbisrXG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uKytdICYgMHgzZiwgc3JjW3Bvc2l0aW9uKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdFx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gTWVzc2FnZVBhY2sgdG9rZW4gJyArIHRva2VuKVxuXG5cdFx0fVxuXHR9XG59XG5jb25zdCB2YWxpZE5hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXFxkXyRdKiQvXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpXG5cdFx0XHRpZiAoc3RydWN0dXJlLmhpZ2hCeXRlID09PSAwKVxuXHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIoZmlyc3RJZCwgc3RydWN0dXJlLnJlYWQpXG5cdFx0XHRyZXR1cm4gcmVhZE9iamVjdCgpIC8vIHNlY29uZCBieXRlIGlzIGFscmVhZHkgcmVhZCwgaWYgdGhlcmUgaXMgb25lIHNvIGltbWVkaWF0ZWx5IHJlYWQgb2JqZWN0XG5cdFx0fVxuXHRcdGxldCBvYmplY3QgPSB7fVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXVxuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXydcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDBcblx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMCkge1xuXHRcdHJldHVybiBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHJlYWRPYmplY3QpXG5cdH1cblx0cmV0dXJuIHJlYWRPYmplY3Rcbn1cblxuY29uc3QgY3JlYXRlU2Vjb25kQnl0ZVJlYWRlciA9IChmaXJzdElkLCByZWFkMCkgPT4ge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0bGV0IGhpZ2hCeXRlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0aWYgKGhpZ2hCeXRlID09PSAwKVxuXHRcdFx0cmV0dXJuIHJlYWQwKClcblx0XHRsZXQgaWQgPSBmaXJzdElkIDwgMzIgPyAtKGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSkpIDogZmlyc3RJZCArIChoaWdoQnl0ZSA8PCA1KVxuXHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF0gfHwgbG9hZFN0cnVjdHVyZXMoKVtpZF1cblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZClcblx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU3RydWN0dXJlcygpIHtcblx0bGV0IGxvYWRlZFN0cnVjdHVyZXMgPSBzYXZlU3RhdGUoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbFxuXHRcdHJldHVybiBjdXJyZW50VW5wYWNrci5nZXRTdHJ1Y3R1cmVzKClcblx0fSlcblx0cmV0dXJuIGN1cnJlbnRTdHJ1Y3R1cmVzID0gY3VycmVudFVucGFja3IuX21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBjdXJyZW50U3RydWN0dXJlcylcbn1cblxudmFyIHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmdKU1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzE2ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzMyID0gcmVhZFN0cmluZ0pTXG5leHBvcnQgbGV0IGlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0aXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkID0gdHJ1ZVxuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpXG5cdHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZygyKVxuXHRyZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nKDMpXG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSlcblx0ZnVuY3Rpb24gcmVhZFN0cmluZyhoZWFkZXJMZW5ndGgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVhZFN0cmluZyhsZW5ndGgpIHtcblx0XHRcdGxldCBzdHJpbmcgPSBzdHJpbmdzW3N0cmluZ1Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoc3RyaW5nID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKVxuXHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxuXHRcdFx0XHRsZXQgYnl0ZU9mZnNldCA9IHNyYy5ieXRlT2Zmc2V0XG5cdFx0XHRcdGxldCBleHRyYWN0aW9uID0gZXh0cmFjdFN0cmluZ3MocG9zaXRpb24gLSBoZWFkZXJMZW5ndGggKyBieXRlT2Zmc2V0LCBzcmNFbmQgKyBieXRlT2Zmc2V0LCBzcmMuYnVmZmVyKVxuXHRcdFx0XHRpZiAodHlwZW9mIGV4dHJhY3Rpb24gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRzdHJpbmcgPSBleHRyYWN0aW9uXG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RyaW5ncyA9IGV4dHJhY3Rpb25cblx0XHRcdFx0XHRzdHJpbmdQb3NpdGlvbiA9IDFcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxIC8vIGV2ZW4gaWYgYSB1dGYtOCBzdHJpbmcgd2FzIGRlY29kZWQsIG11c3QgaW5kaWNhdGUgd2UgYXJlIGluIHRoZSBtaWRzdCBvZiBleHRyYWN0ZWQgc3RyaW5ncyBhbmQgY2FuJ3Qgc2tpcCBzdHJpbmdzXG5cdFx0XHRcdFx0c3RyaW5nID0gc3RyaW5nc1swXVxuXHRcdFx0XHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGV0IHNyY1N0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGhcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmdcblx0XHRcdHNyY1N0cmluZ1N0YXJ0ID0gcG9zaXRpb25cblx0XHRcdHNyY1N0cmluZ0VuZCA9IHBvc2l0aW9uICsgc3JjU3RyaW5nTGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiArPSBsZW5ndGhcblx0XHRcdHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKSAvLyB3ZSBrbm93IHdlIGp1c3Qgd2FudCB0aGUgYmVnaW5uaW5nXG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nSlMobGVuZ3RoKSB7XG5cdGxldCByZXN1bHRcblx0aWYgKGxlbmd0aCA8IDE2KSB7XG5cdFx0aWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cdGlmIChsZW5ndGggPiA2NCAmJiBkZWNvZGVyKVxuXHRcdHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoXG5cdGNvbnN0IHVuaXRzID0gW11cblx0cmVzdWx0ID0gJydcblx0d2hpbGUgKHBvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y29uc3QgYnl0ZTEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcblx0XHRcdC8vIDEgYnl0ZVxuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG5cdFx0XHQvLyAyIGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpXG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKVxuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcblx0XHRcdC8vIDQgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0Y29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlNCA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGxldCB1bml0ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MGMpIHwgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTRcblx0XHRcdGlmICh1bml0ID4gMHhmZmZmKSB7XG5cdFx0XHRcdHVuaXQgLT0gMHgxMDAwMFxuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKVxuXHRcdFx0XHR1bml0ID0gMHhkYzAwIHwgKHVuaXQgJiAweDNmZilcblx0XHRcdH1cblx0XHRcdHVuaXRzLnB1c2godW5pdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9XG5cblx0XHRpZiAodW5pdHMubGVuZ3RoID49IDB4MTAwMCkge1xuXHRcdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHRcdFx0dW5pdHMubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdFxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiA9IHN0YXJ0O1xuXHR0cnkge1xuXHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzcmMgPSBleGlzdGluZ1NyYztcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXkobGVuZ3RoKSB7XG5cdGxldCBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKVxuXHR9XG5cdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKGFycmF5KVxuXHRyZXR1cm4gYXJyYXlcbn1cblxuZnVuY3Rpb24gcmVhZE1hcChsZW5ndGgpIHtcblx0aWYgKGN1cnJlbnRVbnBhY2tyLm1hcHNBc09iamVjdHMpIHtcblx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpXG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdHJldHVybiBvYmplY3Rcblx0fSBlbHNlIHtcblx0XHRsZXQgbWFwID0gbmV3IE1hcCgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChyZWFkKCksIHJlYWQoKSlcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5mdW5jdGlvbiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpIHtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb25cblx0bGV0IGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aClcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24rK107XG5cdFx0aWYgKChieXRlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRieXRlc1tpXSA9IGJ5dGVcblx0XHR9XG5cdFx0cmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKVxufVxuZnVuY3Rpb24gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRpZiAobGVuZ3RoIDwgNCkge1xuXHRcdGlmIChsZW5ndGggPCAyKSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gJydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGEgJiAweDgwKSA+IDEpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGIgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSAyXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDMpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYilcblx0XHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGMgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gM1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYylcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0bGV0IGQgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDAgfHwgKGMgJiAweDgwKSA+IDAgfHwgKGQgJiAweDgwKSA+IDApIHtcblx0XHRcdHBvc2l0aW9uIC09IDRcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAobGVuZ3RoIDwgNikge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gNClcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDVcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPCA4KSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA2XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDcpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZilcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGcgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gN1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZylcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBmID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgZyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCB8fCAoZyAmIDB4ODApID4gMCB8fCAoaCAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA4XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDEwKSB7XG5cdFx0XHRcdGlmIChsZW5ndGggPT09IDgpXG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gOVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAxMikge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxMFxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxMSlcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopXG5cdFx0XHRcdGxldCBrID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoayAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDExXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGogPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGwgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwIHx8IChrICYgMHg4MCkgPiAwIHx8IChsICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMTJcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMTQpIHtcblx0XHRcdFx0XHRpZiAobGVuZ3RoID09PSAxMilcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbClcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gMTNcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0bGV0IG4gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDAgfHwgKG4gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDE0XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDE1KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuKVxuXHRcdFx0XHRcdGxldCBvID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0aWYgKChvICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxNVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZWFkT25seUpTU3RyaW5nKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0bGV0IGxlbmd0aFxuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwXG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoKHRva2VuKSB7XG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHRsZW5ndGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3RyaW5nJylcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpXG59XG5cblxuZnVuY3Rpb24gcmVhZEJpbihsZW5ndGgpIHtcblx0cmV0dXJuIGN1cnJlbnRVbnBhY2tyLmNvcHlCdWZmZXJzID9cblx0XHQvLyBzcGVjaWZpY2FsbHkgdXNlIHRoZSBjb3B5aW5nIHNsaWNlIChub3QgdGhlIG5vZGUgb25lKVxuXHRcdFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3JjLCBwb3NpdGlvbiwgcG9zaXRpb24gKz0gbGVuZ3RoKSA6XG5cdFx0c3JjLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kXG5cdFx0cmV0dXJuIGN1cnJlbnRFeHRlbnNpb25zW3R5cGVdKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgZW5kID0gKHBvc2l0aW9uICs9IGxlbmd0aCkpLCAocmVhZFBvc2l0aW9uKSA9PiB7XG5cdFx0XHRwb3NpdGlvbiA9IHJlYWRQb3NpdGlvbjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiByZWFkKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KVxuZnVuY3Rpb24gcmVhZEtleSgpIHtcblx0bGV0IGxlbmd0aCA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAobGVuZ3RoID49IDB4YTAgJiYgbGVuZ3RoIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0ciwgcG90ZW50aWFsbHkgdXNlIGtleSBjYWNoZVxuXHRcdGxlbmd0aCA9IGxlbmd0aCAtIDB4YTBcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSAvLyBpZiBpdCBoYXMgYmVlbiBleHRyYWN0ZWQsIG11c3QgdXNlIGl0IChhbmQgZmFzdGVyIGFueXdheSlcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRlbHNlIGlmICghKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE4MCkpXG5cdFx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHsgLy8gbm90IGNhY2hlYWJsZSwgZ28gYmFjayBhbmQgZG8gYSBzdGFuZGFyZCByZWFkXG5cdFx0cG9zaXRpb24tLVxuXHRcdHJldHVybiBhc1NhZmVTdHJpbmcocmVhZCgpKVxuXHR9XG5cdGxldCBrZXkgPSAoKGxlbmd0aCA8PCA1KSBeIChsZW5ndGggPiAxID8gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA6IGxlbmd0aCA+IDAgPyBzcmNbcG9zaXRpb25dIDogMCkpICYgMHhmZmZcblx0bGV0IGVudHJ5ID0ga2V5Q2FjaGVba2V5XVxuXHRsZXQgY2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdGxldCBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aCAtIDNcblx0bGV0IGNodW5rXG5cdGxldCBpID0gMFxuXHRpZiAoZW50cnkgJiYgZW50cnkuYnl0ZXMgPT0gbGVuZ3RoKSB7XG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gZGF0YVZpZXcuZ2V0VWludDMyKGNoZWNrUG9zaXRpb24pXG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMFxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0XG5cdFx0fVxuXHRcdGVuZCArPSAzXG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK11cblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjaGVja1Bvc2l0aW9uID09PSBlbmQpIHtcblx0XHRcdHBvc2l0aW9uID0gY2hlY2tQb3NpdGlvblxuXHRcdFx0cmV0dXJuIGVudHJ5LnN0cmluZ1xuXHRcdH1cblx0XHRlbmQgLT0gM1xuXHRcdGNoZWNrUG9zaXRpb24gPSBwb3NpdGlvblxuXHR9XG5cdGVudHJ5ID0gW11cblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5XG5cdGVudHJ5LmJ5dGVzID0gbGVuZ3RoXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbilcblx0XHRlbnRyeS5wdXNoKGNodW5rKVxuXHRcdGNoZWNrUG9zaXRpb24gKz0gNFxuXHR9XG5cdGVuZCArPSAzXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXVxuXHRcdGVudHJ5LnB1c2goY2h1bmspXG5cdH1cblx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aClcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJykgcmV0dXJuIHByb3BlcnR5LnRvU3RyaW5nKCk7XG5cdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSB0eXBlIGZvciByZWNvcmQnLCB0eXBlb2YgcHJvcGVydHkpO1xufVxuLy8gdGhlIHJlZ2lzdHJhdGlvbiBvZiB0aGUgcmVjb3JkIGRlZmluaXRpb24gZXh0ZW5zaW9uIChhcyBcInJcIilcbmNvbnN0IHJlY29yZERlZmluaXRpb24gPSAoaWQsIGhpZ2hCeXRlKSA9PiB7XG5cdGxldCBzdHJ1Y3R1cmUgPSByZWFkKCkubWFwKGFzU2FmZVN0cmluZykgLy8gZW5zdXJlIHRoYXQgYWxsIGtleXMgYXJlIHN0cmluZ3MgYW5kXG5cdC8vIHRoYXQgdGhlIGFycmF5IGlzIG11dGFibGVcblx0bGV0IGZpcnN0Qnl0ZSA9IGlkXG5cdGlmIChoaWdoQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWQgPSBpZCA8IDMyID8gLSgoaGlnaEJ5dGUgPDwgNSkgKyBpZCkgOiAoKGhpZ2hCeXRlIDw8IDUpICsgaWQpXG5cdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gaGlnaEJ5dGVcblx0fVxuXHRsZXQgZXhpc3RpbmdTdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF1cblx0Ly8gSWYgaXQgaXMgYSBzaGFyZWQgc3RydWN0dXJlLCB3ZSBuZWVkIHRvIHJlc3RvcmUgYW55IGNoYW5nZXMgYWZ0ZXIgcmVhZGluZy5cblx0Ly8gQWxzbyBpbiBzZXF1ZW50aWFsIG1vZGUsIHdlIG1heSBnZXQgaW5jb21wbGV0ZSByZWFkcyBhbmQgdGh1cyBlcnJvcnMsIGFuZCB3ZSBuZWVkIHRvIHJlc3RvcmVcblx0Ly8gdG8gdGhlIHN0YXRlIHByaW9yIHRvIGFuIGluY29tcGxldGUgcmVhZCBpbiBvcmRlciB0byBwcm9wZXJseSByZXN1bWUuXG5cdGlmIChleGlzdGluZ1N0cnVjdHVyZSAmJiAoZXhpc3RpbmdTdHJ1Y3R1cmUuaXNTaGFyZWQgfHwgc2VxdWVudGlhbE1vZGUpKSB7XG5cdFx0KGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmVcblx0fVxuXHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBzdHJ1Y3R1cmVcblx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdEJ5dGUpXG5cdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG59XG5jdXJyZW50RXh0ZW5zaW9uc1swXSA9ICgpID0+IHt9IC8vIG5vdGVwYWNrIGRlZmluZXMgZXh0ZW5zaW9uIDAgdG8gbWVhbiB1bmRlZmluZWQsIHNvIHVzZSB0aGF0IGFzIHRoZSBkZWZhdWx0IGhlcmVcbmN1cnJlbnRFeHRlbnNpb25zWzBdLm5vQnVmZmVyID0gdHJ1ZVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDQyXSA9IChkYXRhKSA9PiB7XG5cdC8vIGRlY29kZSBiaWdpbnRcblx0bGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRsZXQgdmFsdWUgPSBCaWdJbnQoZGF0YVswXSAmIDB4ODAgPyBkYXRhWzBdIC0gMHgxMDAgOiBkYXRhWzBdKTtcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhbHVlIDw8PSA4bjtcblx0XHR2YWx1ZSArPSBCaWdJbnQoZGF0YVtpXSk7XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5sZXQgZXJyb3JzID0geyBFcnJvciwgVHlwZUVycm9yLCBSZWZlcmVuY2VFcnJvciB9O1xuY3VycmVudEV4dGVuc2lvbnNbMHg2NV0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpXG5cdHJldHVybiAoZXJyb3JzW2RhdGFbMF1dIHx8IEVycm9yKShkYXRhWzFdKVxufVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDY5XSA9IChkYXRhKSA9PiB7XG5cdC8vIGlkIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiAtIDQpXG5cdGlmICghcmVmZXJlbmNlTWFwKVxuXHRcdHJlZmVyZW5jZU1hcCA9IG5ldyBNYXAoKVxuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb25dXG5cdGxldCB0YXJnZXRcblx0Ly8gVE9ETzogaGFuZGxlIE1hcHMsIFNldHMsIGFuZCBvdGhlciB0eXBlcyB0aGF0IGNhbiBjeWNsZTsgdGhpcyBpcyBjb21wbGljYXRlZCwgYmVjYXVzZSB5b3UgcG90ZW50aWFsbHkgbmVlZCB0byByZWFkXG5cdC8vIGFoZWFkIHBhc3QgcmVmZXJlbmNlcyB0byByZWNvcmQgc3RydWN0dXJlIGRlZmluaXRpb25zXG5cdGlmICh0b2tlbiA+PSAweDkwICYmIHRva2VuIDwgMHhhMCB8fCB0b2tlbiA9PSAweGRjIHx8IHRva2VuID09IDB4ZGQpXG5cdFx0dGFyZ2V0ID0gW11cblx0ZWxzZVxuXHRcdHRhcmdldCA9IHt9XG5cblx0bGV0IHJlZkVudHJ5ID0geyB0YXJnZXQgfSAvLyBhIHBsYWNlaG9sZGVyIG9iamVjdFxuXHRyZWZlcmVuY2VNYXAuc2V0KGlkLCByZWZFbnRyeSlcblx0bGV0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkKCkgLy8gcmVhZCB0aGUgbmV4dCB2YWx1ZSBhcyB0aGUgdGFyZ2V0IG9iamVjdCB0byBpZFxuXHRpZiAocmVmRW50cnkudXNlZCkgLy8gdGhlcmUgaXMgYSBjeWNsZSwgc28gd2UgaGF2ZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBvcmlnaW5hbCB0YXJnZXRcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHRhcmdldFByb3BlcnRpZXMpXG5cdHJlZkVudHJ5LnRhcmdldCA9IHRhcmdldFByb3BlcnRpZXMgLy8gdGhlIHBsYWNlaG9sZGVyIHdhc24ndCB1c2VkLCByZXBsYWNlIHdpdGggdGhlIGRlc2VyaWFsaXplZCBvbmVcblx0cmV0dXJuIHRhcmdldFByb3BlcnRpZXMgLy8gbm8gY3ljbGUsIGNhbiBqdXN0IHVzZSB0aGUgcmV0dXJuZWQgcmVhZCBvYmplY3Rcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg3MF0gPSAoZGF0YSkgPT4ge1xuXHQvLyBwb2ludGVyIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiAtIDQpXG5cdGxldCByZWZFbnRyeSA9IHJlZmVyZW5jZU1hcC5nZXQoaWQpXG5cdHJlZkVudHJ5LnVzZWQgPSB0cnVlXG5cdHJldHVybiByZWZFbnRyeS50YXJnZXRcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg3M10gPSAoKSA9PiBuZXcgU2V0KHJlYWQoKSlcblxuZXhwb3J0IGNvbnN0IHR5cGVkQXJyYXlzID0gWydJbnQ4JywnVWludDgnLCdVaW50OENsYW1wZWQnLCdJbnQxNicsJ1VpbnQxNicsJ0ludDMyJywnVWludDMyJywnRmxvYXQzMicsJ0Zsb2F0NjQnLCdCaWdJbnQ2NCcsJ0JpZ1VpbnQ2NCddLm1hcCh0eXBlID0+IHR5cGUgKyAnQXJyYXknKVxuXG5sZXQgZ2xibCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG5jdXJyZW50RXh0ZW5zaW9uc1sweDc0XSA9IChkYXRhKSA9PiB7XG5cdGxldCB0eXBlQ29kZSA9IGRhdGFbMF1cblx0bGV0IHR5cGVkQXJyYXlOYW1lID0gdHlwZWRBcnJheXNbdHlwZUNvZGVdXG5cdGlmICghdHlwZWRBcnJheU5hbWUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBhcnJheSBmb3IgY29kZSAnICsgdHlwZUNvZGUpXG5cdC8vIHdlIGhhdmUgdG8gYWx3YXlzIHNsaWNlL2NvcHkgaGVyZSB0byBnZXQgYSBuZXcgQXJyYXlCdWZmZXIgdGhhdCBpcyB3b3JkL2J5dGUgYWxpZ25lZFxuXHRyZXR1cm4gbmV3IGdsYmxbdHlwZWRBcnJheU5hbWVdKFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSwgMSkuYnVmZmVyKVxufVxuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpXG5cdHJldHVybiBuZXcgUmVnRXhwKGRhdGFbMF0sIGRhdGFbMV0pXG59XG5jb25zdCBURU1QX0JVTkRMRSA9IFtdXG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXVxuXHRsZXQgZGF0YVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aFxuXHRidW5kbGVkU3RyaW5ncyA9IFRFTVBfQlVORExFXG5cdGJ1bmRsZWRTdHJpbmdzID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXVxuXHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAgPSAwXG5cdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSA9IDBcblx0YnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gPSBkYXRhUG9zaXRpb25cblx0cmV0dXJuIHJlYWQoKVxufVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweGZmXSA9IChkYXRhKSA9PiB7XG5cdC8vIDMyLWJpdCBkYXRlIGV4dGVuc2lvblxuXHRpZiAoZGF0YS5sZW5ndGggPT0gNClcblx0XHRyZXR1cm4gbmV3IERhdGUoKGRhdGFbMF0gKiAweDEwMDAwMDAgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gOClcblx0XHRyZXR1cm4gbmV3IERhdGUoXG5cdFx0XHQoKGRhdGFbMF0gPDwgMjIpICsgKGRhdGFbMV0gPDwgMTQpICsgKGRhdGFbMl0gPDwgNikgKyAoZGF0YVszXSA+PiAyKSkgLyAxMDAwMDAwICtcblx0XHRcdCgoZGF0YVszXSAmIDB4MykgKiAweDEwMDAwMDAwMCArIGRhdGFbNF0gKiAweDEwMDAwMDAgKyAoZGF0YVs1XSA8PCAxNikgKyAoZGF0YVs2XSA8PCA4KSArIGRhdGFbN10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gMTIpLy8gVE9ETzogSW1wbGVtZW50IHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXSkgLyAxMDAwMDAwICtcblx0XHRcdCgoKGRhdGFbNF0gJiAweDgwKSA/IC0weDEwMDAwMDAwMDAwMDAgOiAwKSArIGRhdGFbNl0gKiAweDEwMDAwMDAwMDAwICsgZGF0YVs3XSAqIDB4MTAwMDAwMDAwICsgZGF0YVs4XSAqIDB4MTAwMDAwMCArIChkYXRhWzldIDw8IDE2KSArIChkYXRhWzEwXSA8PCA4KSArIGRhdGFbMTFdKSAqIDEwMDApXG5cdGVsc2Vcblx0XHRyZXR1cm4gbmV3IERhdGUoJ2ludmFsaWQnKVxufSAvLyBub3RlcGFjayBkZWZpbmVzIGV4dGVuc2lvbiAwIHRvIG1lYW4gdW5kZWZpbmVkLCBzbyB1c2UgdGhhdCBhcyB0aGUgZGVmYXVsdCBoZXJlXG4vLyByZWdpc3RyYXRpb24gb2YgYnVsayByZWNvcmQgZGVmaW5pdGlvbj9cbi8vIGN1cnJlbnRFeHRlbnNpb25zWzB4NTJdID0gKCkgPT5cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGNhbGxiYWNrKSB7XG5cdGlmIChvblNhdmVTdGF0ZSlcblx0XHRvblNhdmVTdGF0ZSgpO1xuXHRsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmRcblx0bGV0IHNhdmVkUG9zaXRpb24gPSBwb3NpdGlvblxuXHRsZXQgc2F2ZWRTdHJpbmdQb3NpdGlvbiA9IHN0cmluZ1Bvc2l0aW9uXG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnRcblx0bGV0IHNhdmVkU3JjU3RyaW5nRW5kID0gc3JjU3RyaW5nRW5kXG5cdGxldCBzYXZlZFNyY1N0cmluZyA9IHNyY1N0cmluZ1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5nc1xuXHRsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXBcblx0bGV0IHNhdmVkQnVuZGxlZFN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXG5cdC8vIFRPRE86IFdlIG1heSBuZWVkIHRvIHJldmlzaXQgdGhpcyBpZiB3ZSBkbyBtb3JlIGV4dGVybmFsIGNhbGxzIHRvIHVzZXIgY29kZSAoc2luY2UgaXQgY291bGQgYmUgc2xvdylcblx0bGV0IHNhdmVkU3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLnNsaWNlKDAsIHNyY0VuZCkpIC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlc1xuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMgPSBjdXJyZW50U3RydWN0dXJlcy5zbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdGxldCBzYXZlZFBhY2tyID0gY3VycmVudFVucGFja3Jcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZVxuXHRsZXQgdmFsdWUgPSBjYWxsYmFjaygpXG5cdHNyY0VuZCA9IHNhdmVkU3JjRW5kXG5cdHBvc2l0aW9uID0gc2F2ZWRQb3NpdGlvblxuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb25cblx0c3JjU3RyaW5nU3RhcnQgPSBzYXZlZFNyY1N0cmluZ1N0YXJ0XG5cdHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kXG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nXG5cdHN0cmluZ3MgPSBzYXZlZFN0cmluZ3Ncblx0cmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXBcblx0YnVuZGxlZFN0cmluZ3MgPSBzYXZlZEJ1bmRsZWRTdHJpbmdzXG5cdHNyYyA9IHNhdmVkU3JjXG5cdHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZVxuXHRjdXJyZW50U3RydWN0dXJlcyA9IHNhdmVkU3RydWN0dXJlc1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cylcblx0Y3VycmVudFVucGFja3IgPSBzYXZlZFBhY2tyXG5cdGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aClcblx0cmV0dXJuIHZhbHVlXG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG5cdHNyYyA9IG51bGxcblx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFja1xuXHRlbHNlXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uXG59XG5cbmV4cG9ydCBjb25zdCBtdWx0MTAgPSBuZXcgQXJyYXkoMTQ3KSAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0bXVsdDEwW2ldID0gKygnMWUnICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSlcbn1cbmV4cG9ydCBjb25zdCBEZWNvZGVyID0gVW5wYWNrclxudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFja1xuZXhwb3J0IGNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGVcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tcbmV4cG9ydCBjb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpXG5sZXQgdThBcnJheSA9IG5ldyBVaW50OEFycmF5KGYzMkFycmF5LmJ1ZmZlciwgMCwgNClcbmV4cG9ydCBmdW5jdGlvbiByb3VuZEZsb2F0MzIoZmxvYXQzMk51bWJlcikge1xuXHRmMzJBcnJheVswXSA9IGZsb2F0MzJOdW1iZXJcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV1cblx0cmV0dXJuICgobXVsdGlwbGllciAqIGZsb2F0MzJOdW1iZXIgKyAoZmxvYXQzMk51bWJlciA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QgPSB1cGRhdGVkUmVhZFN0cnVjdDtcblx0b25Mb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0cztcblx0b25TYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG59XG4iXSwibmFtZXMiOlsiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZXJyb3IiLCJzcmMiLCJzcmNFbmQiLCJwb3NpdGlvbiIsImFscmVhZHlTZXQiLCJFTVBUWV9BUlJBWSIsInN0cmluZ3MiLCJzdHJpbmdQb3NpdGlvbiIsImN1cnJlbnRVbnBhY2tyIiwiY3VycmVudFN0cnVjdHVyZXMiLCJzcmNTdHJpbmciLCJzcmNTdHJpbmdTdGFydCIsInNyY1N0cmluZ0VuZCIsImJ1bmRsZWRTdHJpbmdzIiwicmVmZXJlbmNlTWFwIiwiY3VycmVudEV4dGVuc2lvbnMiLCJkYXRhVmlldyIsImRlZmF1bHRPcHRpb25zIiwidXNlUmVjb3JkcyIsIm1hcHNBc09iamVjdHMiLCJDMVR5cGUiLCJDMSIsIm5hbWUiLCJzZXF1ZW50aWFsTW9kZSIsImlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQiLCJyZWFkU3RydWN0Iiwib25Mb2FkZWRTdHJ1Y3R1cmVzIiwib25TYXZlU3RhdGUiLCJCbG9ja2VkRnVuY3Rpb24iLCJGdW5jdGlvbiIsIkluZmluaXR5IiwiVW5wYWNrciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsInNlcXVlbnRpYWwiLCJ0cnVzdGVkIiwic3RydWN0dXJlcyIsIm1heFNoYXJlZFN0cnVjdHVyZXMiLCJzaGFyZWRMZW5ndGgiLCJsZW5ndGgiLCJnZXRTdHJ1Y3R1cmVzIiwidW5pbml0aWFsaXplZCIsImludDY0QXNOdW1iZXIiLCJpbnQ2NEFzVHlwZSIsIk9iamVjdCIsImFzc2lnbiIsInVucGFjayIsInNvdXJjZSIsInNhdmVTdGF0ZSIsImNsZWFyU291cmNlIiwicHJvdG90eXBlIiwiY2FsbCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJlbmQiLCJzdGFydCIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsImNoZWNrZWRSZWFkIiwidW5wYWNrTXVsdGlwbGUiLCJmb3JFYWNoIiwidmFsdWVzIiwibGFzdFBvc2l0aW9uIiwic2l6ZSIsInZhbHVlIiwiZGVmYXVsdFVucGFja3IiLCJwdXNoIiwiX21lcmdlU3RydWN0dXJlcyIsImxvYWRlZFN0cnVjdHVyZXMiLCJleGlzdGluZ1N0cnVjdHVyZXMiLCJpc0Zyb3plbiIsIm1hcCIsInN0cnVjdHVyZSIsInNsaWNlIiwiaSIsImwiLCJpc1NoYXJlZCIsImhpZ2hCeXRlIiwiaWQiLCJleGlzdGluZyIsInJlc3RvcmVTdHJ1Y3R1cmVzIiwiZGVjb2RlIiwiZ2V0UG9zaXRpb24iLCJyZXN1bHQiLCJyYW5kb21BY2Nlc3NTdHJ1Y3R1cmUiLCJsYXp5IiwidG9KU09OIiwicmVhZCIsInBvc3RCdW5kbGVQb3NpdGlvbiIsImpzb25WaWV3IiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJSYW5nZUVycm9yIiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJpbmNvbXBsZXRlIiwidG9rZW4iLCJsb2FkU3RydWN0dXJlcyIsImNyZWF0ZVN0cnVjdHVyZVJlYWRlciIsIm9iamVjdCIsImtleSIsInJlYWRLZXkiLCJNYXAiLCJzZXQiLCJhcnJheSIsIkFycmF5IiwiZnJlZXplRGF0YSIsImZyZWV6ZSIsInN0cmluZyIsInNob3J0U3RyaW5nSW5KUyIsImxvbmdTdHJpbmdJbkpTIiwicmVhZEZpeGVkU3RyaW5nIiwicG9zaXRpb24xIiwicG9zaXRpb24wIiwicmVhZEJpbiIsImdldFVpbnQxNiIsImdldFVpbnQzMiIsInJlYWRFeHQiLCJnZXRGbG9hdDMyIiwidXNlRmxvYXQzMiIsIm11bHRpcGxpZXIiLCJtdWx0MTAiLCJnZXRGbG9hdDY0IiwiZ2V0QmlnVWludDY0IiwidG9TdHJpbmciLCJCaWdJbnQiLCJOdW1iZXIiLCJnZXRJbnQ4IiwiZ2V0SW50MTYiLCJnZXRJbnQzMiIsImdldEJpZ0ludDY0IiwicmVjb3JkRGVmaW5pdGlvbiIsImV4dGVuc2lvbiIsIm5vQnVmZmVyIiwic3ViYXJyYXkiLCJyZWFkU3RyaW5nOCIsInJlYWRTdHJpbmcxNiIsInJlYWRTdHJpbmczMiIsInJlYWRBcnJheSIsInJlYWRNYXAiLCJ2YWxpZE5hbWUiLCJmaXJzdElkIiwicmVhZE9iamVjdCIsImNvdW50IiwidGVzdCIsImpvaW4iLCJjcmVhdGVTZWNvbmRCeXRlUmVhZGVyIiwicmVhZDAiLCJyZWFkU3RyaW5nSlMiLCJpc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQiLCJzZXRFeHRyYWN0b3IiLCJleHRyYWN0U3RyaW5ncyIsInJlYWRTdHJpbmciLCJoZWFkZXJMZW5ndGgiLCJleHRyYWN0aW9uIiwic3JjU3RyaW5nTGVuZ3RoIiwidW5pdHMiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInVuaXQiLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIlN0cmluZyIsImV4aXN0aW5nU3JjIiwiYnl0ZXMiLCJieXRlIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJqIiwiayIsIm0iLCJuIiwibyIsInJlYWRPbmx5SlNTdHJpbmciLCJjb3B5QnVmZmVycyIsInR5cGUiLCJyZWFkUG9zaXRpb24iLCJrZXlDYWNoZSIsImFzU2FmZVN0cmluZyIsImVudHJ5IiwiY2hlY2tQb3NpdGlvbiIsImNodW5rIiwicHJvcGVydHkiLCJmaXJzdEJ5dGUiLCJleGlzdGluZ1N0cnVjdHVyZSIsImRhdGEiLCJlcnJvcnMiLCJUeXBlRXJyb3IiLCJSZWZlcmVuY2VFcnJvciIsInN0cnVjdHVyZWRDbG9uZSIsInRhcmdldCIsInJlZkVudHJ5IiwidGFyZ2V0UHJvcGVydGllcyIsInVzZWQiLCJnZXQiLCJTZXQiLCJ0eXBlZEFycmF5cyIsImdsYmwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwidHlwZUNvZGUiLCJ0eXBlZEFycmF5TmFtZSIsIlJlZ0V4cCIsIlRFTVBfQlVORExFIiwiZGF0YVNpemUiLCJkYXRhUG9zaXRpb24iLCJEYXRlIiwiY2FsbGJhY2siLCJzYXZlZFNyY0VuZCIsInNhdmVkUG9zaXRpb24iLCJzYXZlZFN0cmluZ1Bvc2l0aW9uIiwic2F2ZWRTcmNTdHJpbmdTdGFydCIsInNhdmVkU3JjU3RyaW5nRW5kIiwic2F2ZWRTcmNTdHJpbmciLCJzYXZlZFN0cmluZ3MiLCJzYXZlZFJlZmVyZW5jZU1hcCIsInNhdmVkQnVuZGxlZFN0cmluZ3MiLCJzYXZlZFNyYyIsInNhdmVkU3RydWN0dXJlcyIsInNhdmVkU3RydWN0dXJlc0NvbnRlbnRzIiwic2F2ZWRQYWNrciIsInNhdmVkU2VxdWVudGlhbE1vZGUiLCJzcGxpY2UiLCJhZGRFeHRlbnNpb24iLCJNYXRoIiwiZmxvb3IiLCJEZWNvZGVyIiwiRkxPQVQzMl9PUFRJT05TIiwiTkVWRVIiLCJBTFdBWVMiLCJERUNJTUFMX1JPVU5EIiwiREVDSU1BTF9GSVQiLCJmMzJBcnJheSIsIkZsb2F0MzJBcnJheSIsInU4QXJyYXkiLCJyb3VuZEZsb2F0MzIiLCJmbG9hdDMyTnVtYmVyIiwic2V0UmVhZFN0cnVjdCIsInVwZGF0ZWRSZWFkU3RydWN0IiwibG9hZGVkU3RydWN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/unpack.js\n");

/***/ })

};
;