"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bullmq";
exports.ids = ["vendor-chunks/bullmq"];
exports.modules = {

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* binding */ AsyncFifoQueue)\n/* harmony export */ });\n/**\n * AsyncFifoQueue\n *\n * A minimal FIFO queue for asynchronous operations. Allows adding asynchronous operations\n * and consume them in the order they are resolved.\n *\n *  TODO: Optimize using a linked list for the queue instead of an array.\n *  Current implementation requires memory copies when shifting the queue.\n *  For a linked linked implementation, we can exploit the fact that the\n *  maximum number of elements in the list will never exceen the concurrency factor\n *  of the worker, so the nodes of the list could be pre-allocated.\n */ class AsyncFifoQueue {\n    constructor(ignoreErrors = false){\n        this.ignoreErrors = ignoreErrors;\n        /**\n         * A queue of completed promises. As the pending\n         * promises are resolved, they are added to this queue.\n         */ this.queue = [];\n        /**\n         * A set of pending promises.\n         */ this.pending = new Set();\n        this.newPromise();\n    }\n    add(promise) {\n        this.pending.add(promise);\n        promise.then((data)=>{\n            this.pending.delete(promise);\n            if (this.queue.length === 0) {\n                this.resolvePromise(data);\n            }\n            this.queue.push(data);\n        }).catch((err)=>{\n            // Ignore errors\n            if (this.ignoreErrors) {\n                this.queue.push(undefined);\n            }\n            this.pending.delete(promise);\n            this.rejectPromise(err);\n        });\n    }\n    async waitAll() {\n        await Promise.all(this.pending);\n    }\n    numTotal() {\n        return this.pending.size + this.queue.length;\n    }\n    numPending() {\n        return this.pending.size;\n    }\n    numQueued() {\n        return this.queue.length;\n    }\n    resolvePromise(data) {\n        this.resolve(data);\n        this.newPromise();\n    }\n    rejectPromise(err) {\n        this.reject(err);\n        this.newPromise();\n    }\n    newPromise() {\n        this.nextPromise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    async wait() {\n        return this.nextPromise;\n    }\n    async fetch() {\n        if (this.pending.size === 0 && this.queue.length === 0) {\n            return;\n        }\n        while(this.queue.length === 0){\n            try {\n                await this.wait();\n            } catch (err) {\n                // Ignore errors\n                if (!this.ignoreErrors) {\n                    console.error(\"Unexpected Error in AsyncFifoQueue\", err);\n                }\n            }\n        }\n        return this.queue.shift();\n    }\n} //# sourceMappingURL=async-fifo-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvYXN5bmMtZmlmby1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxNQUFNQTtJQUNUQyxZQUFZQyxlQUFlLEtBQUssQ0FBRTtRQUM5QixJQUFJLENBQUNBLFlBQVksR0FBR0E7UUFDcEI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkIsSUFBSSxDQUFDQyxVQUFVO0lBQ25CO0lBQ0FDLElBQUlDLE9BQU8sRUFBRTtRQUNULElBQUksQ0FBQ0osT0FBTyxDQUFDRyxHQUFHLENBQUNDO1FBQ2pCQSxRQUNLQyxJQUFJLENBQUNDLENBQUFBO1lBQ04sSUFBSSxDQUFDTixPQUFPLENBQUNPLE1BQU0sQ0FBQ0g7WUFDcEIsSUFBSSxJQUFJLENBQUNMLEtBQUssQ0FBQ1MsTUFBTSxLQUFLLEdBQUc7Z0JBQ3pCLElBQUksQ0FBQ0MsY0FBYyxDQUFDSDtZQUN4QjtZQUNBLElBQUksQ0FBQ1AsS0FBSyxDQUFDVyxJQUFJLENBQUNKO1FBQ3BCLEdBQ0tLLEtBQUssQ0FBQ0MsQ0FBQUE7WUFDUCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNkLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQyxLQUFLLENBQUNXLElBQUksQ0FBQ0c7WUFDcEI7WUFDQSxJQUFJLENBQUNiLE9BQU8sQ0FBQ08sTUFBTSxDQUFDSDtZQUNwQixJQUFJLENBQUNVLGFBQWEsQ0FBQ0Y7UUFDdkI7SUFDSjtJQUNBLE1BQU1HLFVBQVU7UUFDWixNQUFNQyxRQUFRQyxHQUFHLENBQUMsSUFBSSxDQUFDakIsT0FBTztJQUNsQztJQUNBa0IsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDbEIsT0FBTyxDQUFDbUIsSUFBSSxHQUFHLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ1MsTUFBTTtJQUNoRDtJQUNBWSxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNwQixPQUFPLENBQUNtQixJQUFJO0lBQzVCO0lBQ0FFLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ3RCLEtBQUssQ0FBQ1MsTUFBTTtJQUM1QjtJQUNBQyxlQUFlSCxJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDZ0IsT0FBTyxDQUFDaEI7UUFDYixJQUFJLENBQUNKLFVBQVU7SUFDbkI7SUFDQVksY0FBY0YsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDVyxNQUFNLENBQUNYO1FBQ1osSUFBSSxDQUFDVixVQUFVO0lBQ25CO0lBQ0FBLGFBQWE7UUFDVCxJQUFJLENBQUNzQixXQUFXLEdBQUcsSUFBSVIsUUFBUSxDQUFDTSxTQUFTQztZQUNyQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDbEI7SUFDSjtJQUNBLE1BQU1FLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ0QsV0FBVztJQUMzQjtJQUNBLE1BQU1FLFFBQVE7UUFDVixJQUFJLElBQUksQ0FBQzFCLE9BQU8sQ0FBQ21CLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ1MsTUFBTSxLQUFLLEdBQUc7WUFDcEQ7UUFDSjtRQUNBLE1BQU8sSUFBSSxDQUFDVCxLQUFLLENBQUNTLE1BQU0sS0FBSyxFQUFHO1lBQzVCLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUNpQixJQUFJO1lBQ25CLEVBQ0EsT0FBT2IsS0FBSztnQkFDUixnQkFBZ0I7Z0JBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUNkLFlBQVksRUFBRTtvQkFDcEI2QixRQUFRQyxLQUFLLENBQUMsc0NBQXNDaEI7Z0JBQ3hEO1lBQ0o7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDYixLQUFLLENBQUM4QixLQUFLO0lBQzNCO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2FzeW5jLWZpZm8tcXVldWUuanM/ZjUxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzeW5jRmlmb1F1ZXVlXG4gKlxuICogQSBtaW5pbWFsIEZJRk8gcXVldWUgZm9yIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBBbGxvd3MgYWRkaW5nIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zXG4gKiBhbmQgY29uc3VtZSB0aGVtIGluIHRoZSBvcmRlciB0aGV5IGFyZSByZXNvbHZlZC5cbiAqXG4gKiAgVE9ETzogT3B0aW1pemUgdXNpbmcgYSBsaW5rZWQgbGlzdCBmb3IgdGhlIHF1ZXVlIGluc3RlYWQgb2YgYW4gYXJyYXkuXG4gKiAgQ3VycmVudCBpbXBsZW1lbnRhdGlvbiByZXF1aXJlcyBtZW1vcnkgY29waWVzIHdoZW4gc2hpZnRpbmcgdGhlIHF1ZXVlLlxuICogIEZvciBhIGxpbmtlZCBsaW5rZWQgaW1wbGVtZW50YXRpb24sIHdlIGNhbiBleHBsb2l0IHRoZSBmYWN0IHRoYXQgdGhlXG4gKiAgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3Qgd2lsbCBuZXZlciBleGNlZW4gdGhlIGNvbmN1cnJlbmN5IGZhY3RvclxuICogIG9mIHRoZSB3b3JrZXIsIHNvIHRoZSBub2RlcyBvZiB0aGUgbGlzdCBjb3VsZCBiZSBwcmUtYWxsb2NhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNGaWZvUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGlnbm9yZUVycm9ycyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBxdWV1ZSBvZiBjb21wbGV0ZWQgcHJvbWlzZXMuIEFzIHRoZSBwZW5kaW5nXG4gICAgICAgICAqIHByb21pc2VzIGFyZSByZXNvbHZlZCwgdGhleSBhcmUgYWRkZWQgdG8gdGhpcyBxdWV1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubmV3UHJvbWlzZSgpO1xuICAgIH1cbiAgICBhZGQocHJvbWlzZSkge1xuICAgICAgICB0aGlzLnBlbmRpbmcuYWRkKHByb21pc2UpO1xuICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZy5kZWxldGUocHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzXG4gICAgICAgICAgICBpZiAodGhpcy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZy5kZWxldGUocHJvbWlzZSk7XG4gICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2UoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRBbGwoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMucGVuZGluZyk7XG4gICAgfVxuICAgIG51bVRvdGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nLnNpemUgKyB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgbnVtUGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZy5zaXplO1xuICAgIH1cbiAgICBudW1RdWV1ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgcmVzb2x2ZVByb21pc2UoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIHRoaXMubmV3UHJvbWlzZSgpO1xuICAgIH1cbiAgICByZWplY3RQcm9taXNlKGVycikge1xuICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICB0aGlzLm5ld1Byb21pc2UoKTtcbiAgICB9XG4gICAgbmV3UHJvbWlzZSgpIHtcbiAgICAgICAgdGhpcy5uZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZy5zaXplID09PSAwICYmIHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud2FpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgRXJyb3IgaW4gQXN5bmNGaWZvUXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWZpZm8tcXVldWUuanMubWFwIl0sIm5hbWVzIjpbIkFzeW5jRmlmb1F1ZXVlIiwiY29uc3RydWN0b3IiLCJpZ25vcmVFcnJvcnMiLCJxdWV1ZSIsInBlbmRpbmciLCJTZXQiLCJuZXdQcm9taXNlIiwiYWRkIiwicHJvbWlzZSIsInRoZW4iLCJkYXRhIiwiZGVsZXRlIiwibGVuZ3RoIiwicmVzb2x2ZVByb21pc2UiLCJwdXNoIiwiY2F0Y2giLCJlcnIiLCJ1bmRlZmluZWQiLCJyZWplY3RQcm9taXNlIiwid2FpdEFsbCIsIlByb21pc2UiLCJhbGwiLCJudW1Ub3RhbCIsInNpemUiLCJudW1QZW5kaW5nIiwibnVtUXVldWVkIiwicmVzb2x2ZSIsInJlamVjdCIsIm5leHRQcm9taXNlIiwid2FpdCIsImZldGNoIiwiY29uc29sZSIsImVycm9yIiwic2hpZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/backoffs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Backoffs: () => (/* binding */ Backoffs)\n/* harmony export */ });\nclass Backoffs {\n    static normalize(backoff) {\n        if (Number.isFinite(backoff)) {\n            return {\n                type: \"fixed\",\n                delay: backoff\n            };\n        } else if (backoff) {\n            return backoff;\n        }\n    }\n    static calculate(backoff, attemptsMade, err, job, customStrategy) {\n        if (backoff) {\n            const strategy = lookupStrategy(backoff, customStrategy);\n            return strategy(attemptsMade, backoff.type, err, job);\n        }\n    }\n}\nBackoffs.builtinStrategies = {\n    fixed: function(delay) {\n        return function() {\n            return delay;\n        };\n    },\n    exponential: function(delay) {\n        return function(attemptsMade) {\n            return Math.round(Math.pow(2, attemptsMade - 1) * delay);\n        };\n    }\n};\nfunction lookupStrategy(backoff, customStrategy) {\n    if (backoff.type in Backoffs.builtinStrategies) {\n        return Backoffs.builtinStrategies[backoff.type](backoff.delay);\n    } else if (customStrategy) {\n        return customStrategy;\n    } else {\n        throw new Error(`Unknown backoff strategy ${backoff.type}.\n      If a custom backoff strategy is used, specify it when the queue is created.`);\n    }\n} //# sourceMappingURL=backoffs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvYmFja29mZnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BO0lBQ1QsT0FBT0MsVUFBVUMsT0FBTyxFQUFFO1FBQ3RCLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsVUFBVTtZQUMxQixPQUFPO2dCQUNIRyxNQUFNO2dCQUNOQyxPQUFPSjtZQUNYO1FBQ0osT0FDSyxJQUFJQSxTQUFTO1lBQ2QsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsT0FBT0ssVUFBVUwsT0FBTyxFQUFFTSxZQUFZLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxjQUFjLEVBQUU7UUFDOUQsSUFBSVQsU0FBUztZQUNULE1BQU1VLFdBQVdDLGVBQWVYLFNBQVNTO1lBQ3pDLE9BQU9DLFNBQVNKLGNBQWNOLFFBQVFHLElBQUksRUFBRUksS0FBS0M7UUFDckQ7SUFDSjtBQUNKO0FBQ0FWLFNBQVNjLGlCQUFpQixHQUFHO0lBQ3pCQyxPQUFPLFNBQVVULEtBQUs7UUFDbEIsT0FBTztZQUNILE9BQU9BO1FBQ1g7SUFDSjtJQUNBVSxhQUFhLFNBQVVWLEtBQUs7UUFDeEIsT0FBTyxTQUFVRSxZQUFZO1lBQ3pCLE9BQU9TLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDLEdBQUdYLGVBQWUsS0FBS0Y7UUFDdEQ7SUFDSjtBQUNKO0FBQ0EsU0FBU08sZUFBZVgsT0FBTyxFQUFFUyxjQUFjO0lBQzNDLElBQUlULFFBQVFHLElBQUksSUFBSUwsU0FBU2MsaUJBQWlCLEVBQUU7UUFDNUMsT0FBT2QsU0FBU2MsaUJBQWlCLENBQUNaLFFBQVFHLElBQUksQ0FBQyxDQUFDSCxRQUFRSSxLQUFLO0lBQ2pFLE9BQ0ssSUFBSUssZ0JBQWdCO1FBQ3JCLE9BQU9BO0lBQ1gsT0FDSztRQUNELE1BQU0sSUFBSVMsTUFBTSxDQUFDLHlCQUF5QixFQUFFbEIsUUFBUUcsSUFBSSxDQUFDO2lGQUNnQixDQUFDO0lBQzlFO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2JhY2tvZmZzLmpzPzA1YmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEJhY2tvZmZzIHtcbiAgICBzdGF0aWMgbm9ybWFsaXplKGJhY2tvZmYpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShiYWNrb2ZmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBiYWNrb2ZmLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiYWNrb2ZmKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFja29mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY2FsY3VsYXRlKGJhY2tvZmYsIGF0dGVtcHRzTWFkZSwgZXJyLCBqb2IsIGN1c3RvbVN0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChiYWNrb2ZmKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGxvb2t1cFN0cmF0ZWd5KGJhY2tvZmYsIGN1c3RvbVN0cmF0ZWd5KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShhdHRlbXB0c01hZGUsIGJhY2tvZmYudHlwZSwgZXJyLCBqb2IpO1xuICAgICAgICB9XG4gICAgfVxufVxuQmFja29mZnMuYnVpbHRpblN0cmF0ZWdpZXMgPSB7XG4gICAgZml4ZWQ6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgZXhwb25lbnRpYWw6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dGVtcHRzTWFkZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5wb3coMiwgYXR0ZW1wdHNNYWRlIC0gMSkgKiBkZWxheSk7XG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBsb29rdXBTdHJhdGVneShiYWNrb2ZmLCBjdXN0b21TdHJhdGVneSkge1xuICAgIGlmIChiYWNrb2ZmLnR5cGUgaW4gQmFja29mZnMuYnVpbHRpblN0cmF0ZWdpZXMpIHtcbiAgICAgICAgcmV0dXJuIEJhY2tvZmZzLmJ1aWx0aW5TdHJhdGVnaWVzW2JhY2tvZmYudHlwZV0oYmFja29mZi5kZWxheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1c3RvbVN0cmF0ZWd5KSB7XG4gICAgICAgIHJldHVybiBjdXN0b21TdHJhdGVneTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBiYWNrb2ZmIHN0cmF0ZWd5ICR7YmFja29mZi50eXBlfS5cbiAgICAgIElmIGEgY3VzdG9tIGJhY2tvZmYgc3RyYXRlZ3kgaXMgdXNlZCwgc3BlY2lmeSBpdCB3aGVuIHRoZSBxdWV1ZSBpcyBjcmVhdGVkLmApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmZzLmpzLm1hcCJdLCJuYW1lcyI6WyJCYWNrb2ZmcyIsIm5vcm1hbGl6ZSIsImJhY2tvZmYiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInR5cGUiLCJkZWxheSIsImNhbGN1bGF0ZSIsImF0dGVtcHRzTWFkZSIsImVyciIsImpvYiIsImN1c3RvbVN0cmF0ZWd5Iiwic3RyYXRlZ3kiLCJsb29rdXBTdHJhdGVneSIsImJ1aWx0aW5TdHJhdGVnaWVzIiwiZml4ZWQiLCJleHBvbmVudGlhbCIsIk1hdGgiLCJyb3VuZCIsInBvdyIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child-pool.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildPool: () => (/* binding */ ChildPool)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _child__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./child */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child.js\");\n\n\nconst CHILD_KILL_TIMEOUT = 30000;\nclass ChildPool {\n    constructor({ mainFile = path__WEBPACK_IMPORTED_MODULE_0__.join(process.cwd(), \"dist/cjs/classes/main.js\"), useWorkerThreads }){\n        this.retained = {};\n        this.free = {};\n        this.opts = {\n            mainFile,\n            useWorkerThreads\n        };\n    }\n    async retain(processFile) {\n        let child = this.getFree(processFile).pop();\n        if (child) {\n            this.retained[child.pid] = child;\n            return child;\n        }\n        child = new _child__WEBPACK_IMPORTED_MODULE_1__.Child(this.opts.mainFile, processFile, {\n            useWorkerThreads: this.opts.useWorkerThreads\n        });\n        child.on(\"exit\", this.remove.bind(this, child));\n        try {\n            await child.init();\n            this.retained[child.pid] = child;\n            return child;\n        } catch (err) {\n            console.error(err);\n            this.release(child);\n            throw err;\n        }\n    }\n    release(child) {\n        delete this.retained[child.pid];\n        this.getFree(child.processFile).push(child);\n    }\n    remove(child) {\n        delete this.retained[child.pid];\n        const free = this.getFree(child.processFile);\n        const childIndex = free.indexOf(child);\n        if (childIndex > -1) {\n            free.splice(childIndex, 1);\n        }\n    }\n    async kill(child, signal = \"SIGKILL\") {\n        this.remove(child);\n        return child.kill(signal, CHILD_KILL_TIMEOUT);\n    }\n    async clean() {\n        const children = Object.values(this.retained).concat(this.getAllFree());\n        this.retained = {};\n        this.free = {};\n        await Promise.all(children.map((c)=>this.kill(c, \"SIGTERM\")));\n    }\n    getFree(id) {\n        return this.free[id] = this.free[id] || [];\n    }\n    getAllFree() {\n        return Object.values(this.free).reduce((first, second)=>first.concat(second), []);\n    }\n} //# sourceMappingURL=child-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQtcG9vbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZCO0FBQ0c7QUFDaEMsTUFBTUUscUJBQXFCO0FBQ3BCLE1BQU1DO0lBQ1RDLFlBQVksRUFBRUMsV0FBV0wsc0NBQVMsQ0FBQ08sUUFBUUMsR0FBRyxJQUFJLDJCQUEyQixFQUFFQyxnQkFBZ0IsRUFBRyxDQUFFO1FBQ2hHLElBQUksQ0FBQ0MsUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztRQUNiLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQUVQO1lBQVVJO1FBQWlCO0lBQzdDO0lBQ0EsTUFBTUksT0FBT0MsV0FBVyxFQUFFO1FBQ3RCLElBQUlDLFFBQVEsSUFBSSxDQUFDQyxPQUFPLENBQUNGLGFBQWFHLEdBQUc7UUFDekMsSUFBSUYsT0FBTztZQUNQLElBQUksQ0FBQ0wsUUFBUSxDQUFDSyxNQUFNRyxHQUFHLENBQUMsR0FBR0g7WUFDM0IsT0FBT0E7UUFDWDtRQUNBQSxRQUFRLElBQUlkLHlDQUFLQSxDQUFDLElBQUksQ0FBQ1csSUFBSSxDQUFDUCxRQUFRLEVBQUVTLGFBQWE7WUFDL0NMLGtCQUFrQixJQUFJLENBQUNHLElBQUksQ0FBQ0gsZ0JBQWdCO1FBQ2hEO1FBQ0FNLE1BQU1JLEVBQUUsQ0FBQyxRQUFRLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSSxFQUFFTjtRQUN4QyxJQUFJO1lBQ0EsTUFBTUEsTUFBTU8sSUFBSTtZQUNoQixJQUFJLENBQUNaLFFBQVEsQ0FBQ0ssTUFBTUcsR0FBRyxDQUFDLEdBQUdIO1lBQzNCLE9BQU9BO1FBQ1gsRUFDQSxPQUFPUSxLQUFLO1lBQ1JDLFFBQVFDLEtBQUssQ0FBQ0Y7WUFDZCxJQUFJLENBQUNHLE9BQU8sQ0FBQ1g7WUFDYixNQUFNUTtRQUNWO0lBQ0o7SUFDQUcsUUFBUVgsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNMLFFBQVEsQ0FBQ0ssTUFBTUcsR0FBRyxDQUFDO1FBQy9CLElBQUksQ0FBQ0YsT0FBTyxDQUFDRCxNQUFNRCxXQUFXLEVBQUVhLElBQUksQ0FBQ1o7SUFDekM7SUFDQUssT0FBT0wsS0FBSyxFQUFFO1FBQ1YsT0FBTyxJQUFJLENBQUNMLFFBQVEsQ0FBQ0ssTUFBTUcsR0FBRyxDQUFDO1FBQy9CLE1BQU1QLE9BQU8sSUFBSSxDQUFDSyxPQUFPLENBQUNELE1BQU1ELFdBQVc7UUFDM0MsTUFBTWMsYUFBYWpCLEtBQUtrQixPQUFPLENBQUNkO1FBQ2hDLElBQUlhLGFBQWEsQ0FBQyxHQUFHO1lBQ2pCakIsS0FBS21CLE1BQU0sQ0FBQ0YsWUFBWTtRQUM1QjtJQUNKO0lBQ0EsTUFBTUcsS0FBS2hCLEtBQUssRUFBRWlCLFNBQVMsU0FBUyxFQUFFO1FBQ2xDLElBQUksQ0FBQ1osTUFBTSxDQUFDTDtRQUNaLE9BQU9BLE1BQU1nQixJQUFJLENBQUNDLFFBQVE5QjtJQUM5QjtJQUNBLE1BQU0rQixRQUFRO1FBQ1YsTUFBTUMsV0FBV0MsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQzFCLFFBQVEsRUFBRTJCLE1BQU0sQ0FBQyxJQUFJLENBQUNDLFVBQVU7UUFDcEUsSUFBSSxDQUFDNUIsUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztRQUNiLE1BQU00QixRQUFRQyxHQUFHLENBQUNOLFNBQVNPLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSyxJQUFJLENBQUNYLElBQUksQ0FBQ1csR0FBRztJQUNyRDtJQUNBMUIsUUFBUTJCLEVBQUUsRUFBRTtRQUNSLE9BQVEsSUFBSSxDQUFDaEMsSUFBSSxDQUFDZ0MsR0FBRyxHQUFHLElBQUksQ0FBQ2hDLElBQUksQ0FBQ2dDLEdBQUcsSUFBSSxFQUFFO0lBQy9DO0lBQ0FMLGFBQWE7UUFDVCxPQUFPSCxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDekIsSUFBSSxFQUFFaUMsTUFBTSxDQUFDLENBQUNDLE9BQU9DLFNBQVdELE1BQU1SLE1BQU0sQ0FBQ1MsU0FBUyxFQUFFO0lBQ3RGO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2NoaWxkLXBvb2wuanM/NjE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgQ2hpbGQgfSBmcm9tICcuL2NoaWxkJztcbmNvbnN0IENISUxEX0tJTExfVElNRU9VVCA9IDMwMDAwO1xuZXhwb3J0IGNsYXNzIENoaWxkUG9vbCB7XG4gICAgY29uc3RydWN0b3IoeyBtYWluRmlsZSA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGlzdC9janMvY2xhc3Nlcy9tYWluLmpzJyksIHVzZVdvcmtlclRocmVhZHMsIH0pIHtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmZyZWUgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyBtYWluRmlsZSwgdXNlV29ya2VyVGhyZWFkcyB9O1xuICAgIH1cbiAgICBhc3luYyByZXRhaW4ocHJvY2Vzc0ZpbGUpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGcmVlKHByb2Nlc3NGaWxlKS5wb3AoKTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkW2NoaWxkLnBpZF0gPSBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IG5ldyBDaGlsZCh0aGlzLm9wdHMubWFpbkZpbGUsIHByb2Nlc3NGaWxlLCB7XG4gICAgICAgICAgICB1c2VXb3JrZXJUaHJlYWRzOiB0aGlzLm9wdHMudXNlV29ya2VyVGhyZWFkcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkLm9uKCdleGl0JywgdGhpcy5yZW1vdmUuYmluZCh0aGlzLCBjaGlsZCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2hpbGQuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdID0gY2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKGNoaWxkKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxlYXNlKGNoaWxkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJldGFpbmVkW2NoaWxkLnBpZF07XG4gICAgICAgIHRoaXMuZ2V0RnJlZShjaGlsZC5wcm9jZXNzRmlsZSkucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJlbW92ZShjaGlsZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdO1xuICAgICAgICBjb25zdCBmcmVlID0gdGhpcy5nZXRGcmVlKGNoaWxkLnByb2Nlc3NGaWxlKTtcbiAgICAgICAgY29uc3QgY2hpbGRJbmRleCA9IGZyZWUuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGZyZWUuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGtpbGwoY2hpbGQsIHNpZ25hbCA9ICdTSUdLSUxMJykge1xuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZC5raWxsKHNpZ25hbCwgQ0hJTERfS0lMTF9USU1FT1VUKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYW4oKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJldGFpbmVkKS5jb25jYXQodGhpcy5nZXRBbGxGcmVlKCkpO1xuICAgICAgICB0aGlzLnJldGFpbmVkID0ge307XG4gICAgICAgIHRoaXMuZnJlZSA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZHJlbi5tYXAoYyA9PiB0aGlzLmtpbGwoYywgJ1NJR1RFUk0nKSkpO1xuICAgIH1cbiAgICBnZXRGcmVlKGlkKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mcmVlW2lkXSA9IHRoaXMuZnJlZVtpZF0gfHwgW10pO1xuICAgIH1cbiAgICBnZXRBbGxGcmVlKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmZyZWUpLnJlZHVjZSgoZmlyc3QsIHNlY29uZCkgPT4gZmlyc3QuY29uY2F0KHNlY29uZCksIFtdKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZC1wb29sLmpzLm1hcCJdLCJuYW1lcyI6WyJwYXRoIiwiQ2hpbGQiLCJDSElMRF9LSUxMX1RJTUVPVVQiLCJDaGlsZFBvb2wiLCJjb25zdHJ1Y3RvciIsIm1haW5GaWxlIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJ1c2VXb3JrZXJUaHJlYWRzIiwicmV0YWluZWQiLCJmcmVlIiwib3B0cyIsInJldGFpbiIsInByb2Nlc3NGaWxlIiwiY2hpbGQiLCJnZXRGcmVlIiwicG9wIiwicGlkIiwib24iLCJyZW1vdmUiLCJiaW5kIiwiaW5pdCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInJlbGVhc2UiLCJwdXNoIiwiY2hpbGRJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJraWxsIiwic2lnbmFsIiwiY2xlYW4iLCJjaGlsZHJlbiIsIk9iamVjdCIsInZhbHVlcyIsImNvbmNhdCIsImdldEFsbEZyZWUiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiYyIsImlkIiwicmVkdWNlIiwiZmlyc3QiLCJzZWNvbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child-processor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildProcessor: () => (/* binding */ ChildProcessor)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n\n\nvar ChildStatus;\n(function(ChildStatus) {\n    ChildStatus[ChildStatus[\"Idle\"] = 0] = \"Idle\";\n    ChildStatus[ChildStatus[\"Started\"] = 1] = \"Started\";\n    ChildStatus[ChildStatus[\"Terminating\"] = 2] = \"Terminating\";\n    ChildStatus[ChildStatus[\"Errored\"] = 3] = \"Errored\";\n})(ChildStatus || (ChildStatus = {}));\n/**\n * ChildProcessor\n *\n * This class acts as the interface between a child process and it parent process\n * so that jobs can be processed in different processes.\n *\n */ class ChildProcessor {\n    constructor(send){\n        this.send = send;\n    }\n    async init(processorFile) {\n        let processor;\n        try {\n            const { default: processorFn } = await __webpack_require__(\"(rsc)/./node_modules/bullmq/dist/esm/classes lazy recursive referencedExports: default\")(processorFile);\n            processor = processorFn;\n            if (processor.default) {\n                // support es2015 module.\n                processor = processor.default;\n            }\n            if (typeof processor !== \"function\") {\n                throw new Error(\"No function is exported in processor file\");\n            }\n        } catch (err) {\n            this.status = ChildStatus.Errored;\n            return this.send({\n                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.InitFailed,\n                err: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(err)\n            });\n        }\n        const origProcessor = processor;\n        processor = function(job, token) {\n            try {\n                return Promise.resolve(origProcessor(job, token));\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        };\n        this.processor = processor;\n        this.status = ChildStatus.Idle;\n        await this.send({\n            cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.InitCompleted\n        });\n    }\n    async start(jobJson, token) {\n        if (this.status !== ChildStatus.Idle) {\n            return this.send({\n                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Error,\n                err: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(new Error(\"cannot start a not idling child process\"))\n            });\n        }\n        this.status = ChildStatus.Started;\n        this.currentJobPromise = (async ()=>{\n            try {\n                const job = this.wrapJob(jobJson, this.send);\n                const result = await this.processor(job, token);\n                await this.send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Completed,\n                    value: typeof result === \"undefined\" ? null : result\n                });\n            } catch (err) {\n                await this.send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Failed,\n                    value: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(!err.message ? new Error(err) : err)\n                });\n            } finally{\n                this.status = ChildStatus.Idle;\n                this.currentJobPromise = undefined;\n            }\n        })();\n    }\n    async stop() {}\n    async waitForCurrentJobAndExit() {\n        this.status = ChildStatus.Terminating;\n        try {\n            await this.currentJobPromise;\n        } finally{\n            process.exit(process.exitCode || 0);\n        }\n    }\n    /**\n     * Enhance the given job argument with some functions\n     * that can be called from the sandboxed job processor.\n     *\n     * Note, the `job` argument is a JSON deserialized message\n     * from the main node process to this forked child process,\n     * the functions on the original job object are not in tact.\n     * The wrapped job adds back some of those original functions.\n     */ wrapJob(job, send) {\n        return Object.assign(Object.assign({}, job), {\n            data: JSON.parse(job.data || \"{}\"),\n            opts: job.opts,\n            returnValue: JSON.parse(job.returnvalue || \"{}\"),\n            /*\n             * Emulate the real job `updateProgress` function, should works as `progress` function.\n             */ async updateProgress (progress) {\n                // Locally store reference to new progress value\n                // so that we can return it from this process synchronously.\n                this.progress = progress;\n                // Send message to update job progress.\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Progress,\n                    value: progress\n                });\n            },\n            /*\n             * Emulate the real job `log` function.\n             */ log: async (row)=>{\n                send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Log,\n                    value: row\n                });\n            },\n            /*\n             * Emulate the real job `moveToDelayed` function.\n             */ moveToDelayed: async (timestamp, token)=>{\n                send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToDelayed,\n                    value: {\n                        timestamp,\n                        token\n                    }\n                });\n            },\n            /*\n             * Emulate the real job `updateData` function.\n             */ updateData: async (data)=>{\n                send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Update,\n                    value: data\n                });\n            }\n        });\n    }\n} //# sourceMappingURL=child-processor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQtcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNGO0FBQ3ZDLElBQUlFO0FBQ0gsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFDQSxXQUFXLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN2Q0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztBQUM5QyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DO0lBQ1RDLFlBQVlDLElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtJQUNoQjtJQUNBLE1BQU1DLEtBQUtDLGFBQWEsRUFBRTtRQUN0QixJQUFJQztRQUNKLElBQUk7WUFDQSxNQUFNLEVBQUVDLFNBQVNDLFdBQVcsRUFBRSxHQUFHLE1BQU0sOEdBQU9ILGFBQWFBLENBQUNBO1lBQzVEQyxZQUFZRTtZQUNaLElBQUlGLFVBQVVDLE9BQU8sRUFBRTtnQkFDbkIseUJBQXlCO2dCQUN6QkQsWUFBWUEsVUFBVUMsT0FBTztZQUNqQztZQUNBLElBQUksT0FBT0QsY0FBYyxZQUFZO2dCQUNqQyxNQUFNLElBQUlHLE1BQU07WUFDcEI7UUFDSixFQUNBLE9BQU9DLEtBQUs7WUFDUixJQUFJLENBQUNDLE1BQU0sR0FBR1gsWUFBWVksT0FBTztZQUNqQyxPQUFPLElBQUksQ0FBQ1QsSUFBSSxDQUFDO2dCQUNiVSxLQUFLZixpREFBYUEsQ0FBQ2dCLFVBQVU7Z0JBQzdCSixLQUFLWCxtREFBV0EsQ0FBQ1c7WUFDckI7UUFDSjtRQUNBLE1BQU1LLGdCQUFnQlQ7UUFDdEJBLFlBQVksU0FBVVUs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Q0FBQzBELGFBQWE7b0JBQ2hDMUIsT0FBTzt3QkFBRXlCO3dCQUFXdEM7b0JBQU07Z0JBQzlCO1lBQ0o7WUFDQTs7YUFFQyxHQUNEd0MsWUFBWSxPQUFPZjtnQkFDZnZDLEtBQUs7b0JBQ0RVLEtBQUtmLGlEQUFhQSxDQUFDNEQsTUFBTTtvQkFDekI1QixPQUFPWTtnQkFDWDtZQUNKO1FBQUU7SUFDVjtBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9jaGlsZC1wcm9jZXNzb3IuanM/ZGI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJlbnRDb21tYW5kIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgZXJyb3JUb0pTT04gfSBmcm9tICcuLi91dGlscyc7XG52YXIgQ2hpbGRTdGF0dXM7XG4oZnVuY3Rpb24gKENoaWxkU3RhdHVzKSB7XG4gICAgQ2hpbGRTdGF0dXNbQ2hpbGRTdGF0dXNbXCJJZGxlXCJdID0gMF0gPSBcIklkbGVcIjtcbiAgICBDaGlsZFN0YXR1c1tDaGlsZFN0YXR1c1tcIlN0YXJ0ZWRcIl0gPSAxXSA9IFwiU3RhcnRlZFwiO1xuICAgIENoaWxkU3RhdHVzW0NoaWxkU3RhdHVzW1wiVGVybWluYXRpbmdcIl0gPSAyXSA9IFwiVGVybWluYXRpbmdcIjtcbiAgICBDaGlsZFN0YXR1c1tDaGlsZFN0YXR1c1tcIkVycm9yZWRcIl0gPSAzXSA9IFwiRXJyb3JlZFwiO1xufSkoQ2hpbGRTdGF0dXMgfHwgKENoaWxkU3RhdHVzID0ge30pKTtcbi8qKlxuICogQ2hpbGRQcm9jZXNzb3JcbiAqXG4gKiBUaGlzIGNsYXNzIGFjdHMgYXMgdGhlIGludGVyZmFjZSBiZXR3ZWVuIGEgY2hpbGQgcHJvY2VzcyBhbmQgaXQgcGFyZW50IHByb2Nlc3NcbiAqIHNvIHRoYXQgam9icyBjYW4gYmUgcHJvY2Vzc2VkIGluIGRpZmZlcmVudCBwcm9jZXNzZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hpbGRQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlbmQpIHtcbiAgICAgICAgdGhpcy5zZW5kID0gc2VuZDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChwcm9jZXNzb3JGaWxlKSB7XG4gICAgICAgIGxldCBwcm9jZXNzb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IHByb2Nlc3NvckZuIH0gPSBhd2FpdCBpbXBvcnQocHJvY2Vzc29yRmlsZSk7XG4gICAgICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3JGbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3IuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgZXMyMDE1IG1vZHVsZS5cbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmdW5jdGlvbiBpcyBleHBvcnRlZCBpbiBwcm9jZXNzb3IgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQ2hpbGRTdGF0dXMuRXJyb3JlZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5Jbml0RmFpbGVkLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JUb0pTT04oZXJyKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdQcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHByb2Nlc3NvciA9IGZ1bmN0aW9uIChqb2IsIHRva2VuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3JpZ1Byb2Nlc3Nvcihqb2IsIHRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLklkbGU7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuSW5pdENvbXBsZXRlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KGpvYkpzb24sIHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hpbGRTdGF0dXMuSWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLkVycm9yLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JUb0pTT04obmV3IEVycm9yKCdjYW5ub3Qgc3RhcnQgYSBub3QgaWRsaW5nIGNoaWxkIHByb2Nlc3MnKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLlN0YXJ0ZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudEpvYlByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLndyYXBKb2Ioam9iSnNvbiwgdGhpcy5zZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3Nvcihqb2IsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuQ29tcGxldGVkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJvclRvSlNPTighZXJyLm1lc3NhZ2UgPyBuZXcgRXJyb3IoZXJyKSA6IGVyciksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLklkbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Sm9iUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHsgfVxuICAgIGFzeW5jIHdhaXRGb3JDdXJyZW50Sm9iQW5kRXhpdCgpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDaGlsZFN0YXR1cy5UZXJtaW5hdGluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudEpvYlByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQocHJvY2Vzcy5leGl0Q29kZSB8fCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHRoZSBnaXZlbiBqb2IgYXJndW1lbnQgd2l0aCBzb21lIGZ1bmN0aW9uc1xuICAgICAqIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzYW5kYm94ZWQgam9iIHByb2Nlc3Nvci5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBgam9iYCBhcmd1bWVudCBpcyBhIEpTT04gZGVzZXJpYWxpemVkIG1lc3NhZ2VcbiAgICAgKiBmcm9tIHRoZSBtYWluIG5vZGUgcHJvY2VzcyB0byB0aGlzIGZvcmtlZCBjaGlsZCBwcm9jZXNzLFxuICAgICAqIHRoZSBmdW5jdGlvbnMgb24gdGhlIG9yaWdpbmFsIGpvYiBvYmplY3QgYXJlIG5vdCBpbiB0YWN0LlxuICAgICAqIFRoZSB3cmFwcGVkIGpvYiBhZGRzIGJhY2sgc29tZSBvZiB0aG9zZSBvcmlnaW5hbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgd3JhcEpvYihqb2IsIHNlbmQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgam9iKSwgeyBkYXRhOiBKU09OLnBhcnNlKGpvYi5kYXRhIHx8ICd7fScpLCBvcHRzOiBqb2Iub3B0cywgcmV0dXJuVmFsdWU6IEpTT04ucGFyc2Uoam9iLnJldHVybnZhbHVlIHx8ICd7fScpLCBcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBFbXVsYXRlIHRoZSByZWFsIGpvYiBgdXBkYXRlUHJvZ3Jlc3NgIGZ1bmN0aW9uLCBzaG91bGQgd29ya3MgYXMgYHByb2dyZXNzYCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXN5bmMgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2NhbGx5IHN0b3JlIHJlZmVyZW5jZSB0byBuZXcgcHJvZ3Jlc3MgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiByZXR1cm4gaXQgZnJvbSB0aGlzIHByb2Nlc3Mgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBtZXNzYWdlIHRvIHVwZGF0ZSBqb2IgcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRW11bGF0ZSB0aGUgcmVhbCBqb2IgYGxvZ2AgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxvZzogYXN5bmMgKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuTG9nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcm93LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRW11bGF0ZSB0aGUgcmVhbCBqb2IgYG1vdmVUb0RlbGF5ZWRgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtb3ZlVG9EZWxheWVkOiBhc3luYyAodGltZXN0YW1wLCB0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuTW92ZVRvRGVsYXllZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgdGltZXN0YW1wLCB0b2tlbiB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRW11bGF0ZSB0aGUgcmVhbCBqb2IgYHVwZGF0ZURhdGFgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGVEYXRhOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGQtcHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6WyJQYXJlbnRDb21tYW5kIiwiZXJyb3JUb0pTT04iLCJDaGlsZFN0YXR1cyIsIkNoaWxkUHJvY2Vzc29yIiwiY29uc3RydWN0b3IiLCJzZW5kIiwiaW5pdCIsInByb2Nlc3NvckZpbGUiLCJwcm9jZXNzb3IiLCJkZWZhdWx0IiwicHJvY2Vzc29yRm4iLCJFcnJvciIsImVyciIsInN0YXR1cyIsIkVycm9yZWQiLCJjbWQiLCJJbml0RmFpbGVkIiwib3JpZ1Byb2Nlc3NvciIsImpvYiIsInRva2VuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJJZGxlIiwiSW5pdENvbXBsZXRlZCIsInN0YXJ0Iiwiam9iSnNvbiIsIlN0YXJ0ZWQiLCJjdXJyZW50Sm9iUHJvbWlzZSIsIndyYXBKb2IiLCJyZXN1bHQiLCJDb21wbGV0ZWQiLCJ2YWx1ZSIsIkZhaWxlZCIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJzdG9wIiwid2FpdEZvckN1cnJlbnRKb2JBbmRFeGl0IiwiVGVybWluYXRpbmciLCJwcm9jZXNzIiwiZXhpdCIsImV4aXRDb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsIm9wdHMiLCJyZXR1cm5WYWx1ZSIsInJldHVybnZhbHVlIiwidXBkYXRlUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsIlByb2dyZXNzIiwibG9nIiwicm93IiwiTG9nIiwibW92ZVRvRGVsYXllZCIsInRpbWVzdGFtcCIsIk1vdmVUb0RlbGF5ZWQiLCJ1cGRhdGVEYXRhIiwiVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Child: () => (/* binding */ Child)\n/* harmony export */ });\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var worker_threads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n/* harmony import */ var worker_threads__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(worker_threads__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(net__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n/**\n * @see https://nodejs.org/api/process.html#process_exit_codes\n */ const exitCodesErrors = {\n    1: \"Uncaught Fatal Exception\",\n    2: \"Unused\",\n    3: \"Internal JavaScript Parse Error\",\n    4: \"Internal JavaScript Evaluation Failure\",\n    5: \"Fatal Error\",\n    6: \"Non-function Internal Exception Handler\",\n    7: \"Internal Exception Handler Run-Time Failure\",\n    8: \"Unused\",\n    9: \"Invalid Argument\",\n    10: \"Internal JavaScript Run-Time Failure\",\n    12: \"Invalid Debug Argument\",\n    13: \"Unfinished Top-Level Await\"\n};\n/**\n * Child class\n *\n * This class is used to create a child process or worker thread, and allows using\n * isolated processes or threads for processing jobs.\n *\n */ class Child extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n    constructor(mainFile, processFile, opts = {\n        useWorkerThreads: false\n    }){\n        super();\n        this.mainFile = mainFile;\n        this.processFile = processFile;\n        this.opts = opts;\n        this._exitCode = null;\n        this._signalCode = null;\n        this._killed = false;\n    }\n    get pid() {\n        if (this.childProcess) {\n            return this.childProcess.pid;\n        } else if (this.worker) {\n            return this.worker.threadId;\n        } else {\n            throw new Error(\"No child process or worker thread\");\n        }\n    }\n    get exitCode() {\n        return this._exitCode;\n    }\n    get signalCode() {\n        return this._signalCode;\n    }\n    get killed() {\n        if (this.childProcess) {\n            return this.childProcess.killed;\n        }\n        return this._killed;\n    }\n    async init() {\n        const execArgv = await convertExecArgv(process.execArgv);\n        let parent;\n        if (this.opts.useWorkerThreads) {\n            this.worker = parent = new worker_threads__WEBPACK_IMPORTED_MODULE_1__.Worker(this.mainFile, {\n                execArgv,\n                stdin: true,\n                stdout: true,\n                stderr: true\n            });\n        } else {\n            this.childProcess = parent = (0,child_process__WEBPACK_IMPORTED_MODULE_0__.fork)(this.mainFile, [], {\n                execArgv,\n                stdio: \"pipe\"\n            });\n        }\n        parent.on(\"exit\", (exitCode, signalCode)=>{\n            this._exitCode = exitCode;\n            // Coerce to null if undefined for backwards compatibility\n            signalCode = typeof signalCode === \"undefined\" ? null : signalCode;\n            this._signalCode = signalCode;\n            this._killed = true;\n            this.emit(\"exit\", exitCode, signalCode);\n            // Clean all listeners, we do not expect any more events after \"exit\"\n            parent.removeAllListeners();\n            this.removeAllListeners();\n        });\n        parent.on(\"error\", (...args)=>this.emit(\"error\", ...args));\n        parent.on(\"message\", (...args)=>this.emit(\"message\", ...args));\n        parent.on(\"close\", (...args)=>this.emit(\"close\", ...args));\n        parent.stdout.pipe(process.stdout);\n        parent.stderr.pipe(process.stderr);\n        await this.initChild();\n    }\n    async send(msg) {\n        return new Promise((resolve, reject)=>{\n            if (this.childProcess) {\n                this.childProcess.send(msg, (err)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            } else if (this.worker) {\n                resolve(this.worker.postMessage(msg));\n            } else {\n                resolve();\n            }\n        });\n    }\n    killProcess(signal = \"SIGKILL\") {\n        if (this.childProcess) {\n            this.childProcess.kill(signal);\n        } else if (this.worker) {\n            this.worker.terminate();\n        }\n    }\n    async kill(signal = \"SIGKILL\", timeoutMs) {\n        if (this.hasProcessExited()) {\n            return;\n        }\n        const onExit = onExitOnce(this.childProcess || this.worker);\n        this.killProcess(signal);\n        if (timeoutMs !== undefined && (timeoutMs === 0 || isFinite(timeoutMs))) {\n            const timeoutHandle = setTimeout(()=>{\n                if (!this.hasProcessExited()) {\n                    this.killProcess(\"SIGKILL\");\n                }\n            }, timeoutMs);\n            await onExit;\n            clearTimeout(timeoutHandle);\n        }\n        await onExit;\n    }\n    async initChild() {\n        const onComplete = new Promise((resolve, reject)=>{\n            const onMessageHandler = (msg)=>{\n                if (msg.cmd === _enums__WEBPACK_IMPORTED_MODULE_3__.ParentCommand.InitCompleted) {\n                    resolve();\n                } else if (msg.cmd === _enums__WEBPACK_IMPORTED_MODULE_3__.ParentCommand.InitFailed) {\n                    const err = new Error();\n                    err.stack = msg.err.stack;\n                    err.message = msg.err.message;\n                    reject(err);\n                }\n                this.off(\"message\", onMessageHandler);\n                this.off(\"close\", onCloseHandler);\n            };\n            const onCloseHandler = (code, signal)=>{\n                if (code > 128) {\n                    code -= 128;\n                }\n                const msg = exitCodesErrors[code] || `Unknown exit code ${code}`;\n                reject(new Error(`Error initializing child: ${msg} and signal ${signal}`));\n                this.off(\"message\", onMessageHandler);\n                this.off(\"close\", onCloseHandler);\n            };\n            this.on(\"message\", onMessageHandler);\n            this.on(\"close\", onCloseHandler);\n        });\n        await this.send({\n            cmd: _enums__WEBPACK_IMPORTED_MODULE_3__.ChildCommand.Init,\n            value: this.processFile\n        });\n        await onComplete;\n    }\n    hasProcessExited() {\n        return !!(this.exitCode !== null || this.signalCode);\n    }\n}\nfunction onExitOnce(child) {\n    return new Promise((resolve)=>{\n        child.once(\"exit\", ()=>resolve());\n    });\n}\nconst getFreePort = async ()=>{\n    return new Promise((resolve)=>{\n        const server = (0,net__WEBPACK_IMPORTED_MODULE_2__.createServer)();\n        server.listen(0, ()=>{\n            const { port } = server.address();\n            server.close(()=>resolve(port));\n        });\n    });\n};\nconst convertExecArgv = async (execArgv)=>{\n    const standard = [];\n    const convertedArgs = [];\n    for(let i = 0; i < execArgv.length; i++){\n        const arg = execArgv[i];\n        if (arg.indexOf(\"--inspect\") === -1) {\n            standard.push(arg);\n        } else {\n            const argName = arg.split(\"=\")[0];\n            const port = await getFreePort();\n            convertedArgs.push(`${argName}=${port}`);\n        }\n    }\n    return standard.concat(convertedArgs);\n}; //# sourceMappingURL=child.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNHO0FBQ0w7QUFDb0I7QUFDakI7QUFDdEM7O0NBRUMsR0FDRCxNQUFNTSxrQkFBa0I7SUFDcEIsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0FBQ1I7QUFDQTs7Ozs7O0NBTUMsR0FDTSxNQUFNQyxjQUFjRixnREFBWUE7SUFDbkNHLFlBQVlDLFFBQVEsRUFBRUMsV0FBVyxFQUFFQyxPQUFPO1FBQ3RDQyxrQkFBa0I7SUFDdEIsQ0FBQyxDQUFFO1FBQ0MsS0FBSztRQUNMLElBQUksQ0FBQ0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDbkI7SUFDQSxJQUFJQyxNQUFNO1FBQ04sSUFBSSxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUNuQixPQUFPLElBQUksQ0FBQ0EsWUFBWSxDQUFDRCxHQUFHO1FBQ2hDLE9BQ0ssSUFBSSxJQUFJLENBQUNFLE1BQU0sRUFBRTtZQUNsQixPQUFPLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxRQUFRO1FBQy9CLE9BQ0s7WUFDRCxNQUFNLElBQUlDLE1BQU07UUFDcEI7SUFDSjtJQUNBLElBQUlDLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ1IsU0FBUztJQUN6QjtJQUNBLElBQUlTLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ1IsV0FBVztJQUMzQjtJQUNBLElBQUlTLFNBQVM7UUFDVCxJQUFJLElB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QUFFQyxRQUFRLENBQUMsRUFBRVYsS0FBSyxDQUFDO1FBQzNDO0lBQ0o7SUFDQSxPQUFPRyxTQUFTUyxNQUFNLENBQUNSO0FBQzNCLEdBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9jaGlsZC5qcz8wMGNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcmsgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IFdvcmtlciB9IGZyb20gJ3dvcmtlcl90aHJlYWRzJztcbmltcG9ydCB7IGNyZWF0ZVNlcnZlciB9IGZyb20gJ25ldCc7XG5pbXBvcnQgeyBDaGlsZENvbW1hbmQsIFBhcmVudENvbW1hbmQgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfZXhpdF9jb2Rlc1xuICovXG5jb25zdCBleGl0Q29kZXNFcnJvcnMgPSB7XG4gICAgMTogJ1VuY2F1Z2h0IEZhdGFsIEV4Y2VwdGlvbicsXG4gICAgMjogJ1VudXNlZCcsXG4gICAgMzogJ0ludGVybmFsIEphdmFTY3JpcHQgUGFyc2UgRXJyb3InLFxuICAgIDQ6ICdJbnRlcm5hbCBKYXZhU2NyaXB0IEV2YWx1YXRpb24gRmFpbHVyZScsXG4gICAgNTogJ0ZhdGFsIEVycm9yJyxcbiAgICA2OiAnTm9uLWZ1bmN0aW9uIEludGVybmFsIEV4Y2VwdGlvbiBIYW5kbGVyJyxcbiAgICA3OiAnSW50ZXJuYWwgRXhjZXB0aW9uIEhhbmRsZXIgUnVuLVRpbWUgRmFpbHVyZScsXG4gICAgODogJ1VudXNlZCcsXG4gICAgOTogJ0ludmFsaWQgQXJndW1lbnQnLFxuICAgIDEwOiAnSW50ZXJuYWwgSmF2YVNjcmlwdCBSdW4tVGltZSBGYWlsdXJlJyxcbiAgICAxMjogJ0ludmFsaWQgRGVidWcgQXJndW1lbnQnLFxuICAgIDEzOiAnVW5maW5pc2hlZCBUb3AtTGV2ZWwgQXdhaXQnLFxufTtcbi8qKlxuICogQ2hpbGQgY2xhc3NcbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGEgY2hpbGQgcHJvY2VzcyBvciB3b3JrZXIgdGhyZWFkLCBhbmQgYWxsb3dzIHVzaW5nXG4gKiBpc29sYXRlZCBwcm9jZXNzZXMgb3IgdGhyZWFkcyBmb3IgcHJvY2Vzc2luZyBqb2JzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENoaWxkIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluRmlsZSwgcHJvY2Vzc0ZpbGUsIG9wdHMgPSB7XG4gICAgICAgIHVzZVdvcmtlclRocmVhZHM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYWluRmlsZSA9IG1haW5GaWxlO1xuICAgICAgICB0aGlzLnByb2Nlc3NGaWxlID0gcHJvY2Vzc0ZpbGU7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuX2V4aXRDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2lnbmFsQ29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2tpbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcGlkKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZFByb2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkUHJvY2Vzcy5waWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndvcmtlci50aHJlYWRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2hpbGQgcHJvY2VzcyBvciB3b3JrZXIgdGhyZWFkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV4aXRDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhpdENvZGU7XG4gICAgfVxuICAgIGdldCBzaWduYWxDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsQ29kZTtcbiAgICB9XG4gICAgZ2V0IGtpbGxlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFByb2Nlc3Mua2lsbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9raWxsZWQ7XG4gICAgfVxuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGV4ZWNBcmd2ID0gYXdhaXQgY29udmVydEV4ZWNBcmd2KHByb2Nlc3MuZXhlY0FyZ3YpO1xuICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5vcHRzLnVzZVdvcmtlclRocmVhZHMpIHtcbiAgICAgICAgICAgIHRoaXMud29ya2VyID0gcGFyZW50ID0gbmV3IFdvcmtlcih0aGlzLm1haW5GaWxlLCB7XG4gICAgICAgICAgICAgICAgZXhlY0FyZ3YsXG4gICAgICAgICAgICAgICAgc3RkaW46IHRydWUsXG4gICAgICAgICAgICAgICAgc3Rkb3V0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0ZGVycjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFByb2Nlc3MgPSBwYXJlbnQgPSBmb3JrKHRoaXMubWFpbkZpbGUsIFtdLCB7XG4gICAgICAgICAgICAgICAgZXhlY0FyZ3YsXG4gICAgICAgICAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5vbignZXhpdCcsIChleGl0Q29kZSwgc2lnbmFsQ29kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXhpdENvZGUgPSBleGl0Q29kZTtcbiAgICAgICAgICAgIC8vIENvZXJjZSB0byBudWxsIGlmIHVuZGVmaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIHNpZ25hbENvZGUgPSB0eXBlb2Ygc2lnbmFsQ29kZSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogc2lnbmFsQ29kZTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbENvZGUgPSBzaWduYWxDb2RlO1xuICAgICAgICAgICAgdGhpcy5fa2lsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXhpdCcsIGV4aXRDb2RlLCBzaWduYWxDb2RlKTtcbiAgICAgICAgICAgIC8vIENsZWFuIGFsbCBsaXN0ZW5lcnMsIHdlIGRvIG5vdCBleHBlY3QgYW55IG1vcmUgZXZlbnRzIGFmdGVyIFwiZXhpdFwiXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50Lm9uKCdlcnJvcicsICguLi5hcmdzKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgLi4uYXJncykpO1xuICAgICAgICBwYXJlbnQub24oJ21lc3NhZ2UnLCAoLi4uYXJncykgPT4gdGhpcy5lbWl0KCdtZXNzYWdlJywgLi4uYXJncykpO1xuICAgICAgICBwYXJlbnQub24oJ2Nsb3NlJywgKC4uLmFyZ3MpID0+IHRoaXMuZW1pdCgnY2xvc2UnLCAuLi5hcmdzKSk7XG4gICAgICAgIHBhcmVudC5zdGRvdXQucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgICAgIHBhcmVudC5zdGRlcnIucGlwZShwcm9jZXNzLnN0ZGVycik7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdENoaWxkKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobXNnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZFByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkUHJvY2Vzcy5zZW5kKG1zZywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2lsbFByb2Nlc3Moc2lnbmFsID0gJ1NJR0tJTEwnKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkUHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFByb2Nlc3Mua2lsbChzaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBraWxsKHNpZ25hbCA9ICdTSUdLSUxMJywgdGltZW91dE1zKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1Byb2Nlc3NFeGl0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRXhpdCA9IG9uRXhpdE9uY2UodGhpcy5jaGlsZFByb2Nlc3MgfHwgdGhpcy53b3JrZXIpO1xuICAgICAgICB0aGlzLmtpbGxQcm9jZXNzKHNpZ25hbCk7XG4gICAgICAgIGlmICh0aW1lb3V0TXMgIT09IHVuZGVmaW5lZCAmJiAodGltZW91dE1zID09PSAwIHx8IGlzRmluaXRlKHRpbWVvdXRNcykpKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1Byb2Nlc3NFeGl0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbGxQcm9jZXNzKCdTSUdLSUxMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dE1zKTtcbiAgICAgICAgICAgIGF3YWl0IG9uRXhpdDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBvbkV4aXQ7XG4gICAgfVxuICAgIGFzeW5jIGluaXRDaGlsZCgpIHtcbiAgICAgICAgY29uc3Qgb25Db21wbGV0ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uTWVzc2FnZUhhbmRsZXIgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5jbWQgPT09IFBhcmVudENvbW1hbmQuSW5pdENvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5jbWQgPT09IFBhcmVudENvbW1hbmQuSW5pdEZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gbXNnLmVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtc2cuZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9mZignbWVzc2FnZScsIG9uTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdjbG9zZScsIG9uQ2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbkNsb3NlSGFuZGxlciA9IChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA+IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlIC09IDEyODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gZXhpdENvZGVzRXJyb3JzW2NvZGVdIHx8IGBVbmtub3duIGV4aXQgY29kZSAke2NvZGV9YDtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBFcnJvciBpbml0aWFsaXppbmcgY2hpbGQ6ICR7bXNnfSBhbmQgc2lnbmFsICR7c2lnbmFsfWApKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignbWVzc2FnZScsIG9uTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdjbG9zZScsIG9uQ2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uKCdtZXNzYWdlJywgb25NZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLm9uKCdjbG9zZScsIG9uQ2xvc2VIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBjbWQ6IENoaWxkQ29tbWFuZC5Jbml0LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucHJvY2Vzc0ZpbGUsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBvbkNvbXBsZXRlO1xuICAgIH1cbiAgICBoYXNQcm9jZXNzRXhpdGVkKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5leGl0Q29kZSAhPT0gbnVsbCB8fCB0aGlzLnNpZ25hbENvZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9uRXhpdE9uY2UoY2hpbGQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNoaWxkLm9uY2UoJ2V4aXQnLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgIH0pO1xufVxuY29uc3QgZ2V0RnJlZVBvcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBjcmVhdGVTZXJ2ZXIoKTtcbiAgICAgICAgc2VydmVyLmxpc3RlbigwLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBvcnQgfSA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4gcmVzb2x2ZShwb3J0KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IGNvbnZlcnRFeGVjQXJndiA9IGFzeW5jIChleGVjQXJndikgPT4ge1xuICAgIGNvbnN0IHN0YW5kYXJkID0gW107XG4gICAgY29uc3QgY29udmVydGVkQXJncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhlY0FyZ3YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJnID0gZXhlY0FyZ3ZbaV07XG4gICAgICAgIGlmIChhcmcuaW5kZXhPZignLS1pbnNwZWN0JykgPT09IC0xKSB7XG4gICAgICAgICAgICBzdGFuZGFyZC5wdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcmdOYW1lID0gYXJnLnNwbGl0KCc9JylbMF07XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgZ2V0RnJlZVBvcnQoKTtcbiAgICAgICAgICAgIGNvbnZlcnRlZEFyZ3MucHVzaChgJHthcmdOYW1lfT0ke3BvcnR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YW5kYXJkLmNvbmNhdChjb252ZXJ0ZWRBcmdzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZC5qcy5tYXAiXSwibmFtZXMiOlsiZm9yayIsIldvcmtlciIsImNyZWF0ZVNlcnZlciIsIkNoaWxkQ29tbWFuZCIsIlBhcmVudENvbW1hbmQiLCJFdmVudEVtaXR0ZXIiLCJleGl0Q29kZXNFcnJvcnMiLCJDaGlsZCIsImNvbnN0cnVjdG9yIiwibWFpbkZpbGUiLCJwcm9jZXNzRmlsZSIsIm9wdHMiLCJ1c2VXb3JrZXJUaHJlYWRzIiwiX2V4aXRDb2RlIiwiX3NpZ25hbENvZGUiLCJfa2lsbGVkIiwicGlkIiwiY2hpbGRQcm9jZXNzIiwid29ya2VyIiwidGhyZWFkSWQiLCJFcnJvciIsImV4aXRDb2RlIiwic2lnbmFsQ29kZSIsImtpbGxlZCIsImluaXQiLCJleGVjQXJndiIsImNvbnZlcnRFeGVjQXJndiIsInByb2Nlc3MiLCJwYXJlbnQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsInN0ZGlvIiwib24iLCJlbWl0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYXJncyIsInBpcGUiLCJpbml0Q2hpbGQiLCJzZW5kIiwibXNnIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnIiLCJwb3N0TWVzc2FnZSIsImtpbGxQcm9jZXNzIiwic2lnbmFsIiwia2lsbCIsInRlcm1pbmF0ZSIsInRpbWVvdXRNcyIsImhhc1Byb2Nlc3NFeGl0ZWQiLCJvbkV4aXQiLCJvbkV4aXRPbmNlIiwidW5kZWZpbmVkIiwiaXNGaW5pdGUiLCJ0aW1lb3V0SGFuZGxlIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIm9uQ29tcGxldGUiLCJvbk1lc3NhZ2VIYW5kbGVyIiwiY21kIiwiSW5pdENvbXBsZXRlZCIsIkluaXRGYWlsZWQiLCJzdGFjayIsIm1lc3NhZ2UiLCJvZmYiLCJvbkNsb3NlSGFuZGxlciIsImNvZGUiLCJJbml0IiwidmFsdWUiLCJjaGlsZCIsIm9uY2UiLCJnZXRGcmVlUG9ydCIsInNlcnZlciIsImxpc3RlbiIsInBvcnQiLCJhZGRyZXNzIiwiY2xvc2UiLCJzdGFuZGFyZCIsImNvbnZlcnRlZEFyZ3MiLCJpIiwibGVuZ3RoIiwiYXJnIiwiaW5kZXhPZiIsInB1c2giLCJhcmdOYW1lIiwic3BsaXQiLCJjb25jYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DelayedError: () => (/* binding */ DelayedError)\n/* harmony export */ });\n/**\n * DelayedError\n *\n * Error to be thrown when job is moved to delayed state\n * from job in active state.\n *\n */ class DelayedError extends Error {\n    constructor(message){\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n} //# sourceMappingURL=delayed-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL2RlbGF5ZWQtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLHFCQUFxQkM7SUFDOUJDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUNFLElBQUk7UUFDakNDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9lcnJvcnMvZGVsYXllZC1lcnJvci5qcz82ZjMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVsYXllZEVycm9yXG4gKlxuICogRXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gam9iIGlzIG1vdmVkIHRvIGRlbGF5ZWQgc3RhdGVcbiAqIGZyb20gam9iIGluIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWxheWVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5ZWQtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIkRlbGF5ZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DelayedError: () => (/* reexport safe */ _delayed_error__WEBPACK_IMPORTED_MODULE_0__.DelayedError),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _rate_limit_error__WEBPACK_IMPORTED_MODULE_2__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _rate_limit_error__WEBPACK_IMPORTED_MODULE_2__.RateLimitError),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _unrecoverable_error__WEBPACK_IMPORTED_MODULE_1__.UnrecoverableError),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _waiting_children_error__WEBPACK_IMPORTED_MODULE_3__.WaitingChildrenError)\n/* harmony export */ });\n/* harmony import */ var _delayed_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./delayed-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js\");\n/* harmony import */ var _unrecoverable_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unrecoverable-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\");\n/* harmony import */ var _rate_limit_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rate-limit-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js\");\n/* harmony import */ var _waiting_children_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./waiting-children-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnQztBQUNNO0FBQ0g7QUFDTSxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2Vycm9ycy9pbmRleC5qcz8zNDVhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZGVsYXllZC1lcnJvcic7XG5leHBvcnQgKiBmcm9tICcuL3VucmVjb3ZlcmFibGUtZXJyb3InO1xuZXhwb3J0ICogZnJvbSAnLi9yYXRlLWxpbWl0LWVycm9yJztcbmV4cG9ydCAqIGZyb20gJy4vd2FpdGluZy1jaGlsZHJlbi1lcnJvcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* binding */ RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError)\n/* harmony export */ });\nconst RATE_LIMIT_ERROR = \"bullmq:rateLimitExceeded\";\n/**\n * RateLimitError\n *\n * Error to be thrown when queue reaches a rate limit.\n *\n */ class RateLimitError extends Error {\n    constructor(message = RATE_LIMIT_ERROR){\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n} //# sourceMappingURL=rate-limit-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3JhdGUtbGltaXQtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxtQkFBbUIsMkJBQTJCO0FBQzNEOzs7OztDQUtDLEdBQ00sTUFBTUMsdUJBQXVCQztJQUNoQ0MsWUFBWUMsVUFBVUosZ0JBQWdCLENBQUU7UUFDcEMsS0FBSyxDQUFDSTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0YsV0FBVyxDQUFDRSxJQUFJO1FBQ2pDQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVdDLFNBQVM7SUFDcEQ7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3JhdGUtbGltaXQtZXJyb3IuanM/NzJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUkFURV9MSU1JVF9FUlJPUiA9ICdidWxsbXE6cmF0ZUxpbWl0RXhjZWVkZWQnO1xuLyoqXG4gKiBSYXRlTGltaXRFcnJvclxuICpcbiAqIEVycm9yIHRvIGJlIHRocm93biB3aGVuIHF1ZXVlIHJlYWNoZXMgYSByYXRlIGxpbWl0LlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBSQVRFX0xJTUlUX0VSUk9SKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0ZS1saW1pdC1lcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiUkFURV9MSU1JVF9FUlJPUiIsIlJhdGVMaW1pdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnrecoverableError: () => (/* binding */ UnrecoverableError)\n/* harmony export */ });\n/**\n * UnrecoverableError\n *\n * Error to move a job to failed even if the attemptsMade\n * are lower than the expected limit.\n *\n */ class UnrecoverableError extends Error {\n    constructor(message){\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n} //# sourceMappingURL=unrecoverable-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3VucmVjb3ZlcmFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLDJCQUEyQkM7SUFDcENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUNFLElBQUk7UUFDakNDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9lcnJvcnMvdW5yZWNvdmVyYWJsZS1lcnJvci5qcz84ODVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW5yZWNvdmVyYWJsZUVycm9yXG4gKlxuICogRXJyb3IgdG8gbW92ZSBhIGpvYiB0byBmYWlsZWQgZXZlbiBpZiB0aGUgYXR0ZW1wdHNNYWRlXG4gKiBhcmUgbG93ZXIgdGhhbiB0aGUgZXhwZWN0ZWQgbGltaXQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgVW5yZWNvdmVyYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnJlY292ZXJhYmxlLWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJVbnJlY292ZXJhYmxlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaitingChildrenError: () => (/* binding */ WaitingChildrenError)\n/* harmony export */ });\n/**\n * WaitingChildrenError\n *\n * Error to be thrown when job is moved to waiting-children state\n * from job in active state.\n *\n */ class WaitingChildrenError extends Error {\n    constructor(message){\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n} //# sourceMappingURL=waiting-children-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3dhaXRpbmctY2hpbGRyZW4tZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLDZCQUE2QkM7SUFDdENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUNFLElBQUk7UUFDakNDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKLEVBQ0Esa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9lcnJvcnMvd2FpdGluZy1jaGlsZHJlbi1lcnJvci5qcz8yZmI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2FpdGluZ0NoaWxkcmVuRXJyb3JcbiAqXG4gKiBFcnJvciB0byBiZSB0aHJvd24gd2hlbiBqb2IgaXMgbW92ZWQgdG8gd2FpdGluZy1jaGlsZHJlbiBzdGF0ZVxuICogZnJvbSBqb2IgaW4gYWN0aXZlIHN0YXRlLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFdhaXRpbmdDaGlsZHJlbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWl0aW5nLWNoaWxkcmVuLWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJXYWl0aW5nQ2hpbGRyZW5FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/flow-producer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowProducer: () => (/* binding */ FlowProducer)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/get */ \"lodash/get\");\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n\n\n\n\n\n\n\n/**\n * This class allows to add jobs with dependencies between them in such\n * a way that it is possible to build complex flows.\n * Note: A flow is a tree-like structure of jobs that depend on each other.\n * Whenever the children of a given parent are completed, the parent\n * will be processed, being able to access the children's result data.\n * All Jobs can be in different queues, either children or parents,\n */ class FlowProducer extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(opts = {\n        connection: {}\n    }, Connection = _redis_connection__WEBPACK_IMPORTED_MODULE_5__.RedisConnection){\n        super();\n        this.opts = opts;\n        this.opts = Object.assign({\n            prefix: \"bull\"\n        }, opts);\n        this.connection = new Connection(opts.connection, (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isRedisInstance)(opts.connection), false, opts.skipVersionCheck);\n        this.connection.on(\"error\", (error)=>this.emit(\"error\", error));\n        this.connection.on(\"close\", ()=>{\n            if (!this.closing) {\n                this.emit(\"ioredis:close\");\n            }\n        });\n        this.queueKeys = new _queue_keys__WEBPACK_IMPORTED_MODULE_4__.QueueKeys(opts.prefix);\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Returns a promise that resolves to a redis client. Normally used only by subclasses.\n     */ get client() {\n        return this.connection.client;\n    }\n    /**\n     * Helper to easily extend Job class calls.\n     */ get Job() {\n        return _job__WEBPACK_IMPORTED_MODULE_3__.Job;\n    }\n    waitUntilReady() {\n        return this.client;\n    }\n    /**\n     * Adds a flow.\n     *\n     * This call would be atomic, either it fails and no jobs will\n     * be added to the queues, or it succeeds and all jobs will be added.\n     *\n     * @param flow - an object with a tree-like structure where children jobs\n     * will be processed before their parents.\n     * @param opts - options that will be applied to the flow object.\n     */ async add(flow, opts) {\n        var _a;\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const multi = client.multi();\n        const parentOpts = (_a = flow === null || flow === void 0 ? void 0 : flow.opts) === null || _a === void 0 ? void 0 : _a.parent;\n        const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(parentOpts);\n        const parentDependenciesKey = parentKey ? `${parentKey}:dependencies` : undefined;\n        const jobsTree = this.addNode({\n            multi,\n            node: flow,\n            queuesOpts: opts === null || opts === void 0 ? void 0 : opts.queuesOptions,\n            parent: {\n                parentOpts,\n                parentDependenciesKey\n            }\n        });\n        await multi.exec();\n        return jobsTree;\n    }\n    /**\n     * Get a flow.\n     *\n     * @param opts - an object with options for getting a JobNode.\n     */ async getFlow(opts) {\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const updatedOpts = Object.assign({\n            depth: 10,\n            maxChildren: 20\n        }, opts);\n        const jobsTree = this.getNode(client, updatedOpts);\n        return jobsTree;\n    }\n    /**\n     * Adds multiple flows.\n     *\n     * A flow is a tree-like structure of jobs that depend on each other.\n     * Whenever the children of a given parent are completed, the parent\n     * will be processed, being able to access the children's result data.\n     *\n     * All Jobs can be in different queues, either children or parents,\n     * however this call would be atomic, either it fails and no jobs will\n     * be added to the queues, or it succeeds and all jobs will be added.\n     *\n     * @param flows - an array of objects with a tree-like structure where children jobs\n     * will be processed before their parents.\n     */ async addBulk(flows) {\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const multi = client.multi();\n        const jobsTrees = this.addNodes(multi, flows);\n        await multi.exec();\n        return jobsTrees;\n    }\n    /**\n     * Add a node (job) of a flow to the queue. This method will recursively\n     * add all its children as well. Note that a given job can potentially be\n     * a parent and a child job at the same time depending on where it is located\n     * in the tree hierarchy.\n     *\n     * @param multi - ioredis ChainableCommander\n     * @param node - the node representing a job to be added to some queue\n     * @param parent - parent data sent to children to create the \"links\" to their parent\n     * @returns\n     */ addNode({ multi, node, parent, queuesOpts }) {\n        var _a;\n        const prefix = node.prefix || this.opts.prefix;\n        const queue = this.queueFromNode(node, new _queue_keys__WEBPACK_IMPORTED_MODULE_4__.QueueKeys(prefix), prefix);\n        const queueOpts = queuesOpts && queuesOpts[node.queueName];\n        const jobsOpts = lodash_get__WEBPACK_IMPORTED_MODULE_1___default()(queueOpts, \"defaultJobOptions\");\n        const jobId = ((_a = node.opts) === null || _a === void 0 ? void 0 : _a.jobId) || (0,uuid__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n        const job = new this.Job(queue, node.name, node.data, Object.assign(Object.assign(Object.assign({}, jobsOpts ? jobsOpts : {}), node.opts), {\n            parent: parent === null || parent === void 0 ? void 0 : parent.parentOpts\n        }), jobId);\n        const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(parent === null || parent === void 0 ? void 0 : parent.parentOpts);\n        if (node.children && node.children.length > 0) {\n            // Create parent job, will be a job in status \"waiting-children\".\n            const parentId = jobId;\n            const queueKeysParent = new _queue_keys__WEBPACK_IMPORTED_MODULE_4__.QueueKeys(node.prefix || this.opts.prefix);\n            const waitChildrenKey = queueKeysParent.toKey(node.queueName, \"waiting-children\");\n            job.addJob(multi, {\n                parentDependenciesKey: parent === null || parent === void 0 ? void 0 : parent.parentDependenciesKey,\n                waitChildrenKey,\n                parentKey\n            });\n            const parentDependenciesKey = `${queueKeysParent.toKey(node.queueName, parentId)}:dependencies`;\n            const children = this.addChildren({\n                multi,\n                nodes: node.children,\n                parent: {\n                    parentOpts: {\n                        id: parentId,\n                        queue: queueKeysParent.getQueueQualifiedName(node.queueName)\n                    },\n                    parentDependenciesKey\n                },\n                queuesOpts\n            });\n            return {\n                job,\n                children\n            };\n        } else {\n            job.addJob(multi, {\n                parentDependenciesKey: parent === null || parent === void 0 ? void 0 : parent.parentDependenciesKey,\n                parentKey\n            });\n            return {\n                job\n            };\n        }\n    }\n    /**\n     * Adds nodes (jobs) of multiple flows to the queue. This method will recursively\n     * add all its children as well. Note that a given job can potentially be\n     * a parent and a child job at the same time depending on where it is located\n     * in the tree hierarchy.\n     *\n     * @param multi - ioredis ChainableCommander\n     * @param nodes - the nodes representing jobs to be added to some queue\n     * @returns\n     */ addNodes(multi, nodes) {\n        return nodes.map((node)=>{\n            var _a;\n            const parentOpts = (_a = node === null || node === void 0 ? void 0 : node.opts) === null || _a === void 0 ? void 0 : _a.parent;\n            const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(parentOpts);\n            const parentDependenciesKey = parentKey ? `${parentKey}:dependencies` : undefined;\n            return this.addNode({\n                multi,\n                node,\n                parent: {\n                    parentOpts,\n                    parentDependenciesKey\n                }\n            });\n        });\n    }\n    async getNode(client, node) {\n        const queue = this.queueFromNode(node, new _queue_keys__WEBPACK_IMPORTED_MODULE_4__.QueueKeys(node.prefix), node.prefix);\n        const job = await this.Job.fromId(queue, node.id);\n        if (job) {\n            const { processed = {}, unprocessed = [] } = await job.getDependencies({\n                processed: {\n                    count: node.maxChildren\n                },\n                unprocessed: {\n                    count: node.maxChildren\n                }\n            });\n            const processedKeys = Object.keys(processed);\n            const childrenCount = processedKeys.length + unprocessed.length;\n            const newDepth = node.depth - 1;\n            if (childrenCount > 0 && newDepth) {\n                const children = await this.getChildren(client, [\n                    ...processedKeys,\n                    ...unprocessed\n                ], newDepth, node.maxChildren);\n                return {\n                    job,\n                    children\n                };\n            } else {\n                return {\n                    job\n                };\n            }\n        }\n    }\n    addChildren({ multi, nodes, parent, queuesOpts }) {\n        return nodes.map((node)=>this.addNode({\n                multi,\n                node,\n                parent,\n                queuesOpts\n            }));\n    }\n    getChildren(client, childrenKeys, depth, maxChildren) {\n        const getChild = (key)=>{\n            const [prefix, queueName, id] = key.split(\":\");\n            return this.getNode(client, {\n                id,\n                queueName,\n                prefix,\n                depth,\n                maxChildren\n            });\n        };\n        return Promise.all([\n            ...childrenKeys.map(getChild)\n        ]);\n    }\n    /**\n     * Helper factory method that creates a queue-like object\n     * required to create jobs in any queue.\n     *\n     * @param node -\n     * @param queueKeys -\n     * @returns\n     */ queueFromNode(node, queueKeys, prefix) {\n        return {\n            client: this.connection.client,\n            name: node.queueName,\n            keys: queueKeys.getKeys(node.queueName),\n            toKey: (type)=>queueKeys.toKey(node.queueName, type),\n            opts: {\n                prefix,\n                connection: {}\n            },\n            qualifiedName: queueKeys.getQueueQualifiedName(node.queueName),\n            closing: this.closing,\n            waitUntilReady: async ()=>this.connection.client,\n            removeListener: this.removeListener.bind(this),\n            emit: this.emit.bind(this),\n            on: this.on.bind(this),\n            redisVersion: this.connection.redisVersion\n        };\n    }\n    /**\n     *\n     * Closes the connection and returns a promise that resolves when the connection is closed.\n     */ async close() {\n        if (!this.closing) {\n            this.closing = this.connection.close();\n        }\n        await this.closing;\n    }\n    /**\n     *\n     * Force disconnects a connection.\n     */ disconnect() {\n        return this.connection.disconnect();\n    }\n} //# sourceMappingURL=flow-producer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZmxvdy1wcm9kdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1Q7QUFDSDtBQUMrQjtBQUM3QjtBQUNhO0FBQ1k7QUFDckQ7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1RLHFCQUFxQlIsZ0RBQVlBO0lBQzFDUyxZQUFZQyxPQUFPO1FBQUVDLFlBQVksQ0FBQztJQUFFLENBQUMsRUFBRUMsYUFBYUwsOERBQWUsQ0FBRTtRQUNqRSxLQUFLO1FBQ0wsSUFBSSxDQUFDRyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQSxJQUFJLEdBQUdHLE9BQU9DLE1BQU0sQ0FBQztZQUFFQyxRQUFRO1FBQU8sR0FBR0w7UUFDOUMsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSUMsV0FBV0YsS0FBS0MsVUFBVSxFQUFFUCx1REFBZUEsQ0FBQ00sS0FBS0MsVUFBVSxHQUFHLE9BQU9ELEtBQUtNLGdCQUFnQjtRQUNoSCxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sRUFBRSxDQUFDLFNBQVMsQ0FBQ0MsUUFBVSxJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDtRQUMxRCxJQUFJLENBQUNQLFVBQVUsQ0FBQ00sRUFBRSxDQUFDLFNBQVM7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0csT0FBTyxFQUFFO2dCQUNmLElBQUksQ0FBQ0QsSUFBSSxDQUFDO1lBQ2Q7UUFDSjtRQUNBLElBQUksQ0FBQ0UsU0FBUyxHQUFHLElBQUlmLGtEQUFTQSxDQUFDSSxLQUFLSyxNQUFNO0lBQzlDO0lBQ0FJLEtBQUtHLEtBQUssRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsT0FBTyxLQUFLLENBQUNKLEtBQUtHLFVBQVVDO0lBQ2hDO0lBQ0FDLElBQUlDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ3JCLEtBQUssQ0FBQ0YsSUFBSUMsV0FBV0M7UUFDckIsT0FBTyxJQUFJO0lBQ2Y7SUFDQVQsR0FBR0ssS0FB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SztRQUN4QztRQUNBLE1BQU0sSUFBSSxDQUFDN0UsT0FBTztJQUN0QjtJQUNBOzs7S0FHQyxHQUNEOEUsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDdkYsVUFBVSxDQUFDdUYsVUFBVTtJQUNyQztBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9mbG93LXByb2R1Y2VyLmpzPzNjYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgZ2V0UGFyZW50S2V5LCBpc1JlZGlzSW5zdGFuY2UgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBKb2IgfSBmcm9tICcuL2pvYic7XG5pbXBvcnQgeyBRdWV1ZUtleXMgfSBmcm9tICcuL3F1ZXVlLWtleXMnO1xuaW1wb3J0IHsgUmVkaXNDb25uZWN0aW9uIH0gZnJvbSAnLi9yZWRpcy1jb25uZWN0aW9uJztcbi8qKlxuICogVGhpcyBjbGFzcyBhbGxvd3MgdG8gYWRkIGpvYnMgd2l0aCBkZXBlbmRlbmNpZXMgYmV0d2VlbiB0aGVtIGluIHN1Y2hcbiAqIGEgd2F5IHRoYXQgaXQgaXMgcG9zc2libGUgdG8gYnVpbGQgY29tcGxleCBmbG93cy5cbiAqIE5vdGU6IEEgZmxvdyBpcyBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgb2Ygam9icyB0aGF0IGRlcGVuZCBvbiBlYWNoIG90aGVyLlxuICogV2hlbmV2ZXIgdGhlIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gcGFyZW50IGFyZSBjb21wbGV0ZWQsIHRoZSBwYXJlbnRcbiAqIHdpbGwgYmUgcHJvY2Vzc2VkLCBiZWluZyBhYmxlIHRvIGFjY2VzcyB0aGUgY2hpbGRyZW4ncyByZXN1bHQgZGF0YS5cbiAqIEFsbCBKb2JzIGNhbiBiZSBpbiBkaWZmZXJlbnQgcXVldWVzLCBlaXRoZXIgY2hpbGRyZW4gb3IgcGFyZW50cyxcbiAqL1xuZXhwb3J0IGNsYXNzIEZsb3dQcm9kdWNlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHsgY29ubmVjdGlvbjoge30gfSwgQ29ubmVjdGlvbiA9IFJlZGlzQ29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHsgcHJlZml4OiAnYnVsbCcgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKG9wdHMuY29ubmVjdGlvbiwgaXNSZWRpc0luc3RhbmNlKG9wdHMuY29ubmVjdGlvbiksIGZhbHNlLCBvcHRzLnNraXBWZXJzaW9uQ2hlY2spO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpb3JlZGlzOmNsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlS2V5cyA9IG5ldyBRdWV1ZUtleXMob3B0cy5wcmVmaXgpO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgcmVkaXMgY2xpZW50LiBOb3JtYWxseSB1c2VkIG9ubHkgYnkgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIGVhc2lseSBleHRlbmQgSm9iIGNsYXNzIGNhbGxzLlxuICAgICAqL1xuICAgIGdldCBKb2IoKSB7XG4gICAgICAgIHJldHVybiBKb2I7XG4gICAgfVxuICAgIHdhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmbG93LlxuICAgICAqXG4gICAgICogVGhpcyBjYWxsIHdvdWxkIGJlIGF0b21pYywgZWl0aGVyIGl0IGZhaWxzIGFuZCBubyBqb2JzIHdpbGxcbiAgICAgKiBiZSBhZGRlZCB0byB0aGUgcXVldWVzLCBvciBpdCBzdWNjZWVkcyBhbmQgYWxsIGpvYnMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbG93IC0gYW4gb2JqZWN0IHdpdGggYSB0cmVlLWxpa2Ugc3RydWN0dXJlIHdoZXJlIGNoaWxkcmVuIGpvYnNcbiAgICAgKiB3aWxsIGJlIHByb2Nlc3NlZCBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZsb3cgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGFkZChmbG93LCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudE9wdHMgPSAoX2EgPSBmbG93ID09PSBudWxsIHx8IGZsb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZsb3cub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudDtcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KHBhcmVudE9wdHMpO1xuICAgICAgICBjb25zdCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBwYXJlbnRLZXlcbiAgICAgICAgICAgID8gYCR7cGFyZW50S2V5fTpkZXBlbmRlbmNpZXNgXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgam9ic1RyZWUgPSB0aGlzLmFkZE5vZGUoe1xuICAgICAgICAgICAgbXVsdGksXG4gICAgICAgICAgICBub2RlOiBmbG93LFxuICAgICAgICAgICAgcXVldWVzT3B0czogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnF1ZXVlc09wdGlvbnMsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICBwYXJlbnRPcHRzLFxuICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBtdWx0aS5leGVjKCk7XG4gICAgICAgIHJldHVybiBqb2JzVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucyBmb3IgZ2V0dGluZyBhIEpvYk5vZGUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmxvdyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY2xpZW50O1xuICAgICAgICBjb25zdCB1cGRhdGVkT3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZGVwdGg6IDEwLFxuICAgICAgICAgICAgbWF4Q2hpbGRyZW46IDIwLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgY29uc3Qgam9ic1RyZWUgPSB0aGlzLmdldE5vZGUoY2xpZW50LCB1cGRhdGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBqb2JzVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtdWx0aXBsZSBmbG93cy5cbiAgICAgKlxuICAgICAqIEEgZmxvdyBpcyBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgb2Ygam9icyB0aGF0IGRlcGVuZCBvbiBlYWNoIG90aGVyLlxuICAgICAqIFdoZW5ldmVyIHRoZSBjaGlsZHJlbiBvZiBhIGdpdmVuIHBhcmVudCBhcmUgY29tcGxldGVkLCB0aGUgcGFyZW50XG4gICAgICogd2lsbCBiZSBwcm9jZXNzZWQsIGJlaW5nIGFibGUgdG8gYWNjZXNzIHRoZSBjaGlsZHJlbidzIHJlc3VsdCBkYXRhLlxuICAgICAqXG4gICAgICogQWxsIEpvYnMgY2FuIGJlIGluIGRpZmZlcmVudCBxdWV1ZXMsIGVpdGhlciBjaGlsZHJlbiBvciBwYXJlbnRzLFxuICAgICAqIGhvd2V2ZXIgdGhpcyBjYWxsIHdvdWxkIGJlIGF0b21pYywgZWl0aGVyIGl0IGZhaWxzIGFuZCBubyBqb2JzIHdpbGxcbiAgICAgKiBiZSBhZGRlZCB0byB0aGUgcXVldWVzLCBvciBpdCBzdWNjZWVkcyBhbmQgYWxsIGpvYnMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbG93cyAtIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgd2hlcmUgY2hpbGRyZW4gam9ic1xuICAgICAqIHdpbGwgYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGVpciBwYXJlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZEJ1bGsoZmxvd3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIGNvbnN0IGpvYnNUcmVlcyA9IHRoaXMuYWRkTm9kZXMobXVsdGksIGZsb3dzKTtcbiAgICAgICAgYXdhaXQgbXVsdGkuZXhlYygpO1xuICAgICAgICByZXR1cm4gam9ic1RyZWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIChqb2IpIG9mIGEgZmxvdyB0byB0aGUgcXVldWUuIFRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHlcbiAgICAgKiBhZGQgYWxsIGl0cyBjaGlsZHJlbiBhcyB3ZWxsLiBOb3RlIHRoYXQgYSBnaXZlbiBqb2IgY2FuIHBvdGVudGlhbGx5IGJlXG4gICAgICogYSBwYXJlbnQgYW5kIGEgY2hpbGQgam9iIGF0IHRoZSBzYW1lIHRpbWUgZGVwZW5kaW5nIG9uIHdoZXJlIGl0IGlzIGxvY2F0ZWRcbiAgICAgKiBpbiB0aGUgdHJlZSBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXVsdGkgLSBpb3JlZGlzIENoYWluYWJsZUNvbW1hbmRlclxuICAgICAqIEBwYXJhbSBub2RlIC0gdGhlIG5vZGUgcmVwcmVzZW50aW5nIGEgam9iIHRvIGJlIGFkZGVkIHRvIHNvbWUgcXVldWVcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gcGFyZW50IGRhdGEgc2VudCB0byBjaGlsZHJlbiB0byBjcmVhdGUgdGhlIFwibGlua3NcIiB0byB0aGVpciBwYXJlbnRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFkZE5vZGUoeyBtdWx0aSwgbm9kZSwgcGFyZW50LCBxdWV1ZXNPcHRzIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBub2RlLnByZWZpeCB8fCB0aGlzLm9wdHMucHJlZml4O1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVGcm9tTm9kZShub2RlLCBuZXcgUXVldWVLZXlzKHByZWZpeCksIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlT3B0cyA9IHF1ZXVlc09wdHMgJiYgcXVldWVzT3B0c1tub2RlLnF1ZXVlTmFtZV07XG4gICAgICAgIGNvbnN0IGpvYnNPcHRzID0gZ2V0KHF1ZXVlT3B0cywgJ2RlZmF1bHRKb2JPcHRpb25zJyk7XG4gICAgICAgIGNvbnN0IGpvYklkID0gKChfYSA9IG5vZGUub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvYklkKSB8fCB2NCgpO1xuICAgICAgICBjb25zdCBqb2IgPSBuZXcgdGhpcy5Kb2IocXVldWUsIG5vZGUubmFtZSwgbm9kZS5kYXRhLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGpvYnNPcHRzID8gam9ic09wdHMgOiB7fSkpLCBub2RlLm9wdHMpLCB7IHBhcmVudDogcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnBhcmVudE9wdHMgfSksIGpvYklkKTtcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnRPcHRzKTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgcGFyZW50IGpvYiwgd2lsbCBiZSBhIGpvYiBpbiBzdGF0dXMgXCJ3YWl0aW5nLWNoaWxkcmVuXCIuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGpvYklkO1xuICAgICAgICAgICAgY29uc3QgcXVldWVLZXlzUGFyZW50ID0gbmV3IFF1ZXVlS2V5cyhub2RlLnByZWZpeCB8fCB0aGlzLm9wdHMucHJlZml4KTtcbiAgICAgICAgICAgIGNvbnN0IHdhaXRDaGlsZHJlbktleSA9IHF1ZXVlS2V5c1BhcmVudC50b0tleShub2RlLnF1ZXVlTmFtZSwgJ3dhaXRpbmctY2hpbGRyZW4nKTtcbiAgICAgICAgICAgIGpvYi5hZGRKb2IobXVsdGksIHtcbiAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXk6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgd2FpdENoaWxkcmVuS2V5LFxuICAgICAgICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gYCR7cXVldWVLZXlzUGFyZW50LnRvS2V5KG5vZGUucXVldWVOYW1lLCBwYXJlbnRJZCl9OmRlcGVuZGVuY2llc2A7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuYWRkQ2hpbGRyZW4oe1xuICAgICAgICAgICAgICAgIG11bHRpLFxuICAgICAgICAgICAgICAgIG5vZGVzOiBub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogcXVldWVLZXlzUGFyZW50LmdldFF1ZXVlUXVhbGlmaWVkTmFtZShub2RlLnF1ZXVlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXVlc09wdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGpvYiwgY2hpbGRyZW4gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGpvYi5hZGRKb2IobXVsdGksIHtcbiAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXk6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBqb2IgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5vZGVzIChqb2JzKSBvZiBtdWx0aXBsZSBmbG93cyB0byB0aGUgcXVldWUuIFRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHlcbiAgICAgKiBhZGQgYWxsIGl0cyBjaGlsZHJlbiBhcyB3ZWxsLiBOb3RlIHRoYXQgYSBnaXZlbiBqb2IgY2FuIHBvdGVudGlhbGx5IGJlXG4gICAgICogYSBwYXJlbnQgYW5kIGEgY2hpbGQgam9iIGF0IHRoZSBzYW1lIHRpbWUgZGVwZW5kaW5nIG9uIHdoZXJlIGl0IGlzIGxvY2F0ZWRcbiAgICAgKiBpbiB0aGUgdHJlZSBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXVsdGkgLSBpb3JlZGlzIENoYWluYWJsZUNvbW1hbmRlclxuICAgICAqIEBwYXJhbSBub2RlcyAtIHRoZSBub2RlcyByZXByZXNlbnRpbmcgam9icyB0byBiZSBhZGRlZCB0byBzb21lIHF1ZXVlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhZGROb2RlcyhtdWx0aSwgbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLm1hcChub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE9wdHMgPSAoX2EgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IGdldFBhcmVudEtleShwYXJlbnRPcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERlcGVuZGVuY2llc0tleSA9IHBhcmVudEtleVxuICAgICAgICAgICAgICAgID8gYCR7cGFyZW50S2V5fTpkZXBlbmRlbmNpZXNgXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICBtdWx0aSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPcHRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9kZShjbGllbnQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlRnJvbU5vZGUobm9kZSwgbmV3IFF1ZXVlS2V5cyhub2RlLnByZWZpeCksIG5vZGUucHJlZml4KTtcbiAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5Kb2IuZnJvbUlkKHF1ZXVlLCBub2RlLmlkKTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9jZXNzZWQgPSB7fSwgdW5wcm9jZXNzZWQgPSBbXSB9ID0gYXdhaXQgam9iLmdldERlcGVuZGVuY2llcyh7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBub2RlLm1heENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IG5vZGUubWF4Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkS2V5cyA9IE9iamVjdC5rZXlzKHByb2Nlc3NlZCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkNvdW50ID0gcHJvY2Vzc2VkS2V5cy5sZW5ndGggKyB1bnByb2Nlc3NlZC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBuZXdEZXB0aCA9IG5vZGUuZGVwdGggLSAxO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuQ291bnQgPiAwICYmIG5ld0RlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBhd2FpdCB0aGlzLmdldENoaWxkcmVuKGNsaWVudCwgWy4uLnByb2Nlc3NlZEtleXMsIC4uLnVucHJvY2Vzc2VkXSwgbmV3RGVwdGgsIG5vZGUubWF4Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGpvYiwgY2hpbGRyZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGpvYiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENoaWxkcmVuKHsgbXVsdGksIG5vZGVzLCBwYXJlbnQsIHF1ZXVlc09wdHMgfSkge1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKG5vZGUgPT4gdGhpcy5hZGROb2RlKHsgbXVsdGksIG5vZGUsIHBhcmVudCwgcXVldWVzT3B0cyB9KSk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGNsaWVudCwgY2hpbGRyZW5LZXlzLCBkZXB0aCwgbWF4Q2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZ2V0Q2hpbGQgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbcHJlZml4LCBxdWV1ZU5hbWUsIGlkXSA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZShjbGllbnQsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBxdWV1ZU5hbWUsXG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgICAgIG1heENoaWxkcmVuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY2hpbGRyZW5LZXlzLm1hcChnZXRDaGlsZCldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZhY3RvcnkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHF1ZXVlLWxpa2Ugb2JqZWN0XG4gICAgICogcmVxdWlyZWQgdG8gY3JlYXRlIGpvYnMgaW4gYW55IHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLVxuICAgICAqIEBwYXJhbSBxdWV1ZUtleXMgLVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcXVldWVGcm9tTm9kZShub2RlLCBxdWV1ZUtleXMsIHByZWZpeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNvbm5lY3Rpb24uY2xpZW50LFxuICAgICAgICAgICAgbmFtZTogbm9kZS5xdWV1ZU5hbWUsXG4gICAgICAgICAgICBrZXlzOiBxdWV1ZUtleXMuZ2V0S2V5cyhub2RlLnF1ZXVlTmFtZSksXG4gICAgICAgICAgICB0b0tleTogKHR5cGUpID0+IHF1ZXVlS2V5cy50b0tleShub2RlLnF1ZXVlTmFtZSwgdHlwZSksXG4gICAgICAgICAgICBvcHRzOiB7IHByZWZpeCwgY29ubmVjdGlvbjoge30gfSxcbiAgICAgICAgICAgIHF1YWxpZmllZE5hbWU6IHF1ZXVlS2V5cy5nZXRRdWV1ZVF1YWxpZmllZE5hbWUobm9kZS5xdWV1ZU5hbWUpLFxuICAgICAgICAgICAgY2xvc2luZzogdGhpcy5jbG9zaW5nLFxuICAgICAgICAgICAgd2FpdFVudGlsUmVhZHk6IGFzeW5jICgpID0+IHRoaXMuY29ubmVjdGlvbi5jbGllbnQsXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogdGhpcy5yZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZW1pdDogdGhpcy5lbWl0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVkaXNWZXJzaW9uOiB0aGlzLmNvbm5lY3Rpb24ucmVkaXNWZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGb3JjZSBkaXNjb25uZWN0cyBhIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy1wcm9kdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiZ2V0IiwidjQiLCJnZXRQYXJlbnRLZXkiLCJpc1JlZGlzSW5zdGFuY2UiLCJKb2IiLCJRdWV1ZUtleXMiLCJSZWRpc0Nvbm5lY3Rpb24iLCJGbG93UHJvZHVjZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJjb25uZWN0aW9uIiwiQ29ubmVjdGlvbiIsIk9iamVjdCIsImFzc2lnbiIsInByZWZpeCIsInNraXBWZXJzaW9uQ2hlY2siLCJvbiIsImVycm9yIiwiZW1pdCIsImNsb3NpbmciLCJxdWV1ZUtleXMiLCJldmVudCIsImFyZ3MiLCJvZmYiLCJldmVudE5hbWUiLCJsaXN0ZW5lciIsIm9uY2UiLCJjbGllbnQiLCJ3YWl0VW50aWxSZWFkeSIsImFkZCIsImZsb3ciLCJfYSIsIm11bHRpIiwicGFyZW50T3B0cyIsInBhcmVudCIsInBhcmVudEtleSIsInBhcmVudERlcGVuZGVuY2llc0tleSIsInVuZGVmaW5lZCIsImpvYnNUcmVlIiwiYWRkTm9kZSIsIm5vZGUiLCJxdWV1ZXNPcHRzIiwicXVldWVzT3B0aW9ucyIsImV4ZWMiLCJnZXRGbG93IiwidXBkYXRlZE9wdHMiLCJkZXB0aCIsIm1heENoaWxkcmVuIiwiZ2V0Tm9kZSIsImFkZEJ1bGsiLCJmbG93cyIsImpvYnNUcmVlcyIsImFkZE5vZGVzIiwicXVldWUiLCJxdWV1ZUZyb21Ob2RlIiwicXVldWVPcHRzIiwicXVldWVOYW1lIiwiam9ic09wdHMiLCJqb2JJZCIsImpvYiIsIm5hbWUiLCJkYXRhIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJwYXJlbnRJZCIsInF1ZXVlS2V5c1BhcmVudCIsIndhaXRDaGlsZHJlbktleSIsInRvS2V5IiwiYWRkSm9iIiwiYWRkQ2hpbGRyZW4iLCJub2RlcyIsImlkIiwiZ2V0UXVldWVRdWFsaWZpZWROYW1lIiwibWFwIiwiZnJvbUlkIiwicHJvY2Vzc2VkIiwidW5wcm9jZXNzZWQiLCJnZXREZXBlbmRlbmNpZXMiLCJjb3VudCIsInByb2Nlc3NlZEtleXMiLCJrZXlzIiwiY2hpbGRyZW5Db3VudCIsIm5ld0RlcHRoIiwiZ2V0Q2hpbGRyZW4iLCJjaGlsZHJlbktleXMiLCJnZXRDaGlsZCIsImtleSIsInNwbGl0IiwiUHJvbWlzZSIsImFsbCIsImdldEtleXMiLCJ0eXBlIiwicXVhbGlmaWVkTmFtZSIsInJlbW92ZUxpc3RlbmVyIiwiYmluZCIsInJlZGlzVmVyc2lvbiIsImNsb3NlIiwiZGlzY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* reexport safe */ _async_fifo_queue__WEBPACK_IMPORTED_MODULE_0__.AsyncFifoQueue),\n/* harmony export */   Backoffs: () => (/* reexport safe */ _backoffs__WEBPACK_IMPORTED_MODULE_1__.Backoffs),\n/* harmony export */   ChildPool: () => (/* reexport safe */ _child_pool__WEBPACK_IMPORTED_MODULE_2__.ChildPool),\n/* harmony export */   ChildProcessor: () => (/* reexport safe */ _child_processor__WEBPACK_IMPORTED_MODULE_3__.ChildProcessor),\n/* harmony export */   DelayedError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.DelayedError),\n/* harmony export */   FlowProducer: () => (/* reexport safe */ _flow_producer__WEBPACK_IMPORTED_MODULE_5__.FlowProducer),\n/* harmony export */   Job: () => (/* reexport safe */ _job__WEBPACK_IMPORTED_MODULE_6__.Job),\n/* harmony export */   PRIORITY_LIMIT: () => (/* reexport safe */ _job__WEBPACK_IMPORTED_MODULE_6__.PRIORITY_LIMIT),\n/* harmony export */   Queue: () => (/* reexport safe */ _queue__WEBPACK_IMPORTED_MODULE_11__.Queue),\n/* harmony export */   QueueBase: () => (/* reexport safe */ _queue_base__WEBPACK_IMPORTED_MODULE_7__.QueueBase),\n/* harmony export */   QueueEvents: () => (/* reexport safe */ _queue_events__WEBPACK_IMPORTED_MODULE_8__.QueueEvents),\n/* harmony export */   QueueGetters: () => (/* reexport safe */ _queue_getters__WEBPACK_IMPORTED_MODULE_9__.QueueGetters),\n/* harmony export */   QueueKeys: () => (/* reexport safe */ _queue_keys__WEBPACK_IMPORTED_MODULE_10__.QueueKeys),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.RateLimitError),\n/* harmony export */   RedisConnection: () => (/* reexport safe */ _redis_connection__WEBPACK_IMPORTED_MODULE_12__.RedisConnection),\n/* harmony export */   Repeat: () => (/* reexport safe */ _repeat__WEBPACK_IMPORTED_MODULE_13__.Repeat),\n/* harmony export */   Scripts: () => (/* reexport safe */ _scripts__WEBPACK_IMPORTED_MODULE_15__.Scripts),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.UnrecoverableError),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.WaitingChildrenError),\n/* harmony export */   Worker: () => (/* reexport safe */ _worker__WEBPACK_IMPORTED_MODULE_16__.Worker),\n/* harmony export */   getNextMillis: () => (/* reexport safe */ _repeat__WEBPACK_IMPORTED_MODULE_13__.getNextMillis),\n/* harmony export */   raw2NextJobData: () => (/* reexport safe */ _scripts__WEBPACK_IMPORTED_MODULE_15__.raw2NextJobData)\n/* harmony export */ });\n/* harmony import */ var _async_fifo_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async-fifo-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\");\n/* harmony import */ var _backoffs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./backoffs */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\");\n/* harmony import */ var _child_pool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./child-pool */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\");\n/* harmony import */ var _child_processor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./child-processor */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\");\n/* harmony import */ var _flow_producer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flow-producer */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _queue_events__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./queue-events */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js\");\n/* harmony import */ var _queue_getters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./queue-getters */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n/* harmony import */ var _queue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n/* harmony import */ var _sandbox__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\");\n/* harmony import */ var _worker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./worker */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js\");\n\n\n\n\n\n\n\n// export * from './main'; this file must not be exported\n// export * from './main-worker'; this file must not be exported\n\n\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNSO0FBQ0U7QUFDSztBQUNUO0FBQ087QUFDVjtBQUN0Qix5REFBeUQ7QUFDekQsZ0VBQWdFO0FBQ25DO0FBQ0U7QUFDQztBQUNIO0FBQ0w7QUFDVztBQUNWO0FBQ0M7QUFDQTtBQUNELENBQ3pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvaW5kZXguanM/NGNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FzeW5jLWZpZm8tcXVldWUnO1xuZXhwb3J0ICogZnJvbSAnLi9iYWNrb2Zmcyc7XG5leHBvcnQgKiBmcm9tICcuL2NoaWxkLXBvb2wnO1xuZXhwb3J0ICogZnJvbSAnLi9jaGlsZC1wcm9jZXNzb3InO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9mbG93LXByb2R1Y2VyJztcbmV4cG9ydCAqIGZyb20gJy4vam9iJztcbi8vIGV4cG9ydCAqIGZyb20gJy4vbWFpbic7IHRoaXMgZmlsZSBtdXN0IG5vdCBiZSBleHBvcnRlZFxuLy8gZXhwb3J0ICogZnJvbSAnLi9tYWluLXdvcmtlcic7IHRoaXMgZmlsZSBtdXN0IG5vdCBiZSBleHBvcnRlZFxuZXhwb3J0ICogZnJvbSAnLi9xdWV1ZS1iYXNlJztcbmV4cG9ydCAqIGZyb20gJy4vcXVldWUtZXZlbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vcXVldWUtZ2V0dGVycyc7XG5leHBvcnQgKiBmcm9tICcuL3F1ZXVlLWtleXMnO1xuZXhwb3J0ICogZnJvbSAnLi9xdWV1ZSc7XG5leHBvcnQgKiBmcm9tICcuL3JlZGlzLWNvbm5lY3Rpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9yZXBlYXQnO1xuZXhwb3J0ICogZnJvbSAnLi9zYW5kYm94JztcbmV4cG9ydCAqIGZyb20gJy4vc2NyaXB0cyc7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/job.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/job.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Job: () => (/* binding */ Job),\n/* harmony export */   PRIORITY_LIMIT: () => (/* binding */ PRIORITY_LIMIT)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var lodash_invert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/invert */ \"lodash/invert\");\n/* harmony import */ var lodash_invert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_invert__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _backoffs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./backoffs */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\");\n/* harmony import */ var _errors_unrecoverable_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors/unrecoverable-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\");\n\n\n\n\n\n\n\nconst logger = (0,util__WEBPACK_IMPORTED_MODULE_1__.debuglog)(\"bull\");\nconst optsDecodeMap = {\n    fpof: \"failParentOnFailure\",\n    idof: \"ignoreDependencyOnFailure\",\n    kl: \"keepLogs\",\n    rdof: \"removeDependencyOnFailure\"\n};\nconst optsEncodeMap = lodash_invert__WEBPACK_IMPORTED_MODULE_0___default()(optsDecodeMap);\nconst PRIORITY_LIMIT = 2 ** 21;\n/**\n * Job\n *\n * This class represents a Job in the queue. Normally job are implicitly created when\n * you add a job to the queue with methods such as Queue.addJob( ... )\n *\n * A Job instance is also passed to the Worker's process function.\n *\n * @class Job\n */ class Job {\n    constructor(queue, /**\n     * The name of the Job\n     */ name, /**\n     * The payload for this job.\n     */ data, /**\n     * The options object for this job.\n     */ opts = {}, id){\n        this.queue = queue;\n        this.name = name;\n        this.data = data;\n        this.opts = opts;\n        this.id = id;\n        /**\n         * The progress a job has performed so far.\n         * @defaultValue 0\n         */ this.progress = 0;\n        /**\n         * The value returned by the processor when processing this job.\n         * @defaultValue null\n         */ this.returnvalue = null;\n        /**\n         * Stacktrace for the error (for failed jobs).\n         * @defaultValue null\n         */ this.stacktrace = null;\n        /**\n         * Number of attempts when job is moved to active.\n         * @defaultValue 0\n         */ this.attemptsStarted = 0;\n        /**\n         * Number of attempts after the job has failed.\n         * @defaultValue 0\n         */ this.attemptsMade = 0;\n        const _a = this.opts, { repeatJobKey } = _a, restOpts = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(_a, [\n            \"repeatJobKey\"\n        ]);\n        this.opts = Object.assign({\n            attempts: 0,\n            delay: 0\n        }, restOpts);\n        this.delay = this.opts.delay;\n        this.repeatJobKey = repeatJobKey;\n        this.timestamp = opts.timestamp ? opts.timestamp : Date.now();\n        this.opts.backoff = _backoffs__WEBPACK_IMPORTED_MODULE_3__.Backoffs.normalize(opts.backoff);\n        this.parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(opts.parent);\n        this.parent = opts.parent ? {\n            id: opts.parent.id,\n            queueKey: opts.parent.queue\n        } : undefined;\n        this.toKey = queue.toKey.bind(queue);\n        this.scripts = new _scripts__WEBPACK_IMPORTED_MODULE_4__.Scripts(queue);\n        this.queueQualifiedName = queue.qualifiedName;\n    }\n    /**\n     * Creates a new job and adds it to the queue.\n     *\n     * @param queue - the queue where to add the job.\n     * @param name - the name of the job.\n     * @param data - the payload of the job.\n     * @param opts - the options bag for this job.\n     * @returns\n     */ static async create(queue, name, data, opts) {\n        const client = await queue.client;\n        const job = new this(queue, name, data, opts, opts && opts.jobId);\n        job.id = await job.addJob(client, {\n            parentKey: job.parentKey,\n            parentDependenciesKey: job.parentKey ? `${job.parentKey}:dependencies` : \"\"\n        });\n        return job;\n    }\n    /**\n     * Creates a bulk of jobs and adds them atomically to the given queue.\n     *\n     * @param queue -the queue were to add the jobs.\n     * @param jobs - an array of jobs to be added to the queue.\n     * @returns\n     */ static async createBulk(queue, jobs) {\n        const client = await queue.client;\n        const jobInstances = jobs.map((job)=>{\n            var _a;\n            return new this(queue, job.name, job.data, job.opts, (_a = job.opts) === null || _a === void 0 ? void 0 : _a.jobId);\n        });\n        const multi = client.multi();\n        for (const job of jobInstances){\n            job.addJob(multi, {\n                parentKey: job.parentKey,\n                parentDependenciesKey: job.parentKey ? `${job.parentKey}:dependencies` : \"\"\n            });\n        }\n        const results = await multi.exec();\n        for(let index = 0; index < results.length; ++index){\n            const [err, id] = results[index];\n            if (err) {\n                throw err;\n            }\n            jobInstances[index].id = id;\n        }\n        return jobInstances;\n    }\n    /**\n     * Instantiates a Job from a JobJsonRaw object (coming from a deserialized JSON object)\n     *\n     * @param queue - the queue where the job belongs to.\n     * @param json - the plain object containing the job.\n     * @param jobId - an optional job id (overrides the id coming from the JSON object)\n     * @returns\n     */ static fromJSON(queue, json, jobId) {\n        const data = JSON.parse(json.data || \"{}\");\n        const opts = Job.optsFromJSON(json.opts);\n        const job = new this(queue, json.name, data, opts, json.id || jobId);\n        job.progress = JSON.parse(json.progress || \"0\");\n        job.delay = parseInt(json.delay);\n        job.timestamp = parseInt(json.timestamp);\n        if (json.finishedOn) {\n            job.finishedOn = parseInt(json.finishedOn);\n        }\n        if (json.processedOn) {\n            job.processedOn = parseInt(json.processedOn);\n        }\n        if (json.rjk) {\n            job.repeatJobKey = json.rjk;\n        }\n        job.failedReason = json.failedReason;\n        job.attemptsStarted = parseInt(json.ats || \"0\");\n        job.attemptsMade = parseInt(json.attemptsMade || json.atm || \"0\");\n        job.stacktrace = getTraces(json.stacktrace);\n        if (typeof json.returnvalue === \"string\") {\n            job.returnvalue = getReturnValue(json.returnvalue);\n        }\n        if (json.parentKey) {\n            job.parentKey = json.parentKey;\n        }\n        if (json.parent) {\n            job.parent = JSON.parse(json.parent);\n        }\n        if (json.pb) {\n            job.processedBy = json.pb;\n        }\n        return job;\n    }\n    static optsFromJSON(rawOpts) {\n        const opts = JSON.parse(rawOpts || \"{}\");\n        const optionEntries = Object.entries(opts);\n        const options = {};\n        for (const item of optionEntries){\n            const [attributeName, value] = item;\n            if (optsDecodeMap[attributeName]) {\n                options[optsDecodeMap[attributeName]] = value;\n            } else {\n                options[attributeName] = value;\n            }\n        }\n        return options;\n    }\n    /**\n     * Fetches a Job from the queue given the passed job id.\n     *\n     * @param queue - the queue where the job belongs to.\n     * @param jobId - the job id.\n     * @returns\n     */ static async fromId(queue, jobId) {\n        // jobId can be undefined if moveJob returns undefined\n        if (jobId) {\n            const client = await queue.client;\n            const jobData = await client.hgetall(queue.toKey(jobId));\n            return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(jobData) ? undefined : this.fromJSON(queue, jobData, jobId);\n        }\n    }\n    /**\n     * addJobLog\n     *\n     * @param queue Queue instance\n     * @param jobId Job id\n     * @param logRow Log row\n     * @param keepLogs optional maximum number of logs to keep\n     *\n     * @returns The total number of log entries for this job so far.\n     */ static async addJobLog(queue, jobId, logRow, keepLogs) {\n        const client = await queue.client;\n        const logsKey = queue.toKey(jobId) + \":logs\";\n        const multi = client.multi();\n        multi.rpush(logsKey, logRow);\n        if (keepLogs) {\n            multi.ltrim(logsKey, -keepLogs, -1);\n        }\n        const result = await multi.exec();\n        return keepLogs ? Math.min(keepLogs, result[0][1]) : result[0][1];\n    }\n    toJSON() {\n        const _a = this, { queue, scripts } = _a, withoutQueueAndScripts = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(_a, [\n            \"queue\",\n            \"scripts\"\n        ]);\n        return withoutQueueAndScripts;\n    }\n    /**\n     * Prepares a job to be serialized for storage in Redis.\n     * @returns\n     */ asJSON() {\n        return {\n            id: this.id,\n            name: this.name,\n            data: JSON.stringify(typeof this.data === \"undefined\" ? {} : this.data),\n            opts: this.optsAsJSON(this.opts),\n            parent: this.parent ? Object.assign({}, this.parent) : undefined,\n            parentKey: this.parentKey,\n            progress: this.progress,\n            attemptsMade: this.attemptsMade,\n            attemptsStarted: this.attemptsStarted,\n            finishedOn: this.finishedOn,\n            processedOn: this.processedOn,\n            timestamp: this.timestamp,\n            failedReason: JSON.stringify(this.failedReason),\n            stacktrace: JSON.stringify(this.stacktrace),\n            repeatJobKey: this.repeatJobKey,\n            returnvalue: JSON.stringify(this.returnvalue)\n        };\n    }\n    optsAsJSON(opts = {}) {\n        const optionEntries = Object.entries(opts);\n        const options = {};\n        for (const item of optionEntries){\n            const [attributeName, value] = item;\n            if (optsEncodeMap[attributeName]) {\n                options[optsEncodeMap[attributeName]] = value;\n            } else {\n                options[attributeName] = value;\n            }\n        }\n        return options;\n    }\n    /**\n     * Prepares a job to be passed to Sandbox.\n     * @returns\n     */ asJSONSandbox() {\n        return Object.assign(Object.assign({}, this.asJSON()), {\n            queueName: this.queueName,\n            prefix: this.prefix\n        });\n    }\n    /**\n     * Updates a job's data\n     *\n     * @param data - the data that will replace the current jobs data.\n     */ updateData(data) {\n        this.data = data;\n        return this.scripts.updateData(this, data);\n    }\n    /**\n     * Updates a job's progress\n     *\n     * @param progress - number or object to be saved as progress.\n     */ async updateProgress(progress) {\n        this.progress = progress;\n        await this.scripts.updateProgress(this.id, progress);\n        this.queue.emit(\"progress\", this, progress);\n    }\n    /**\n     * Logs one row of log data.\n     *\n     * @param logRow - string with log data to be logged.\n     * @returns The total number of log entries for this job so far.\n     */ async log(logRow) {\n        return Job.addJobLog(this.queue, this.id, logRow, this.opts.keepLogs);\n    }\n    /**\n     * Removes child dependency from parent when child is not yet finished\n     *\n     * @returns True if the relationship existed and if it was removed.\n     */ async removeChildDependency() {\n        const childDependencyIsRemoved = await this.scripts.removeChildDependency(this.id, this.parentKey);\n        if (childDependencyIsRemoved) {\n            this.parent = undefined;\n            this.parentKey = undefined;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Clears job's logs\n     *\n     * @param keepLogs - the amount of log entries to preserve\n     */ async clearLogs(keepLogs) {\n        const client = await this.queue.client;\n        const logsKey = this.toKey(this.id) + \":logs\";\n        if (keepLogs) {\n            await client.ltrim(logsKey, -keepLogs, -1);\n        } else {\n            await client.del(logsKey);\n        }\n    }\n    /**\n     * Completely remove the job from the queue.\n     * Note, this call will throw an exception if the job\n     * is being processed when the call is performed.\n     *\n     * @param opts - Options to remove a job\n     */ async remove({ removeChildren = true } = {}) {\n        await this.queue.waitUntilReady();\n        const queue = this.queue;\n        const job = this;\n        const removed = await this.scripts.remove(job.id, removeChildren);\n        if (removed) {\n            queue.emit(\"removed\", job);\n        } else {\n            throw new Error(`Job ${this.id} could not be removed because it is locked by another worker`);\n        }\n    }\n    /**\n     * Extend the lock for this job.\n     *\n     * @param token - unique token for the lock\n     * @param duration - lock duration in milliseconds\n     */ extendLock(token, duration) {\n        return this.scripts.extendLock(this.id, token, duration);\n    }\n    /**\n     * Moves a job to the completed queue.\n     * Returned job to be used with Queue.prototype.nextJobFromJobData.\n     *\n     * @param returnValue - The jobs success message.\n     * @param token - Worker token used to acquire completed job.\n     * @param fetchNext - True when wanting to fetch the next job.\n     * @returns Returns the jobData of the next job in the waiting queue.\n     */ async moveToCompleted(returnValue, token, fetchNext = true) {\n        await this.queue.waitUntilReady();\n        this.returnvalue = returnValue || void 0;\n        const stringifiedReturnValue = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.tryCatch)(JSON.stringify, JSON, [\n            returnValue\n        ]);\n        if (stringifiedReturnValue === _utils__WEBPACK_IMPORTED_MODULE_2__.errorObject) {\n            throw _utils__WEBPACK_IMPORTED_MODULE_2__.errorObject.value;\n        }\n        const args = this.scripts.moveToCompletedArgs(this, stringifiedReturnValue, this.opts.removeOnComplete, token, fetchNext);\n        const result = await this.scripts.moveToFinished(this.id, args);\n        this.finishedOn = args[this.scripts.moveToFinishedKeys.length + 1];\n        this.attemptsMade += 1;\n        return result;\n    }\n    /**\n     * Moves a job to the failed queue.\n     *\n     * @param err - the jobs error message.\n     * @param token - token to check job is locked by current worker\n     * @param fetchNext - true when wanting to fetch the next job\n     * @returns void\n     */ async moveToFailed(err, token, fetchNext = false) {\n        const client = await this.queue.client;\n        const message = err === null || err === void 0 ? void 0 : err.message;\n        const queue = this.queue;\n        this.failedReason = message;\n        let command;\n        const multi = client.multi();\n        this.saveStacktrace(multi, err);\n        //\n        // Check if an automatic retry should be performed\n        //\n        let moveToFailed = false;\n        let finishedOn, delay;\n        if (this.attemptsMade + 1 < this.opts.attempts && !this.discarded && !(err instanceof _errors_unrecoverable_error__WEBPACK_IMPORTED_MODULE_5__.UnrecoverableError || err.name == \"UnrecoverableError\")) {\n            const opts = queue.opts;\n            // Check if backoff is needed\n            delay = await _backoffs__WEBPACK_IMPORTED_MODULE_3__.Backoffs.calculate(this.opts.backoff, this.attemptsMade + 1, err, this, opts.settings && opts.settings.backoffStrategy);\n            if (delay === -1) {\n                moveToFailed = true;\n            } else if (delay) {\n                const args = this.scripts.moveToDelayedArgs(this.id, Date.now() + delay, token, delay);\n                multi.moveToDelayed(args);\n                command = \"delayed\";\n            } else {\n                // Retry immediately\n                multi.retryJob(this.scripts.retryJobArgs(this.id, this.opts.lifo, token));\n                command = \"retryJob\";\n            }\n        } else {\n            // If not, move to failed\n            moveToFailed = true;\n        }\n        if (moveToFailed) {\n            const args = this.scripts.moveToFailedArgs(this, message, this.opts.removeOnFail, token, fetchNext);\n            multi.moveToFinished(args);\n            finishedOn = args[this.scripts.moveToFinishedKeys.length + 1];\n            command = \"failed\";\n        }\n        const results = await multi.exec();\n        const anyError = results.find((result)=>result[0]);\n        if (anyError) {\n            throw new Error(`Error \"moveToFailed\" with command ${command}: ${anyError}`);\n        }\n        const code = results[results.length - 1][1];\n        if (code < 0) {\n            throw this.scripts.finishedErrors({\n                code,\n                jobId: this.id,\n                command,\n                state: \"active\"\n            });\n        }\n        if (finishedOn && typeof finishedOn === \"number\") {\n            this.finishedOn = finishedOn;\n        }\n        if (delay && typeof delay === \"number\") {\n            this.delay = delay;\n        }\n        this.attemptsMade += 1;\n    }\n    /**\n     * @returns true if the job has completed.\n     */ isCompleted() {\n        return this.isInZSet(\"completed\");\n    }\n    /**\n     * @returns true if the job has failed.\n     */ isFailed() {\n        return this.isInZSet(\"failed\");\n    }\n    /**\n     * @returns true if the job is delayed.\n     */ isDelayed() {\n        return this.isInZSet(\"delayed\");\n    }\n    /**\n     * @returns true if the job is waiting for children.\n     */ isWaitingChildren() {\n        return this.isInZSet(\"waiting-children\");\n    }\n    /**\n     * @returns true of the job is active.\n     */ isActive() {\n        return this.isInList(\"active\");\n    }\n    /**\n     * @returns true if the job is waiting.\n     */ async isWaiting() {\n        return await this.isInList(\"wait\") || await this.isInList(\"paused\");\n    }\n    /**\n     * @returns the queue name this job belongs to.\n     */ get queueName() {\n        return this.queue.name;\n    }\n    /**\n     * @returns the prefix that is used.\n     */ get prefix() {\n        return this.queue.opts.prefix;\n    }\n    /**\n     * Get current state.\n     *\n     * @returns Returns one of these values:\n     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.\n     */ getState() {\n        return this.scripts.getState(this.id);\n    }\n    /**\n     * Change delay of a delayed job.\n     *\n     * @param delay - milliseconds to be added to current time.\n     * @returns void\n     */ async changeDelay(delay) {\n        await this.scripts.changeDelay(this.id, delay);\n        this.delay = delay;\n    }\n    /**\n     * Change job priority.\n     *\n     * @returns void\n     */ async changePriority(opts) {\n        await this.scripts.changePriority(this.id, opts.priority, opts.lifo);\n    }\n    /**\n     * Get this jobs children result values if any.\n     *\n     * @returns Object mapping children job keys with their values.\n     */ async getChildrenValues() {\n        const client = await this.queue.client;\n        const result = await client.hgetall(this.toKey(`${this.id}:processed`));\n        if (result) {\n            return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.parseObjectValues)(result);\n        }\n    }\n    /**\n     * Get this jobs children failure values if any.\n     *\n     * @returns Object mapping children job keys with their failure values.\n     */ async getFailedChildrenValues() {\n        const client = await this.queue.client;\n        return client.hgetall(this.toKey(`${this.id}:failed`));\n    }\n    /**\n     * Get children job keys if this job is a parent and has children.\n     * @remarks\n     * Count options before Redis v7.2 works as expected with any quantity of entries\n     * on processed/unprocessed dependencies, since v7.2 you must consider that count\n     * won't have any effect until processed/unprocessed dependencies have a length\n     * greater than 127\n     * @see https://redis.io/docs/management/optimization/memory-optimization/#redis--72\n     * @returns dependencies separated by processed and unprocessed.\n     */ async getDependencies(opts = {}) {\n        const client = await this.queue.client;\n        const multi = client.multi();\n        if (!opts.processed && !opts.unprocessed) {\n            multi.hgetall(this.toKey(`${this.id}:processed`));\n            multi.smembers(this.toKey(`${this.id}:dependencies`));\n            const [[err1, processed], [err2, unprocessed]] = await multi.exec();\n            const transformedProcessed = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.parseObjectValues)(processed);\n            return {\n                processed: transformedProcessed,\n                unprocessed\n            };\n        } else {\n            const defaultOpts = {\n                cursor: 0,\n                count: 20\n            };\n            if (opts.processed) {\n                const processedOpts = Object.assign(Object.assign({}, defaultOpts), opts.processed);\n                multi.hscan(this.toKey(`${this.id}:processed`), processedOpts.cursor, \"COUNT\", processedOpts.count);\n            }\n            if (opts.unprocessed) {\n                const unprocessedOpts = Object.assign(Object.assign({}, defaultOpts), opts.unprocessed);\n                multi.sscan(this.toKey(`${this.id}:dependencies`), unprocessedOpts.cursor, \"COUNT\", unprocessedOpts.count);\n            }\n            const [result1, result2] = await multi.exec();\n            const [processedCursor, processed = []] = opts.processed ? result1[1] : [];\n            const [unprocessedCursor, unprocessed = []] = opts.unprocessed ? opts.processed ? result2[1] : result1[1] : [];\n            const transformedProcessed = {};\n            for(let index = 0; index < processed.length; ++index){\n                if (index % 2) {\n                    transformedProcessed[processed[index - 1]] = JSON.parse(processed[index]);\n                }\n            }\n            return Object.assign(Object.assign({}, processedCursor ? {\n                processed: transformedProcessed,\n                nextProcessedCursor: Number(processedCursor)\n            } : {}), unprocessedCursor ? {\n                unprocessed,\n                nextUnprocessedCursor: Number(unprocessedCursor)\n            } : {});\n        }\n    }\n    /**\n     * Get children job counts if this job is a parent and has children.\n     *\n     * @returns dependencies count separated by processed and unprocessed.\n     */ async getDependenciesCount(opts = {}) {\n        const client = await this.queue.client;\n        const multi = client.multi();\n        const updatedOpts = !opts.processed && !opts.unprocessed ? {\n            processed: true,\n            unprocessed: true\n        } : opts;\n        if (updatedOpts.processed) {\n            multi.hlen(this.toKey(`${this.id}:processed`));\n        }\n        if (updatedOpts.unprocessed) {\n            multi.scard(this.toKey(`${this.id}:dependencies`));\n        }\n        const [[err1, result1] = [], [err2, result2] = []] = await multi.exec();\n        const processed = updatedOpts.processed ? result1 : undefined;\n        const unprocessed = updatedOpts.unprocessed ? updatedOpts.processed ? result2 : result1 : undefined;\n        return Object.assign(Object.assign({}, updatedOpts.processed ? {\n            processed\n        } : {}), updatedOpts.unprocessed ? {\n            unprocessed\n        } : {});\n    }\n    /**\n     * Returns a promise the resolves when the job has completed (containing the return value of the job),\n     * or rejects when the job has failed (containing the failedReason).\n     *\n     * @param queueEvents - Instance of QueueEvents.\n     * @param ttl - Time in milliseconds to wait for job to finish before timing out.\n     */ async waitUntilFinished(queueEvents, ttl) {\n        await this.queue.waitUntilReady();\n        const jobId = this.id;\n        return new Promise(async (resolve, reject)=>{\n            let timeout;\n            if (ttl) {\n                timeout = setTimeout(()=>onFailed(/* eslint-disable max-len */ `Job wait ${this.name} timed out before finishing, no finish notification arrived after ${ttl}ms (id=${jobId})`), ttl);\n            }\n            function onCompleted(args) {\n                removeListeners();\n                resolve(args.returnvalue);\n            }\n            function onFailed(args) {\n                removeListeners();\n                reject(new Error(args.failedReason || args));\n            }\n            const completedEvent = `completed:${jobId}`;\n            const failedEvent = `failed:${jobId}`;\n            queueEvents.on(completedEvent, onCompleted);\n            queueEvents.on(failedEvent, onFailed);\n            this.queue.on(\"closing\", onFailed);\n            const removeListeners = ()=>{\n                clearInterval(timeout);\n                queueEvents.removeListener(completedEvent, onCompleted);\n                queueEvents.removeListener(failedEvent, onFailed);\n                this.queue.removeListener(\"closing\", onFailed);\n            };\n            // Poll once right now to see if the job has already finished. The job may have been completed before we were able\n            // to register the event handlers on the QueueEvents, so we check here to make sure we're not waiting for an event\n            // that has already happened. We block checking the job until the queue events object is actually listening to\n            // Redis so there's no chance that it will miss events.\n            await queueEvents.waitUntilReady();\n            const [status, result] = await this.scripts.isFinished(jobId, true);\n            const finished = status != 0;\n            if (finished) {\n                if (status == -1 || status == 2) {\n                    onFailed({\n                        failedReason: result\n                    });\n                } else {\n                    onCompleted({\n                        returnvalue: getReturnValue(result)\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Moves the job to the delay set.\n     *\n     * @param timestamp - timestamp where the job should be moved back to \"wait\"\n     * @param token - token to check job is locked by current worker\n     * @returns\n     */ async moveToDelayed(timestamp, token) {\n        const delay = timestamp - Date.now();\n        const movedToDelayed = await this.scripts.moveToDelayed(this.id, timestamp, delay > 0 ? delay : 0, token, {\n            skipAttempt: true\n        });\n        return movedToDelayed;\n    }\n    /**\n     * Moves the job to the waiting-children set.\n     *\n     * @param token - Token to check job is locked by current worker\n     * @param opts - The options bag for moving a job to waiting-children.\n     * @returns true if the job was moved\n     */ async moveToWaitingChildren(token, opts = {}) {\n        const movedToWaitingChildren = await this.scripts.moveToWaitingChildren(this.id, token, opts);\n        return movedToWaitingChildren;\n    }\n    /**\n     * Promotes a delayed job so that it starts to be processed as soon as possible.\n     */ async promote() {\n        const jobId = this.id;\n        await this.scripts.promote(jobId);\n        this.delay = 0;\n    }\n    /**\n     * Attempts to retry the job. Only a job that has failed or completed can be retried.\n     *\n     * @param state - completed / failed\n     * @returns If resolved and return code is 1, then the queue emits a waiting event\n     * otherwise the operation was not a success and throw the corresponding error. If the promise\n     * rejects, it indicates that the script failed to execute\n     */ retry(state = \"failed\") {\n        this.failedReason = null;\n        this.finishedOn = null;\n        this.processedOn = null;\n        this.returnvalue = null;\n        return this.scripts.reprocessJob(this, state);\n    }\n    /**\n     * Marks a job to not be retried if it fails (even if attempts has been configured)\n     */ discard() {\n        this.discarded = true;\n    }\n    async isInZSet(set) {\n        const client = await this.queue.client;\n        const score = await client.zscore(this.queue.toKey(set), this.id);\n        return score !== null;\n    }\n    async isInList(list) {\n        return this.scripts.isJobInList(this.queue.toKey(list), this.id);\n    }\n    /**\n     * Adds the job to Redis.\n     *\n     * @param client -\n     * @param parentOpts -\n     * @returns\n     */ addJob(client, parentOpts) {\n        const jobData = this.asJSON();\n        this.validateOptions(jobData);\n        return this.scripts.addJob(client, jobData, jobData.opts, this.id, parentOpts);\n    }\n    validateOptions(jobData) {\n        var _a;\n        const exceedLimit = this.opts.sizeLimit && (0,_utils__WEBPACK_IMPORTED_MODULE_2__.lengthInUtf8Bytes)(jobData.data) > this.opts.sizeLimit;\n        if (exceedLimit) {\n            throw new Error(`The size of job ${this.name} exceeds the limit ${this.opts.sizeLimit} bytes`);\n        }\n        if (this.opts.delay && this.opts.repeat && !((_a = this.opts.repeat) === null || _a === void 0 ? void 0 : _a.count)) {\n            throw new Error(`Delay and repeat options could not be used together`);\n        }\n        if (this.opts.removeDependencyOnFailure && this.opts.failParentOnFailure) {\n            throw new Error(`RemoveDependencyOnFailure and failParentOnFailure options can not be used together`);\n        }\n        if (`${parseInt(this.id, 10)}` === this.id) {\n            throw new Error(\"Custom Ids cannot be integers\");\n        }\n        if (this.opts.priority) {\n            if (Math.trunc(this.opts.priority) !== this.opts.priority) {\n                throw new Error(`Priority should not be float`);\n            }\n            if (this.opts.priority > PRIORITY_LIMIT) {\n                throw new Error(`Priority should be between 0 and ${PRIORITY_LIMIT}`);\n            }\n        }\n    }\n    saveStacktrace(multi, err) {\n        this.stacktrace = this.stacktrace || [];\n        if (err === null || err === void 0 ? void 0 : err.stack) {\n            this.stacktrace.push(err.stack);\n            if (this.opts.stackTraceLimit) {\n                this.stacktrace = this.stacktrace.slice(0, this.opts.stackTraceLimit);\n            }\n        }\n        const args = this.scripts.saveStacktraceArgs(this.id, JSON.stringify(this.stacktrace), err === null || err === void 0 ? void 0 : err.message);\n        multi.saveStacktrace(args);\n    }\n}\nfunction getTraces(stacktrace) {\n    const traces = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.tryCatch)(JSON.parse, JSON, [\n        stacktrace\n    ]);\n    if (traces === _utils__WEBPACK_IMPORTED_MODULE_2__.errorObject || !(traces instanceof Array)) {\n        return [];\n    } else {\n        return traces;\n    }\n}\nfunction getReturnValue(_value) {\n    const value = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.tryCatch)(JSON.parse, JSON, [\n        _value\n    ]);\n    if (value !== _utils__WEBPACK_IMPORTED_MODULE_2__.errorObject) {\n        return value;\n    } else {\n        logger(\"corrupted returnvalue: \" + _value, value);\n    }\n} //# sourceMappingURL=job.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvam9iLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0M7QUFDQTtBQUMrRTtBQUN6RTtBQUNGO0FBQzhCO0FBQ2xFLE1BQU1ZLFNBQVNWLDhDQUFRQSxDQUFDO0FBQ3hCLE1BQU1XLGdCQUFnQjtJQUNsQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLElBQUk7SUFDSkMsTUFBTTtBQUNWO0FBQ0EsTUFBTUMsZ0JBQWdCakIsb0RBQU1BLENBQUNZO0FBQ3RCLE1BQU1NLGlCQUFpQixLQUFLLEdBQUc7QUFDdEM7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUM7SUFDVEMsWUFBWUMsS0FBSyxFQUNqQjs7S0FFQyxHQUNEQyxJQUFJLEVBQ0o7O0tBRUMsR0FDREMsSUFBSSxFQUNKOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFDLEVBQUVDLEVBQUUsQ0FBRTtRQUNYLElBQUksQ0FBQ0osS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtRQUNWOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25COzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLE1BQU1DLEtBQUssSUFBSSxDQUFDUCxJQUFJLEVBQUUsRUFBRVEsWUFBWSxFQUFFLEdBQUdELElBQUlFLFdBQVdsQyw2Q0FBTUEsQ0FBQ2dDLElBQUk7WUFBQztTQUFlO1FBQ25GLElBQUksQ0FBQ1AsSUFBSSxHQUFHVSxP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YnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2pvYi5qcz9hOGE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaW52ZXJ0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGRlYnVnbG9nIH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBlcnJvck9iamVjdCwgaXNFbXB0eSwgZ2V0UGFyZW50S2V5LCBsZW5ndGhJblV0ZjhCeXRlcywgcGFyc2VPYmplY3RWYWx1ZXMsIHRyeUNhdGNoLCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEJhY2tvZmZzIH0gZnJvbSAnLi9iYWNrb2Zmcyc7XG5pbXBvcnQgeyBTY3JpcHRzIH0gZnJvbSAnLi9zY3JpcHRzJztcbmltcG9ydCB7IFVucmVjb3ZlcmFibGVFcnJvciB9IGZyb20gJy4vZXJyb3JzL3VucmVjb3ZlcmFibGUtZXJyb3InO1xuY29uc3QgbG9nZ2VyID0gZGVidWdsb2coJ2J1bGwnKTtcbmNvbnN0IG9wdHNEZWNvZGVNYXAgPSB7XG4gICAgZnBvZjogJ2ZhaWxQYXJlbnRPbkZhaWx1cmUnLFxuICAgIGlkb2Y6ICdpZ25vcmVEZXBlbmRlbmN5T25GYWlsdXJlJyxcbiAgICBrbDogJ2tlZXBMb2dzJyxcbiAgICByZG9mOiAncmVtb3ZlRGVwZW5kZW5jeU9uRmFpbHVyZScsXG59O1xuY29uc3Qgb3B0c0VuY29kZU1hcCA9IGludmVydChvcHRzRGVjb2RlTWFwKTtcbmV4cG9ydCBjb25zdCBQUklPUklUWV9MSU1JVCA9IDIgKiogMjE7XG4vKipcbiAqIEpvYlxuICpcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIEpvYiBpbiB0aGUgcXVldWUuIE5vcm1hbGx5IGpvYiBhcmUgaW1wbGljaXRseSBjcmVhdGVkIHdoZW5cbiAqIHlvdSBhZGQgYSBqb2IgdG8gdGhlIHF1ZXVlIHdpdGggbWV0aG9kcyBzdWNoIGFzIFF1ZXVlLmFkZEpvYiggLi4uIClcbiAqXG4gKiBBIEpvYiBpbnN0YW5jZSBpcyBhbHNvIHBhc3NlZCB0byB0aGUgV29ya2VyJ3MgcHJvY2VzcyBmdW5jdGlvbi5cbiAqXG4gKiBAY2xhc3MgSm9iXG4gKi9cbmV4cG9ydCBjbGFzcyBKb2Ige1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgSm9iXG4gICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgICogVGhlIHBheWxvYWQgZm9yIHRoaXMgam9iLlxuICAgICAqL1xuICAgIGRhdGEsIFxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBqb2IuXG4gICAgICovXG4gICAgb3B0cyA9IHt9LCBpZCkge1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9ncmVzcyBhIGpvYiBoYXMgcGVyZm9ybWVkIHNvIGZhci5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yIHdoZW4gcHJvY2Vzc2luZyB0aGlzIGpvYi5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJldHVybnZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YWNrdHJhY2UgZm9yIHRoZSBlcnJvciAoZm9yIGZhaWxlZCBqb2JzKS5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrdHJhY2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHdoZW4gam9iIGlzIG1vdmVkIHRvIGFjdGl2ZS5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzU3RhcnRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgYWZ0ZXIgdGhlIGpvYiBoYXMgZmFpbGVkLlxuICAgICAgICAgKiBAZGVmYXVsdFZhbHVlIDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdHNNYWRlID0gMDtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLm9wdHMsIHsgcmVwZWF0Sm9iS2V5IH0gPSBfYSwgcmVzdE9wdHMgPSBfX3Jlc3QoX2EsIFtcInJlcGVhdEpvYktleVwiXSk7XG4gICAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgfSwgcmVzdE9wdHMpO1xuICAgICAgICB0aGlzLmRlbGF5ID0gdGhpcy5vcHRzLmRlbGF5O1xuICAgICAgICB0aGlzLnJlcGVhdEpvYktleSA9IHJlcGVhdEpvYktleTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBvcHRzLnRpbWVzdGFtcCA/IG9wdHMudGltZXN0YW1wIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5vcHRzLmJhY2tvZmYgPSBCYWNrb2Zmcy5ub3JtYWxpemUob3B0cy5iYWNrb2ZmKTtcbiAgICAgICAgdGhpcy5wYXJlbnRLZXkgPSBnZXRQYXJlbnRLZXkob3B0cy5wYXJlbnQpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50XG4gICAgICAgICAgICA/IHsgaWQ6IG9wdHMucGFyZW50LmlkLCBxdWV1ZUtleTogb3B0cy5wYXJlbnQucXVldWUgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudG9LZXkgPSBxdWV1ZS50b0tleS5iaW5kKHF1ZXVlKTtcbiAgICAgICAgdGhpcy5zY3JpcHRzID0gbmV3IFNjcmlwdHMocXVldWUpO1xuICAgICAgICB0aGlzLnF1ZXVlUXVhbGlmaWVkTmFtZSA9IHF1ZXVlLnF1YWxpZmllZE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgam9iIGFuZCBhZGRzIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZSAtIHRoZSBxdWV1ZSB3aGVyZSB0byBhZGQgdGhlIGpvYi5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBqb2IuXG4gICAgICogQHBhcmFtIGRhdGEgLSB0aGUgcGF5bG9hZCBvZiB0aGUgam9iLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIG9wdGlvbnMgYmFnIGZvciB0aGlzIGpvYi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUocXVldWUsIG5hbWUsIGRhdGEsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBqb2IgPSBuZXcgdGhpcyhxdWV1ZSwgbmFtZSwgZGF0YSwgb3B0cywgb3B0cyAmJiBvcHRzLmpvYklkKTtcbiAgICAgICAgam9iLmlkID0gYXdhaXQgam9iLmFkZEpvYihjbGllbnQsIHtcbiAgICAgICAgICAgIHBhcmVudEtleTogam9iLnBhcmVudEtleSxcbiAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleTogam9iLnBhcmVudEtleVxuICAgICAgICAgICAgICAgID8gYCR7am9iLnBhcmVudEtleX06ZGVwZW5kZW5jaWVzYFxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gam9iO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYnVsayBvZiBqb2JzIGFuZCBhZGRzIHRoZW0gYXRvbWljYWxseSB0byB0aGUgZ2l2ZW4gcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVldWUgLXRoZSBxdWV1ZSB3ZXJlIHRvIGFkZCB0aGUgam9icy5cbiAgICAgKiBAcGFyYW0gam9icyAtIGFuIGFycmF5IG9mIGpvYnMgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZUJ1bGsocXVldWUsIGpvYnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBqb2JJbnN0YW5jZXMgPSBqb2JzLm1hcChqb2IgPT4geyB2YXIgX2E7IHJldHVybiBuZXcgdGhpcyhxdWV1ZSwgam9iLm5hbWUsIGpvYi5kYXRhLCBqb2Iub3B0cywgKF9hID0gam9iLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2JJZCk7IH0pO1xuICAgICAgICBjb25zdCBtdWx0aSA9IGNsaWVudC5tdWx0aSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGpvYiBvZiBqb2JJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGpvYi5hZGRKb2IobXVsdGksIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IGpvYi5wYXJlbnRLZXksXG4gICAgICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5OiBqb2IucGFyZW50S2V5XG4gICAgICAgICAgICAgICAgICAgID8gYCR7am9iLnBhcmVudEtleX06ZGVwZW5kZW5jaWVzYFxuICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IChhd2FpdCBtdWx0aS5leGVjKCkpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlcnIsIGlkXSA9IHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpvYkluc3RhbmNlc1tpbmRleF0uaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gam9iSW5zdGFuY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBKb2IgZnJvbSBhIEpvYkpzb25SYXcgb2JqZWN0IChjb21pbmcgZnJvbSBhIGRlc2VyaWFsaXplZCBKU09OIG9iamVjdClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZSAtIHRoZSBxdWV1ZSB3aGVyZSB0aGUgam9iIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIGpzb24gLSB0aGUgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGpvYi5cbiAgICAgKiBAcGFyYW0gam9iSWQgLSBhbiBvcHRpb25hbCBqb2IgaWQgKG92ZXJyaWRlcyB0aGUgaWQgY29taW5nIGZyb20gdGhlIEpTT04gb2JqZWN0KVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHF1ZXVlLCBqc29uLCBqb2JJZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uLmRhdGEgfHwgJ3t9Jyk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBKb2Iub3B0c0Zyb21KU09OKGpzb24ub3B0cyk7XG4gICAgICAgIGNvbnN0IGpvYiA9IG5ldyB0aGlzKHF1ZXVlLCBqc29uLm5hbWUsIGRhdGEsIG9wdHMsIGpzb24uaWQgfHwgam9iSWQpO1xuICAgICAgICBqb2IucHJvZ3Jlc3MgPSBKU09OLnBhcnNlKGpzb24ucHJvZ3Jlc3MgfHwgJzAnKTtcbiAgICAgICAgam9iLmRlbGF5ID0gcGFyc2VJbnQoanNvbi5kZWxheSk7XG4gICAgICAgIGpvYi50aW1lc3RhbXAgPSBwYXJzZUludChqc29uLnRpbWVzdGFtcCk7XG4gICAgICAgIGlmIChqc29uLmZpbmlzaGVkT24pIHtcbiAgICAgICAgICAgIGpvYi5maW5pc2hlZE9uID0gcGFyc2VJbnQoanNvbi5maW5pc2hlZE9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWRPbikge1xuICAgICAgICAgICAgam9iLnByb2Nlc3NlZE9uID0gcGFyc2VJbnQoanNvbi5wcm9jZXNzZWRPbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24ucmprKSB7XG4gICAgICAgICAgICBqb2IucmVwZWF0Sm9iS2V5ID0ganNvbi5yams7XG4gICAgICAgIH1cbiAgICAgICAgam9iLmZhaWxlZFJlYXNvbiA9IGpzb24uZmFpbGVkUmVhc29uO1xuICAgICAgICBqb2IuYXR0ZW1wdHNTdGFydGVkID0gcGFyc2VJbnQoanNvbi5hdHMgfHwgJzAnKTtcbiAgICAgICAgam9iLmF0dGVtcHRzTWFkZSA9IHBhcnNlSW50KGpzb24uYXR0ZW1wdHNNYWRlIHx8IGpzb24uYXRtIHx8ICcwJyk7XG4gICAgICAgIGpvYi5zdGFja3RyYWNlID0gZ2V0VHJhY2VzKGpzb24uc3RhY2t0cmFjZSk7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5yZXR1cm52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGpvYi5yZXR1cm52YWx1ZSA9IGdldFJldHVyblZhbHVlKGpzb24ucmV0dXJudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnBhcmVudEtleSkge1xuICAgICAgICAgICAgam9iLnBhcmVudEtleSA9IGpzb24ucGFyZW50S2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnBhcmVudCkge1xuICAgICAgICAgICAgam9iLnBhcmVudCA9IEpTT04ucGFyc2UoanNvbi5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnBiKSB7XG4gICAgICAgICAgICBqb2IucHJvY2Vzc2VkQnkgPSBqc29uLnBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2I7XG4gICAgfVxuICAgIHN0YXRpYyBvcHRzRnJvbUpTT04ocmF3T3B0cykge1xuICAgICAgICBjb25zdCBvcHRzID0gSlNPTi5wYXJzZShyYXdPcHRzIHx8ICd7fScpO1xuICAgICAgICBjb25zdCBvcHRpb25FbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob3B0cyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9wdGlvbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFthdHRyaWJ1dGVOYW1lLCB2YWx1ZV0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKG9wdHNEZWNvZGVNYXBbYXR0cmlidXRlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW29wdHNEZWNvZGVNYXBbYXR0cmlidXRlTmFtZV1dID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBKb2IgZnJvbSB0aGUgcXVldWUgZ2l2ZW4gdGhlIHBhc3NlZCBqb2IgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVldWUgLSB0aGUgcXVldWUgd2hlcmUgdGhlIGpvYiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSBqb2JJZCAtIHRoZSBqb2IgaWQuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUlkKHF1ZXVlLCBqb2JJZCkge1xuICAgICAgICAvLyBqb2JJZCBjYW4gYmUgdW5kZWZpbmVkIGlmIG1vdmVKb2IgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgICAgaWYgKGpvYklkKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG4gICAgICAgICAgICBjb25zdCBqb2JEYXRhID0gYXdhaXQgY2xpZW50LmhnZXRhbGwocXVldWUudG9LZXkoam9iSWQpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5KGpvYkRhdGEpXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHRoaXMuZnJvbUpTT04ocXVldWUsIGpvYkRhdGEsIGpvYklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRKb2JMb2dcbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZSBRdWV1ZSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBqb2JJZCBKb2IgaWRcbiAgICAgKiBAcGFyYW0gbG9nUm93IExvZyByb3dcbiAgICAgKiBAcGFyYW0ga2VlcExvZ3Mgb3B0aW9uYWwgbWF4aW11bSBudW1iZXIgb2YgbG9ncyB0byBrZWVwXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIGxvZyBlbnRyaWVzIGZvciB0aGlzIGpvYiBzbyBmYXIuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGFkZEpvYkxvZyhxdWV1ZSwgam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBsb2dzS2V5ID0gcXVldWUudG9LZXkoam9iSWQpICsgJzpsb2dzJztcbiAgICAgICAgY29uc3QgbXVsdGkgPSBjbGllbnQubXVsdGkoKTtcbiAgICAgICAgbXVsdGkucnB1c2gobG9nc0tleSwgbG9nUm93KTtcbiAgICAgICAgaWYgKGtlZXBMb2dzKSB7XG4gICAgICAgICAgICBtdWx0aS5sdHJpbShsb2dzS2V5LCAta2VlcExvZ3MsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgbXVsdGkuZXhlYygpKTtcbiAgICAgICAgcmV0dXJuIGtlZXBMb2dzID8gTWF0aC5taW4oa2VlcExvZ3MsIHJlc3VsdFswXVsxXSkgOiByZXN1bHRbMF1bMV07XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLCB7IHF1ZXVlLCBzY3JpcHRzIH0gPSBfYSwgd2l0aG91dFF1ZXVlQW5kU2NyaXB0cyA9IF9fcmVzdChfYSwgW1wicXVldWVcIiwgXCJzY3JpcHRzXCJdKTtcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRRdWV1ZUFuZFNjcmlwdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgam9iIHRvIGJlIHNlcmlhbGl6ZWQgZm9yIHN0b3JhZ2UgaW4gUmVkaXMuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHR5cGVvZiB0aGlzLmRhdGEgPT09ICd1bmRlZmluZWQnID8ge30gOiB0aGlzLmRhdGEpLFxuICAgICAgICAgICAgb3B0czogdGhpcy5vcHRzQXNKU09OKHRoaXMub3B0cyksXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50ID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudEtleSxcbiAgICAgICAgICAgIHByb2dyZXNzOiB0aGlzLnByb2dyZXNzLFxuICAgICAgICAgICAgYXR0ZW1wdHNNYWRlOiB0aGlzLmF0dGVtcHRzTWFkZSxcbiAgICAgICAgICAgIGF0dGVtcHRzU3RhcnRlZDogdGhpcy5hdHRlbXB0c1N0YXJ0ZWQsXG4gICAgICAgICAgICBmaW5pc2hlZE9uOiB0aGlzLmZpbmlzaGVkT24sXG4gICAgICAgICAgICBwcm9jZXNzZWRPbjogdGhpcy5wcm9jZXNzZWRPbixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAsXG4gICAgICAgICAgICBmYWlsZWRSZWFzb246IEpTT04uc3RyaW5naWZ5KHRoaXMuZmFpbGVkUmVhc29uKSxcbiAgICAgICAgICAgIHN0YWNrdHJhY2U6IEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhY2t0cmFjZSksXG4gICAgICAgICAgICByZXBlYXRKb2JLZXk6IHRoaXMucmVwZWF0Sm9iS2V5LFxuICAgICAgICAgICAgcmV0dXJudmFsdWU6IEpTT04uc3RyaW5naWZ5KHRoaXMucmV0dXJudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRzQXNKU09OKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcHRpb25FbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob3B0cyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9wdGlvbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFthdHRyaWJ1dGVOYW1lLCB2YWx1ZV0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKG9wdHNFbmNvZGVNYXBbYXR0cmlidXRlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW29wdHNFbmNvZGVNYXBbYXR0cmlidXRlTmFtZV1dID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgam9iIHRvIGJlIHBhc3NlZCB0byBTYW5kYm94LlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXNKU09OU2FuZGJveCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hc0pTT04oKSksIHsgcXVldWVOYW1lOiB0aGlzLnF1ZXVlTmFtZSwgcHJlZml4OiB0aGlzLnByZWZpeCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIGpvYidzIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gdGhlIGRhdGEgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIGN1cnJlbnQgam9icyBkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLnVwZGF0ZURhdGEodGhpcywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBqb2IncyBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHByb2dyZXNzIC0gbnVtYmVyIG9yIG9iamVjdCB0byBiZSBzYXZlZCBhcyBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIGF3YWl0IHRoaXMuc2NyaXB0cy51cGRhdGVQcm9ncmVzcyh0aGlzLmlkLCBwcm9ncmVzcyk7XG4gICAgICAgIHRoaXMucXVldWUuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3Mgb25lIHJvdyBvZiBsb2cgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2dSb3cgLSBzdHJpbmcgd2l0aCBsb2cgZGF0YSB0byBiZSBsb2dnZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBsb2cgZW50cmllcyBmb3IgdGhpcyBqb2Igc28gZmFyLlxuICAgICAqL1xuICAgIGFzeW5jIGxvZyhsb2dSb3cpIHtcbiAgICAgICAgcmV0dXJuIEpvYi5hZGRKb2JMb2codGhpcy5xdWV1ZSwgdGhpcy5pZCwgbG9nUm93LCB0aGlzLm9wdHMua2VlcExvZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNoaWxkIGRlcGVuZGVuY3kgZnJvbSBwYXJlbnQgd2hlbiBjaGlsZCBpcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZWxhdGlvbnNoaXAgZXhpc3RlZCBhbmQgaWYgaXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hpbGREZXBlbmRlbmN5KCkge1xuICAgICAgICBjb25zdCBjaGlsZERlcGVuZGVuY3lJc1JlbW92ZWQgPSBhd2FpdCB0aGlzLnNjcmlwdHMucmVtb3ZlQ2hpbGREZXBlbmRlbmN5KHRoaXMuaWQsIHRoaXMucGFyZW50S2V5KTtcbiAgICAgICAgaWYgKGNoaWxkRGVwZW5kZW5jeUlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGpvYidzIGxvZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZWVwTG9ncyAtIHRoZSBhbW91bnQgb2YgbG9nIGVudHJpZXMgdG8gcHJlc2VydmVcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhckxvZ3Moa2VlcExvZ3MpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGxvZ3NLZXkgPSB0aGlzLnRvS2V5KHRoaXMuaWQpICsgJzpsb2dzJztcbiAgICAgICAgaWYgKGtlZXBMb2dzKSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQubHRyaW0obG9nc0tleSwgLWtlZXBMb2dzLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZGVsKGxvZ3NLZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSBqb2IgZnJvbSB0aGUgcXVldWUuXG4gICAgICogTm90ZSwgdGhpcyBjYWxsIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBqb2JcbiAgICAgKiBpcyBiZWluZyBwcm9jZXNzZWQgd2hlbiB0aGUgY2FsbCBpcyBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgdG8gcmVtb3ZlIGEgam9iXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlKHsgcmVtb3ZlQ2hpbGRyZW4gPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLnF1ZXVlLndhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgY29uc3Qgam9iID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHRoaXMuc2NyaXB0cy5yZW1vdmUoam9iLmlkLCByZW1vdmVDaGlsZHJlbik7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICBxdWV1ZS5lbWl0KCdyZW1vdmVkJywgam9iKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSm9iICR7dGhpcy5pZH0gY291bGQgbm90IGJlIHJlbW92ZWQgYmVjYXVzZSBpdCBpcyBsb2NrZWQgYnkgYW5vdGhlciB3b3JrZXJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgdGhlIGxvY2sgZm9yIHRoaXMgam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gdW5pcXVlIHRva2VuIGZvciB0aGUgbG9ja1xuICAgICAqIEBwYXJhbSBkdXJhdGlvbiAtIGxvY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZXh0ZW5kTG9jayh0b2tlbiwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5leHRlbmRMb2NrKHRoaXMuaWQsIHRva2VuLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgam9iIHRvIHRoZSBjb21wbGV0ZWQgcXVldWUuXG4gICAgICogUmV0dXJuZWQgam9iIHRvIGJlIHVzZWQgd2l0aCBRdWV1ZS5wcm90b3R5cGUubmV4dEpvYkZyb21Kb2JEYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJldHVyblZhbHVlIC0gVGhlIGpvYnMgc3VjY2VzcyBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFdvcmtlciB0b2tlbiB1c2VkIHRvIGFjcXVpcmUgY29tcGxldGVkIGpvYi5cbiAgICAgKiBAcGFyYW0gZmV0Y2hOZXh0IC0gVHJ1ZSB3aGVuIHdhbnRpbmcgdG8gZmV0Y2ggdGhlIG5leHQgam9iLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGpvYkRhdGEgb2YgdGhlIG5leHQgam9iIGluIHRoZSB3YWl0aW5nIHF1ZXVlLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb0NvbXBsZXRlZChyZXR1cm5WYWx1ZSwgdG9rZW4sIGZldGNoTmV4dCA9IHRydWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZS53YWl0VW50aWxSZWFkeSgpO1xuICAgICAgICB0aGlzLnJldHVybnZhbHVlID0gcmV0dXJuVmFsdWUgfHwgdm9pZCAwO1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZFJldHVyblZhbHVlID0gdHJ5Q2F0Y2goSlNPTi5zdHJpbmdpZnksIEpTT04sIFtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVkUmV0dXJuVmFsdWUgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvck9iamVjdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5zY3JpcHRzLm1vdmVUb0NvbXBsZXRlZEFyZ3ModGhpcywgc3RyaW5naWZpZWRSZXR1cm5WYWx1ZSwgdGhpcy5vcHRzLnJlbW92ZU9uQ29tcGxldGUsIHRva2VuLCBmZXRjaE5leHQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvRmluaXNoZWQodGhpcy5pZCwgYXJncyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWRPbiA9IGFyZ3NbdGhpcy5zY3JpcHRzLm1vdmVUb0ZpbmlzaGVkS2V5cy5sZW5ndGggKyAxXTtcbiAgICAgICAgdGhpcy5hdHRlbXB0c01hZGUgKz0gMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBqb2IgdG8gdGhlIGZhaWxlZCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgLSB0aGUgam9icyBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIHRva2VuIHRvIGNoZWNrIGpvYiBpcyBsb2NrZWQgYnkgY3VycmVudCB3b3JrZXJcbiAgICAgKiBAcGFyYW0gZmV0Y2hOZXh0IC0gdHJ1ZSB3aGVuIHdhbnRpbmcgdG8gZmV0Y2ggdGhlIG5leHQgam9iXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb0ZhaWxlZChlcnIsIHRva2VuLCBmZXRjaE5leHQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHRoaXMuZmFpbGVkUmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IGNvbW1hbmQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIHRoaXMuc2F2ZVN0YWNrdHJhY2UobXVsdGksIGVycik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIGF1dG9tYXRpYyByZXRyeSBzaG91bGQgYmUgcGVyZm9ybWVkXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBtb3ZlVG9GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpbmlzaGVkT24sIGRlbGF5O1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0c01hZGUgKyAxIDwgdGhpcy5vcHRzLmF0dGVtcHRzICYmXG4gICAgICAgICAgICAhdGhpcy5kaXNjYXJkZWQgJiZcbiAgICAgICAgICAgICEoZXJyIGluc3RhbmNlb2YgVW5yZWNvdmVyYWJsZUVycm9yIHx8IGVyci5uYW1lID09ICdVbnJlY292ZXJhYmxlRXJyb3InKSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHF1ZXVlLm9wdHM7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBiYWNrb2ZmIGlzIG5lZWRlZFxuICAgICAgICAgICAgZGVsYXkgPSBhd2FpdCBCYWNrb2Zmcy5jYWxjdWxhdGUodGhpcy5vcHRzLmJhY2tvZmYsIHRoaXMuYXR0ZW1wdHNNYWRlICsgMSwgZXJyLCB0aGlzLCBvcHRzLnNldHRpbmdzICYmIG9wdHMuc2V0dGluZ3MuYmFja29mZlN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGlmIChkZWxheSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlVG9GYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5zY3JpcHRzLm1vdmVUb0RlbGF5ZWRBcmdzKHRoaXMuaWQsIERhdGUubm93KCkgKyBkZWxheSwgdG9rZW4sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBtdWx0aS5tb3ZlVG9EZWxheWVkKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSAnZGVsYXllZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIG11bHRpLnJldHJ5Sm9iKHRoaXMuc2NyaXB0cy5yZXRyeUpvYkFyZ3ModGhpcy5pZCwgdGhpcy5vcHRzLmxpZm8sIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgY29tbWFuZCA9ICdyZXRyeUpvYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBub3QsIG1vdmUgdG8gZmFpbGVkXG4gICAgICAgICAgICBtb3ZlVG9GYWlsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlVG9GYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnNjcmlwdHMubW92ZVRvRmFpbGVkQXJncyh0aGlzLCBtZXNzYWdlLCB0aGlzLm9wdHMucmVtb3ZlT25GYWlsLCB0b2tlbiwgZmV0Y2hOZXh0KTtcbiAgICAgICAgICAgIG11bHRpLm1vdmVUb0ZpbmlzaGVkKGFyZ3MpO1xuICAgICAgICAgICAgZmluaXNoZWRPbiA9IGFyZ3NbdGhpcy5zY3JpcHRzLm1vdmVUb0ZpbmlzaGVkS2V5cy5sZW5ndGggKyAxXTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSAnZmFpbGVkJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbXVsdGkuZXhlYygpO1xuICAgICAgICBjb25zdCBhbnlFcnJvciA9IHJlc3VsdHMuZmluZChyZXN1bHQgPT4gcmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKGFueUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIFwibW92ZVRvRmFpbGVkXCIgd2l0aCBjb21tYW5kICR7Y29tbWFuZH06ICR7YW55RXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXVsxXTtcbiAgICAgICAgaWYgKGNvZGUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnNjcmlwdHMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgam9iSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2FjdGl2ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluaXNoZWRPbiAmJiB0eXBlb2YgZmluaXNoZWRPbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRPbiA9IGZpbmlzaGVkT247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGF5ICYmIHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dGVtcHRzTWFkZSArPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBpc0NvbXBsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ2NvbXBsZXRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaGFzIGZhaWxlZC5cbiAgICAgKi9cbiAgICBpc0ZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ2ZhaWxlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbiAgICAgKi9cbiAgICBpc0RlbGF5ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5aU2V0KCdkZWxheWVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGpvYiBpcyB3YWl0aW5nIGZvciBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBpc1dhaXRpbmdDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ3dhaXRpbmctY2hpbGRyZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBvZiB0aGUgam9iIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbkxpc3QoJ2FjdGl2ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaXMgd2FpdGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBpc1dhaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5pc0luTGlzdCgnd2FpdCcpKSB8fCAoYXdhaXQgdGhpcy5pc0luTGlzdCgncGF1c2VkJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgcXVldWUgbmFtZSB0aGlzIGpvYiBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIGdldCBxdWV1ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBwcmVmaXggdGhhdCBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCBwcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLm9wdHMucHJlZml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgb25lIG9mIHRoZXNlIHZhbHVlczpcbiAgICAgKiAnY29tcGxldGVkJywgJ2ZhaWxlZCcsICdkZWxheWVkJywgJ2FjdGl2ZScsICd3YWl0aW5nJywgJ3dhaXRpbmctY2hpbGRyZW4nLCAndW5rbm93bicuXG4gICAgICovXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMuZ2V0U3RhdGUodGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBkZWxheSBvZiBhIGRlbGF5ZWQgam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlbGF5IC0gbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkIHRvIGN1cnJlbnQgdGltZS5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgYXN5bmMgY2hhbmdlRGVsYXkoZGVsYXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLmNoYW5nZURlbGF5KHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2Ugam9iIHByaW9yaXR5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGFzeW5jIGNoYW5nZVByaW9yaXR5KG9wdHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLmNoYW5nZVByaW9yaXR5KHRoaXMuaWQsIG9wdHMucHJpb3JpdHksIG9wdHMubGlmbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGlzIGpvYnMgY2hpbGRyZW4gcmVzdWx0IHZhbHVlcyBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBPYmplY3QgbWFwcGluZyBjaGlsZHJlbiBqb2Iga2V5cyB3aXRoIHRoZWlyIHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDaGlsZHJlblZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChhd2FpdCBjbGllbnQuaGdldGFsbCh0aGlzLnRvS2V5KGAke3RoaXMuaWR9OnByb2Nlc3NlZGApKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdFZhbHVlcyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGlzIGpvYnMgY2hpbGRyZW4gZmFpbHVyZSB2YWx1ZXMgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgT2JqZWN0IG1hcHBpbmcgY2hpbGRyZW4gam9iIGtleXMgd2l0aCB0aGVpciBmYWlsdXJlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYWlsZWRDaGlsZHJlblZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuaGdldGFsbCh0aGlzLnRvS2V5KGAke3RoaXMuaWR9OmZhaWxlZGApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNoaWxkcmVuIGpvYiBrZXlzIGlmIHRoaXMgam9iIGlzIGEgcGFyZW50IGFuZCBoYXMgY2hpbGRyZW4uXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb3VudCBvcHRpb25zIGJlZm9yZSBSZWRpcyB2Ny4yIHdvcmtzIGFzIGV4cGVjdGVkIHdpdGggYW55IHF1YW50aXR5IG9mIGVudHJpZXNcbiAgICAgKiBvbiBwcm9jZXNzZWQvdW5wcm9jZXNzZWQgZGVwZW5kZW5jaWVzLCBzaW5jZSB2Ny4yIHlvdSBtdXN0IGNvbnNpZGVyIHRoYXQgY291bnRcbiAgICAgKiB3b24ndCBoYXZlIGFueSBlZmZlY3QgdW50aWwgcHJvY2Vzc2VkL3VucHJvY2Vzc2VkIGRlcGVuZGVuY2llcyBoYXZlIGEgbGVuZ3RoXG4gICAgICogZ3JlYXRlciB0aGFuIDEyN1xuICAgICAqIEBzZWUgaHR0cHM6Ly9yZWRpcy5pby9kb2NzL21hbmFnZW1lbnQvb3B0aW1pemF0aW9uL21lbW9yeS1vcHRpbWl6YXRpb24vI3JlZGlzLS03MlxuICAgICAqIEByZXR1cm5zIGRlcGVuZGVuY2llcyBzZXBhcmF0ZWQgYnkgcHJvY2Vzc2VkIGFuZCB1bnByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBlbmRlbmNpZXMob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBtdWx0aSA9IGNsaWVudC5tdWx0aSgpO1xuICAgICAgICBpZiAoIW9wdHMucHJvY2Vzc2VkICYmICFvcHRzLnVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBtdWx0aS5oZ2V0YWxsKHRoaXMudG9LZXkoYCR7dGhpcy5pZH06cHJvY2Vzc2VkYCkpO1xuICAgICAgICAgICAgbXVsdGkuc21lbWJlcnModGhpcy50b0tleShgJHt0aGlzLmlkfTpkZXBlbmRlbmNpZXNgKSk7XG4gICAgICAgICAgICBjb25zdCBbW2VycjEsIHByb2Nlc3NlZF0sIFtlcnIyLCB1bnByb2Nlc3NlZF1dID0gKGF3YWl0IG11bHRpLmV4ZWMoKSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFByb2Nlc3NlZCA9IHBhcnNlT2JqZWN0VmFsdWVzKHByb2Nlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4geyBwcm9jZXNzZWQ6IHRyYW5zZm9ybWVkUHJvY2Vzc2VkLCB1bnByb2Nlc3NlZCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdE9wdHMgPSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiAwLFxuICAgICAgICAgICAgICAgIGNvdW50OiAyMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0cy5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRPcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0cyksIG9wdHMucHJvY2Vzc2VkKTtcbiAgICAgICAgICAgICAgICBtdWx0aS5oc2Nhbih0aGlzLnRvS2V5KGAke3RoaXMuaWR9OnByb2Nlc3NlZGApLCBwcm9jZXNzZWRPcHRzLmN1cnNvciwgJ0NPVU5UJywgcHJvY2Vzc2VkT3B0cy5jb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy51bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdHMpLCBvcHRzLnVucHJvY2Vzc2VkKTtcbiAgICAgICAgICAgICAgICBtdWx0aS5zc2Nhbih0aGlzLnRvS2V5KGAke3RoaXMuaWR9OmRlcGVuZGVuY2llc2ApLCB1bnByb2Nlc3NlZE9wdHMuY3Vyc29yLCAnQ09VTlQnLCB1bnByb2Nlc3NlZE9wdHMuY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3Jlc3VsdDEsIHJlc3VsdDJdID0gKGF3YWl0IG11bHRpLmV4ZWMoKSk7XG4gICAgICAgICAgICBjb25zdCBbcHJvY2Vzc2VkQ3Vyc29yLCBwcm9jZXNzZWQgPSBbXV0gPSBvcHRzLnByb2Nlc3NlZFxuICAgICAgICAgICAgICAgID8gcmVzdWx0MVsxXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBjb25zdCBbdW5wcm9jZXNzZWRDdXJzb3IsIHVucHJvY2Vzc2VkID0gW11dID0gb3B0cy51bnByb2Nlc3NlZFxuICAgICAgICAgICAgICAgID8gb3B0cy5wcm9jZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQyWzFdXG4gICAgICAgICAgICAgICAgICAgIDogcmVzdWx0MVsxXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFByb2Nlc3NlZCA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb2Nlc3NlZC5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUHJvY2Vzc2VkW3Byb2Nlc3NlZFtpbmRleCAtIDFdXSA9IEpTT04ucGFyc2UocHJvY2Vzc2VkW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHByb2Nlc3NlZEN1cnNvclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQ6IHRyYW5zZm9ybWVkUHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvY2Vzc2VkQ3Vyc29yOiBOdW1iZXIocHJvY2Vzc2VkQ3Vyc29yKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCAodW5wcm9jZXNzZWRDdXJzb3JcbiAgICAgICAgICAgICAgICA/IHsgdW5wcm9jZXNzZWQsIG5leHRVbnByb2Nlc3NlZEN1cnNvcjogTnVtYmVyKHVucHJvY2Vzc2VkQ3Vyc29yKSB9XG4gICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjaGlsZHJlbiBqb2IgY291bnRzIGlmIHRoaXMgam9iIGlzIGEgcGFyZW50IGFuZCBoYXMgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBkZXBlbmRlbmNpZXMgY291bnQgc2VwYXJhdGVkIGJ5IHByb2Nlc3NlZCBhbmQgdW5wcm9jZXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwZW5kZW5jaWVzQ291bnQob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBtdWx0aSA9IGNsaWVudC5tdWx0aSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVkT3B0cyA9ICFvcHRzLnByb2Nlc3NlZCAmJiAhb3B0cy51bnByb2Nlc3NlZFxuICAgICAgICAgICAgPyB7IHByb2Nlc3NlZDogdHJ1ZSwgdW5wcm9jZXNzZWQ6IHRydWUgfVxuICAgICAgICAgICAgOiBvcHRzO1xuICAgICAgICBpZiAodXBkYXRlZE9wdHMucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBtdWx0aS5obGVuKHRoaXMudG9LZXkoYCR7dGhpcy5pZH06cHJvY2Vzc2VkYCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkT3B0cy51bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgbXVsdGkuc2NhcmQodGhpcy50b0tleShgJHt0aGlzLmlkfTpkZXBlbmRlbmNpZXNgKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW1tlcnIxLCByZXN1bHQxXSA9IFtdLCBbZXJyMiwgcmVzdWx0Ml0gPSBbXV0gPSAoYXdhaXQgbXVsdGkuZXhlYygpKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdXBkYXRlZE9wdHMucHJvY2Vzc2VkID8gcmVzdWx0MSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWQgPSB1cGRhdGVkT3B0cy51bnByb2Nlc3NlZFxuICAgICAgICAgICAgPyB1cGRhdGVkT3B0cy5wcm9jZXNzZWRcbiAgICAgICAgICAgICAgICA/IHJlc3VsdDJcbiAgICAgICAgICAgICAgICA6IHJlc3VsdDFcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAodXBkYXRlZE9wdHMucHJvY2Vzc2VkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSksICh1cGRhdGVkT3B0cy51bnByb2Nlc3NlZCA/IHsgdW5wcm9jZXNzZWQgfSA6IHt9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoZSByZXNvbHZlcyB3aGVuIHRoZSBqb2IgaGFzIGNvbXBsZXRlZCAoY29udGFpbmluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBqb2IpLFxuICAgICAqIG9yIHJlamVjdHMgd2hlbiB0aGUgam9iIGhhcyBmYWlsZWQgKGNvbnRhaW5pbmcgdGhlIGZhaWxlZFJlYXNvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVldWVFdmVudHMgLSBJbnN0YW5jZSBvZiBRdWV1ZUV2ZW50cy5cbiAgICAgKiBAcGFyYW0gdHRsIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3Igam9iIHRvIGZpbmlzaCBiZWZvcmUgdGltaW5nIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0VW50aWxGaW5pc2hlZChxdWV1ZUV2ZW50cywgdHRsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucXVldWUud2FpdFVudGlsUmVhZHkoKTtcbiAgICAgICAgY29uc3Qgam9iSWQgPSB0aGlzLmlkO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAodHRsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gb25GYWlsZWQoXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgICAgIGBKb2Igd2FpdCAke3RoaXMubmFtZX0gdGltZWQgb3V0IGJlZm9yZSBmaW5pc2hpbmcsIG5vIGZpbmlzaCBub3RpZmljYXRpb24gYXJyaXZlZCBhZnRlciAke3R0bH1tcyAoaWQ9JHtqb2JJZH0pYCksIHR0bCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlZChhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzLnJldHVybnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbGVkKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGFyZ3MuZmFpbGVkUmVhc29uIHx8IGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZEV2ZW50ID0gYGNvbXBsZXRlZDoke2pvYklkfWA7XG4gICAgICAgICAgICBjb25zdCBmYWlsZWRFdmVudCA9IGBmYWlsZWQ6JHtqb2JJZH1gO1xuICAgICAgICAgICAgcXVldWVFdmVudHMub24oY29tcGxldGVkRXZlbnQsIG9uQ29tcGxldGVkKTtcbiAgICAgICAgICAgIHF1ZXVlRXZlbnRzLm9uKGZhaWxlZEV2ZW50LCBvbkZhaWxlZCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLm9uKCdjbG9zaW5nJywgb25GYWlsZWQpO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZW91dCk7XG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHMucmVtb3ZlTGlzdGVuZXIoY29tcGxldGVkRXZlbnQsIG9uQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50cy5yZW1vdmVMaXN0ZW5lcihmYWlsZWRFdmVudCwgb25GYWlsZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NpbmcnLCBvbkZhaWxlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUG9sbCBvbmNlIHJpZ2h0IG5vdyB0byBzZWUgaWYgdGhlIGpvYiBoYXMgYWxyZWFkeSBmaW5pc2hlZC4gVGhlIGpvYiBtYXkgaGF2ZSBiZWVuIGNvbXBsZXRlZCBiZWZvcmUgd2Ugd2VyZSBhYmxlXG4gICAgICAgICAgICAvLyB0byByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlcnMgb24gdGhlIFF1ZXVlRXZlbnRzLCBzbyB3ZSBjaGVjayBoZXJlIHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3Qgd2FpdGluZyBmb3IgYW4gZXZlbnRcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIGFscmVhZHkgaGFwcGVuZWQuIFdlIGJsb2NrIGNoZWNraW5nIHRoZSBqb2IgdW50aWwgdGhlIHF1ZXVlIGV2ZW50cyBvYmplY3QgaXMgYWN0dWFsbHkgbGlzdGVuaW5nIHRvXG4gICAgICAgICAgICAvLyBSZWRpcyBzbyB0aGVyZSdzIG5vIGNoYW5jZSB0aGF0IGl0IHdpbGwgbWlzcyBldmVudHMuXG4gICAgICAgICAgICBhd2FpdCBxdWV1ZUV2ZW50cy53YWl0VW50aWxSZWFkeSgpO1xuICAgICAgICAgICAgY29uc3QgW3N0YXR1cywgcmVzdWx0XSA9IChhd2FpdCB0aGlzLnNjcmlwdHMuaXNGaW5pc2hlZChqb2JJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uc3QgZmluaXNoZWQgPSBzdGF0dXMgIT0gMDtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gLTEgfHwgc3RhdHVzID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25GYWlsZWQoeyBmYWlsZWRSZWFzb246IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGVkKHsgcmV0dXJudmFsdWU6IGdldFJldHVyblZhbHVlKHJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGpvYiB0byB0aGUgZGVsYXkgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRpbWVzdGFtcCB3aGVyZSB0aGUgam9iIHNob3VsZCBiZSBtb3ZlZCBiYWNrIHRvIFwid2FpdFwiXG4gICAgICogQHBhcmFtIHRva2VuIC0gdG9rZW4gdG8gY2hlY2sgam9iIGlzIGxvY2tlZCBieSBjdXJyZW50IHdvcmtlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgbW92ZVRvRGVsYXllZCh0aW1lc3RhbXAsIHRva2VuKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gdGltZXN0YW1wIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgbW92ZWRUb0RlbGF5ZWQgPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvRGVsYXllZCh0aGlzLmlkLCB0aW1lc3RhbXAsIGRlbGF5ID4gMCA/IGRlbGF5IDogMCwgdG9rZW4sIHsgc2tpcEF0dGVtcHQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBtb3ZlZFRvRGVsYXllZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGpvYiB0byB0aGUgd2FpdGluZy1jaGlsZHJlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiB0byBjaGVjayBqb2IgaXMgbG9ja2VkIGJ5IGN1cnJlbnQgd29ya2VyXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucyBiYWcgZm9yIG1vdmluZyBhIGpvYiB0byB3YWl0aW5nLWNoaWxkcmVuLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGpvYiB3YXMgbW92ZWRcbiAgICAgKi9cbiAgICBhc3luYyBtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4odG9rZW4sIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb3ZlZFRvV2FpdGluZ0NoaWxkcmVuID0gYXdhaXQgdGhpcy5zY3JpcHRzLm1vdmVUb1dhaXRpbmdDaGlsZHJlbih0aGlzLmlkLCB0b2tlbiwgb3B0cyk7XG4gICAgICAgIHJldHVybiBtb3ZlZFRvV2FpdGluZ0NoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9tb3RlcyBhIGRlbGF5ZWQgam9iIHNvIHRoYXQgaXQgc3RhcnRzIHRvIGJlIHByb2Nlc3NlZCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHByb21vdGUoKSB7XG4gICAgICAgIGNvbnN0IGpvYklkID0gdGhpcy5pZDtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLnByb21vdGUoam9iSWQpO1xuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmV0cnkgdGhlIGpvYi4gT25seSBhIGpvYiB0aGF0IGhhcyBmYWlsZWQgb3IgY29tcGxldGVkIGNhbiBiZSByZXRyaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIC0gY29tcGxldGVkIC8gZmFpbGVkXG4gICAgICogQHJldHVybnMgSWYgcmVzb2x2ZWQgYW5kIHJldHVybiBjb2RlIGlzIDEsIHRoZW4gdGhlIHF1ZXVlIGVtaXRzIGEgd2FpdGluZyBldmVudFxuICAgICAqIG90aGVyd2lzZSB0aGUgb3BlcmF0aW9uIHdhcyBub3QgYSBzdWNjZXNzIGFuZCB0aHJvdyB0aGUgY29ycmVzcG9uZGluZyBlcnJvci4gSWYgdGhlIHByb21pc2VcbiAgICAgKiByZWplY3RzLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgc2NyaXB0IGZhaWxlZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgcmV0cnkoc3RhdGUgPSAnZmFpbGVkJykge1xuICAgICAgICB0aGlzLmZhaWxlZFJlYXNvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluaXNoZWRPbiA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkT24gPSBudWxsO1xuICAgICAgICB0aGlzLnJldHVybnZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5yZXByb2Nlc3NKb2IodGhpcywgc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIGpvYiB0byBub3QgYmUgcmV0cmllZCBpZiBpdCBmYWlscyAoZXZlbiBpZiBhdHRlbXB0cyBoYXMgYmVlbiBjb25maWd1cmVkKVxuICAgICAqL1xuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgaXNJblpTZXQoc2V0KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBzY29yZSA9IGF3YWl0IGNsaWVudC56c2NvcmUodGhpcy5xdWV1ZS50b0tleShzZXQpLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIHNjb3JlICE9PSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBpc0luTGlzdChsaXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMuaXNKb2JJbkxpc3QodGhpcy5xdWV1ZS50b0tleShsaXN0KSwgdGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGpvYiB0byBSZWRpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnQgLVxuICAgICAqIEBwYXJhbSBwYXJlbnRPcHRzIC1cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFkZEpvYihjbGllbnQsIHBhcmVudE9wdHMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IHRoaXMuYXNKU09OKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVPcHRpb25zKGpvYkRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLmFkZEpvYihjbGllbnQsIGpvYkRhdGEsIGpvYkRhdGEub3B0cywgdGhpcy5pZCwgcGFyZW50T3B0cyk7XG4gICAgfVxuICAgIHZhbGlkYXRlT3B0aW9ucyhqb2JEYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZXhjZWVkTGltaXQgPSB0aGlzLm9wdHMuc2l6ZUxpbWl0ICYmXG4gICAgICAgICAgICBsZW5ndGhJblV0ZjhCeXRlcyhqb2JEYXRhLmRhdGEpID4gdGhpcy5vcHRzLnNpemVMaW1pdDtcbiAgICAgICAgaWYgKGV4Y2VlZExpbWl0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIGpvYiAke3RoaXMubmFtZX0gZXhjZWVkcyB0aGUgbGltaXQgJHt0aGlzLm9wdHMuc2l6ZUxpbWl0fSBieXRlc2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGVsYXkgJiYgdGhpcy5vcHRzLnJlcGVhdCAmJiAhKChfYSA9IHRoaXMub3B0cy5yZXBlYXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVsYXkgYW5kIHJlcGVhdCBvcHRpb25zIGNvdWxkIG5vdCBiZSB1c2VkIHRvZ2V0aGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5yZW1vdmVEZXBlbmRlbmN5T25GYWlsdXJlICYmIHRoaXMub3B0cy5mYWlsUGFyZW50T25GYWlsdXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUgYW5kIGZhaWxQYXJlbnRPbkZhaWx1cmUgb3B0aW9ucyBjYW4gbm90IGJlIHVzZWQgdG9nZXRoZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYCR7cGFyc2VJbnQodGhpcy5pZCwgMTApfWAgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIElkcyBjYW5ub3QgYmUgaW50ZWdlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC50cnVuYyh0aGlzLm9wdHMucHJpb3JpdHkpICE9PSB0aGlzLm9wdHMucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByaW9yaXR5IHNob3VsZCBub3QgYmUgZmxvYXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMucHJpb3JpdHkgPiBQUklPUklUWV9MSU1JVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJpb3JpdHkgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHtQUklPUklUWV9MSU1JVH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzYXZlU3RhY2t0cmFjZShtdWx0aSwgZXJyKSB7XG4gICAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IHRoaXMuc3RhY2t0cmFjZSB8fCBbXTtcbiAgICAgICAgaWYgKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5zdGFjaykge1xuICAgICAgICAgICAgdGhpcy5zdGFja3RyYWNlLnB1c2goZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc3RhY2tUcmFjZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja3RyYWNlID0gdGhpcy5zdGFja3RyYWNlLnNsaWNlKDAsIHRoaXMub3B0cy5zdGFja1RyYWNlTGltaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnNjcmlwdHMuc2F2ZVN0YWNrdHJhY2VBcmdzKHRoaXMuaWQsIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhY2t0cmFjZSksIGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKTtcbiAgICAgICAgbXVsdGkuc2F2ZVN0YWNrdHJhY2UoYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhY2VzKHN0YWNrdHJhY2UpIHtcbiAgICBjb25zdCB0cmFjZXMgPSB0cnlDYXRjaChKU09OLnBhcnNlLCBKU09OLCBbc3RhY2t0cmFjZV0pO1xuICAgIGlmICh0cmFjZXMgPT09IGVycm9yT2JqZWN0IHx8ICEodHJhY2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmV0dXJuVmFsdWUoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0cnlDYXRjaChKU09OLnBhcnNlLCBKU09OLCBbX3ZhbHVlXSk7XG4gICAgaWYgKHZhbHVlICE9PSBlcnJvck9iamVjdCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIoJ2NvcnJ1cHRlZCByZXR1cm52YWx1ZTogJyArIF92YWx1ZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiaW52ZXJ0IiwiZGVidWdsb2ciLCJlcnJvck9iamVjdCIsImlzRW1wdHkiLCJnZXRQYXJlbnRLZXkiLCJsZW5ndGhJblV0ZjhCeXRlcyIsInBhcnNlT2JqZWN0VmFsdWVzIiwidHJ5Q2F0Y2giLCJCYWNrb2ZmcyIsIlNjcmlwdHMiLCJVbnJlY292ZXJhYmxlRXJyb3IiLCJsb2dnZXIiLCJvcHRzRGVjb2RlTWFwIiwiZnBvZiIsImlkb2YiLCJrbCIsInJkb2YiLCJvcHRzRW5jb2RlTWFwIiwiUFJJT1JJVFlfTElNSVQiLCJKb2IiLCJjb25zdHJ1Y3RvciIsInF1ZXVlIiwibmFtZSIsImRhdGEiLCJvcHRzIiwiaWQiLCJwcm9ncmVzcyIsInJldHVybnZhbHVlIiwic3RhY2t0cmFjZSIsImF0dGVtcHRzU3RhcnRlZCIsImF0dGVtcHRzTWFkZSIsIl9hIiwicmVwZWF0Sm9iS2V5IiwicmVzdE9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJhdHRlbXB0cyIsImRlbGF5IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImJhY2tvZmYiLCJub3JtYWxpemUiLCJwYXJlbnRLZXkiLCJwYXJlbnQiLCJxdWV1ZUtleSIsInVuZGVmaW5lZCIsInRvS2V5IiwiYmluZCIsInNjcmlwdHMiLCJxdWV1ZVF1YWxpZmllZE5hbWUiLCJxdWFsaWZpZWROYW1lIiwiY3JlYXRlIiwiY2xpZW50Iiwiam9iIiwiam9iSWQiLCJhZGRKb2IiLCJwYXJlbnREZXBlbmRlbmNpZXNLZXkiLCJjcmVhdGVCdWxrIiwiam9icyIsImpvYkluc3RhbmNlcyIsIm1hcCIsIm11bHRpIiwicmVzdWx0cyIsImV4ZWMiLCJpbmRleCIsImxlbmd0aCIsImVyciIsImZyb21KU09OIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIm9wdHNGcm9tSlNPTiIsInBhcnNlSW50IiwiZmluaXNoZWRPbiIsInByb2Nlc3NlZE9uIiwicmprIiwiZmFpbGVkUmVhc29uIiwiYXRzIiwiYXRtIiwiZ2V0VHJhY2VzIiwiZ2V0UmV0dXJuVmFsdWUiLCJwYiIsInByb2Nlc3NlZEJ5IiwicmF3T3B0cyIsIm9wdGlvbkVudHJpZXMiLCJlbnRyaWVzIiwib3B0aW9ucyIsIml0ZW0iLCJhdHRyaWJ1dGVOYW1lIiwidmFsdWUiLCJmcm9tSWQiLCJqb2JEYXRhIiwiaGdldGFsbCIsImFkZEpvYkxvZyIsImxvZ1JvdyIsImtlZXBMb2dzIiwibG9nc0tleSIsInJwdXNoIiwibHRyaW0iLCJyZXN1bHQiLCJNYXRoIiwibWluIiwidG9KU09OIiwid2l0aG91dFF1ZXVlQW5kU2NyaXB0cyIsImFzSlNPTiIsInN0cmluZ2lmeSIsIm9wdHNBc0pTT04iLCJhc0pTT05TYW5kYm94IiwicXVldWVOYW1lIiwicHJlZml4IiwidXBkYXRlRGF0YSIsInVwZGF0ZVByb2dyZXNzIiwiZW1pdCIsImxvZyIsInJlbW92ZUNoaWxkRGVwZW5kZW5jeSIsImNoaWxkRGVwZW5kZW5jeUlzUmVtb3ZlZCIsImNsZWFyTG9ncyIsImRlbCIsInJlbW92ZSIsInJlbW92ZUNoaWxkcmVuIiwid2FpdFVudGlsUmVhZHkiLCJyZW1vdmVkIiwiRXJyb3IiLCJleHRlbmRMb2NrIiwidG9rZW4iLCJkdXJhdGlvbiIsIm1vdmVUb0NvbXBsZXRlZCIsInJldHVyblZhbHVlIiwiZmV0Y2hOZXh0Iiwic3RyaW5naWZpZWRSZXR1cm5WYWx1ZSIsImFyZ3MiLCJtb3ZlVG9Db21wbGV0ZWRBcmdzIiwicmVtb3ZlT25Db21wbGV0ZSIsIm1vdmVUb0ZpbmlzaGVkIiwibW92ZVRvRmluaXNoZWRLZXlzIiwibW92ZVRvRmFpbGVkIiwibWVzc2FnZSIsImNvbW1hbmQiLCJzYXZlU3RhY2t0cmFjZSIsImRpc2NhcmRlZCIsImNhbGN1bGF0ZSIsInNldHRpbmdzIiwiYmFja29mZlN0cmF0ZWd5IiwibW92ZVRvRGVsYXllZEFyZ3MiLCJtb3ZlVG9EZWxheWVkIiwicmV0cnlKb2IiLCJyZXRyeUpvYkFyZ3MiLCJsaWZvIiwibW92ZVRvRmFpbGVkQXJncyIsInJlbW92ZU9uRmFpbCIsImFueUVycm9yIiwiZmluZCIsImNvZGUiLCJmaW5pc2hlZEVycm9ycyIsInN0YXRlIiwiaXNDb21wbGV0ZWQiLCJpc0luWlNldCIsImlzRmFpbGVkIiwiaXNEZWxheWVkIiwiaXNXYWl0aW5nQ2hpbGRyZW4iLCJpc0FjdGl2ZSIsImlzSW5MaXN0IiwiaXNXYWl0aW5nIiwiZ2V0U3RhdGUiLCJjaGFuZ2VEZWxheSIsImNoYW5nZVByaW9yaXR5IiwicHJpb3JpdHkiLCJnZXRDaGlsZHJlblZhbHVlcyIsImdldEZhaWxlZENoaWxkcmVuVmFsdWVzIiwiZ2V0RGVwZW5kZW5jaWVzIiwicHJvY2Vzc2VkIiwidW5wcm9jZXNzZWQiLCJzbWVtYmVycyIsImVycjEiLCJlcnIyIiwidHJhbnNmb3JtZWRQcm9jZXNzZWQiLCJkZWZhdWx0T3B0cyIsImN1cnNvciIsImNvdW50IiwicHJvY2Vzc2VkT3B0cyIsImhzY2FuIiwidW5wcm9jZXNzZWRPcHRzIiwic3NjYW4iLCJyZXN1bHQxIiwicmVzdWx0MiIsInByb2Nlc3NlZEN1cnNvciIsInVucHJvY2Vzc2VkQ3Vyc29yIiwibmV4dFByb2Nlc3NlZEN1cnNvciIsIk51bWJlciIsIm5leHRVbnByb2Nlc3NlZEN1cnNvciIsImdldERlcGVuZGVuY2llc0NvdW50IiwidXBkYXRlZE9wdHMiLCJobGVuIiwic2NhcmQiLCJ3YWl0VW50aWxGaW5pc2hlZCIsInF1ZXVlRXZlbnRzIiwidHRsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsIm9uRmFpbGVkIiwib25Db21wbGV0ZWQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJjb21wbGV0ZWRFdmVudCIsImZhaWxlZEV2ZW50Iiwib24iLCJjbGVhckludGVydmFsIiwicmVtb3ZlTGlzdGVuZXIiLCJzdGF0dXMiLCJpc0ZpbmlzaGVkIiwiZmluaXNoZWQiLCJtb3ZlZFRvRGVsYXllZCIsInNraXBBdHRlbXB0IiwibW92ZVRvV2FpdGluZ0NoaWxkcmVuIiwibW92ZWRUb1dhaXRpbmdDaGlsZHJlbiIsInByb21vdGUiLCJyZXRyeSIsInJlcHJvY2Vzc0pvYiIsImRpc2NhcmQiLCJzZXQiLCJzY29yZSIsInpzY29yZSIsImxpc3QiLCJpc0pvYkluTGlzdCIsInBhcmVudE9wdHMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJleGNlZWRMaW1pdCIsInNpemVMaW1pdCIsInJlcGVhdCIsInJlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUiLCJmYWlsUGFyZW50T25GYWlsdXJlIiwidHJ1bmMiLCJzdGFjayIsInB1c2giLCJzdGFja1RyYWNlTGltaXQiLCJzbGljZSIsInNhdmVTdGFja3RyYWNlQXJncyIsInRyYWNlcyIsIkFycmF5IiwiX3ZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-base.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueBase: () => (/* binding */ QueueBase)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\");\n\n\n\n\n\n\n/**\n * @class QueueBase\n * @extends EventEmitter\n *\n * @description Base class for all classes that need to interact with queues.\n * This class is normally not used directly, but extended by the other classes.\n *\n */ class QueueBase extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n     *\n     * @param name - The name of the queue.\n     * @param opts - Options for the queue.\n     * @param Connection - An optional \"Connection\" class used to instantiate a Connection. This is useful for\n     * testing with mockups and/or extending the Connection class and passing an alternate implementation.\n     */ constructor(name, opts = {\n        connection: {}\n    }, Connection = _redis_connection__WEBPACK_IMPORTED_MODULE_2__.RedisConnection){\n        super();\n        this.name = name;\n        this.opts = opts;\n        this.closed = false;\n        this.opts = Object.assign({\n            prefix: \"bull\"\n        }, opts);\n        if (!name) {\n            throw new Error(\"Queue name must be provided\");\n        }\n        this.connection = new Connection(opts.connection, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isRedisInstance)(opts.connection), opts.blockingConnection, opts.skipVersionCheck);\n        this.connection.on(\"error\", (error)=>this.emit(\"error\", error));\n        this.connection.on(\"close\", ()=>{\n            if (!this.closing) {\n                this.emit(\"ioredis:close\");\n            }\n        });\n        const queueKeys = new _queue_keys__WEBPACK_IMPORTED_MODULE_4__.QueueKeys(opts.prefix);\n        this.qualifiedName = queueKeys.getQueueQualifiedName(name);\n        this.keys = queueKeys.getKeys(name);\n        this.toKey = (type)=>queueKeys.toKey(name, type);\n        this.scripts = new _scripts__WEBPACK_IMPORTED_MODULE_5__.Scripts(this);\n    }\n    /**\n     * Returns a promise that resolves to a redis client. Normally used only by subclasses.\n     */ get client() {\n        return this.connection.client;\n    }\n    /**\n     * Returns the version of the Redis instance the client is connected to,\n     */ get redisVersion() {\n        return this.connection.redisVersion;\n    }\n    /**\n     * Helper to easily extend Job class calls.\n     */ get Job() {\n        return _job__WEBPACK_IMPORTED_MODULE_3__.Job;\n    }\n    /**\n     * Emits an event. Normally used by subclasses to emit events.\n     *\n     * @param event - The emitted event.\n     * @param args -\n     * @returns\n     */ emit(event, ...args) {\n        try {\n            return super.emit(event, ...args);\n        } catch (err) {\n            try {\n                return super.emit(\"error\", err);\n            } catch (err) {\n                // We give up if the error event also throws an exception.\n                console.error(err);\n                return false;\n            }\n        }\n    }\n    waitUntilReady() {\n        return this.client;\n    }\n    base64Name() {\n        return Buffer.from(this.name).toString(\"base64\");\n    }\n    clientName(suffix = \"\") {\n        const queueNameBase64 = this.base64Name();\n        return `${this.opts.prefix}:${queueNameBase64}${suffix}`;\n    }\n    /**\n     *\n     * Closes the connection and returns a promise that resolves when the connection is closed.\n     */ async close() {\n        if (!this.closing) {\n            this.closing = this.connection.close();\n        }\n        await this.closing;\n        this.closed = true;\n    }\n    /**\n     *\n     * Force disconnects a connection.\n     */ disconnect() {\n        return this.connection.disconnect();\n    }\n    async checkConnectionError(fn, delayInMs = _utils__WEBPACK_IMPORTED_MODULE_1__.DELAY_TIME_5) {\n        try {\n            return await fn();\n        } catch (error) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNotConnectionError)(error)) {\n                this.emit(\"error\", error);\n            }\n            if (!this.closing && delayInMs) {\n                await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.delay)(delayInMs);\n            } else {\n                return;\n            }\n        }\n    }\n} //# sourceMappingURL=queue-base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUNpRDtBQUNsQztBQUN6QjtBQUNhO0FBQ0w7QUFDcEM7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1TLGtCQUFrQlQsZ0RBQVlBO0lBQ3ZDOzs7Ozs7S0FNQyxHQUNEVSxZQUFZQyxJQUFJLEVBQUVDLE9BQU87UUFBRUMsWUFBWSxDQUFDO0lBQUUsQ0FBQyxFQUFFQyxhQUFhVCw4REFBZSxDQUFFO1FBQ3ZFLEtBQUs7UUFDTCxJQUFJLENBQUNNLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0gsSUFBSSxHQUFHSSxPQUFPQyxNQUFNLENBQUM7WUFBRUMsUUFBUTtRQUFPLEdBQUdOO1FBQzlDLElBQUksQ0FBQ0QsTUFBTTtZQUNQLE1BQU0sSUFBSVEsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ04sVUFBVSxHQUFHLElBQUlDLFdBQVdGLEtBQUtDLFVBQVUsRUFBRVQsdURBQWVBLENBQUNRLEtBQUtDLFVBQVUsR0FBR0QsS0FBS1Esa0JBQWtCLEVBQUVSLEtBQUtTLGdCQUFnQjtRQUNsSSxJQUFJLENBQUNSLFVBQVUsQ0FBQ1MsRUFBRSxDQUFDLFNBQVMsQ0FBQ0MsUUFBVSxJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDtRQUMxRCxJQUFJLENBQUNWLFVBQVUsQ0FBQ1MsRUFBRSxDQUFDLFNBQVM7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0csT0FBTyxFQUFFO2dCQUNmLElBQUksQ0FBQ0QsSUFBSSxDQUFDO1lBQ2Q7UUFDSjtRQUNBLE1BQU1FLFlBQVksSUFBSW5CLGtEQUFTQSxDQUFDSyxLQUFLTSxNQUFNO1FBQzNDLElBQUksQ0FBQ1MsYUFBYSxHQUFHRCxVQUFVRSxxQkFBcUIsQ0FBQ2pCO1FBQ3JELElBQUksQ0FBQ2tCLElBQUksR0FBR0gsVUFBVUksT0FBTyxDQUFDbkI7UUFDOUIsSUFBSSxDQUFDb0IsS0FBSyxHQUFHLENBQUNDLE9BQVNOLFVBQVVLLEtBQUssQ0FBQ3BCLE1BQU1xQjtRQUM3QyxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJekIsNkNBQU9BLENBQUMsSUFBSTtJQUNuQztJQUNBOztLQUVDLEdBQ0QsSUFBSTBCLFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ3FCLE1BQU07SUFDakM7SUFDQTs7S0FFQyxHQUNELElBQUlDLGVBQWU7UUFDZixPQUFPLElBQUksQ0FBQ3RCLFVBQVUsQ0FBQ3NCLFlBQVk7SUFDdkM7SUFDQTs7S0FFQyxHQUNELElBQUk3QixNQUFNO1FBQ04sT0FBT0EscUNBQUdBO0lBQ2Q7SUFDQTs7Ozs7O0tBTUMsR0FDRGtCLEtBQUtZLEtBQUssRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsSUFBSTtZQUNBLE9BQU8sS0FBSyxDQUFDYixLQUFLWSxVQUFVQztRQUNoQyxFQUNBLE9BQU9DLEtBQUs7WUFDUixJQUFJO2dCQUNBLE9BQU8sS0FBSyxDQUFDZCxLQUFLLFNBQVNjO1lBQy9CLEVBQ0EsT0FBT0EsS0FBSztnQkFDUiwwREFBMEQ7Z0JBQzFEQyxRQUFRaEIsS0FBSyxDQUFDZTtnQkFDZCxPQUFPO1lBQ1g7UUFDSjtJQUNKO0lBQ0FFLGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDTixNQUFNO0lBQ3RCO0lBQ0FPLGFBQWE7UUFDVCxPQUFPQyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDaEMsSUFBSSxFQUFFaUMsUUFBUSxDQUFDO0lBQzNDO0lBQ0FDLFdBQVdDLFNBQVMsRUFBRSxFQUFFO1FBQ3BCLE1BQU1DLGtCQUFrQixJQUFJLENBQUNOLFVBQVU7UUFDdkMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDN0IsSUFBSSxDQUFDTSxNQUFNLENBQUMsQ0FBQyxFQUFFNkIsZ0JBQWdCLEVBQUVELE9BQU8sQ0FBQztJQUM1RDtJQUNBOzs7S0FHQyxHQUNELE1BQU1FLFFBQVE7UUFDVixJQUFJLENBQUMsSUFBSSxDQUFDdkIsT0FBTyxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDWixVQUFVLENBQUNtQyxLQUFLO1FBQ3hDO1FBQ0EsTUFBTSxJQUFJLENBQUN2QixPQUFPO1FBQ2xCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO0lBQ2xCO0lBQ0E7OztLQUdDLEdBQ0RrQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNwQyxVQUFVLENBQUNvQyxVQUFVO0lBQ3JDO0lBQ0EsTUFBTUMscUJBQXFCQyxFQUFFLEVBQUVDLFlBQVlsRCxnREFBWSxFQUFFO1FBQ3JELElBQUk7WUFDQSxPQUFPLE1BQU1pRDtRQUNqQixFQUNBLE9BQU81QixPQUFPO1lBQ1YsSUFBSXBCLDREQUFvQkEsQ0FBQ29CLFFBQVE7Z0JBQzdCLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVNEO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxJQUFJMkIsV0FBVztnQkFDNUIsTUFBTW5ELDZDQUFLQSxDQUFDbUQ7WUFDaEIsT0FDSztnQkFDRDtZQUNKO1FBQ0o7SUFDSjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9xdWV1ZS1iYXNlLmpzPzZmMTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IGRlbGF5LCBERUxBWV9USU1FXzUsIGlzTm90Q29ubmVjdGlvbkVycm9yLCBpc1JlZGlzSW5zdGFuY2UsIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgUmVkaXNDb25uZWN0aW9uIH0gZnJvbSAnLi9yZWRpcy1jb25uZWN0aW9uJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IFF1ZXVlS2V5cyB9IGZyb20gJy4vcXVldWUta2V5cyc7XG5pbXBvcnQgeyBTY3JpcHRzIH0gZnJvbSAnLi9zY3JpcHRzJztcbi8qKlxuICogQGNsYXNzIFF1ZXVlQmFzZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKlxuICogQGRlc2NyaXB0aW9uIEJhc2UgY2xhc3MgZm9yIGFsbCBjbGFzc2VzIHRoYXQgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHF1ZXVlcy5cbiAqIFRoaXMgY2xhc3MgaXMgbm9ybWFsbHkgbm90IHVzZWQgZGlyZWN0bHksIGJ1dCBleHRlbmRlZCBieSB0aGUgb3RoZXIgY2xhc3Nlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZUJhc2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGZvciB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIENvbm5lY3Rpb24gLSBBbiBvcHRpb25hbCBcIkNvbm5lY3Rpb25cIiBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGEgQ29ubmVjdGlvbi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAgICogdGVzdGluZyB3aXRoIG1vY2t1cHMgYW5kL29yIGV4dGVuZGluZyB0aGUgQ29ubmVjdGlvbiBjbGFzcyBhbmQgcGFzc2luZyBhbiBhbHRlcm5hdGUgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0cyA9IHsgY29ubmVjdGlvbjoge30gfSwgQ29ubmVjdGlvbiA9IFJlZGlzQ29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHsgcHJlZml4OiAnYnVsbCcgfSwgb3B0cyk7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWV1ZSBuYW1lIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihvcHRzLmNvbm5lY3Rpb24sIGlzUmVkaXNJbnN0YW5jZShvcHRzLmNvbm5lY3Rpb24pLCBvcHRzLmJsb2NraW5nQ29ubmVjdGlvbiwgb3B0cy5za2lwVmVyc2lvbkNoZWNrKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdlcnJvcicsIChlcnJvcikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaW9yZWRpczpjbG9zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gbmV3IFF1ZXVlS2V5cyhvcHRzLnByZWZpeCk7XG4gICAgICAgIHRoaXMucXVhbGlmaWVkTmFtZSA9IHF1ZXVlS2V5cy5nZXRRdWV1ZVF1YWxpZmllZE5hbWUobmFtZSk7XG4gICAgICAgIHRoaXMua2V5cyA9IHF1ZXVlS2V5cy5nZXRLZXlzKG5hbWUpO1xuICAgICAgICB0aGlzLnRvS2V5ID0gKHR5cGUpID0+IHF1ZXVlS2V5cy50b0tleShuYW1lLCB0eXBlKTtcbiAgICAgICAgdGhpcy5zY3JpcHRzID0gbmV3IFNjcmlwdHModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSByZWRpcyBjbGllbnQuIE5vcm1hbGx5IHVzZWQgb25seSBieSBzdWJjbGFzc2VzLlxuICAgICAqL1xuICAgIGdldCBjbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoZSBSZWRpcyBpbnN0YW5jZSB0aGUgY2xpZW50IGlzIGNvbm5lY3RlZCB0byxcbiAgICAgKi9cbiAgICBnZXQgcmVkaXNWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnJlZGlzVmVyc2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIGVhc2lseSBleHRlbmQgSm9iIGNsYXNzIGNhbGxzLlxuICAgICAqL1xuICAgIGdldCBKb2IoKSB7XG4gICAgICAgIHJldHVybiBKb2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50LiBOb3JtYWxseSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gZW1pdCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZW1pdHRlZCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJncyAtXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdpdmUgdXAgaWYgdGhlIGVycm9yIGV2ZW50IGFsc28gdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQ7XG4gICAgfVxuICAgIGJhc2U2NE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLm5hbWUpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgY2xpZW50TmFtZShzdWZmaXggPSAnJykge1xuICAgICAgICBjb25zdCBxdWV1ZU5hbWVCYXNlNjQgPSB0aGlzLmJhc2U2NE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0cy5wcmVmaXh9OiR7cXVldWVOYW1lQmFzZTY0fSR7c3VmZml4fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nID0gdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zaW5nO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRm9yY2UgZGlzY29ubmVjdHMgYSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0Nvbm5lY3Rpb25FcnJvcihmbiwgZGVsYXlJbk1zID0gREVMQVlfVElNRV81KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc05vdENvbm5lY3Rpb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcgJiYgZGVsYXlJbk1zKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLWJhc2UuanMubWFwIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsImRlbGF5IiwiREVMQVlfVElNRV81IiwiaXNOb3RDb25uZWN0aW9uRXJyb3IiLCJpc1JlZGlzSW5zdGFuY2UiLCJSZWRpc0Nvbm5lY3Rpb24iLCJKb2IiLCJRdWV1ZUtleXMiLCJTY3JpcHRzIiwiUXVldWVCYXNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwib3B0cyIsImNvbm5lY3Rpb24iLCJDb25uZWN0aW9uIiwiY2xvc2VkIiwiT2JqZWN0IiwiYXNzaWduIiwicHJlZml4IiwiRXJyb3IiLCJibG9ja2luZ0Nvbm5lY3Rpb24iLCJza2lwVmVyc2lvbkNoZWNrIiwib24iLCJlcnJvciIsImVtaXQiLCJjbG9zaW5nIiwicXVldWVLZXlzIiwicXVhbGlmaWVkTmFtZSIsImdldFF1ZXVlUXVhbGlmaWVkTmFtZSIsImtleXMiLCJnZXRLZXlzIiwidG9LZXkiLCJ0eXBlIiwic2NyaXB0cyIsImNsaWVudCIsInJlZGlzVmVyc2lvbiIsImV2ZW50IiwiYXJncyIsImVyciIsImNvbnNvbGUiLCJ3YWl0VW50aWxSZWFkeSIsImJhc2U2NE5hbWUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJjbGllbnROYW1lIiwic3VmZml4IiwicXVldWVOYW1lQmFzZTY0IiwiY2xvc2UiLCJkaXNjb25uZWN0IiwiY2hlY2tDb25uZWN0aW9uRXJyb3IiLCJmbiIsImRlbGF5SW5NcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-events.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueEvents: () => (/* binding */ QueueEvents)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n\n\n\n/**\n * The QueueEvents class is used for listening to the global events\n * emitted by a given queue.\n *\n * This class requires a dedicated redis connection.\n *\n */ class QueueEvents extends _queue_base__WEBPACK_IMPORTED_MODULE_1__.QueueBase {\n    constructor(name, _a = {\n        connection: {}\n    }, Connection){\n        var { connection, autorun = true } = _a, opts = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(_a, [\n            \"connection\",\n            \"autorun\"\n        ]);\n        super(name, Object.assign(Object.assign({}, opts), {\n            connection: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isRedisInstance)(connection) ? connection.duplicate() : connection,\n            blockingConnection: true\n        }), Connection);\n        this.running = false;\n        this.opts = Object.assign({\n            blockingTimeout: 10000\n        }, this.opts);\n        if (autorun) {\n            this.run().catch((error)=>this.emit(\"error\", error));\n        }\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Manually starts running the event consumming loop. This shall be used if you do not\n     * use the default \"autorun\" option on the constructor.\n     */ async run() {\n        if (!this.running) {\n            try {\n                this.running = true;\n                const client = await this.client;\n                // TODO: Planed for deprecation as it has no really a use case\n                try {\n                    await client.client(\"SETNAME\", this.clientName(_utils__WEBPACK_IMPORTED_MODULE_0__.QUEUE_EVENT_SUFFIX));\n                } catch (err) {\n                    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.clientCommandMessageReg.test(err.message)) {\n                        throw err;\n                    }\n                }\n                await this.consumeEvents(client);\n            } catch (error) {\n                this.running = false;\n                throw error;\n            }\n        } else {\n            throw new Error(\"Queue Events is already running.\");\n        }\n    }\n    async consumeEvents(client) {\n        const opts = this.opts;\n        const key = this.keys.events;\n        let id = opts.lastEventId || \"$\";\n        while(!this.closing){\n            // Cast to actual return type, see: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44301\n            const data = await this.checkConnectionError(()=>client.xread(\"BLOCK\", opts.blockingTimeout, \"STREAMS\", key, id));\n            if (data) {\n                const stream = data[0];\n                const events = stream[1];\n                for(let i = 0; i < events.length; i++){\n                    id = events[i][0];\n                    const args = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.array2obj)(events[i][1]);\n                    //\n                    // TODO: we may need to have a separate xtream for progress data\n                    // to avoid this hack.\n                    switch(args.event){\n                        case \"progress\":\n                            args.data = JSON.parse(args.data);\n                            break;\n                        case \"completed\":\n                            args.returnvalue = JSON.parse(args.returnvalue);\n                            break;\n                    }\n                    const { event } = args, restArgs = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(args, [\n                        \"event\"\n                    ]);\n                    if (event === \"drained\") {\n                        this.emit(event, id);\n                    } else {\n                        this.emit(event, restArgs, id);\n                        this.emit(`${event}:${restArgs.jobId}`, restArgs, id);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Stops consuming events and close the underlying Redis connection if necessary.\n     *\n     * @returns\n     */ close() {\n        if (!this.closing) {\n            this.closing = this.disconnect();\n        }\n        return this.closing;\n    }\n} //# sourceMappingURL=queue-events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDcUU7QUFDM0Q7QUFDekM7Ozs7OztDQU1DLEdBQ00sTUFBTU0sb0JBQW9CRCxrREFBU0E7SUFDdENFLFlBQVlDLElBQUksRUFBRUMsS0FBSztRQUNuQkMsWUFBWSxDQUFDO0lBQ2pCLENBQUMsRUFBRUMsVUFBVSxDQUFFO1FBQ1gsSUFBSSxFQUFFRCxVQUFVLEVBQUVFLFVBQVUsSUFBSSxFQUFFLEdBQUdILElBQUlJLE9BQU9iLDZDQUFNQSxDQUFDUyxJQUFJO1lBQUM7WUFBYztTQUFVO1FBQ3BGLEtBQUssQ0FBQ0QsTUFBTU0sT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHRixPQUFPO1lBQUVILFlBQVlQLHVEQUFlQSxDQUFDTyxjQUN2RUEsV0FBV00sU0FBUyxLQUNwQk47WUFBWU8sb0JBQW9CO1FBQUssSUFBSU47UUFDbkQsSUFBSSxDQUFDTyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNMLElBQUksR0FBR0MsT0FBT0MsTUFBTSxDQUFDO1lBQ3RCSSxpQkFBaUI7UUFDckIsR0FBRyxJQUFJLENBQUNOLElBQUk7UUFDWixJQUFJRCxTQUFTO1lBQ1QsSUFBSSxDQUFDUSxHQUFHLEdBQUdDLEtBQUssQ0FBQ0MsQ0FBQUEsUUFBUyxJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDtRQUNqRDtJQUNKO0lBQ0FDLEtBQUtDLEtBQUssRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsT0FBTyxLQUFLLENBQUNGLEtBQUtDLFVBQVVDO0lBQ2hDO0lBQ0FDLElBQUlDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ3JCLEtBQUssQ0FBQ0YsSUFBSUMsV0FBV0M7UUFDckIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsR0FBR0wsS0FBSyxFQUFFSSxRQUFRLEVBQUU7UUFDaEIsS0FBSyxDQUFDQyxH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Q0osRUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLWV2ZW50cy5qcz8xMjIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYXJyYXkyb2JqLCBjbGllbnRDb21tYW5kTWVzc2FnZVJlZywgaXNSZWRpc0luc3RhbmNlLCBRVUVVRV9FVkVOVF9TVUZGSVgsIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgUXVldWVCYXNlIH0gZnJvbSAnLi9xdWV1ZS1iYXNlJztcbi8qKlxuICogVGhlIFF1ZXVlRXZlbnRzIGNsYXNzIGlzIHVzZWQgZm9yIGxpc3RlbmluZyB0byB0aGUgZ2xvYmFsIGV2ZW50c1xuICogZW1pdHRlZCBieSBhIGdpdmVuIHF1ZXVlLlxuICpcbiAqIFRoaXMgY2xhc3MgcmVxdWlyZXMgYSBkZWRpY2F0ZWQgcmVkaXMgY29ubmVjdGlvbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZUV2ZW50cyBleHRlbmRzIFF1ZXVlQmFzZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgX2EgPSB7XG4gICAgICAgIGNvbm5lY3Rpb246IHt9LFxuICAgIH0sIENvbm5lY3Rpb24pIHtcbiAgICAgICAgdmFyIHsgY29ubmVjdGlvbiwgYXV0b3J1biA9IHRydWUgfSA9IF9hLCBvcHRzID0gX19yZXN0KF9hLCBbXCJjb25uZWN0aW9uXCIsIFwiYXV0b3J1blwiXSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgY29ubmVjdGlvbjogaXNSZWRpc0luc3RhbmNlKGNvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgPyBjb25uZWN0aW9uLmR1cGxpY2F0ZSgpXG4gICAgICAgICAgICAgICAgOiBjb25uZWN0aW9uLCBibG9ja2luZ0Nvbm5lY3Rpb246IHRydWUgfSksIENvbm5lY3Rpb24pO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBibG9ja2luZ1RpbWVvdXQ6IDEwMDAwLFxuICAgICAgICB9LCB0aGlzLm9wdHMpO1xuICAgICAgICBpZiAoYXV0b3J1bikge1xuICAgICAgICAgICAgdGhpcy5ydW4oKS5jYXRjaChlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBzdGFydHMgcnVubmluZyB0aGUgZXZlbnQgY29uc3VtbWluZyBsb29wLiBUaGlzIHNoYWxsIGJlIHVzZWQgaWYgeW91IGRvIG5vdFxuICAgICAqIHVzZSB0aGUgZGVmYXVsdCBcImF1dG9ydW5cIiBvcHRpb24gb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBQbGFuZWQgZm9yIGRlcHJlY2F0aW9uIGFzIGl0IGhhcyBubyByZWFsbHkgYSB1c2UgY2FzZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jbGllbnQoJ1NFVE5BTUUnLCB0aGlzLmNsaWVudE5hbWUoUVVFVUVfRVZFTlRfU1VGRklYKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGllbnRDb21tYW5kTWVzc2FnZVJlZy50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29uc3VtZUV2ZW50cyhjbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXVlIEV2ZW50cyBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29uc3VtZUV2ZW50cyhjbGllbnQpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlzLmV2ZW50cztcbiAgICAgICAgbGV0IGlkID0gb3B0cy5sYXN0RXZlbnRJZCB8fCAnJCc7XG4gICAgICAgIHdoaWxlICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAvLyBDYXN0IHRvIGFjdHVhbCByZXR1cm4gdHlwZSwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9pc3N1ZXMvNDQzMDFcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNoZWNrQ29ubmVjdGlvbkVycm9yKCgpID0+IGNsaWVudC54cmVhZCgnQkxPQ0snLCBvcHRzLmJsb2NraW5nVGltZW91dCwgJ1NUUkVBTVMnLCBrZXksIGlkKSk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gc3RyZWFtWzFdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gZXZlbnRzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gYXJyYXkyb2JqKGV2ZW50c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG1heSBuZWVkIHRvIGhhdmUgYSBzZXBhcmF0ZSB4dHJlYW0gZm9yIHByb2dyZXNzIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgdGhpcyBoYWNrLlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ3MuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmRhdGEgPSBKU09OLnBhcnNlKGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucmV0dXJudmFsdWUgPSBKU09OLnBhcnNlKGFyZ3MucmV0dXJudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IGFyZ3MsIHJlc3RBcmdzID0gX19yZXN0KGFyZ3MsIFtcImV2ZW50XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50ID09PSAnZHJhaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCByZXN0QXJncywgaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGAke2V2ZW50fToke3Jlc3RBcmdzLmpvYklkfWAsIHJlc3RBcmdzLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgY29uc3VtaW5nIGV2ZW50cyBhbmQgY2xvc2UgdGhlIHVuZGVybHlpbmcgUmVkaXMgY29ubmVjdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nID0gdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2luZztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS1ldmVudHMuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsImFycmF5Mm9iaiIsImNsaWVudENvbW1hbmRNZXNzYWdlUmVnIiwiaXNSZWRpc0luc3RhbmNlIiwiUVVFVUVfRVZFTlRfU1VGRklYIiwiUXVldWVCYXNlIiwiUXVldWVFdmVudHMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJfYSIsImNvbm5lY3Rpb24iLCJDb25uZWN0aW9uIiwiYXV0b3J1biIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJkdXBsaWNhdGUiLCJibG9ja2luZ0Nvbm5lY3Rpb24iLCJydW5uaW5nIiwiYmxvY2tpbmdUaW1lb3V0IiwicnVuIiwiY2F0Y2giLCJlcnJvciIsImVtaXQiLCJldmVudCIsImFyZ3MiLCJvZmYiLCJldmVudE5hbWUiLCJsaXN0ZW5lciIsIm9uIiwib25jZSIsImNsaWVudCIsImNsaWVudE5hbWUiLCJlcnIiLCJ0ZXN0IiwibWVzc2FnZSIsImNvbnN1bWVFdmVudHMiLCJFcnJvciIsImtleSIsImtleXMiLCJldmVudHMiLCJpZCIsImxhc3RFdmVudElkIiwiY2xvc2luZyIsImRhdGEiLCJjaGVja0Nvbm5lY3Rpb25FcnJvciIsInhyZWFkIiwic3RyZWFtIiwiaSIsImxlbmd0aCIsIkpTT04iLCJwYXJzZSIsInJldHVybnZhbHVlIiwicmVzdEFyZ3MiLCJqb2JJZCIsImNsb3NlIiwiZGlzY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-getters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueGetters: () => (/* binding */ QueueGetters)\n/* harmony export */ });\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/*eslint-env node */ \n\n\n\n/**\n *\n * @class QueueGetters\n * @extends QueueBase\n *\n * @description Provides different getters for different aspects of a queue.\n */ class QueueGetters extends _queue_base__WEBPACK_IMPORTED_MODULE_0__.QueueBase {\n    getJob(jobId) {\n        return this.Job.fromId(this, jobId);\n    }\n    commandByType(types, count, callback) {\n        return types.map((type)=>{\n            type = type === \"waiting\" ? \"wait\" : type; // alias\n            const key = this.toKey(type);\n            switch(type){\n                case \"completed\":\n                case \"failed\":\n                case \"delayed\":\n                case \"prioritized\":\n                case \"repeat\":\n                case \"waiting-children\":\n                    return callback(key, count ? \"zcard\" : \"zrange\");\n                case \"active\":\n                case \"wait\":\n                case \"paused\":\n                    return callback(key, count ? \"llen\" : \"lrange\");\n            }\n        });\n    }\n    /**\n     * Helper to easily extend Job class calls.\n     */ get Job() {\n        return _job__WEBPACK_IMPORTED_MODULE_1__.Job;\n    }\n    sanitizeJobTypes(types) {\n        const currentTypes = typeof types === \"string\" ? [\n            types\n        ] : types;\n        if (Array.isArray(currentTypes) && currentTypes.length > 0) {\n            const sanitizedTypes = [\n                ...currentTypes\n            ];\n            if (sanitizedTypes.indexOf(\"waiting\") !== -1) {\n                sanitizedTypes.push(\"paused\");\n            }\n            return [\n                ...new Set(sanitizedTypes)\n            ];\n        }\n        return [\n            \"active\",\n            \"completed\",\n            \"delayed\",\n            \"failed\",\n            \"paused\",\n            \"prioritized\",\n            \"waiting\",\n            \"waiting-children\"\n        ];\n    }\n    /**\n      Returns the number of jobs waiting to be processed. This includes jobs that are\n      \"waiting\" or \"delayed\" or \"prioritized\" or \"waiting-children\".\n    */ async count() {\n        const count = await this.getJobCountByTypes(\"waiting\", \"paused\", \"delayed\", \"prioritized\", \"waiting-children\");\n        return count;\n    }\n    /**\n     * Returns the time to live for a rate limited key in milliseconds.\n     * @returns -2 if the key does not exist.\n     * -1 if the key exists but has no associated expire.\n     * @see {@link https://redis.io/commands/pttl/}\n     */ async getRateLimitTtl() {\n        const client = await this.client;\n        return client.pttl(this.keys.limiter);\n    }\n    /**\n     * Job counts by type\n     *\n     * Queue#getJobCountByTypes('completed') => completed count\n     * Queue#getJobCountByTypes('completed,failed') => completed + failed count\n     * Queue#getJobCountByTypes('completed', 'failed') => completed + failed count\n     * Queue#getJobCountByTypes('completed', 'waiting', 'failed') => completed + waiting + failed count\n     */ async getJobCountByTypes(...types) {\n        const result = await this.getJobCounts(...types);\n        return Object.values(result).reduce((sum, count)=>sum + count, 0);\n    }\n    /**\n     * Returns the job counts for each type specified or every list/set in the queue by default.\n     *\n     * @returns An object, key (type) and value (count)\n     */ async getJobCounts(...types) {\n        const currentTypes = this.sanitizeJobTypes(types);\n        const responses = await this.scripts.getCounts(currentTypes);\n        const counts = {};\n        responses.forEach((res, index)=>{\n            counts[currentTypes[index]] = res || 0;\n        });\n        return counts;\n    }\n    /**\n     * Get current job state.\n     *\n     * @returns Returns one of these values:\n     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.\n     */ getJobState(jobId) {\n        return this.scripts.getState(jobId);\n    }\n    /**\n     * Returns the number of jobs in completed status.\n     */ getCompletedCount() {\n        return this.getJobCountByTypes(\"completed\");\n    }\n    /**\n     * Returns the number of jobs in failed status.\n     */ getFailedCount() {\n        return this.getJobCountByTypes(\"failed\");\n    }\n    /**\n     * Returns the number of jobs in delayed status.\n     */ getDelayedCount() {\n        return this.getJobCountByTypes(\"delayed\");\n    }\n    /**\n     * Returns the number of jobs in active status.\n     */ getActiveCount() {\n        return this.getJobCountByTypes(\"active\");\n    }\n    /**\n     * Returns the number of jobs in prioritized status.\n     */ getPrioritizedCount() {\n        return this.getJobCountByTypes(\"prioritized\");\n    }\n    /**\n     * Returns the number of jobs in waiting or paused statuses.\n     */ getWaitingCount() {\n        return this.getJobCountByTypes(\"waiting\");\n    }\n    /**\n     * Returns the number of jobs in waiting-children status.\n     */ getWaitingChildrenCount() {\n        return this.getJobCountByTypes(\"waiting-children\");\n    }\n    /**\n     * Returns the jobs that are in the \"waiting\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getWaiting(start = 0, end = -1) {\n        return this.getJobs([\n            \"waiting\"\n        ], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"waiting-children\" status.\n     * I.E. parent jobs that have at least one child that has not completed yet.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getWaitingChildren(start = 0, end = -1) {\n        return this.getJobs([\n            \"waiting-children\"\n        ], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"active\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getActive(start = 0, end = -1) {\n        return this.getJobs([\n            \"active\"\n        ], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"delayed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getDelayed(start = 0, end = -1) {\n        return this.getJobs([\n            \"delayed\"\n        ], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"prioritized\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getPrioritized(start = 0, end = -1) {\n        return this.getJobs([\n            \"prioritized\"\n        ], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"completed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getCompleted(start = 0, end = -1) {\n        return this.getJobs([\n            \"completed\"\n        ], start, end, false);\n    }\n    /**\n     * Returns the jobs that are in the \"failed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */ getFailed(start = 0, end = -1) {\n        return this.getJobs([\n            \"failed\"\n        ], start, end, false);\n    }\n    /**\n     * Returns the qualified job ids and the raw job data (if available) of the\n     * children jobs of the given parent job.\n     * It is possible to get either the already processed children, in this case\n     * an array of qualified job ids and their result values will be returned,\n     * or the pending children, in this case an array of qualified job ids will\n     * be returned.\n     * A qualified job id is a string representing the job id in a given queue,\n     * for example: \"bull:myqueue:jobid\".\n     *\n     * @param parentId The id of the parent job\n     * @param type \"processed\" | \"pending\"\n     * @param opts\n     *\n     * @returns  { items: { id: string, v?: any, err?: string } [], jobs: JobJsonRaw[], total: number}\n     */ async getDependencies(parentId, type, start, end) {\n        const key = this.toKey(type == \"processed\" ? `${parentId}:processed` : `${parentId}:dependencies`);\n        const { items, total, jobs } = await this.scripts.paginate(key, {\n            start,\n            end,\n            fetchJobs: true\n        });\n        return {\n            items,\n            jobs,\n            total\n        };\n    }\n    async getRanges(types, start = 0, end = 1, asc = false) {\n        const multiCommands = [];\n        this.commandByType(types, false, (key, command)=>{\n            switch(command){\n                case \"lrange\":\n                    multiCommands.push(\"lrange\");\n                    break;\n                case \"zrange\":\n                    multiCommands.push(\"zrange\");\n                    break;\n            }\n        });\n        const responses = await this.scripts.getRanges(types, start, end, asc);\n        let results = [];\n        responses.forEach((response, index)=>{\n            const result = response || [];\n            if (asc && multiCommands[index] === \"lrange\") {\n                results = results.concat(result.reverse());\n            } else {\n                results = results.concat(result);\n            }\n        });\n        return [\n            ...new Set(results)\n        ];\n    }\n    /**\n     * Returns the jobs that are on the given statuses (note that JobType is synonym for job status)\n     * @param types - the statuses of the jobs to return.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     * @param asc - if true, the jobs will be returned in ascending order.\n     */ async getJobs(types, start = 0, end = -1, asc = false) {\n        const currentTypes = this.sanitizeJobTypes(types);\n        const jobIds = await this.getRanges(currentTypes, start, end, asc);\n        return Promise.all(jobIds.map((jobId)=>this.Job.fromId(this, jobId)));\n    }\n    /**\n     * Returns the logs for a given Job.\n     * @param jobId - the id of the job to get the logs for.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     * @param asc - if true, the jobs will be returned in ascending order.\n     */ async getJobLogs(jobId, start = 0, end = -1, asc = true) {\n        const client = await this.client;\n        const multi = client.multi();\n        const logsKey = this.toKey(jobId + \":logs\");\n        if (asc) {\n            multi.lrange(logsKey, start, end);\n        } else {\n            multi.lrange(logsKey, -(end + 1), -(start + 1));\n        }\n        multi.llen(logsKey);\n        const result = await multi.exec();\n        if (!asc) {\n            result[0][1].reverse();\n        }\n        return {\n            logs: result[0][1],\n            count: result[1][1]\n        };\n    }\n    async baseGetClients(matcher) {\n        const client = await this.client;\n        const clients = await client.client(\"LIST\");\n        try {\n            const list = this.parseClientList(clients, matcher);\n            return list;\n        } catch (err) {\n            if (!_utils__WEBPACK_IMPORTED_MODULE_2__.clientCommandMessageReg.test(err.message)) {\n                throw err;\n            }\n            return [];\n        }\n    }\n    /**\n     * Get the worker list related to the queue. i.e. all the known\n     * workers that are available to process jobs for this queue.\n     * Note: GCP does not support SETNAME, so this call will not work\n     *\n     * @returns - Returns an array with workers info.\n     */ getWorkers() {\n        const unnamedWorkerClientName = `${this.clientName()}`;\n        const namedWorkerClientName = `${this.clientName()}:w:`;\n        const matcher = (name)=>name && (name === unnamedWorkerClientName || name.startsWith(namedWorkerClientName));\n        return this.baseGetClients(matcher);\n    }\n    /**\n     * Get queue events list related to the queue.\n     * Note: GCP does not support SETNAME, so this call will not work\n     *\n     * @deprecated do not use this method, it will be removed in the future.\n     *\n     * @returns - Returns an array with queue events info.\n     */ async getQueueEvents() {\n        const clientName = `${this.clientName()}${_utils__WEBPACK_IMPORTED_MODULE_2__.QUEUE_EVENT_SUFFIX}`;\n        return this.baseGetClients((name)=>name === clientName);\n    }\n    /**\n     * Get queue metrics related to the queue.\n     *\n     * This method returns the gathered metrics for the queue.\n     * The metrics are represented as an array of job counts\n     * per unit of time (1 minute).\n     *\n     * @param start - Start point of the metrics, where 0\n     * is the newest point to be returned.\n     * @param end - End point of the metrics, where -1 is the\n     * oldest point to be returned.\n     *\n     * @returns - Returns an object with queue metrics.\n     */ async getMetrics(type, start = 0, end = -1) {\n        const client = await this.client;\n        const metricsKey = this.toKey(`metrics:${type}`);\n        const dataKey = `${metricsKey}:data`;\n        const multi = client.multi();\n        multi.hmget(metricsKey, \"count\", \"prevTS\", \"prevCount\");\n        multi.lrange(dataKey, start, end);\n        multi.llen(dataKey);\n        const [hmget, range, len] = await multi.exec();\n        const [err, [count, prevTS, prevCount]] = hmget;\n        const [err2, data] = range;\n        const [err3, numPoints] = len;\n        if (err || err2) {\n            throw err || err2 || err3;\n        }\n        return {\n            meta: {\n                count: parseInt(count || \"0\", 10),\n                prevTS: parseInt(prevTS || \"0\", 10),\n                prevCount: parseInt(prevCount || \"0\", 10)\n            },\n            data,\n            count: numPoints\n        };\n    }\n    parseClientList(list, matcher) {\n        const lines = list.split(\"\\n\");\n        const clients = [];\n        lines.forEach((line)=>{\n            const client = {};\n            const keyValues = line.split(\" \");\n            keyValues.forEach(function(keyValue) {\n                const index = keyValue.indexOf(\"=\");\n                const key = keyValue.substring(0, index);\n                const value = keyValue.substring(index + 1);\n                client[key] = value;\n            });\n            const name = client[\"name\"];\n            if (matcher(name)) {\n                client[\"name\"] = this.name;\n                client[\"rawname\"] = name;\n                clients.push(client);\n            }\n        });\n        return clients;\n    }\n} //# sourceMappingURL=queue-getters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtZ2V0dGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsa0JBQWtCLEdBQ2xCO0FBQ3lDO0FBQ2I7QUFDMkM7QUFDdkU7Ozs7OztDQU1DLEdBQ00sTUFBTUkscUJBQXFCSixrREFBU0E7SUFDdkNLLE9BQU9DLEtBQUssRUFBRTtRQUNWLE9BQU8sSUFBSSxDQUFDTCxHQUFHLENBQUNNLE1BQU0sQ0FBQyxJQUFJLEVBQUVEO0lBQ2pDO0lBQ0FFLGNBQWNDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsT0FBT0YsTUFBTUcsR0FBRyxDQUFDLENBQUNDO1lBQ2RBLE9BQU9BLFNBQVMsWUFBWSxTQUFTQSxNQUFNLFFBQVE7WUFDbkQsTUFBTUMsTUFBTSxJQUFJLENBQUNDLEtBQUssQ0FBQ0Y7WUFDdkIsT0FBUUE7Z0JBQ0osS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0QsT0FBT0YsU0FBU0csS0FBS0osUUFBUSxVQUFVO2dCQUMzQyxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDRCxPQUFPQyxTQUFTRyxLQUFLSixRQUFRLFNBQVM7WUFDOUM7UUFDSjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxJQUFJVCxNQUFNO1FBQ04sT0FBT0EscUNBQUdBO0lBQ2Q7SUFDQWUsaUJBQWlCUCxLQUFLLEVBQUU7UUFDcEIsTUFBTVEsZUFBZSxPQUFPUixVQUFVLFdBQVc7WUFBQ0E7U0FBTSxHQUFHQTtRQUMzRCxJQUFJUyxNQUFNQyxPQUFPLENBQUNGLGlCQUFpQkEsYUFBYUcsTUFBTSxHQUFHLEdBQUc7WUFDeEQsTUFBTUMsaUJBQWlCO21CQUFJSjthQUFhO1lBQ3hDLElBQUlJLGVBQWVDLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRztnQkFDMUNELGVBQWVFLElBQUksQ0FBQztZQUN4QjtZ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TUFBTTtZQUNiLE1BQU1sQixPQUFPa0IsUUFBUUU7UUFDekI7UUFDQSxPQUFPO1lBQ0hFLE1BQU07Z0JBQ0Z6RyxPQUFPMEcsU0FBUzFHLFNBQVMsS0FBSztnQkFDOUJtRyxRQUFRTyxTQUFTUCxVQUFVLEtBQUs7Z0JBQ2hDQyxXQUFXTSxTQUFTTixhQUFhLEtBQUs7WUFDMUM7WUFDQUU7WUFDQXRHLE9BQU93RztRQUNYO0lBQ0o7SUFDQXRCLGdCQUFnQkQsSUFBSSxFQUFFRixPQUFPLEVBQUU7UUFDM0IsTUFBTTRCLFFBQVExQixLQUFLMkIsS0FBSyxDQUFDO1FBQ3pCLE1BQU01QixVQUFVLEVBQUU7UUFDbEIyQixNQUFNNUUsT0FBTyxDQUFDLENBQUM4RTtZQUNYLE1BQU01RixTQUFTLENBQUM7WUFDaEIsTUFBTTZGLFlBQVlELEtBQUtELEtBQUssQ0FBQztZQUM3QkUsVUFBVS9FLE9BQU8sQ0FBQyxTQUFVZ0YsUUFBUTtnQkFDaEMsTUFBTTlFLFFBQVE4RSxTQUFTbkcsT0FBTyxDQUFDO2dCQUMvQixNQUFNUixNQUFNMkcsU0FBU0MsU0FBUyxDQUFDLEdBQUcvRTtnQkFDbEMsTUFBTWdGLFFBQVFGLFNBQVNDLFNBQVMsQ0FBQy9FLFFBQVE7Z0JBQ3pDaEIsTUFBTSxDQUFDYixJQUFJLEdBQUc2RztZQUNsQjtZQUNBLE1BQU12QixPQUFPekUsTUFBTSxDQUFDLE9BQU87WUFDM0IsSUFBSThELFFBQVFXLE9BQU87Z0JBQ2Z6RSxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQ3lFLElBQUk7Z0JBQzFCekUsTUFBTSxDQUFDLFVBQVUsR0FBR3lFO2dCQUNwQlYsUUFBUW5FLElBQUksQ0FBQ0k7WUFDakI7UUFDSjtRQUNBLE9BQU8rRDtJQUNYO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLWdldHRlcnMuanM/ZGFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgUXVldWVCYXNlIH0gZnJvbSAnLi9xdWV1ZS1iYXNlJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IGNsaWVudENvbW1hbmRNZXNzYWdlUmVnLCBRVUVVRV9FVkVOVF9TVUZGSVggfSBmcm9tICcuLi91dGlscyc7XG4vKipcbiAqXG4gKiBAY2xhc3MgUXVldWVHZXR0ZXJzXG4gKiBAZXh0ZW5kcyBRdWV1ZUJhc2VcbiAqXG4gKiBAZGVzY3JpcHRpb24gUHJvdmlkZXMgZGlmZmVyZW50IGdldHRlcnMgZm9yIGRpZmZlcmVudCBhc3BlY3RzIG9mIGEgcXVldWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZUdldHRlcnMgZXh0ZW5kcyBRdWV1ZUJhc2Uge1xuICAgIGdldEpvYihqb2JJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Kb2IuZnJvbUlkKHRoaXMsIGpvYklkKTtcbiAgICB9XG4gICAgY29tbWFuZEJ5VHlwZSh0eXBlcywgY291bnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0eXBlcy5tYXAoKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID09PSAnd2FpdGluZycgPyAnd2FpdCcgOiB0eXBlOyAvLyBhbGlhc1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50b0tleSh0eXBlKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZWxheWVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcmlvcml0aXplZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwZWF0JzpcbiAgICAgICAgICAgICAgICBjYXNlICd3YWl0aW5nLWNoaWxkcmVuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGtleSwgY291bnQgPyAnemNhcmQnIDogJ3pyYW5nZScpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FpdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncGF1c2VkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGtleSwgY291bnQgPyAnbGxlbicgOiAnbHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gZWFzaWx5IGV4dGVuZCBKb2IgY2xhc3MgY2FsbHMuXG4gICAgICovXG4gICAgZ2V0IEpvYigpIHtcbiAgICAgICAgcmV0dXJuIEpvYjtcbiAgICB9XG4gICAgc2FuaXRpemVKb2JUeXBlcyh0eXBlcykge1xuICAgICAgICBjb25zdCBjdXJyZW50VHlwZXMgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gW3R5cGVzXSA6IHR5cGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHlwZXMpICYmIGN1cnJlbnRUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRUeXBlcyA9IFsuLi5jdXJyZW50VHlwZXNdO1xuICAgICAgICAgICAgaWYgKHNhbml0aXplZFR5cGVzLmluZGV4T2YoJ3dhaXRpbmcnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRUeXBlcy5wdXNoKCdwYXVzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbLi4ubmV3IFNldChzYW5pdGl6ZWRUeXBlcyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYWN0aXZlJyxcbiAgICAgICAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgJ2RlbGF5ZWQnLFxuICAgICAgICAgICAgJ2ZhaWxlZCcsXG4gICAgICAgICAgICAncGF1c2VkJyxcbiAgICAgICAgICAgICdwcmlvcml0aXplZCcsXG4gICAgICAgICAgICAnd2FpdGluZycsXG4gICAgICAgICAgICAnd2FpdGluZy1jaGlsZHJlbicsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGpvYnMgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIFRoaXMgaW5jbHVkZXMgam9icyB0aGF0IGFyZVxuICAgICAgXCJ3YWl0aW5nXCIgb3IgXCJkZWxheWVkXCIgb3IgXCJwcmlvcml0aXplZFwiIG9yIFwid2FpdGluZy1jaGlsZHJlblwiLlxuICAgICovXG4gICAgYXN5bmMgY291bnQoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3dhaXRpbmcnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAncHJpb3JpdGl6ZWQnLCAnd2FpdGluZy1jaGlsZHJlbicpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWUgdG8gbGl2ZSBmb3IgYSByYXRlIGxpbWl0ZWQga2V5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyAtMiBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgICAqIC0xIGlmIHRoZSBrZXkgZXhpc3RzIGJ1dCBoYXMgbm8gYXNzb2NpYXRlZCBleHBpcmUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZWRpcy5pby9jb21tYW5kcy9wdHRsL31cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSYXRlTGltaXRUdGwoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LnB0dGwodGhpcy5rZXlzLmxpbWl0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2IgY291bnRzIGJ5IHR5cGVcbiAgICAgKlxuICAgICAqIFF1ZXVlI2dldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJykgPT4gY29tcGxldGVkIGNvdW50XG4gICAgICogUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQsZmFpbGVkJykgPT4gY29tcGxldGVkICsgZmFpbGVkIGNvdW50XG4gICAgICogUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnLCAnZmFpbGVkJykgPT4gY29tcGxldGVkICsgZmFpbGVkIGNvdW50XG4gICAgICogUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnLCAnd2FpdGluZycsICdmYWlsZWQnKSA9PiBjb21wbGV0ZWQgKyB3YWl0aW5nICsgZmFpbGVkIGNvdW50XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Sm9iQ291bnRCeVR5cGVzKC4uLnR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0Sm9iQ291bnRzKC4uLnR5cGVzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0KS5yZWR1Y2UoKHN1bSwgY291bnQpID0+IHN1bSArIGNvdW50LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9iIGNvdW50cyBmb3IgZWFjaCB0eXBlIHNwZWNpZmllZCBvciBldmVyeSBsaXN0L3NldCBpbiB0aGUgcXVldWUgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCwga2V5ICh0eXBlKSBhbmQgdmFsdWUgKGNvdW50KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEpvYkNvdW50cyguLi50eXBlcykge1xuICAgICAgICBjb25zdCBjdXJyZW50VHlwZXMgPSB0aGlzLnNhbml0aXplSm9iVHlwZXModHlwZXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLnNjcmlwdHMuZ2V0Q291bnRzKGN1cnJlbnRUeXBlcyk7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgICAgICByZXNwb25zZXMuZm9yRWFjaCgocmVzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY291bnRzW2N1cnJlbnRUeXBlc1tpbmRleF1dID0gcmVzIHx8IDA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY291bnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBqb2Igc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIG9uZSBvZiB0aGVzZSB2YWx1ZXM6XG4gICAgICogJ2NvbXBsZXRlZCcsICdmYWlsZWQnLCAnZGVsYXllZCcsICdhY3RpdmUnLCAnd2FpdGluZycsICd3YWl0aW5nLWNoaWxkcmVuJywgJ3Vua25vd24nLlxuICAgICAqL1xuICAgIGdldEpvYlN0YXRlKGpvYklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMuZ2V0U3RhdGUoam9iSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiBjb21wbGV0ZWQgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldENvbXBsZXRlZENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2NvbXBsZXRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiBmYWlsZWQgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldEZhaWxlZENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2ZhaWxlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiBkZWxheWVkIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXREZWxheWVkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnZGVsYXllZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiBhY3RpdmUgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2FjdGl2ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiBwcmlvcml0aXplZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0UHJpb3JpdGl6ZWRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdwcmlvcml0aXplZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiB3YWl0aW5nIG9yIHBhdXNlZCBzdGF0dXNlcy5cbiAgICAgKi9cbiAgICBnZXRXYWl0aW5nQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnd2FpdGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygam9icyBpbiB3YWl0aW5nLWNoaWxkcmVuIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXRXYWl0aW5nQ2hpbGRyZW5Db3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCd3YWl0aW5nLWNoaWxkcmVuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwid2FpdGluZ1wiIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKi9cbiAgICBnZXRXYWl0aW5nKHN0YXJ0ID0gMCwgZW5kID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ3dhaXRpbmcnXSwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwid2FpdGluZy1jaGlsZHJlblwiIHN0YXR1cy5cbiAgICAgKiBJLkUuIHBhcmVudCBqb2JzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgY2hpbGQgdGhhdCBoYXMgbm90IGNvbXBsZXRlZCB5ZXQuXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gemVybyBiYXNlZCBpbmRleCBmcm9tIHdoZXJlIHRvIHN0YXJ0IHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBlbmQgLSB6ZXJvIGJhc2VkIGluZGV4IHdoZXJlIHRvIHN0b3AgcmV0dXJuaW5nIGpvYnMuXG4gICAgICovXG4gICAgZ2V0V2FpdGluZ0NoaWxkcmVuKHN0YXJ0ID0gMCwgZW5kID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ3dhaXRpbmctY2hpbGRyZW4nXSwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwiYWN0aXZlXCIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZShzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYnMoWydhY3RpdmUnXSwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwiZGVsYXllZFwiIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKi9cbiAgICBnZXREZWxheWVkKHN0YXJ0ID0gMCwgZW5kID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ2RlbGF5ZWQnXSwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwicHJpb3JpdGl6ZWRcIiBzdGF0dXMuXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gemVybyBiYXNlZCBpbmRleCBmcm9tIHdoZXJlIHRvIHN0YXJ0IHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBlbmQgLSB6ZXJvIGJhc2VkIGluZGV4IHdoZXJlIHRvIHN0b3AgcmV0dXJuaW5nIGpvYnMuXG4gICAgICovXG4gICAgZ2V0UHJpb3JpdGl6ZWQoc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsncHJpb3JpdGl6ZWQnXSwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwiY29tcGxldGVkXCIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqL1xuICAgIGdldENvbXBsZXRlZChzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYnMoWydjb21wbGV0ZWQnXSwgc3RhcnQsIGVuZCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqb2JzIHRoYXQgYXJlIGluIHRoZSBcImZhaWxlZFwiIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKi9cbiAgICBnZXRGYWlsZWQoc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsnZmFpbGVkJ10sIHN0YXJ0LCBlbmQsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcXVhbGlmaWVkIGpvYiBpZHMgYW5kIHRoZSByYXcgam9iIGRhdGEgKGlmIGF2YWlsYWJsZSkgb2YgdGhlXG4gICAgICogY2hpbGRyZW4gam9icyBvZiB0aGUgZ2l2ZW4gcGFyZW50IGpvYi5cbiAgICAgKiBJdCBpcyBwb3NzaWJsZSB0byBnZXQgZWl0aGVyIHRoZSBhbHJlYWR5IHByb2Nlc3NlZCBjaGlsZHJlbiwgaW4gdGhpcyBjYXNlXG4gICAgICogYW4gYXJyYXkgb2YgcXVhbGlmaWVkIGpvYiBpZHMgYW5kIHRoZWlyIHJlc3VsdCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCxcbiAgICAgKiBvciB0aGUgcGVuZGluZyBjaGlsZHJlbiwgaW4gdGhpcyBjYXNlIGFuIGFycmF5IG9mIHF1YWxpZmllZCBqb2IgaWRzIHdpbGxcbiAgICAgKiBiZSByZXR1cm5lZC5cbiAgICAgKiBBIHF1YWxpZmllZCBqb2IgaWQgaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBqb2IgaWQgaW4gYSBnaXZlbiBxdWV1ZSxcbiAgICAgKiBmb3IgZXhhbXBsZTogXCJidWxsOm15cXVldWU6am9iaWRcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJlbnRJZCBUaGUgaWQgb2YgdGhlIHBhcmVudCBqb2JcbiAgICAgKiBAcGFyYW0gdHlwZSBcInByb2Nlc3NlZFwiIHwgXCJwZW5kaW5nXCJcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqXG4gICAgICogQHJldHVybnMgIHsgaXRlbXM6IHsgaWQ6IHN0cmluZywgdj86IGFueSwgZXJyPzogc3RyaW5nIH0gW10sIGpvYnM6IEpvYkpzb25SYXdbXSwgdG90YWw6IG51bWJlcn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBlbmRlbmNpZXMocGFyZW50SWQsIHR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50b0tleSh0eXBlID09ICdwcm9jZXNzZWQnXG4gICAgICAgICAgICA/IGAke3BhcmVudElkfTpwcm9jZXNzZWRgXG4gICAgICAgICAgICA6IGAke3BhcmVudElkfTpkZXBlbmRlbmNpZXNgKTtcbiAgICAgICAgY29uc3QgeyBpdGVtcywgdG90YWwsIGpvYnMgfSA9IGF3YWl0IHRoaXMuc2NyaXB0cy5wYWdpbmF0ZShrZXksIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgZmV0Y2hKb2JzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgam9icyxcbiAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRSYW5nZXModHlwZXMsIHN0YXJ0ID0gMCwgZW5kID0gMSwgYXNjID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbXVsdGlDb21tYW5kcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbW1hbmRCeVR5cGUodHlwZXMsIGZhbHNlLCAoa2V5LCBjb21tYW5kKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdscmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aUNvbW1hbmRzLnB1c2goJ2xyYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd6cmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aUNvbW1hbmRzLnB1c2goJ3pyYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMuc2NyaXB0cy5nZXRSYW5nZXModHlwZXMsIHN0YXJ0LCBlbmQsIGFzYyk7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG4gICAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlIHx8IFtdO1xuICAgICAgICAgICAgaWYgKGFzYyAmJiBtdWx0aUNvbW1hbmRzW2luZGV4XSA9PT0gJ2xyYW5nZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzdWx0LnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChyZXN1bHRzKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgb24gdGhlIGdpdmVuIHN0YXR1c2VzIChub3RlIHRoYXQgSm9iVHlwZSBpcyBzeW5vbnltIGZvciBqb2Igc3RhdHVzKVxuICAgICAqIEBwYXJhbSB0eXBlcyAtIHRoZSBzdGF0dXNlcyBvZiB0aGUgam9icyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gemVybyBiYXNlZCBpbmRleCBmcm9tIHdoZXJlIHRvIHN0YXJ0IHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBlbmQgLSB6ZXJvIGJhc2VkIGluZGV4IHdoZXJlIHRvIHN0b3AgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGFzYyAtIGlmIHRydWUsIHRoZSBqb2JzIHdpbGwgYmUgcmV0dXJuZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEpvYnModHlwZXMsIHN0YXJ0ID0gMCwgZW5kID0gLTEsIGFzYyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlcyA9IHRoaXMuc2FuaXRpemVKb2JUeXBlcyh0eXBlcyk7XG4gICAgICAgIGNvbnN0IGpvYklkcyA9IGF3YWl0IHRoaXMuZ2V0UmFuZ2VzKGN1cnJlbnRUeXBlcywgc3RhcnQsIGVuZCwgYXNjKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGpvYklkcy5tYXAoam9iSWQgPT4gdGhpcy5Kb2IuZnJvbUlkKHRoaXMsIGpvYklkKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2dzIGZvciBhIGdpdmVuIEpvYi5cbiAgICAgKiBAcGFyYW0gam9iSWQgLSB0aGUgaWQgb2YgdGhlIGpvYiB0byBnZXQgdGhlIGxvZ3MgZm9yLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBhc2MgLSBpZiB0cnVlLCB0aGUgam9icyB3aWxsIGJlIHJldHVybmVkIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRKb2JMb2dzKGpvYklkLCBzdGFydCA9IDAsIGVuZCA9IC0xLCBhc2MgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICBjb25zdCBtdWx0aSA9IGNsaWVudC5tdWx0aSgpO1xuICAgICAgICBjb25zdCBsb2dzS2V5ID0gdGhpcy50b0tleShqb2JJZCArICc6bG9ncycpO1xuICAgICAgICBpZiAoYXNjKSB7XG4gICAgICAgICAgICBtdWx0aS5scmFuZ2UobG9nc0tleSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtdWx0aS5scmFuZ2UobG9nc0tleSwgLShlbmQgKyAxKSwgLShzdGFydCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aS5sbGVuKGxvZ3NLZXkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgbXVsdGkuZXhlYygpKTtcbiAgICAgICAgaWYgKCFhc2MpIHtcbiAgICAgICAgICAgIHJlc3VsdFswXVsxXS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvZ3M6IHJlc3VsdFswXVsxXSxcbiAgICAgICAgICAgIGNvdW50OiByZXN1bHRbMV1bMV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGJhc2VHZXRDbGllbnRzKG1hdGNoZXIpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGNsaWVudHMgPSAoYXdhaXQgY2xpZW50LmNsaWVudCgnTElTVCcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLnBhcnNlQ2xpZW50TGlzdChjbGllbnRzLCBtYXRjaGVyKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghY2xpZW50Q29tbWFuZE1lc3NhZ2VSZWcudGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3b3JrZXIgbGlzdCByZWxhdGVkIHRvIHRoZSBxdWV1ZS4gaS5lLiBhbGwgdGhlIGtub3duXG4gICAgICogd29ya2VycyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gcHJvY2VzcyBqb2JzIGZvciB0aGlzIHF1ZXVlLlxuICAgICAqIE5vdGU6IEdDUCBkb2VzIG5vdCBzdXBwb3J0IFNFVE5BTUUsIHNvIHRoaXMgY2FsbCB3aWxsIG5vdCB3b3JrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgYW4gYXJyYXkgd2l0aCB3b3JrZXJzIGluZm8uXG4gICAgICovXG4gICAgZ2V0V29ya2VycygpIHtcbiAgICAgICAgY29uc3QgdW5uYW1lZFdvcmtlckNsaWVudE5hbWUgPSBgJHt0aGlzLmNsaWVudE5hbWUoKX1gO1xuICAgICAgICBjb25zdCBuYW1lZFdvcmtlckNsaWVudE5hbWUgPSBgJHt0aGlzLmNsaWVudE5hbWUoKX06dzpgO1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gKG5hbWUpID0+IG5hbWUgJiZcbiAgICAgICAgICAgIChuYW1lID09PSB1bm5hbWVkV29ya2VyQ2xpZW50TmFtZSB8fFxuICAgICAgICAgICAgICAgIG5hbWUuc3RhcnRzV2l0aChuYW1lZFdvcmtlckNsaWVudE5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUdldENsaWVudHMobWF0Y2hlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBxdWV1ZSBldmVudHMgbGlzdCByZWxhdGVkIHRvIHRoZSBxdWV1ZS5cbiAgICAgKiBOb3RlOiBHQ1AgZG9lcyBub3Qgc3VwcG9ydCBTRVROQU1FLCBzbyB0aGlzIGNhbGwgd2lsbCBub3Qgd29ya1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgZG8gbm90IHVzZSB0aGlzIG1ldGhvZCwgaXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgYW4gYXJyYXkgd2l0aCBxdWV1ZSBldmVudHMgaW5mby5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TmFtZSA9IGAke3RoaXMuY2xpZW50TmFtZSgpfSR7UVVFVUVfRVZFTlRfU1VGRklYfWA7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VHZXRDbGllbnRzKChuYW1lKSA9PiBuYW1lID09PSBjbGllbnROYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXVlIG1ldHJpY3MgcmVsYXRlZCB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBnYXRoZXJlZCBtZXRyaWNzIGZvciB0aGUgcXVldWUuXG4gICAgICogVGhlIG1ldHJpY3MgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGpvYiBjb3VudHNcbiAgICAgKiBwZXIgdW5pdCBvZiB0aW1lICgxIG1pbnV0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBwb2ludCBvZiB0aGUgbWV0cmljcywgd2hlcmUgMFxuICAgICAqIGlzIHRoZSBuZXdlc3QgcG9pbnQgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGVuZCAtIEVuZCBwb2ludCBvZiB0aGUgbWV0cmljcywgd2hlcmUgLTEgaXMgdGhlXG4gICAgICogb2xkZXN0IHBvaW50IHRvIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHF1ZXVlIG1ldHJpY3MuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWV0cmljcyh0eXBlLCBzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICBjb25zdCBtZXRyaWNzS2V5ID0gdGhpcy50b0tleShgbWV0cmljczoke3R5cGV9YCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSBgJHttZXRyaWNzS2V5fTpkYXRhYDtcbiAgICAgICAgY29uc3QgbXVsdGkgPSBjbGllbnQubXVsdGkoKTtcbiAgICAgICAgbXVsdGkuaG1nZXQobWV0cmljc0tleSwgJ2NvdW50JywgJ3ByZXZUUycsICdwcmV2Q291bnQnKTtcbiAgICAgICAgbXVsdGkubHJhbmdlKGRhdGFLZXksIHN0YXJ0LCBlbmQpO1xuICAgICAgICBtdWx0aS5sbGVuKGRhdGFLZXkpO1xuICAgICAgICBjb25zdCBbaG1nZXQsIHJhbmdlLCBsZW5dID0gKGF3YWl0IG11bHRpLmV4ZWMoKSk7XG4gICAgICAgIGNvbnN0IFtlcnIsIFtjb3VudCwgcHJldlRTLCBwcmV2Q291bnRdXSA9IGhtZ2V0O1xuICAgICAgICBjb25zdCBbZXJyMiwgZGF0YV0gPSByYW5nZTtcbiAgICAgICAgY29uc3QgW2VycjMsIG51bVBvaW50c10gPSBsZW47XG4gICAgICAgIGlmIChlcnIgfHwgZXJyMikge1xuICAgICAgICAgICAgdGhyb3cgZXJyIHx8IGVycjIgfHwgZXJyMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIGNvdW50OiBwYXJzZUludChjb3VudCB8fCAnMCcsIDEwKSxcbiAgICAgICAgICAgICAgICBwcmV2VFM6IHBhcnNlSW50KHByZXZUUyB8fCAnMCcsIDEwKSxcbiAgICAgICAgICAgICAgICBwcmV2Q291bnQ6IHBhcnNlSW50KHByZXZDb3VudCB8fCAnMCcsIDEwKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY291bnQ6IG51bVBvaW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VDbGllbnRMaXN0KGxpc3QsIG1hdGNoZXIpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBsaXN0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlcyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGtleVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0ga2V5VmFsdWUuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleVZhbHVlLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBrZXlWYWx1ZS5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBjbGllbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY2xpZW50WyduYW1lJ107XG4gICAgICAgICAgICBpZiAobWF0Y2hlcihuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNsaWVudFsnbmFtZSddID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIGNsaWVudFsncmF3bmFtZSddID0gbmFtZTtcbiAgICAgICAgICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnRzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLWdldHRlcnMuanMubWFwIl0sIm5hbWVzIjpbIlF1ZXVlQmFzZSIsIkpvYiIsImNsaWVudENvbW1hbmRNZXNzYWdlUmVnIiwiUVVFVUVfRVZFTlRfU1VGRklYIiwiUXVldWVHZXR0ZXJzIiwiZ2V0Sm9iIiwiam9iSWQiLCJmcm9tSWQiLCJjb21tYW5kQnlUeXBlIiwidHlwZXMiLCJjb3VudCIsImNhbGxiYWNrIiwibWFwIiwidHlwZSIsImtleSIsInRvS2V5Iiwic2FuaXRpemVKb2JUeXBlcyIsImN1cnJlbnRUeXBlcyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInNhbml0aXplZFR5cGVzIiwiaW5kZXhPZiIsInB1c2giLCJTZXQiLCJnZXRKb2JDb3VudEJ5VHlwZXMiLCJnZXRSYXRlTGltaXRUdGwiLCJjbGllbnQiLCJwdHRsIiwia2V5cyIsImxpbWl0ZXIiLCJyZXN1bHQiLCJnZXRKb2JDb3VudHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzdW0iLCJyZXNwb25zZXMiLCJzY3JpcHRzIiwiZ2V0Q291bnRzIiwiY291bnRzIiwiZm9yRWFjaCIsInJlcyIsImluZGV4IiwiZ2V0Sm9iU3RhdGUiLCJnZXRTdGF0ZSIsImdldENvbXBsZXRlZENvdW50IiwiZ2V0RmFpbGVkQ291bnQiLCJnZXREZWxheWVkQ291bnQiLCJnZXRBY3RpdmVDb3VudCIsImdldFByaW9yaXRpemVkQ291bnQiLCJnZXRXYWl0aW5nQ291bnQiLCJnZXRXYWl0aW5nQ2hpbGRyZW5Db3VudCIsImdldFdhaXRpbmciLCJzdGFydCIsImVuZCIsImdldEpvYnMiLCJnZXRXYWl0aW5nQ2hpbGRyZW4iLCJnZXRBY3RpdmUiLCJnZXREZWxheWVkIiwiZ2V0UHJpb3JpdGl6ZWQiLCJnZXRDb21wbGV0ZWQiLCJnZXRGYWlsZWQiLCJnZXREZXBlbmRlbmNpZXMiLCJwYXJlbnRJZCIsIml0ZW1zIiwidG90YWwiLCJqb2JzIiwicGFnaW5hdGUiLCJmZXRjaEpvYnMiLCJnZXRSYW5nZXMiLCJhc2MiLCJtdWx0aUNvbW1hbmRzIiwiY29tbWFuZCIsInJlc3VsdHMiLCJyZXNwb25zZSIsImNvbmNhdCIsInJldmVyc2UiLCJqb2JJZHMiLCJQcm9taXNlIiwiYWxsIiwiZ2V0Sm9iTG9ncyIsIm11bHRpIiwibG9nc0tleSIsImxyYW5nZSIsImxsZW4iLCJleGVjIiwibG9ncyIsImJhc2VHZXRDbGllbnRzIiwibWF0Y2hlciIsImNsaWVudHMiLCJsaXN0IiwicGFyc2VDbGllbnRMaXN0IiwiZXJyIiwidGVzdCIsIm1lc3NhZ2UiLCJnZXRXb3JrZXJzIiwidW5uYW1lZFdvcmtlckNsaWVudE5hbWUiLCJjbGllbnROYW1lIiwibmFtZWRXb3JrZXJDbGllbnROYW1lIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJnZXRRdWV1ZUV2ZW50cyIsImdldE1ldHJpY3MiLCJtZXRyaWNzS2V5IiwiZGF0YUtleSIsImhtZ2V0IiwicmFuZ2UiLCJsZW4iLCJwcmV2VFMiLCJwcmV2Q291bnQiLCJlcnIyIiwiZGF0YSIsImVycjMiLCJudW1Qb2ludHMiLCJtZXRhIiwicGFyc2VJbnQiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsImtleVZhbHVlcyIsImtleVZhbHVlIiwic3Vic3RyaW5nIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-keys.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueKeys: () => (/* binding */ QueueKeys)\n/* harmony export */ });\nclass QueueKeys {\n    constructor(prefix = \"bull\"){\n        this.prefix = prefix;\n    }\n    getKeys(name) {\n        const keys = {};\n        [\n            \"\",\n            \"active\",\n            \"wait\",\n            \"waiting-children\",\n            \"paused\",\n            \"id\",\n            \"delayed\",\n            \"prioritized\",\n            \"stalled-check\",\n            \"completed\",\n            \"failed\",\n            \"stalled\",\n            \"repeat\",\n            \"limiter\",\n            \"meta\",\n            \"events\",\n            \"pc\",\n            \"marker\"\n        ].forEach((key)=>{\n            keys[key] = this.toKey(name, key);\n        });\n        return keys;\n    }\n    toKey(name, type) {\n        return `${this.getQueueQualifiedName(name)}:${type}`;\n    }\n    getQueueQualifiedName(name) {\n        return `${this.prefix}:${name}`;\n    }\n} //# sourceMappingURL=queue-keys.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUta2V5cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUE7SUFDVEMsWUFBWUMsU0FBUyxNQUFNLENBQUU7UUFDekIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2xCO0lBQ0FDLFFBQVFDLElBQUksRUFBRTtRQUNWLE1BQU1DLE9BQU8sQ0FBQztRQUNkO1lBQ0k7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0gsQ0FBQ0MsT0FBTyxDQUFDQyxDQUFBQTtZQUNORixJQUFJLENBQUNFLElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssQ0FBQ0osTUFBTUc7UUFDakM7UUFDQSxPQUFPRjtJQUNYO0lBQ0FHLE1BQU1KLElBQUksRUFBRUssSUFBSSxFQUFFO1FBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ04sTUFBTSxDQUFDLEVBQUVLLEtBQUssQ0FBQztJQUN4RDtJQUNBQyxzQkFBc0JOLElBQUksRUFBRTtRQUN4QixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNGLE1BQU0sQ0FBQyxDQUFDLEVBQUVFLEtBQUssQ0FBQztJQUNuQztBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9xdWV1ZS1rZXlzLmpzPzU5YjMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFF1ZXVlS2V5cyB7XG4gICAgY29uc3RydWN0b3IocHJlZml4ID0gJ2J1bGwnKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBnZXRLZXlzKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHt9O1xuICAgICAgICBbXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdhY3RpdmUnLFxuICAgICAgICAgICAgJ3dhaXQnLFxuICAgICAgICAgICAgJ3dhaXRpbmctY2hpbGRyZW4nLFxuICAgICAgICAgICAgJ3BhdXNlZCcsXG4gICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgJ2RlbGF5ZWQnLFxuICAgICAgICAgICAgJ3ByaW9yaXRpemVkJyxcbiAgICAgICAgICAgICdzdGFsbGVkLWNoZWNrJyxcbiAgICAgICAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgJ2ZhaWxlZCcsXG4gICAgICAgICAgICAnc3RhbGxlZCcsXG4gICAgICAgICAgICAncmVwZWF0JyxcbiAgICAgICAgICAgICdsaW1pdGVyJyxcbiAgICAgICAgICAgICdtZXRhJyxcbiAgICAgICAgICAgICdldmVudHMnLFxuICAgICAgICAgICAgJ3BjJyxcbiAgICAgICAgICAgICdtYXJrZXInLCAvLyBtYXJrZXIga2V5XG4gICAgICAgIF0uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5c1trZXldID0gdGhpcy50b0tleShuYW1lLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHRvS2V5KG5hbWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5hbWUpfToke3R5cGV9YDtcbiAgICB9XG4gICAgZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fToke25hbWV9YDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6WyJRdWV1ZUtleXMiLCJjb25zdHJ1Y3RvciIsInByZWZpeCIsImdldEtleXMiLCJuYW1lIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ0b0tleSIsInR5cGUiLCJnZXRRdWV1ZVF1YWxpZmllZE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ \"lodash/get\");\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_getters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queue-getters */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n\n\n\n\n\n/**\n * Queue\n *\n * This class provides methods to add jobs to a queue and some other high-level\n * administration such as pausing or deleting queues.\n *\n */ class Queue extends _queue_getters__WEBPACK_IMPORTED_MODULE_2__.QueueGetters {\n    constructor(name, opts, Connection){\n        var _a;\n        super(name, Object.assign({\n            blockingConnection: false\n        }, opts), Connection);\n        this.token = (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n        this.jobsOpts = (_a = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(opts, \"defaultJobOptions\")) !== null && _a !== void 0 ? _a : {};\n        this.waitUntilReady().then((client)=>{\n            if (!this.closing) {\n                client.hset(this.keys.meta, \"opts.maxLenEvents\", lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(opts, \"streams.events.maxLen\", 10000));\n            }\n        }).catch((err)=>{\n        // We ignore this error to avoid warnings. The error can still\n        // be received by listening to event 'error'\n        });\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Returns this instance current default job options.\n     */ get defaultJobOptions() {\n        return Object.assign({}, this.jobsOpts);\n    }\n    get repeat() {\n        return new Promise(async (resolve)=>{\n            if (!this._repeat) {\n                this._repeat = new _repeat__WEBPACK_IMPORTED_MODULE_3__.Repeat(this.name, Object.assign(Object.assign({}, this.opts), {\n                    connection: await this.client\n                }));\n                this._repeat.on(\"error\", (e)=>this.emit.bind(this, e));\n            }\n            resolve(this._repeat);\n        });\n    }\n    /**\n     * Adds a new job to the queue.\n     *\n     * @param name - Name of the job to be added to the queue,.\n     * @param data - Arbitrary data to append to the job.\n     * @param opts - Job options that affects how the job is going to be processed.\n     */ async add(name, data, opts) {\n        if (opts && opts.repeat) {\n            return (await this.repeat).addNextRepeatableJob(name, data, Object.assign(Object.assign({}, this.jobsOpts), opts), true);\n        } else {\n            const jobId = opts === null || opts === void 0 ? void 0 : opts.jobId;\n            if (jobId == \"0\" || (jobId === null || jobId === void 0 ? void 0 : jobId.startsWith(\"0:\"))) {\n                throw new Error(\"JobId cannot be '0' or start with 0:\");\n            }\n            const job = await this.Job.create(this, name, data, Object.assign(Object.assign(Object.assign({}, this.jobsOpts), opts), {\n                jobId\n            }));\n            this.emit(\"waiting\", job);\n            return job;\n        }\n    }\n    /**\n     * Adds an array of jobs to the queue. This method may be faster than adding\n     * one job at a time in a sequence.\n     *\n     * @param jobs - The array of jobs to add to the queue. Each job is defined by 3\n     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.\n     */ addBulk(jobs) {\n        return this.Job.createBulk(this, jobs.map((job)=>{\n            var _a;\n            return {\n                name: job.name,\n                data: job.data,\n                opts: Object.assign(Object.assign(Object.assign({}, this.jobsOpts), job.opts), {\n                    jobId: (_a = job.opts) === null || _a === void 0 ? void 0 : _a.jobId\n                })\n            };\n        }));\n    }\n    /**\n     * Pauses the processing of this queue globally.\n     *\n     * We use an atomic RENAME operation on the wait queue. Since\n     * we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue\n     * is renamed to 'paused', no new jobs will be processed (the current ones\n     * will run until finalized).\n     *\n     * Adding jobs requires a LUA script to check first if the paused list exist\n     * and in that case it will add it there instead of the wait list.\n     */ async pause() {\n        await this.scripts.pause(true);\n        this.emit(\"paused\");\n    }\n    /**\n     * Close the queue instance.\n     *\n     */ async close() {\n        if (!this.closing) {\n            if (this._repeat) {\n                await this._repeat.close();\n            }\n        }\n        return super.close();\n    }\n    /**\n     * Resumes the processing of this queue globally.\n     *\n     * The method reverses the pause operation by resuming the processing of the\n     * queue.\n     */ async resume() {\n        await this.scripts.pause(false);\n        this.emit(\"resumed\");\n    }\n    /**\n     * Returns true if the queue is currently paused.\n     */ async isPaused() {\n        const client = await this.client;\n        const pausedKeyExists = await client.hexists(this.keys.meta, \"paused\");\n        return pausedKeyExists === 1;\n    }\n    /**\n     * Get all repeatable meta jobs.\n     *\n     * @param start - Offset of first job to return.\n     * @param end - Offset of last job to return.\n     * @param asc - Determine the order in which jobs are returned based on their\n     * next execution time.\n     */ async getRepeatableJobs(start, end, asc) {\n        return (await this.repeat).getRepeatableJobs(start, end, asc);\n    }\n    /**\n     * Removes a repeatable job.\n     *\n     * Note: you need to use the exact same repeatOpts when deleting a repeatable job\n     * than when adding it.\n     *\n     * @see removeRepeatableByKey\n     *\n     * @param name - job name\n     * @param repeatOpts -\n     * @param jobId -\n     * @returns\n     */ async removeRepeatable(name, repeatOpts, jobId) {\n        const repeat = await this.repeat;\n        const removed = await repeat.removeRepeatable(name, repeatOpts, jobId);\n        return !removed;\n    }\n    /**\n     * Removes a repeatable job by its key. Note that the key is the one used\n     * to store the repeatable job metadata and not one of the job iterations\n     * themselves. You can use \"getRepeatableJobs\" in order to get the keys.\n     *\n     * @see getRepeatableJobs\n     *\n     * @param repeatJobKey - to the repeatable job.\n     * @returns\n     */ async removeRepeatableByKey(key) {\n        const repeat = await this.repeat;\n        const removed = await repeat.removeRepeatableByKey(key);\n        return !removed;\n    }\n    /**\n     * Removes the given job from the queue as well as all its\n     * dependencies.\n     *\n     * @param jobId - The id of the job to remove\n     * @param opts - Options to remove a job\n     * @returns 1 if it managed to remove the job or 0 if the job or\n     * any of its dependencies were locked.\n     */ remove(jobId, { removeChildren = true } = {}) {\n        return this.scripts.remove(jobId, removeChildren);\n    }\n    /**\n     * Updates the given job's progress.\n     *\n     * @param jobId - The id of the job to update\n     * @param progress - number or object to be saved as progress.\n     */ async updateJobProgress(jobId, progress) {\n        return this.scripts.updateProgress(jobId, progress);\n    }\n    /**\n     * Logs one row of job's log data.\n     *\n     * @param jobId - The job id to log against.\n     * @param logRow - string with log data to be logged.\n     * @param keepLogs - max number of log entries to keep (0 for unlimited).\n     *\n     * @returns The total number of log entries for this job so far.\n     */ async addJobLog(jobId, logRow, keepLogs) {\n        return _job__WEBPACK_IMPORTED_MODULE_1__.Job.addJobLog(this, jobId, logRow, keepLogs);\n    }\n    /**\n     * Drains the queue, i.e., removes all jobs that are waiting\n     * or delayed, but not active, completed or failed.\n     *\n     * @param delayed - Pass true if it should also clean the\n     * delayed jobs.\n     */ drain(delayed = false) {\n        return this.scripts.drain(delayed);\n    }\n    /**\n     * Cleans jobs from a queue. Similar to drain but keeps jobs within a certain\n     * grace period.\n     *\n     * @param grace - The grace period\n     * @param limit - Max number of jobs to clean\n     * @param type - The type of job to clean\n     * Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.\n     * @returns Id jobs from the deleted records\n     */ async clean(grace, limit, type = \"completed\") {\n        const maxCount = limit || Infinity;\n        const maxCountPerCall = Math.min(10000, maxCount);\n        const timestamp = Date.now() - grace;\n        let deletedCount = 0;\n        const deletedJobsIds = [];\n        while(deletedCount < maxCount){\n            const jobsIds = await this.scripts.cleanJobsInSet(type, timestamp, maxCountPerCall);\n            this.emit(\"cleaned\", jobsIds, type);\n            deletedCount += jobsIds.length;\n            deletedJobsIds.push(...jobsIds);\n            if (jobsIds.length < maxCountPerCall) {\n                break;\n            }\n        }\n        return deletedJobsIds;\n    }\n    /**\n     * Completely destroys the queue and all of its contents irreversibly.\n     * This method will the *pause* the queue and requires that there are no\n     * active jobs. It is possible to bypass this requirement, i.e. not\n     * having active jobs using the \"force\" option.\n     *\n     * Note: This operation requires to iterate on all the jobs stored in the queue\n     * and can be slow for very large queues.\n     *\n     * @param opts - Obliterate options.\n     */ async obliterate(opts) {\n        await this.pause();\n        let cursor = 0;\n        do {\n            cursor = await this.scripts.obliterate(Object.assign({\n                force: false,\n                count: 1000\n            }, opts));\n        }while (cursor);\n    }\n    /**\n     * Retry all the failed or completed jobs.\n     *\n     * @param opts: { count: number; state: FinishedStatus; timestamp: number}\n     *   - count  number to limit how many jobs will be moved to wait status per iteration,\n     *   - state  failed by default or completed.\n     *   - timestamp from which timestamp to start moving jobs to wait status, default Date.now().\n     *\n     * @returns\n     */ async retryJobs(opts = {}) {\n        let cursor = 0;\n        do {\n            cursor = await this.scripts.retryJobs(opts.state, opts.count, opts.timestamp);\n        }while (cursor);\n    }\n    /**\n     * Promote all the delayed jobs.\n     *\n     * @param opts: { count: number }\n     *   - count  number to limit how many jobs will be moved to wait status per iteration\n     *\n     * @returns\n     */ async promoteJobs(opts = {}) {\n        let cursor = 0;\n        do {\n            cursor = await this.scripts.promoteJobs(opts.count);\n        }while (cursor);\n    }\n    /**\n     * Trim the event stream to an approximately maxLength.\n     *\n     * @param maxLength -\n     */ async trimEvents(maxLength) {\n        const client = await this.client;\n        return client.xtrim(this.keys.events, \"MAXLEN\", \"~\", maxLength);\n    }\n    /**\n     * Delete old priority helper key.\n     */ async removeDeprecatedPriorityKey() {\n        const client = await this.client;\n        return client.del(this.toKey(\"priority\"));\n    }\n} //# sourceMappingURL=queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QjtBQUNIO0FBQ0U7QUFDbUI7QUFDYjtBQUNsQzs7Ozs7O0NBTUMsR0FDTSxNQUFNSyxjQUFjRix3REFBWUE7SUFDbkNHLFlBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxVQUFVLENBQUU7UUFDaEMsSUFBSUM7UUFDSixLQUFLLENBQUNILE1BQU1JLE9BQU9DLE1BQU0sQ0FBQztZQUFFQyxvQkFBb0I7UUFBTSxHQUFHTCxPQUFPQztRQUNoRSxJQUFJLENBQUNLLEtBQUssR0FBR2IsZ0RBQUVBO1FBQ2YsSUFBSSxDQUFDYyxRQUFRLEdBQUcsQ0FBQ0wsS0FBS1YsaURBQUdBLENBQUNRLE1BQU0sb0JBQW1CLE1BQU8sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQUssQ0FBQztRQUN4RixJQUFJLENBQUNNLGNBQWMsR0FDZEMsSUFBSSxDQUFDQyxDQUFBQTtZQUNOLElBQUksQ0FBQyxJQUFJLENBQUNDLE9BQU8sRUFBRTtnQkFDZkQsT0FBT0UsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEVBQUUscUJBQXFCdEIsaURBQUdBLENBQUNRLE1BQU0seUJBQXlCO1lBQ3hGO1FBQ0osR0FDS2UsS0FBSyxDQUFDQyxDQUFBQTtRQUNQLDhEQUE4RDtRQUM5RCw0Q0FBNEM7UUFDaEQ7SUFDSjtJQUNBQyxLQUFLQyxLQUFLLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ2pCLE9BQU8sS0FBSyxDQUFDRixLQUFLQyxVQUFVQztJQUNoQztJQUNBQyxJQUFJQyxTQUFTLEVBQUVDLFFBQVEsRUFBRTtRQUNyQixLQUFLLENBQUNGLElBQUlDLFdBQVdDO1FBQ3JCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLEdBQUdMLEtBQUssRUFBRUksUUFBUSxFQUFFO1FBQ2hCLEtBQUssQ0FBQ0MsR0FBR0wsT0FBT0k7UUFDaEIsT0FBTyxJ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LElBQUksQ0FBQ0EsTUFBTTtRQUNoQyxPQUFPQSxPQUFPMkYsR0FBRyxDQUFDLElBQUksQ0FBQ0MsS0FBSyxDQUFDO0lBQ2pDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLmpzP2QwMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBKb2IgfSBmcm9tICcuL2pvYic7XG5pbXBvcnQgeyBRdWV1ZUdldHRlcnMgfSBmcm9tICcuL3F1ZXVlLWdldHRlcnMnO1xuaW1wb3J0IHsgUmVwZWF0IH0gZnJvbSAnLi9yZXBlYXQnO1xuLyoqXG4gKiBRdWV1ZVxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBhZGQgam9icyB0byBhIHF1ZXVlIGFuZCBzb21lIG90aGVyIGhpZ2gtbGV2ZWxcbiAqIGFkbWluaXN0cmF0aW9uIHN1Y2ggYXMgcGF1c2luZyBvciBkZWxldGluZyBxdWV1ZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUXVldWUgZXh0ZW5kcyBRdWV1ZUdldHRlcnMge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdHMsIENvbm5lY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihuYW1lLCBPYmplY3QuYXNzaWduKHsgYmxvY2tpbmdDb25uZWN0aW9uOiBmYWxzZSB9LCBvcHRzKSwgQ29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMudG9rZW4gPSB2NCgpO1xuICAgICAgICB0aGlzLmpvYnNPcHRzID0gKF9hID0gZ2V0KG9wdHMsICdkZWZhdWx0Sm9iT3B0aW9ucycpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgdGhpcy53YWl0VW50aWxSZWFkeSgpXG4gICAgICAgICAgICAudGhlbihjbGllbnQgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBjbGllbnQuaHNldCh0aGlzLmtleXMubWV0YSwgJ29wdHMubWF4TGVuRXZlbnRzJywgZ2V0KG9wdHMsICdzdHJlYW1zLmV2ZW50cy5tYXhMZW4nLCAxMDAwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhpcyBlcnJvciB0byBhdm9pZCB3YXJuaW5ncy4gVGhlIGVycm9yIGNhbiBzdGlsbFxuICAgICAgICAgICAgLy8gYmUgcmVjZWl2ZWQgYnkgbGlzdGVuaW5nIHRvIGV2ZW50ICdlcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBpbnN0YW5jZSBjdXJyZW50IGRlZmF1bHQgam9iIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRKb2JPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5qb2JzT3B0cyk7XG4gICAgfVxuICAgIGdldCByZXBlYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQgPSBuZXcgUmVwZWF0KHRoaXMubmFtZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpLCB7IGNvbm5lY3Rpb246IGF3YWl0IHRoaXMuY2xpZW50IH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQub24oJ2Vycm9yJywgZSA9PiB0aGlzLmVtaXQuYmluZCh0aGlzLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGpvYiB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGpvYiB0byBiZSBhZGRlZCB0byB0aGUgcXVldWUsLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQXJiaXRyYXJ5IGRhdGEgdG8gYXBwZW5kIHRvIHRoZSBqb2IuXG4gICAgICogQHBhcmFtIG9wdHMgLSBKb2Igb3B0aW9ucyB0aGF0IGFmZmVjdHMgaG93IHRoZSBqb2IgaXMgZ29pbmcgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZChuYW1lLCBkYXRhLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMucmVwZWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVwZWF0KS5hZGROZXh0UmVwZWF0YWJsZUpvYihuYW1lLCBkYXRhLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuam9ic09wdHMpLCBvcHRzKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBqb2JJZCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5qb2JJZDtcbiAgICAgICAgICAgIGlmIChqb2JJZCA9PSAnMCcgfHwgKGpvYklkID09PSBudWxsIHx8IGpvYklkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBqb2JJZC5zdGFydHNXaXRoKCcwOicpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpvYklkIGNhbm5vdCBiZSAnMCcgb3Igc3RhcnQgd2l0aCAwOlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IHRoaXMuSm9iLmNyZWF0ZSh0aGlzLCBuYW1lLCBkYXRhLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5qb2JzT3B0cyksIG9wdHMpLCB7IGpvYklkIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnd2FpdGluZycsIGpvYik7XG4gICAgICAgICAgICByZXR1cm4gam9iO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXJyYXkgb2Ygam9icyB0byB0aGUgcXVldWUuIFRoaXMgbWV0aG9kIG1heSBiZSBmYXN0ZXIgdGhhbiBhZGRpbmdcbiAgICAgKiBvbmUgam9iIGF0IGEgdGltZSBpbiBhIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYnMgLSBUaGUgYXJyYXkgb2Ygam9icyB0byBhZGQgdG8gdGhlIHF1ZXVlLiBFYWNoIGpvYiBpcyBkZWZpbmVkIGJ5IDNcbiAgICAgKiBwcm9wZXJ0aWVzLCAnbmFtZScsICdkYXRhJyBhbmQgJ29wdHMnLiBUaGV5IGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmUgYXMgJ1F1ZXVlLmFkZCcuXG4gICAgICovXG4gICAgYWRkQnVsayhqb2JzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkpvYi5jcmVhdGVCdWxrKHRoaXMsIGpvYnMubWFwKGpvYiA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBqb2IubmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBqb2IuZGF0YSxcbiAgICAgICAgICAgICAgICBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5qb2JzT3B0cyksIGpvYi5vcHRzKSwgeyBqb2JJZDogKF9hID0gam9iLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2JJZCB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0aGlzIHF1ZXVlIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogV2UgdXNlIGFuIGF0b21pYyBSRU5BTUUgb3BlcmF0aW9uIG9uIHRoZSB3YWl0IHF1ZXVlLiBTaW5jZVxuICAgICAqIHdlIGhhdmUgYmxvY2tpbmcgY2FsbHMgd2l0aCBCUlBPUExQVVNIIG9uIHRoZSB3YWl0IHF1ZXVlLCBhcyBsb25nIGFzIHRoZSBxdWV1ZVxuICAgICAqIGlzIHJlbmFtZWQgdG8gJ3BhdXNlZCcsIG5vIG5ldyBqb2JzIHdpbGwgYmUgcHJvY2Vzc2VkICh0aGUgY3VycmVudCBvbmVzXG4gICAgICogd2lsbCBydW4gdW50aWwgZmluYWxpemVkKS5cbiAgICAgKlxuICAgICAqIEFkZGluZyBqb2JzIHJlcXVpcmVzIGEgTFVBIHNjcmlwdCB0byBjaGVjayBmaXJzdCBpZiB0aGUgcGF1c2VkIGxpc3QgZXhpc3RcbiAgICAgKiBhbmQgaW4gdGhhdCBjYXNlIGl0IHdpbGwgYWRkIGl0IHRoZXJlIGluc3RlYWQgb2YgdGhlIHdhaXQgbGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBwYXVzZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLnBhdXNlKHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgcXVldWUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZXBlYXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZiB0aGlzIHF1ZXVlIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCByZXZlcnNlcyB0aGUgcGF1c2Ugb3BlcmF0aW9uIGJ5IHJlc3VtaW5nIHRoZSBwcm9jZXNzaW5nIG9mIHRoZVxuICAgICAqIHF1ZXVlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VtZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaXMgY3VycmVudGx5IHBhdXNlZC5cbiAgICAgKi9cbiAgICBhc3luYyBpc1BhdXNlZCgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIGNvbnN0IHBhdXNlZEtleUV4aXN0cyA9IGF3YWl0IGNsaWVudC5oZXhpc3RzKHRoaXMua2V5cy5tZXRhLCAncGF1c2VkJyk7XG4gICAgICAgIHJldHVybiBwYXVzZWRLZXlFeGlzdHMgPT09IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVwZWF0YWJsZSBtZXRhIGpvYnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBPZmZzZXQgb2YgZmlyc3Qgam9iIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gZW5kIC0gT2Zmc2V0IG9mIGxhc3Qgam9iIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gYXNjIC0gRGV0ZXJtaW5lIHRoZSBvcmRlciBpbiB3aGljaCBqb2JzIGFyZSByZXR1cm5lZCBiYXNlZCBvbiB0aGVpclxuICAgICAqIG5leHQgZXhlY3V0aW9uIHRpbWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVwZWF0YWJsZUpvYnMoc3RhcnQsIGVuZCwgYXNjKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5yZXBlYXQpLmdldFJlcGVhdGFibGVKb2JzKHN0YXJ0LCBlbmQsIGFzYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSByZXBlYXRhYmxlIGpvYi5cbiAgICAgKlxuICAgICAqIE5vdGU6IHlvdSBuZWVkIHRvIHVzZSB0aGUgZXhhY3Qgc2FtZSByZXBlYXRPcHRzIHdoZW4gZGVsZXRpbmcgYSByZXBlYXRhYmxlIGpvYlxuICAgICAqIHRoYW4gd2hlbiBhZGRpbmcgaXQuXG4gICAgICpcbiAgICAgKiBAc2VlIHJlbW92ZVJlcGVhdGFibGVCeUtleVxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBqb2IgbmFtZVxuICAgICAqIEBwYXJhbSByZXBlYXRPcHRzIC1cbiAgICAgKiBAcGFyYW0gam9iSWQgLVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZShuYW1lLCByZXBlYXRPcHRzLCBqb2JJZCkge1xuICAgICAgICBjb25zdCByZXBlYXQgPSBhd2FpdCB0aGlzLnJlcGVhdDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHJlcGVhdC5yZW1vdmVSZXBlYXRhYmxlKG5hbWUsIHJlcGVhdE9wdHMsIGpvYklkKTtcbiAgICAgICAgcmV0dXJuICFyZW1vdmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcmVwZWF0YWJsZSBqb2IgYnkgaXRzIGtleS4gTm90ZSB0aGF0IHRoZSBrZXkgaXMgdGhlIG9uZSB1c2VkXG4gICAgICogdG8gc3RvcmUgdGhlIHJlcGVhdGFibGUgam9iIG1ldGFkYXRhIGFuZCBub3Qgb25lIG9mIHRoZSBqb2IgaXRlcmF0aW9uc1xuICAgICAqIHRoZW1zZWx2ZXMuIFlvdSBjYW4gdXNlIFwiZ2V0UmVwZWF0YWJsZUpvYnNcIiBpbiBvcmRlciB0byBnZXQgdGhlIGtleXMuXG4gICAgICpcbiAgICAgKiBAc2VlIGdldFJlcGVhdGFibGVKb2JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVwZWF0Sm9iS2V5IC0gdG8gdGhlIHJlcGVhdGFibGUgam9iLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZUJ5S2V5KGtleSkge1xuICAgICAgICBjb25zdCByZXBlYXQgPSBhd2FpdCB0aGlzLnJlcGVhdDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHJlcGVhdC5yZW1vdmVSZXBlYXRhYmxlQnlLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuICFyZW1vdmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBqb2IgZnJvbSB0aGUgcXVldWUgYXMgd2VsbCBhcyBhbGwgaXRzXG4gICAgICogZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYklkIC0gVGhlIGlkIG9mIHRoZSBqb2IgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIHRvIHJlbW92ZSBhIGpvYlxuICAgICAqIEByZXR1cm5zIDEgaWYgaXQgbWFuYWdlZCB0byByZW1vdmUgdGhlIGpvYiBvciAwIGlmIHRoZSBqb2Igb3JcbiAgICAgKiBhbnkgb2YgaXRzIGRlcGVuZGVuY2llcyB3ZXJlIGxvY2tlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoam9iSWQsIHsgcmVtb3ZlQ2hpbGRyZW4gPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLnJlbW92ZShqb2JJZCwgcmVtb3ZlQ2hpbGRyZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBqb2IncyBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqb2JJZCAtIFRoZSBpZCBvZiB0aGUgam9iIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyAtIG51bWJlciBvciBvYmplY3QgdG8gYmUgc2F2ZWQgYXMgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSm9iUHJvZ3Jlc3Moam9iSWQsIHByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMudXBkYXRlUHJvZ3Jlc3Moam9iSWQsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBvbmUgcm93IG9mIGpvYidzIGxvZyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYklkIC0gVGhlIGpvYiBpZCB0byBsb2cgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gbG9nUm93IC0gc3RyaW5nIHdpdGggbG9nIGRhdGEgdG8gYmUgbG9nZ2VkLlxuICAgICAqIEBwYXJhbSBrZWVwTG9ncyAtIG1heCBudW1iZXIgb2YgbG9nIGVudHJpZXMgdG8ga2VlcCAoMCBmb3IgdW5saW1pdGVkKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2YgbG9nIGVudHJpZXMgZm9yIHRoaXMgam9iIHNvIGZhci5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRKb2JMb2coam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpIHtcbiAgICAgICAgcmV0dXJuIEpvYi5hZGRKb2JMb2codGhpcywgam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmFpbnMgdGhlIHF1ZXVlLCBpLmUuLCByZW1vdmVzIGFsbCBqb2JzIHRoYXQgYXJlIHdhaXRpbmdcbiAgICAgKiBvciBkZWxheWVkLCBidXQgbm90IGFjdGl2ZSwgY29tcGxldGVkIG9yIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWxheWVkIC0gUGFzcyB0cnVlIGlmIGl0IHNob3VsZCBhbHNvIGNsZWFuIHRoZVxuICAgICAqIGRlbGF5ZWQgam9icy5cbiAgICAgKi9cbiAgICBkcmFpbihkZWxheWVkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5kcmFpbihkZWxheWVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIGpvYnMgZnJvbSBhIHF1ZXVlLiBTaW1pbGFyIHRvIGRyYWluIGJ1dCBrZWVwcyBqb2JzIHdpdGhpbiBhIGNlcnRhaW5cbiAgICAgKiBncmFjZSBwZXJpb2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JhY2UgLSBUaGUgZ3JhY2UgcGVyaW9kXG4gICAgICogQHBhcmFtIGxpbWl0IC0gTWF4IG51bWJlciBvZiBqb2JzIHRvIGNsZWFuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBqb2IgdG8gY2xlYW5cbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGNvbXBsZXRlZCwgd2FpdCwgYWN0aXZlLCBwYXVzZWQsIGRlbGF5ZWQsIGZhaWxlZC4gRGVmYXVsdHMgdG8gY29tcGxldGVkLlxuICAgICAqIEByZXR1cm5zIElkIGpvYnMgZnJvbSB0aGUgZGVsZXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgYXN5bmMgY2xlYW4oZ3JhY2UsIGxpbWl0LCB0eXBlID0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgY29uc3QgbWF4Q291bnQgPSBsaW1pdCB8fCBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgbWF4Q291bnRQZXJDYWxsID0gTWF0aC5taW4oMTAwMDAsIG1heENvdW50KTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKSAtIGdyYWNlO1xuICAgICAgICBsZXQgZGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgZGVsZXRlZEpvYnNJZHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGRlbGV0ZWRDb3VudCA8IG1heENvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBqb2JzSWRzID0gYXdhaXQgdGhpcy5zY3JpcHRzLmNsZWFuSm9ic0luU2V0KHR5cGUsIHRpbWVzdGFtcCwgbWF4Q291bnRQZXJDYWxsKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xlYW5lZCcsIGpvYnNJZHMsIHR5cGUpO1xuICAgICAgICAgICAgZGVsZXRlZENvdW50ICs9IGpvYnNJZHMubGVuZ3RoO1xuICAgICAgICAgICAgZGVsZXRlZEpvYnNJZHMucHVzaCguLi5qb2JzSWRzKTtcbiAgICAgICAgICAgIGlmIChqb2JzSWRzLmxlbmd0aCA8IG1heENvdW50UGVyQ2FsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkSm9ic0lkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVseSBkZXN0cm95cyB0aGUgcXVldWUgYW5kIGFsbCBvZiBpdHMgY29udGVudHMgaXJyZXZlcnNpYmx5LlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgdGhlICpwYXVzZSogdGhlIHF1ZXVlIGFuZCByZXF1aXJlcyB0aGF0IHRoZXJlIGFyZSBub1xuICAgICAqIGFjdGl2ZSBqb2JzLiBJdCBpcyBwb3NzaWJsZSB0byBieXBhc3MgdGhpcyByZXF1aXJlbWVudCwgaS5lLiBub3RcbiAgICAgKiBoYXZpbmcgYWN0aXZlIGpvYnMgdXNpbmcgdGhlIFwiZm9yY2VcIiBvcHRpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiByZXF1aXJlcyB0byBpdGVyYXRlIG9uIGFsbCB0aGUgam9icyBzdG9yZWQgaW4gdGhlIHF1ZXVlXG4gICAgICogYW5kIGNhbiBiZSBzbG93IGZvciB2ZXJ5IGxhcmdlIHF1ZXVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT2JsaXRlcmF0ZSBvcHRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIG9ibGl0ZXJhdGUob3B0cykge1xuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJzb3IgPSBhd2FpdCB0aGlzLnNjcmlwdHMub2JsaXRlcmF0ZShPYmplY3QuYXNzaWduKHsgZm9yY2U6IGZhbHNlLCBjb3VudDogMTAwMCB9LCBvcHRzKSk7XG4gICAgICAgIH0gd2hpbGUgKGN1cnNvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJ5IGFsbCB0aGUgZmFpbGVkIG9yIGNvbXBsZXRlZCBqb2JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHM6IHsgY291bnQ6IG51bWJlcjsgc3RhdGU6IEZpbmlzaGVkU3RhdHVzOyB0aW1lc3RhbXA6IG51bWJlcn1cbiAgICAgKiAgIC0gY291bnQgIG51bWJlciB0byBsaW1pdCBob3cgbWFueSBqb2JzIHdpbGwgYmUgbW92ZWQgdG8gd2FpdCBzdGF0dXMgcGVyIGl0ZXJhdGlvbixcbiAgICAgKiAgIC0gc3RhdGUgIGZhaWxlZCBieSBkZWZhdWx0IG9yIGNvbXBsZXRlZC5cbiAgICAgKiAgIC0gdGltZXN0YW1wIGZyb20gd2hpY2ggdGltZXN0YW1wIHRvIHN0YXJ0IG1vdmluZyBqb2JzIHRvIHdhaXQgc3RhdHVzLCBkZWZhdWx0IERhdGUubm93KCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIHJldHJ5Sm9icyhvcHRzID0ge30pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1cnNvciA9IGF3YWl0IHRoaXMuc2NyaXB0cy5yZXRyeUpvYnMob3B0cy5zdGF0ZSwgb3B0cy5jb3VudCwgb3B0cy50aW1lc3RhbXApO1xuICAgICAgICB9IHdoaWxlIChjdXJzb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9tb3RlIGFsbCB0aGUgZGVsYXllZCBqb2JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHM6IHsgY291bnQ6IG51bWJlciB9XG4gICAgICogICAtIGNvdW50ICBudW1iZXIgdG8gbGltaXQgaG93IG1hbnkgam9icyB3aWxsIGJlIG1vdmVkIHRvIHdhaXQgc3RhdHVzIHBlciBpdGVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcHJvbW90ZUpvYnMob3B0cyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJzb3IgPSBhd2FpdCB0aGlzLnNjcmlwdHMucHJvbW90ZUpvYnMob3B0cy5jb3VudCk7XG4gICAgICAgIH0gd2hpbGUgKGN1cnNvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW0gdGhlIGV2ZW50IHN0cmVhbSB0byBhbiBhcHByb3hpbWF0ZWx5IG1heExlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXhMZW5ndGggLVxuICAgICAqL1xuICAgIGFzeW5jIHRyaW1FdmVudHMobWF4TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50Lnh0cmltKHRoaXMua2V5cy5ldmVudHMsICdNQVhMRU4nLCAnficsIG1heExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBvbGQgcHJpb3JpdHkgaGVscGVyIGtleS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVEZXByZWNhdGVkUHJpb3JpdHlLZXkoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmRlbCh0aGlzLnRvS2V5KCdwcmlvcml0eScpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0IiwidjQiLCJKb2IiLCJRdWV1ZUdldHRlcnMiLCJSZXBlYXQiLCJRdWV1ZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm9wdHMiLCJDb25uZWN0aW9uIiwiX2EiLCJPYmplY3QiLCJhc3NpZ24iLCJibG9ja2luZ0Nvbm5lY3Rpb24iLCJ0b2tlbiIsImpvYnNPcHRzIiwid2FpdFVudGlsUmVhZHkiLCJ0aGVuIiwiY2xpZW50IiwiY2xvc2luZyIsImhzZXQiLCJrZXlzIiwibWV0YSIsImNhdGNoIiwiZXJyIiwiZW1pdCIsImV2ZW50IiwiYXJncyIsIm9mZiIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwib24iLCJvbmNlIiwiZGVmYXVsdEpvYk9wdGlvbnMiLCJyZXBlYXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9yZXBlYXQiLCJjb25uZWN0aW9uIiwiZSIsImJpbmQiLCJhZGQiLCJkYXRhIiwiYWRkTmV4dFJlcGVhdGFibGVKb2IiLCJqb2JJZCIsInN0YXJ0c1dpdGgiLCJFcnJvciIsImpvYiIsImNyZWF0ZSIsImFkZEJ1bGsiLCJqb2JzIiwiY3JlYXRlQnVsayIsIm1hcCIsInBhdXNlIiwic2NyaXB0cyIsImNsb3NlIiwicmVzdW1lIiwiaXNQYXVzZWQiLCJwYXVzZWRLZXlFeGlzdHMiLCJoZXhpc3RzIiwiZ2V0UmVwZWF0YWJsZUpvYnMiLCJzdGFydCIsImVuZCIsImFzYyIsInJlbW92ZVJlcGVhdGFibGUiLCJyZXBlYXRPcHRzIiwicmVtb3ZlZCIsInJlbW92ZVJlcGVhdGFibGVCeUtleSIsImtleSIsInJlbW92ZSIsInJlbW92ZUNoaWxkcmVuIiwidXBkYXRlSm9iUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInVwZGF0ZVByb2dyZXNzIiwiYWRkSm9iTG9nIiwibG9nUm93Iiwia2VlcExvZ3MiLCJkcmFpbiIsImRlbGF5ZWQiLCJjbGVhbiIsImdyYWNlIiwibGltaXQiLCJ0eXBlIiwibWF4Q291bnQiLCJJbmZpbml0eSIsIm1heENvdW50UGVyQ2FsbCIsIk1hdGgiLCJtaW4iLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiZGVsZXRlZENvdW50IiwiZGVsZXRlZEpvYnNJZHMiLCJqb2JzSWRzIiwiY2xlYW5Kb2JzSW5TZXQiLCJsZW5ndGgiLCJwdXNoIiwib2JsaXRlcmF0ZSIsImN1cnNvciIsImZvcmNlIiwiY291bnQiLCJyZXRyeUpvYnMiLCJzdGF0ZSIsInByb21vdGVKb2JzIiwidHJpbUV2ZW50cyIsIm1heExlbmd0aCIsInh0cmltIiwiZXZlbnRzIiwicmVtb3ZlRGVwcmVjYXRlZFByaW9yaXR5S2V5IiwiZGVsIiwidG9LZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/redis-connection.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedisConnection: () => (/* binding */ RedisConnection)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ioredis */ \"(rsc)/./node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ioredis/built/utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js\");\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\n\nconst overrideMessage = [\n    \"BullMQ: WARNING! Your redis options maxRetriesPerRequest must be null\",\n    \"and will be overridden by BullMQ.\"\n].join(\" \");\nconst deprecationMessage = \"BullMQ: Your redis options maxRetriesPerRequest must be null.\";\nclass RedisConnection extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(opts, shared = false, blocking = true, skipVersionCheck = false){\n        super();\n        this.shared = shared;\n        this.blocking = blocking;\n        this.capabilities = {\n            canDoubleTimeout: false\n        };\n        this.status = \"initializing\";\n        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisInstance)(opts)) {\n            this.checkBlockingOptions(overrideMessage, opts);\n            this.opts = Object.assign({\n                port: 6379,\n                host: \"127.0.0.1\",\n                retryStrategy: function(times) {\n                    return Math.max(Math.min(Math.exp(times), 20000), 1000);\n                }\n            }, opts);\n            if (this.blocking) {\n                this.opts.maxRetriesPerRequest = null;\n            }\n        } else {\n            this._client = opts;\n            // Test if the redis instance is using keyPrefix\n            // and if so, throw an error.\n            if (this._client.options.keyPrefix) {\n                throw new Error(\"BullMQ: ioredis does not support ioredis prefixes, use the prefix option instead.\");\n            }\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisCluster)(this._client)) {\n                this.opts = this._client.options.redisOptions;\n            } else {\n                this.opts = this._client.options;\n            }\n            this.checkBlockingOptions(deprecationMessage, this.opts, true);\n        }\n        this.skipVersionCheck = skipVersionCheck || !!(this.opts && this.opts.skipVersionCheck);\n        this.handleClientError = (err)=>{\n            this.emit(\"error\", err);\n        };\n        this.handleClientClose = ()=>{\n            this.emit(\"close\");\n        };\n        this.handleClientReady = ()=>{\n            this.emit(\"ready\");\n        };\n        this.initializing = this.init();\n        this.initializing.catch((err)=>this.emit(\"error\", err));\n    }\n    checkBlockingOptions(msg, options, throwError = false) {\n        if (this.blocking && options && options.maxRetriesPerRequest) {\n            if (throwError) {\n                throw new Error(msg);\n            } else {\n                console.error(msg);\n            }\n        }\n    }\n    /**\n     * Waits for a redis client to be ready.\n     * @param redis - client\n     */ static async waitUntilReady(client) {\n        if (client.status === \"ready\") {\n            return;\n        }\n        if (client.status === \"wait\") {\n            return client.connect();\n        }\n        if (client.status === \"end\") {\n            throw new Error(ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_CLOSED_ERROR_MSG);\n        }\n        let handleReady;\n        let handleEnd;\n        let handleError;\n        try {\n            await new Promise((resolve, reject)=>{\n                let lastError;\n                handleError = (err)=>{\n                    lastError = err;\n                };\n                handleReady = ()=>{\n                    resolve();\n                };\n                handleEnd = ()=>{\n                    reject(lastError || new Error(ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(client, 3);\n                client.once(\"ready\", handleReady);\n                client.on(\"end\", handleEnd);\n                client.once(\"error\", handleError);\n            });\n        } finally{\n            client.removeListener(\"end\", handleEnd);\n            client.removeListener(\"error\", handleError);\n            client.removeListener(\"ready\", handleReady);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(client, 3);\n        }\n    }\n    get client() {\n        return this.initializing;\n    }\n    loadCommands(providedScripts) {\n        const finalScripts = providedScripts || _scripts__WEBPACK_IMPORTED_MODULE_4__;\n        for(const property in finalScripts){\n            // Only define the command if not already defined\n            if (!this._client[finalScripts[property].name]) {\n                this._client.defineCommand(finalScripts[property].name, {\n                    numberOfKeys: finalScripts[property].keys,\n                    lua: finalScripts[property].content\n                });\n            }\n        }\n    }\n    async init() {\n        if (!this._client) {\n            this._client = new (ioredis__WEBPACK_IMPORTED_MODULE_1___default())(this.opts);\n        }\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(this._client, 3);\n        this._client.on(\"error\", this.handleClientError);\n        // ioredis treats connection errors as a different event ('close')\n        this._client.on(\"close\", this.handleClientClose);\n        this._client.on(\"ready\", this.handleClientReady);\n        await RedisConnection.waitUntilReady(this._client);\n        this.loadCommands();\n        this.version = await this.getRedisVersion();\n        if (this.skipVersionCheck !== true && !this.closing) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, RedisConnection.minimumVersion)) {\n                throw new Error(`Redis version needs to be greater or equal than ${RedisConnection.minimumVersion} Current: ${this.version}`);\n            }\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, RedisConnection.recommendedMinimumVersion)) {\n                console.warn(`It is highly recommended to use a minimum Redis version of ${RedisConnection.recommendedMinimumVersion}\n           Current: ${this.version}`);\n            }\n        }\n        this.capabilities = {\n            canDoubleTimeout: !(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, \"6.0.0\")\n        };\n        this.status = \"ready\";\n        return this._client;\n    }\n    async disconnect(wait = true) {\n        const client = await this.client;\n        if (client.status !== \"end\") {\n            let _resolve, _reject;\n            if (!wait) {\n                return client.disconnect();\n            }\n            const disconnecting = new Promise((resolve, reject)=>{\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(client, 2);\n                client.once(\"end\", resolve);\n                client.once(\"error\", reject);\n                _resolve = resolve;\n                _reject = reject;\n            });\n            client.disconnect();\n            try {\n                await disconnecting;\n            } finally{\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(client, 2);\n                client.removeListener(\"end\", _resolve);\n                client.removeListener(\"error\", _reject);\n            }\n        }\n    }\n    async reconnect() {\n        const client = await this.client;\n        return client.connect();\n    }\n    async close() {\n        if (!this.closing) {\n            const status = this.status;\n            this.status = \"closing\";\n            this.closing = true;\n            try {\n                if (status === \"ready\") {\n                    // Not sure if we need to wait for this\n                    await this.initializing;\n                }\n                if (!this.shared) {\n                    if (status == \"initializing\") {\n                        // If we have not still connected to Redis, we need to disconnect.\n                        this._client.disconnect();\n                    } else {\n                        await this._client.quit();\n                    }\n                    // As IORedis does not update this status properly, we do it ourselves.\n                    this._client[\"status\"] = \"end\";\n                }\n            } catch (error) {\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isNotConnectionError)(error)) {\n                    throw error;\n                }\n            } finally{\n                this._client.off(\"error\", this.handleClientError);\n                this._client.off(\"close\", this.handleClientClose);\n                this._client.off(\"ready\", this.handleClientReady);\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(this._client, 3);\n                this.removeAllListeners();\n                this.status = \"closed\";\n            }\n        }\n    }\n    async getRedisVersion() {\n        const doc = await this._client.info();\n        const redisPrefix = \"redis_version:\";\n        const maxMemoryPolicyPrefix = \"maxmemory_policy:\";\n        const lines = doc.split(\"\\r\\n\");\n        let redisVersion;\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].indexOf(maxMemoryPolicyPrefix) === 0) {\n                const maxMemoryPolicy = lines[i].substr(maxMemoryPolicyPrefix.length);\n                if (maxMemoryPolicy !== \"noeviction\") {\n                    console.warn(`IMPORTANT! Eviction policy is ${maxMemoryPolicy}. It should be \"noeviction\"`);\n                }\n            }\n            if (lines[i].indexOf(redisPrefix) === 0) {\n                redisVersion = lines[i].substr(redisPrefix.length);\n            }\n        }\n        return redisVersion;\n    }\n    get redisVersion() {\n        return this.version;\n    }\n}\nRedisConnection.minimumVersion = \"5.0.0\";\nRedisConnection.recommendedMinimumVersion = \"6.2.0\"; //# sourceMappingURL=redis-connection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcmVkaXMtY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUNPO0FBQzdDLDZEQUE2RDtBQUM3RCxhQUFhO0FBQ3FEO0FBQ3FGO0FBQ2pIO0FBQ3RDLE1BQU1XLGtCQUFrQjtJQUNwQjtJQUNBO0NBQ0gsQ0FBQ0MsSUFBSSxDQUFDO0FBQ1AsTUFBTUMscUJBQXFCO0FBQ3BCLE1BQU1DLHdCQUF3QmQsZ0RBQVlBO0lBQzdDZSxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsS0FBSyxFQUFFQyxXQUFXLElBQUksRUFBRUMsbUJBQW1CLEtBQUssQ0FBRTtRQUN6RSxLQUFLO1FBQ0wsSUFBSSxDQUFDRixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0UsWUFBWSxHQUFHO1lBQ2hCQyxrQkFBa0I7UUFDdEI7UUFDQSxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ2QsdURBQWVBLENBQUNRLE9BQU87WUFDeEIsSUFBSSxDQUFDTyxvQkFBb0IsQ0FBQ1osaUJBQWlCSztZQUMzQyxJQUFJLENBQUNBLElBQUksR0FBR1EsT0FBT0MsTUFBTSxDQUFDO2dCQUFFQyxNQUFNO2dCQUFNQyxNQUFNO2dCQUFhQyxlQUFlLFNBQVVDLEtBQUs7b0JBQ2pGLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDRixLQUFLRyxHQUFHLENBQUNKLFFBQVEsUUFBUTtnQkFDdEQ7WUFBRSxHQUFHYjtZQUNULElBQUksSUFBSSxDQUFDRSxRQUFRLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDRixJQUFJLENBQUNrQixvQkFBb0IsR0FBRztZQUNyQztRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUNDLE9BQU8sR0FBR25CO1lBQ2YsZ0RBQWdEO1lBQ2hELDZCQUE2QjtZQUM3QixJQUFJLElBQUksQ0FBQ21CLE9BQU8sQ0FBQ0Ms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Q0EsTUFBTXNELGtCQUFrQjtRQUNwQixNQUFNZSxNQUFNLE1BQU0sSUFBSSxDQUFDeEQsT0FBTyxDQUFDeUQsSUFBSTtRQUNuQyxNQUFNQyxjQUFjO1FBQ3BCLE1BQU1DLHdCQUF3QjtRQUM5QixNQUFNQyxRQUFRSixJQUFJSyxLQUFLLENBQUM7UUFDeEIsSUFBSUM7UUFDSixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsTUFBTUksTUFBTSxFQUFFRCxJQUFLO1lBQ25DLElBQUlILEtBQUssQ0FBQ0csRUFBRSxDQUFDRSxPQUFPLENBQUNOLDJCQUEyQixHQUFHO2dCQUMvQyxNQUFNTyxrQkFBa0JOLEtBQUssQ0FBQ0csRUFBRSxDQUFDSSxNQUFNLENBQUNSLHNCQUFzQkssTUFBTTtnQkFDcEUsSUFBSUUsb0JBQW9CLGNBQWM7b0JBQ2xDbkQsUUFBUThCLElBQUksQ0FBQyxDQUFDLDhCQUE4QixFQUFFcUIsZ0JBQWdCLDJCQUEyQixDQUFDO2dCQUM5RjtZQUNKO1lBQ0EsSUFBSU4sS0FBSyxDQUFDRyxFQUFFLENBQUNFLE9BQU8sQ0FBQ1AsaUJBQWlCLEdBQUc7Z0JBQ3JDSSxlQUFlRixLQUFLLENBQUNHLEVBQUUsQ0FBQ0ksTUFBTSxDQUFDVCxZQUFZTSxNQUFNO1lBQ3JEO1FBQ0o7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsSUFBSUEsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDdEIsT0FBTztJQUN2QjtBQUNKO0FBQ0E3RCxnQkFBZ0JnRSxjQUFjLEdBQUc7QUFDakNoRSxnQkFBZ0JpRSx5QkFBeUIsR0FBRyxTQUM1Qyw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3JlZGlzLWNvbm5lY3Rpb24uanM/MzRlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBJT1JlZGlzIH0gZnJvbSAnaW9yZWRpcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgfSBmcm9tICdpb3JlZGlzL2J1aWx0L3V0aWxzJztcbmltcG9ydCB7IGRlY3JlYXNlTWF4TGlzdGVuZXJzLCBpbmNyZWFzZU1heExpc3RlbmVycywgaXNOb3RDb25uZWN0aW9uRXJyb3IsIGlzUmVkaXNDbHVzdGVyLCBpc1JlZGlzSW5zdGFuY2UsIGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuLCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIHNjcmlwdHMgZnJvbSAnLi4vc2NyaXB0cyc7XG5jb25zdCBvdmVycmlkZU1lc3NhZ2UgPSBbXG4gICAgJ0J1bGxNUTogV0FSTklORyEgWW91ciByZWRpcyBvcHRpb25zIG1heFJldHJpZXNQZXJSZXF1ZXN0IG11c3QgYmUgbnVsbCcsXG4gICAgJ2FuZCB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgQnVsbE1RLicsXG5dLmpvaW4oJyAnKTtcbmNvbnN0IGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdCdWxsTVE6IFlvdXIgcmVkaXMgb3B0aW9ucyBtYXhSZXRyaWVzUGVyUmVxdWVzdCBtdXN0IGJlIG51bGwuJztcbmV4cG9ydCBjbGFzcyBSZWRpc0Nvbm5lY3Rpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMsIHNoYXJlZCA9IGZhbHNlLCBibG9ja2luZyA9IHRydWUsIHNraXBWZXJzaW9uQ2hlY2sgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNoYXJlZCA9IHNoYXJlZDtcbiAgICAgICAgdGhpcy5ibG9ja2luZyA9IGJsb2NraW5nO1xuICAgICAgICB0aGlzLmNhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgIGNhbkRvdWJsZVRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdpbml0aWFsaXppbmcnO1xuICAgICAgICBpZiAoIWlzUmVkaXNJbnN0YW5jZShvcHRzKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Jsb2NraW5nT3B0aW9ucyhvdmVycmlkZU1lc3NhZ2UsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7IHBvcnQ6IDYzNzksIGhvc3Q6ICcxMjcuMC4wLjEnLCByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKE1hdGguZXhwKHRpbWVzKSwgMjAwMDApLCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9IH0sIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMubWF4UmV0cmllc1BlclJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50ID0gb3B0cztcbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIHJlZGlzIGluc3RhbmNlIGlzIHVzaW5nIGtleVByZWZpeFxuICAgICAgICAgICAgLy8gYW5kIGlmIHNvLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGllbnQub3B0aW9ucy5rZXlQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1bGxNUTogaW9yZWRpcyBkb2VzIG5vdCBzdXBwb3J0IGlvcmVkaXMgcHJlZml4ZXMsIHVzZSB0aGUgcHJlZml4IG9wdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUmVkaXNDbHVzdGVyKHRoaXMuX2NsaWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9jbGllbnQub3B0aW9ucy5yZWRpc09wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9jbGllbnQub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hlY2tCbG9ja2luZ09wdGlvbnMoZGVwcmVjYXRpb25NZXNzYWdlLCB0aGlzLm9wdHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcFZlcnNpb25DaGVjayA9XG4gICAgICAgICAgICBza2lwVmVyc2lvbkNoZWNrIHx8ICEhKHRoaXMub3B0cyAmJiB0aGlzLm9wdHMuc2tpcFZlcnNpb25DaGVjayk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpZW50RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICB9XG4gICAgY2hlY2tCbG9ja2luZ09wdGlvbnMobXNnLCBvcHRpb25zLCB0aHJvd0Vycm9yID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmcgJiYgb3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJpZXNQZXJSZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhyb3dFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBhIHJlZGlzIGNsaWVudCB0byBiZSByZWFkeS5cbiAgICAgKiBAcGFyYW0gcmVkaXMgLSBjbGllbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgd2FpdFVudGlsUmVhZHkoY2xpZW50KSB7XG4gICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAncmVhZHknKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgPT09ICd3YWl0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlUmVhZHk7XG4gICAgICAgIGxldCBoYW5kbGVFbmQ7XG4gICAgICAgIGxldCBoYW5kbGVFcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBoYW5kbGVSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaGFuZGxlRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobGFzdEVycm9yIHx8IG5ldyBFcnJvcihDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluY3JlYXNlTWF4TGlzdGVuZXJzKGNsaWVudCwgMyk7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ3JlYWR5JywgaGFuZGxlUmVhZHkpO1xuICAgICAgICAgICAgICAgIGNsaWVudC5vbignZW5kJywgaGFuZGxlRW5kKTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25jZSgnZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZW5kJywgaGFuZGxlRW5kKTtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ3JlYWR5JywgaGFuZGxlUmVhZHkpO1xuICAgICAgICAgICAgZGVjcmVhc2VNYXhMaXN0ZW5lcnMoY2xpZW50LCAzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXppbmc7XG4gICAgfVxuICAgIGxvYWRDb21tYW5kcyhwcm92aWRlZFNjcmlwdHMpIHtcbiAgICAgICAgY29uc3QgZmluYWxTY3JpcHRzID0gcHJvdmlkZWRTY3JpcHRzIHx8IHNjcmlwdHM7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gZmluYWxTY3JpcHRzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRlZmluZSB0aGUgY29tbWFuZCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NsaWVudFtmaW5hbFNjcmlwdHNbcHJvcGVydHldLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LmRlZmluZUNvbW1hbmQoZmluYWxTY3JpcHRzW3Byb3BlcnR5XS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mS2V5czogZmluYWxTY3JpcHRzW3Byb3BlcnR5XS5rZXlzLFxuICAgICAgICAgICAgICAgICAgICBsdWE6IGZpbmFsU2NyaXB0c1twcm9wZXJ0eV0uY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50ID0gbmV3IElPUmVkaXModGhpcy5vcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpbmNyZWFzZU1heExpc3RlbmVycyh0aGlzLl9jbGllbnQsIDMpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ2Vycm9yJywgdGhpcy5oYW5kbGVDbGllbnRFcnJvcik7XG4gICAgICAgIC8vIGlvcmVkaXMgdHJlYXRzIGNvbm5lY3Rpb24gZXJyb3JzIGFzIGEgZGlmZmVyZW50IGV2ZW50ICgnY2xvc2UnKVxuICAgICAgICB0aGlzLl9jbGllbnQub24oJ2Nsb3NlJywgdGhpcy5oYW5kbGVDbGllbnRDbG9zZSk7XG4gICAgICAgIHRoaXMuX2NsaWVudC5vbigncmVhZHknLCB0aGlzLmhhbmRsZUNsaWVudFJlYWR5KTtcbiAgICAgICAgYXdhaXQgUmVkaXNDb25uZWN0aW9uLndhaXRVbnRpbFJlYWR5KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMubG9hZENvbW1hbmRzKCk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0UmVkaXNWZXJzaW9uKCk7XG4gICAgICAgIGlmICh0aGlzLnNraXBWZXJzaW9uQ2hlY2sgIT09IHRydWUgJiYgIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgaWYgKGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMudmVyc2lvbiwgUmVkaXNDb25uZWN0aW9uLm1pbmltdW1WZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVkaXMgdmVyc2lvbiBuZWVkcyB0byBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gJHtSZWRpc0Nvbm5lY3Rpb24ubWluaW11bVZlcnNpb259IEN1cnJlbnQ6ICR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMudmVyc2lvbiwgUmVkaXNDb25uZWN0aW9uLnJlY29tbWVuZGVkTWluaW11bVZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJdCBpcyBoaWdobHkgcmVjb21tZW5kZWQgdG8gdXNlIGEgbWluaW11bSBSZWRpcyB2ZXJzaW9uIG9mICR7UmVkaXNDb25uZWN0aW9uLnJlY29tbWVuZGVkTWluaW11bVZlcnNpb259XG4gICAgICAgICAgIEN1cnJlbnQ6ICR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgY2FuRG91YmxlVGltZW91dDogIWlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMudmVyc2lvbiwgJzYuMC4wJyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ3JlYWR5JztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCh3YWl0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgIT09ICdlbmQnKSB7XG4gICAgICAgICAgICBsZXQgX3Jlc29sdmUsIF9yZWplY3Q7XG4gICAgICAgICAgICBpZiAoIXdhaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5jcmVhc2VNYXhMaXN0ZW5lcnMoY2xpZW50LCAyKTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGlzY29ubmVjdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlY3JlYXNlTWF4TGlzdGVuZXJzKGNsaWVudCwgMik7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBfcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuY29ubmVjdCgpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSAnY2xvc2luZyc7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAncmVhZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09ICdpbml0aWFsaXppbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vdCBzdGlsbCBjb25uZWN0ZWQgdG8gUmVkaXMsIHdlIG5lZWQgdG8gZGlzY29ubmVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQucXVpdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzIElPUmVkaXMgZG9lcyBub3QgdXBkYXRlIHRoaXMgc3RhdHVzIHByb3Blcmx5LCB3ZSBkbyBpdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudFsnc3RhdHVzJ10gPSAnZW5kJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3RDb25uZWN0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudC5vZmYoJ2Vycm9yJywgdGhpcy5oYW5kbGVDbGllbnRFcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50Lm9mZignY2xvc2UnLCB0aGlzLmhhbmRsZUNsaWVudENsb3NlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQub2ZmKCdyZWFkeScsIHRoaXMuaGFuZGxlQ2xpZW50UmVhZHkpO1xuICAgICAgICAgICAgICAgIGRlY3JlYXNlTWF4TGlzdGVuZXJzKHRoaXMuX2NsaWVudCwgMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJlZGlzVmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5fY2xpZW50LmluZm8oKTtcbiAgICAgICAgY29uc3QgcmVkaXNQcmVmaXggPSAncmVkaXNfdmVyc2lvbjonO1xuICAgICAgICBjb25zdCBtYXhNZW1vcnlQb2xpY3lQcmVmaXggPSAnbWF4bWVtb3J5X3BvbGljeTonO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGRvYy5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGxldCByZWRpc1ZlcnNpb247XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRleE9mKG1heE1lbW9yeVBvbGljeVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhNZW1vcnlQb2xpY3kgPSBsaW5lc1tpXS5zdWJzdHIobWF4TWVtb3J5UG9saWN5UHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heE1lbW9yeVBvbGljeSAhPT0gJ25vZXZpY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSU1QT1JUQU5UISBFdmljdGlvbiBwb2xpY3kgaXMgJHttYXhNZW1vcnlQb2xpY3l9LiBJdCBzaG91bGQgYmUgXCJub2V2aWN0aW9uXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZXhPZihyZWRpc1ByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWRpc1ZlcnNpb24gPSBsaW5lc1tpXS5zdWJzdHIocmVkaXNQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkaXNWZXJzaW9uO1xuICAgIH1cbiAgICBnZXQgcmVkaXNWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgIH1cbn1cblJlZGlzQ29ubmVjdGlvbi5taW5pbXVtVmVyc2lvbiA9ICc1LjAuMCc7XG5SZWRpc0Nvbm5lY3Rpb24ucmVjb21tZW5kZWRNaW5pbXVtVmVyc2lvbiA9ICc2LjIuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcy1jb25uZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJkZWZhdWx0IiwiSU9SZWRpcyIsIkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyIsImRlY3JlYXNlTWF4TGlzdGVuZXJzIiwiaW5jcmVhc2VNYXhMaXN0ZW5lcnMiLCJpc05vdENvbm5lY3Rpb25FcnJvciIsImlzUmVkaXNDbHVzdGVyIiwiaXNSZWRpc0luc3RhbmNlIiwiaXNSZWRpc1ZlcnNpb25Mb3dlclRoYW4iLCJzY3JpcHRzIiwib3ZlcnJpZGVNZXNzYWdlIiwiam9pbiIsImRlcHJlY2F0aW9uTWVzc2FnZSIsIlJlZGlzQ29ubmVjdGlvbiIsImNvbnN0cnVjdG9yIiwib3B0cyIsInNoYXJlZCIsImJsb2NraW5nIiwic2tpcFZlcnNpb25DaGVjayIsImNhcGFiaWxpdGllcyIsImNhbkRvdWJsZVRpbWVvdXQiLCJzdGF0dXMiLCJjaGVja0Jsb2NraW5nT3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInBvcnQiLCJob3N0IiwicmV0cnlTdHJhdGVneSIsInRpbWVzIiwiTWF0aCIsIm1heCIsIm1pbiIsImV4cCIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwiX2NsaWVudCIsIm9wdGlvbnMiLCJrZXlQcmVmaXgiLCJFcnJvciIsInJlZGlzT3B0aW9ucyIsImhhbmRsZUNsaWVudEVycm9yIiwiZXJyIiwiZW1pdCIsImhhbmRsZUNsaWVudENsb3NlIiwiaGFuZGxlQ2xpZW50UmVhZHkiLCJpbml0aWFsaXppbmciLCJpbml0IiwiY2F0Y2giLCJtc2ciLCJ0aHJvd0Vycm9yIiwiY29uc29sZSIsImVycm9yIiwid2FpdFVudGlsUmVhZHkiLCJjbGllbnQiLCJjb25uZWN0IiwiaGFuZGxlUmVhZHkiLCJoYW5kbGVFbmQiLCJoYW5kbGVFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibGFzdEVycm9yIiwib25jZSIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJsb2FkQ29tbWFuZHMiLCJwcm92aWRlZFNjcmlwdHMiLCJmaW5hbFNjcmlwdHMiLCJwcm9wZXJ0eSIsIm5hbWUiLCJkZWZpbmVDb21tYW5kIiwibnVtYmVyT2ZLZXlzIiwia2V5cyIsImx1YSIsImNvbnRlbnQiLCJ2ZXJzaW9uIiwiZ2V0UmVkaXNWZXJzaW9uIiwiY2xvc2luZyIsIm1pbmltdW1WZXJzaW9uIiwicmVjb21tZW5kZWRNaW5pbXVtVmVyc2lvbiIsIndhcm4iLCJkaXNjb25uZWN0Iiwid2FpdCIsIl9yZXNvbHZlIiwiX3JlamVjdCIsImRpc2Nvbm5lY3RpbmciLCJyZWNvbm5lY3QiLCJjbG9zZSIsInF1aXQiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJkb2MiLCJpbmZvIiwicmVkaXNQcmVmaXgiLCJtYXhNZW1vcnlQb2xpY3lQcmVmaXgiLCJsaW5lcyIsInNwbGl0IiwicmVkaXNWZXJzaW9uIiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJtYXhNZW1vcnlQb2xpY3kiLCJzdWJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/repeat.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Repeat: () => (/* binding */ Repeat),\n/* harmony export */   getNextMillis: () => (/* binding */ getNextMillis)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cron-parser */ \"(rsc)/./node_modules/cron-parser/lib/parser.js\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cron_parser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n\n\n\n\nclass Repeat extends _queue_base__WEBPACK_IMPORTED_MODULE_2__.QueueBase {\n    constructor(name, opts, Connection){\n        super(name, opts, Connection);\n        this.repeatStrategy = opts.settings && opts.settings.repeatStrategy || getNextMillis;\n        this.repeatKeyHashAlgorithm = opts.settings && opts.settings.repeatKeyHashAlgorithm || \"md5\";\n    }\n    async addNextRepeatableJob(name, data, opts, skipCheckExists) {\n        var _a;\n        // HACK: This is a temporary fix to enable easy migration from bullmq <3.0.0\n        // to >= 3.0.0. It should be removed when moving to 4.x.\n        const repeatOpts = Object.assign({}, opts.repeat);\n        (_a = repeatOpts.pattern) !== null && _a !== void 0 ? _a : repeatOpts.pattern = repeatOpts.cron;\n        delete repeatOpts.cron;\n        const prevMillis = opts.prevMillis || 0;\n        const currentCount = repeatOpts.count ? repeatOpts.count + 1 : 1;\n        if (typeof repeatOpts.limit !== \"undefined\" && currentCount > repeatOpts.limit) {\n            return;\n        }\n        let now = Date.now();\n        if (!(typeof repeatOpts.endDate === undefined) && now > new Date(repeatOpts.endDate).getTime()) {\n            return;\n        }\n        now = prevMillis < now ? now : prevMillis;\n        const nextMillis = await this.repeatStrategy(now, repeatOpts, name);\n        const pattern = repeatOpts.pattern;\n        const hasImmediately = Boolean((repeatOpts.every || pattern) && repeatOpts.immediately);\n        const offset = hasImmediately ? now - nextMillis : undefined;\n        if (nextMillis) {\n            // We store the undecorated opts.jobId into the repeat options\n            if (!prevMillis && opts.jobId) {\n                repeatOpts.jobId = opts.jobId;\n            }\n            const repeatJobKey = getRepeatKey(name, repeatOpts);\n            let repeatableExists = true;\n            if (!skipCheckExists) {\n                // Check that the repeatable job hasn't been removed\n                // TODO: a lua script would be better here\n                const client = await this.client;\n                repeatableExists = !!await client.zscore(this.keys.repeat, repeatJobKey);\n            }\n            const { immediately } = repeatOpts, filteredRepeatOpts = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(repeatOpts, [\n                \"immediately\"\n            ]);\n            // The job could have been deleted since this check\n            if (repeatableExists) {\n                return this.createNextJob(name, nextMillis, repeatJobKey, Object.assign(Object.assign({}, opts), {\n                    repeat: Object.assign({\n                        offset\n                    }, filteredRepeatOpts)\n                }), data, currentCount, hasImmediately);\n            }\n        }\n    }\n    async createNextJob(name, nextMillis, repeatJobKey, opts, data, currentCount, hasImmediately) {\n        const client = await this.client;\n        //\n        // Generate unique job id for this iteration.\n        //\n        const jobId = this.getRepeatJobId({\n            name,\n            nextMillis,\n            namespace: this.hash(repeatJobKey),\n            jobId: opts.repeat.jobId,\n            key: opts.repeat.key\n        });\n        const now = Date.now();\n        const delay = nextMillis + (opts.repeat.offset ? opts.repeat.offset : 0) - now;\n        const mergedOpts = Object.assign(Object.assign({}, opts), {\n            jobId,\n            delay: delay < 0 || hasImmediately ? 0 : delay,\n            timestamp: now,\n            prevMillis: nextMillis,\n            repeatJobKey\n        });\n        mergedOpts.repeat = Object.assign(Object.assign({}, opts.repeat), {\n            count: currentCount\n        });\n        await client.zadd(this.keys.repeat, nextMillis.toString(), repeatJobKey);\n        return this.Job.create(this, name, data, mergedOpts);\n    }\n    async removeRepeatable(name, repeat, jobId) {\n        const repeatJobKey = getRepeatKey(name, Object.assign(Object.assign({}, repeat), {\n            jobId\n        }));\n        const repeatJobId = this.getRepeatJobId({\n            name,\n            nextMillis: \"\",\n            namespace: this.hash(repeatJobKey),\n            jobId: jobId !== null && jobId !== void 0 ? jobId : repeat.jobId,\n            key: repeat.key\n        });\n        return this.scripts.removeRepeatable(repeatJobId, repeatJobKey);\n    }\n    async removeRepeatableByKey(repeatJobKey) {\n        const data = this.keyToData(repeatJobKey);\n        const repeatJobId = this.getRepeatJobId({\n            name: data.name,\n            nextMillis: \"\",\n            namespace: this.hash(repeatJobKey),\n            jobId: data.id\n        });\n        return this.scripts.removeRepeatable(repeatJobId, repeatJobKey);\n    }\n    keyToData(key, next) {\n        const data = key.split(\":\");\n        const pattern = data.slice(4).join(\":\") || null;\n        return {\n            key,\n            name: data[0],\n            id: data[1] || null,\n            endDate: parseInt(data[2]) || null,\n            tz: data[3] || null,\n            pattern,\n            next\n        };\n    }\n    async getRepeatableJobs(start = 0, end = -1, asc = false) {\n        const client = await this.client;\n        const key = this.keys.repeat;\n        const result = asc ? await client.zrange(key, start, end, \"WITHSCORES\") : await client.zrevrange(key, start, end, \"WITHSCORES\");\n        const jobs = [];\n        for(let i = 0; i < result.length; i += 2){\n            jobs.push(this.keyToData(result[i], parseInt(result[i + 1])));\n        }\n        return jobs;\n    }\n    async getRepeatableCount() {\n        const client = await this.client;\n        return client.zcard(this.toKey(\"repeat\"));\n    }\n    hash(str) {\n        return (0,crypto__WEBPACK_IMPORTED_MODULE_1__.createHash)(this.repeatKeyHashAlgorithm).update(str).digest(\"hex\");\n    }\n    getRepeatJobId({ name, nextMillis, namespace, jobId, key }) {\n        const checksum = key !== null && key !== void 0 ? key : this.hash(`${name}${jobId || \"\"}${namespace}`);\n        return `repeat:${checksum}:${nextMillis}`;\n    // return `repeat:${jobId || ''}:${name}:${namespace}:${nextMillis}`;\n    //return `repeat:${name}:${namespace}:${nextMillis}`;\n    }\n}\nfunction getRepeatKey(name, repeat) {\n    const endDate = repeat.endDate ? new Date(repeat.endDate).getTime() : \"\";\n    const tz = repeat.tz || \"\";\n    const pattern = repeat.pattern;\n    const suffix = (pattern ? pattern : String(repeat.every)) || \"\";\n    const jobId = repeat.jobId ? repeat.jobId : \"\";\n    return `${name}:${jobId}:${endDate}:${tz}:${suffix}`;\n}\nconst getNextMillis = (millis, opts)=>{\n    const pattern = opts.pattern;\n    if (pattern && opts.every) {\n        throw new Error(\"Both .pattern and .every options are defined for this repeatable job\");\n    }\n    if (opts.every) {\n        return Math.floor(millis / opts.every) * opts.every + (opts.immediately ? 0 : opts.every);\n    }\n    const currentDate = opts.startDate && new Date(opts.startDate) > new Date(millis) ? new Date(opts.startDate) : new Date(millis);\n    const interval = (0,cron_parser__WEBPACK_IMPORTED_MODULE_0__.parseExpression)(pattern, Object.assign(Object.assign({}, opts), {\n        currentDate\n    }));\n    try {\n        return interval.next().getTime();\n    } catch (e) {\n    // Ignore error\n    }\n}; //# sourceMappingURL=repeat.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcmVwZWF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2U7QUFDVjtBQUNLO0FBQ2xDLE1BQU1JLGVBQWVELGtEQUFTQTtJQUNqQ0UsWUFBWUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsQ0FBRTtRQUNoQyxLQUFLLENBQUNGLE1BQU1DLE1BQU1DO1FBQ2xCLElBQUksQ0FBQ0MsY0FBYyxHQUNmLEtBQU1DLFFBQVEsSUFBSUgsS0FBS0csUUFBUSxDQUFDRCxjQUFjLElBQUtFO1FBQ3ZELElBQUksQ0FBQ0Msc0JBQXNCLEdBQ3ZCLEtBQU1GLFFBQVEsSUFBSUgsS0FBS0csUUFBUSxDQUFDRSxzQkFBc0IsSUFBSztJQUNuRTtJQUNBLE1BQU1DLHFCQUFxQlAsSUFBSSxFQUFFUSxJQUFJLEVBQUVQLElBQUksRUFBRVEsZUFBZSxFQUFFO1FBQzFELElBQUlDO1FBQ0osNEVBQTRFO1FBQzVFLHdEQUF3RDtRQUN4RCxNQUFNQyxhQUFhQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHWixLQUFLYSxNQUFNO1FBQy9DSixDQUFBQSxLQUFLQyxXQUFXSSxPQUFPLE1BQU0sUUFBUUwsT0FBTyxLQUFLLElBQUlBLEtBQU1DLFdBQVdJLE9BQU8sR0FBR0osV0FBV0ssSUFBSTtRQUNoRyxPQUFPTCxXQUFXSyxJQUFJO1FBQ3RCLE1BQU1DLGFBQWFoQixLQUFLZ0IsVUFBVSxJQUFJO1FBQ3RDLE1BQU1DLGVBQWVQLFdBQVdRLEtBQUssR0FBR1IsV0FBV1EsS0FBSyxHQUFHLElBQUk7UUFDL0QsSUFBSSxPQUFPUixXQUFXUyxLQUFLLEtBQUssZUFDNUJGLGVBQWVQLFdBQVdTLEtBQUssRUFBRTtZQUNqQztRQUNKO1FBQ0EsSUFBSUMsTUFBTUMsS0FBS0QsR0FBRztRQUNsQixJQUFJLENBQUUsUUFBT1YsV0FBV1ksT0FBTyxLQUFLQyxTQUFRLEtBQ3hDSCxNQUFNLElBQUlDLEtB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VUFDcEUsSUFBSTlELEtBQUtyQixLQUFLd0YsU0FBUyxJQUN2QixJQUFJbkUsS0FBSzhEO0lBQ2YsTUFBTU0sV0FBVy9GLDREQUFlQSxDQUFDb0IsU0FBU0gsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHWixPQUFPO1FBQUV1RjtJQUFZO0lBQy9GLElBQUk7UUFDQSxPQUFPRSxTQUFTaEMsSUFBSSxHQUFHakMsT0FBTztJQUNsQyxFQUNBLE9BQU9rRSxHQUFHO0lBQ04sZUFBZTtJQUNuQjtBQUNKLEVBQUUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3JlcGVhdC5qcz9kY2EzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAnY3Jvbi1wYXJzZXInO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBRdWV1ZUJhc2UgfSBmcm9tICcuL3F1ZXVlLWJhc2UnO1xuZXhwb3J0IGNsYXNzIFJlcGVhdCBleHRlbmRzIFF1ZXVlQmFzZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0cywgQ29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcihuYW1lLCBvcHRzLCBDb25uZWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZXBlYXRTdHJhdGVneSA9XG4gICAgICAgICAgICAob3B0cy5zZXR0aW5ncyAmJiBvcHRzLnNldHRpbmdzLnJlcGVhdFN0cmF0ZWd5KSB8fCBnZXROZXh0TWlsbGlzO1xuICAgICAgICB0aGlzLnJlcGVhdEtleUhhc2hBbGdvcml0aG0gPVxuICAgICAgICAgICAgKG9wdHMuc2V0dGluZ3MgJiYgb3B0cy5zZXR0aW5ncy5yZXBlYXRLZXlIYXNoQWxnb3JpdGhtKSB8fCAnbWQ1JztcbiAgICB9XG4gICAgYXN5bmMgYWRkTmV4dFJlcGVhdGFibGVKb2IobmFtZSwgZGF0YSwgb3B0cywgc2tpcENoZWNrRXhpc3RzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gSEFDSzogVGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggdG8gZW5hYmxlIGVhc3kgbWlncmF0aW9uIGZyb20gYnVsbG1xIDwzLjAuMFxuICAgICAgICAvLyB0byA+PSAzLjAuMC4gSXQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBtb3ZpbmcgdG8gNC54LlxuICAgICAgICBjb25zdCByZXBlYXRPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5yZXBlYXQpO1xuICAgICAgICAoX2EgPSByZXBlYXRPcHRzLnBhdHRlcm4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChyZXBlYXRPcHRzLnBhdHRlcm4gPSByZXBlYXRPcHRzLmNyb24pO1xuICAgICAgICBkZWxldGUgcmVwZWF0T3B0cy5jcm9uO1xuICAgICAgICBjb25zdCBwcmV2TWlsbGlzID0gb3B0cy5wcmV2TWlsbGlzIHx8IDA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IHJlcGVhdE9wdHMuY291bnQgPyByZXBlYXRPcHRzLmNvdW50ICsgMSA6IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwZWF0T3B0cy5saW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGN1cnJlbnRDb3VudCA+IHJlcGVhdE9wdHMubGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHJlcGVhdE9wdHMuZW5kRGF0ZSA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgbm93ID4gbmV3IERhdGUocmVwZWF0T3B0cy5lbmREYXRlKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub3cgPSBwcmV2TWlsbGlzIDwgbm93ID8gbm93IDogcHJldk1pbGxpcztcbiAgICAgICAgY29uc3QgbmV4dE1pbGxpcyA9IGF3YWl0IHRoaXMucmVwZWF0U3RyYXRlZ3kobm93LCByZXBlYXRPcHRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlcGVhdE9wdHMucGF0dGVybjtcbiAgICAgICAgY29uc3QgaGFzSW1tZWRpYXRlbHkgPSBCb29sZWFuKChyZXBlYXRPcHRzLmV2ZXJ5IHx8IHBhdHRlcm4pICYmIHJlcGVhdE9wdHMuaW1tZWRpYXRlbHkpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBoYXNJbW1lZGlhdGVseSA/IG5vdyAtIG5leHRNaWxsaXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChuZXh0TWlsbGlzKSB7XG4gICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgdW5kZWNvcmF0ZWQgb3B0cy5qb2JJZCBpbnRvIHRoZSByZXBlYXQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCFwcmV2TWlsbGlzICYmIG9wdHMuam9iSWQpIHtcbiAgICAgICAgICAgICAgICByZXBlYXRPcHRzLmpvYklkID0gb3B0cy5qb2JJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcGVhdEpvYktleSA9IGdldFJlcGVhdEtleShuYW1lLCByZXBlYXRPcHRzKTtcbiAgICAgICAgICAgIGxldCByZXBlYXRhYmxlRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghc2tpcENoZWNrRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVwZWF0YWJsZSBqb2IgaGFzbid0IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGEgbHVhIHNjcmlwdCB3b3VsZCBiZSBiZXR0ZXIgaGVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICAgICAgICAgIHJlcGVhdGFibGVFeGlzdHMgPSAhIShhd2FpdCBjbGllbnQuenNjb3JlKHRoaXMua2V5cy5yZXBlYXQsIHJlcGVhdEpvYktleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBpbW1lZGlhdGVseSB9ID0gcmVwZWF0T3B0cywgZmlsdGVyZWRSZXBlYXRPcHRzID0gX19yZXN0KHJlcGVhdE9wdHMsIFtcImltbWVkaWF0ZWx5XCJdKTtcbiAgICAgICAgICAgIC8vIFRoZSBqb2IgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgc2luY2UgdGhpcyBjaGVja1xuICAgICAgICAgICAgaWYgKHJlcGVhdGFibGVFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOZXh0Sm9iKG5hbWUsIG5leHRNaWxsaXMsIHJlcGVhdEpvYktleSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyByZXBlYXQ6IE9iamVjdC5hc3NpZ24oeyBvZmZzZXQgfSwgZmlsdGVyZWRSZXBlYXRPcHRzKSB9KSwgZGF0YSwgY3VycmVudENvdW50LCBoYXNJbW1lZGlhdGVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTmV4dEpvYihuYW1lLCBuZXh0TWlsbGlzLCByZXBlYXRKb2JLZXksIG9wdHMsIGRhdGEsIGN1cnJlbnRDb3VudCwgaGFzSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBqb2IgaWQgZm9yIHRoaXMgaXRlcmF0aW9uLlxuICAgICAgICAvL1xuICAgICAgICBjb25zdCBqb2JJZCA9IHRoaXMuZ2V0UmVwZWF0Sm9iSWQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5leHRNaWxsaXMsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMuaGFzaChyZXBlYXRKb2JLZXkpLFxuICAgICAgICAgICAgam9iSWQ6IG9wdHMucmVwZWF0LmpvYklkLFxuICAgICAgICAgICAga2V5OiBvcHRzLnJlcGVhdC5rZXksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBkZWxheSA9IG5leHRNaWxsaXMgKyAob3B0cy5yZXBlYXQub2Zmc2V0ID8gb3B0cy5yZXBlYXQub2Zmc2V0IDogMCkgLSBub3c7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IGpvYklkLCBkZWxheTogZGVsYXkgPCAwIHx8IGhhc0ltbWVkaWF0ZWx5ID8gMCA6IGRlbGF5LCB0aW1lc3RhbXA6IG5vdywgcHJldk1pbGxpczogbmV4dE1pbGxpcywgcmVwZWF0Sm9iS2V5IH0pO1xuICAgICAgICBtZXJnZWRPcHRzLnJlcGVhdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5yZXBlYXQpLCB7IGNvdW50OiBjdXJyZW50Q291bnQgfSk7XG4gICAgICAgIGF3YWl0IGNsaWVudC56YWRkKHRoaXMua2V5cy5yZXBlYXQsIG5leHRNaWxsaXMudG9TdHJpbmcoKSwgcmVwZWF0Sm9iS2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuSm9iLmNyZWF0ZSh0aGlzLCBuYW1lLCBkYXRhLCBtZXJnZWRPcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZShuYW1lLCByZXBlYXQsIGpvYklkKSB7XG4gICAgICAgIGNvbnN0IHJlcGVhdEpvYktleSA9IGdldFJlcGVhdEtleShuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcGVhdCksIHsgam9iSWQgfSkpO1xuICAgICAgICBjb25zdCByZXBlYXRKb2JJZCA9IHRoaXMuZ2V0UmVwZWF0Sm9iSWQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5leHRNaWxsaXM6ICcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiB0aGlzLmhhc2gocmVwZWF0Sm9iS2V5KSxcbiAgICAgICAgICAgIGpvYklkOiBqb2JJZCAhPT0gbnVsbCAmJiBqb2JJZCAhPT0gdm9pZCAwID8gam9iSWQgOiByZXBlYXQuam9iSWQsXG4gICAgICAgICAgICBrZXk6IHJlcGVhdC5rZXksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLnJlbW92ZVJlcGVhdGFibGUocmVwZWF0Sm9iSWQsIHJlcGVhdEpvYktleSk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVJlcGVhdGFibGVCeUtleShyZXBlYXRKb2JLZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMua2V5VG9EYXRhKHJlcGVhdEpvYktleSk7XG4gICAgICAgIGNvbnN0IHJlcGVhdEpvYklkID0gdGhpcy5nZXRSZXBlYXRKb2JJZCh7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICBuZXh0TWlsbGlzOiAnJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogdGhpcy5oYXNoKHJlcGVhdEpvYktleSksXG4gICAgICAgICAgICBqb2JJZDogZGF0YS5pZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMucmVtb3ZlUmVwZWF0YWJsZShyZXBlYXRKb2JJZCwgcmVwZWF0Sm9iS2V5KTtcbiAgICB9XG4gICAga2V5VG9EYXRhKGtleSwgbmV4dCkge1xuICAgICAgICBjb25zdCBkYXRhID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkYXRhLnNsaWNlKDQpLmpvaW4oJzonKSB8fCBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbmFtZTogZGF0YVswXSxcbiAgICAgICAgICAgIGlkOiBkYXRhWzFdIHx8IG51bGwsXG4gICAgICAgICAgICBlbmREYXRlOiBwYXJzZUludChkYXRhWzJdKSB8fCBudWxsLFxuICAgICAgICAgICAgdHo6IGRhdGFbM10gfHwgbnVsbCxcbiAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXBlYXRhYmxlSm9icyhzdGFydCA9IDAsIGVuZCA9IC0xLCBhc2MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlzLnJlcGVhdDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXNjXG4gICAgICAgICAgICA/IGF3YWl0IGNsaWVudC56cmFuZ2Uoa2V5LCBzdGFydCwgZW5kLCAnV0lUSFNDT1JFUycpXG4gICAgICAgICAgICA6IGF3YWl0IGNsaWVudC56cmV2cmFuZ2Uoa2V5LCBzdGFydCwgZW5kLCAnV0lUSFNDT1JFUycpO1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBqb2JzLnB1c2godGhpcy5rZXlUb0RhdGEocmVzdWx0W2ldLCBwYXJzZUludChyZXN1bHRbaSArIDFdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2JzO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXBlYXRhYmxlQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LnpjYXJkKHRoaXMudG9LZXkoJ3JlcGVhdCcpKTtcbiAgICB9XG4gICAgaGFzaChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUhhc2godGhpcy5yZXBlYXRLZXlIYXNoQWxnb3JpdGhtKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICBnZXRSZXBlYXRKb2JJZCh7IG5hbWUsIG5leHRNaWxsaXMsIG5hbWVzcGFjZSwgam9iSWQsIGtleSwgfSkge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGtleSAhPT0gbnVsbCAmJiBrZXkgIT09IHZvaWQgMCA/IGtleSA6IHRoaXMuaGFzaChgJHtuYW1lfSR7am9iSWQgfHwgJyd9JHtuYW1lc3BhY2V9YCk7XG4gICAgICAgIHJldHVybiBgcmVwZWF0OiR7Y2hlY2tzdW19OiR7bmV4dE1pbGxpc31gO1xuICAgICAgICAvLyByZXR1cm4gYHJlcGVhdDoke2pvYklkIHx8ICcnfToke25hbWV9OiR7bmFtZXNwYWNlfToke25leHRNaWxsaXN9YDtcbiAgICAgICAgLy9yZXR1cm4gYHJlcGVhdDoke25hbWV9OiR7bmFtZXNwYWNlfToke25leHRNaWxsaXN9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZXBlYXRLZXkobmFtZSwgcmVwZWF0KSB7XG4gICAgY29uc3QgZW5kRGF0ZSA9IHJlcGVhdC5lbmREYXRlID8gbmV3IERhdGUocmVwZWF0LmVuZERhdGUpLmdldFRpbWUoKSA6ICcnO1xuICAgIGNvbnN0IHR6ID0gcmVwZWF0LnR6IHx8ICcnO1xuICAgIGNvbnN0IHBhdHRlcm4gPSByZXBlYXQucGF0dGVybjtcbiAgICBjb25zdCBzdWZmaXggPSAocGF0dGVybiA/IHBhdHRlcm4gOiBTdHJpbmcocmVwZWF0LmV2ZXJ5KSkgfHwgJyc7XG4gICAgY29uc3Qgam9iSWQgPSByZXBlYXQuam9iSWQgPyByZXBlYXQuam9iSWQgOiAnJztcbiAgICByZXR1cm4gYCR7bmFtZX06JHtqb2JJZH06JHtlbmREYXRlfToke3R6fToke3N1ZmZpeH1gO1xufVxuZXhwb3J0IGNvbnN0IGdldE5leHRNaWxsaXMgPSAobWlsbGlzLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IG9wdHMucGF0dGVybjtcbiAgICBpZiAocGF0dGVybiAmJiBvcHRzLmV2ZXJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCAucGF0dGVybiBhbmQgLmV2ZXJ5IG9wdGlvbnMgYXJlIGRlZmluZWQgZm9yIHRoaXMgcmVwZWF0YWJsZSBqb2InKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuZXZlcnkpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKG1pbGxpcyAvIG9wdHMuZXZlcnkpICogb3B0cy5ldmVyeSArXG4gICAgICAgICAgICAob3B0cy5pbW1lZGlhdGVseSA/IDAgOiBvcHRzLmV2ZXJ5KSk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gb3B0cy5zdGFydERhdGUgJiYgbmV3IERhdGUob3B0cy5zdGFydERhdGUpID4gbmV3IERhdGUobWlsbGlzKVxuICAgICAgICA/IG5ldyBEYXRlKG9wdHMuc3RhcnREYXRlKVxuICAgICAgICA6IG5ldyBEYXRlKG1pbGxpcyk7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBwYXJzZUV4cHJlc3Npb24ocGF0dGVybiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBjdXJyZW50RGF0ZSB9KSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsLm5leHQoKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsInBhcnNlRXhwcmVzc2lvbiIsImNyZWF0ZUhhc2giLCJRdWV1ZUJhc2UiLCJSZXBlYXQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJvcHRzIiwiQ29ubmVjdGlvbiIsInJlcGVhdFN0cmF0ZWd5Iiwic2V0dGluZ3MiLCJnZXROZXh0TWlsbGlzIiwicmVwZWF0S2V5SGFzaEFsZ29yaXRobSIsImFkZE5leHRSZXBlYXRhYmxlSm9iIiwiZGF0YSIsInNraXBDaGVja0V4aXN0cyIsIl9hIiwicmVwZWF0T3B0cyIsIk9iamVjdCIsImFzc2lnbiIsInJlcGVhdCIsInBhdHRlcm4iLCJjcm9uIiwicHJldk1pbGxpcyIsImN1cnJlbnRDb3VudCIsImNvdW50IiwibGltaXQiLCJub3ciLCJEYXRlIiwiZW5kRGF0ZSIsInVuZGVmaW5lZCIsImdldFRpbWUiLCJuZXh0TWlsbGlzIiwiaGFzSW1tZWRpYXRlbHkiLCJCb29sZWFuIiwiZXZlcnkiLCJpbW1lZGlhdGVseSIsIm9mZnNldCIsImpvYklkIiwicmVwZWF0Sm9iS2V5IiwiZ2V0UmVwZWF0S2V5IiwicmVwZWF0YWJsZUV4aXN0cyIsImNsaWVudCIsInpzY29yZSIsImtleXMiLCJmaWx0ZXJlZFJlcGVhdE9wdHMiLCJjcmVhdGVOZXh0Sm9iIiwiZ2V0UmVwZWF0Sm9iSWQiLCJuYW1lc3BhY2UiLCJoYXNoIiwia2V5IiwiZGVsYXkiLCJtZXJnZWRPcHRzIiwidGltZXN0YW1wIiwiemFkZCIsInRvU3RyaW5nIiwiSm9iIiwiY3JlYXRlIiwicmVtb3ZlUmVwZWF0YWJsZSIsInJlcGVhdEpvYklkIiwic2NyaXB0cyIsInJlbW92ZVJlcGVhdGFibGVCeUtleSIsImtleVRvRGF0YSIsImlkIiwibmV4dCIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwicGFyc2VJbnQiLCJ0eiIsImdldFJlcGVhdGFibGVKb2JzIiwic3RhcnQiLCJlbmQiLCJhc2MiLCJyZXN1bHQiLCJ6cmFuZ2UiLCJ6cmV2cmFuZ2UiLCJqb2JzIiwiaSIsImxlbmd0aCIsInB1c2giLCJnZXRSZXBlYXRhYmxlQ291bnQiLCJ6Y2FyZCIsInRvS2V5Iiwic3RyIiwidXBkYXRlIiwiZGlnZXN0IiwiY2hlY2tzdW0iLCJzdWZmaXgiLCJTdHJpbmciLCJtaWxsaXMiLCJFcnJvciIsIk1hdGgiLCJmbG9vciIsImN1cnJlbnREYXRlIiwic3RhcnREYXRlIiwiaW50ZXJ2YWwiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/sandbox.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n\nconst sandbox = (processFile, childPool)=>{\n    return async function process(job, token) {\n        const child = await childPool.retain(processFile);\n        let msgHandler;\n        let exitHandler;\n        await child.send({\n            cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ChildCommand.Start,\n            job: job.asJSONSandbox(),\n            token\n        });\n        const done = new Promise((resolve, reject)=>{\n            msgHandler = async (msg)=>{\n                var _a, _b;\n                switch(msg.cmd){\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Completed:\n                        resolve(msg.value);\n                        break;\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Failed:\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Error:\n                        {\n                            const err = new Error();\n                            Object.assign(err, msg.value);\n                            reject(err);\n                            break;\n                        }\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Progress:\n                        await job.updateProgress(msg.value);\n                        break;\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Log:\n                        await job.log(msg.value);\n                        break;\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToDelayed:\n                        await job.moveToDelayed((_a = msg.value) === null || _a === void 0 ? void 0 : _a.timestamp, (_b = msg.value) === null || _b === void 0 ? void 0 : _b.token);\n                        break;\n                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Update:\n                        await job.updateData(msg.value);\n                        break;\n                }\n            };\n            exitHandler = (exitCode, signal)=>{\n                reject(new Error(\"Unexpected exit code: \" + exitCode + \" signal: \" + signal));\n            };\n            child.on(\"message\", msgHandler);\n            child.on(\"exit\", exitHandler);\n        });\n        try {\n            await done;\n            return done;\n        } finally{\n            child.off(\"message\", msgHandler);\n            child.off(\"exit\", exitHandler);\n            if (child.exitCode !== null || /SIG.*/.test(`${child.signalCode}`)) {\n                childPool.remove(child);\n            } else {\n                childPool.release(child);\n            }\n        }\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sandbox); //# sourceMappingURL=sandbox.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2FuZGJveC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDtBQUN2RCxNQUFNRSxVQUFVLENBQUNDLGFBQWFDO0lBQzFCLE9BQU8sZUFBZUMsUUFBUUMsR0FBRyxFQUFFQyxLQUFLO1FBQ3BDLE1BQU1DLFFBQVEsTUFBTUosVUFBVUssTUFBTSxDQUFDTjtRQUNyQyxJQUFJTztRQUNKLElBQUlDO1FBQ0osTUFBTUgsTUFBTUksSUFBSSxDQUFDO1lBQ2JDLEtBQUtiLGdEQUFZQSxDQUFDYyxLQUFLO1lBQ3ZCUixLQUFLQSxJQUFJUyxhQUFhO1lBQ3RCUjtRQUNKO1FBQ0EsTUFBTVMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQy9CVCxhQUFhLE9BQU9VO2dCQUNoQixJQUFJQyxJQUFJQztnQkFDUixPQUFRRixJQUFJUCxHQUFHO29CQUNYLEtBQUtaLGlEQUFhQSxDQUFDc0IsU0FBUzt3QkFDeEJMLFFBQVFFLElBQUlJLEtBQUs7d0JBQ2pCO29CQUNKLEtBQUt2QixpREFBYUEsQ0FBQ3dCLE1BQU07b0JBQ3pCLEtBQUt4QixpREFBYUEsQ0FBQ3lCLEtBQUs7d0JBQUU7NEJBQ3RCLE1BQU1DLE1BQU0sSUFBSUQ7NEJBQ2hCRSxPQUFPQyxNQUFNLENBQUNGLEtBQUtQLElBQUlJLEtBQUs7NEJBQzVCTCxPQUFPUTs0QkFDUDt3QkFDSjtvQkFDQSxLQUFLMUIsaURBQWFBLENBQUM2QixRQUFRO3dCQUN2QixNQUFNeEIsSUFBSXlCLGNBQWMsQ0FBQ1gsSUFBSUksS0FBSzt3QkFDbEM7b0JBQ0osS0FBS3ZCLGlEQUFhQSxDQUFDK0IsR0FBRzt3QkFDbEIsTUFBTTFCLElBQUkyQixHQUFHLENBQUNiLElBQUlJLEtBQUs7d0JBQ3ZCO29CQUNKLEtBQUt2QixpREFBYUEsQ0FBQ2lDLGFBQWE7d0JBQzVCLE1BQU01QixJQUFJNkIsYUFBYSxDQUFDLENBQUNkLEtBQUtELElBQUlJLEtBQUssTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdlLFNBQVMsRUFBRSxDQUFDZCxLQUFLRixJQUFJSSxLQUFLLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZixLQUFLO3dCQUMxSjtvQkFDSixLQUFLTixpREFBYUEsQ0FBQ29DLE1BQU07d0JBQ3JCLE1BQU0vQixJQUFJZ0MsVUFBVSxDQUFDbEIsSUFBSUksS0FBSzt3QkFDOUI7Z0JBQ1I7WUFDSjtZQUNBYixjQUFjLENBQUM0QixVQUFVQztnQkFDckJyQixPQUFPLElBQUlPLE1BQU0sMkJBQTJCYSxXQUFXLGNBQWNDO1lBQ3pFO1lBQ0FoQyxNQUFNaUMsRUFBRSxDQUFDLFdBQVcvQjtZQUNwQkYsTUFBTWlDLEVBQUUsQ0FBQyxRQUFROUI7UUFDckI7UUFDQSxJQUFJO1lBQ0EsTUFBTUs7WUFDTixPQUFPQTtRQUNYLFNBQ1E7WUFDSlIsTUFBTWtDLEdBQUcsQ0FBQyxXQUFXaEM7WUFDckJGLE1BQU1rQyxHQUFHLENBQUMsUUFBUS9CO1lBQ2xCLElBQUlILE1BQU0rQixRQUFRLEtBQUssUUFBUSxRQUFRSSxJQUFJLENBQUMsQ0FBQyxFQUFFbkMsTUFBTW9DLFVBQVUsQ0FBQyxDQUFDLEdBQUc7Z0JBQ2hFeEMsVUFBVXlDLE1BQU0sQ0FBQ3JDO1lBQ3JCLE9BQ0s7Z0JBQ0RKLFVBQVUwQyxPQUFPLENBQUN0QztZQUN0QjtRQUNKO0lBQ0o7QUFDSjtBQUNBLGlFQUFlTixPQUFPQSxFQUFDLENBQ3ZCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2FuZGJveC5qcz8xMmRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoaWxkQ29tbWFuZCwgUGFyZW50Q29tbWFuZCB9IGZyb20gJy4uL2VudW1zJztcbmNvbnN0IHNhbmRib3ggPSAocHJvY2Vzc0ZpbGUsIGNoaWxkUG9vbCkgPT4ge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBwcm9jZXNzKGpvYiwgdG9rZW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBhd2FpdCBjaGlsZFBvb2wucmV0YWluKHByb2Nlc3NGaWxlKTtcbiAgICAgICAgbGV0IG1zZ0hhbmRsZXI7XG4gICAgICAgIGxldCBleGl0SGFuZGxlcjtcbiAgICAgICAgYXdhaXQgY2hpbGQuc2VuZCh7XG4gICAgICAgICAgICBjbWQ6IENoaWxkQ29tbWFuZC5TdGFydCxcbiAgICAgICAgICAgIGpvYjogam9iLmFzSlNPTlNhbmRib3goKSxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9uZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1zZ0hhbmRsZXIgPSBhc3luYyAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1zZy5jbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQYXJlbnRDb21tYW5kLkNvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFBhcmVudENvbW1hbmQuRmFpbGVkOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFBhcmVudENvbW1hbmQuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlcnIsIG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5Qcm9ncmVzczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcyhtc2cudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5Mb2c6XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBqb2IubG9nKG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQYXJlbnRDb21tYW5kLk1vdmVUb0RlbGF5ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBqb2IubW92ZVRvRGVsYXllZCgoX2EgPSBtc2cudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aW1lc3RhbXAsIChfYiA9IG1zZy52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFBhcmVudENvbW1hbmQuVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgam9iLnVwZGF0ZURhdGEobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleGl0SGFuZGxlciA9IChleGl0Q29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5leHBlY3RlZCBleGl0IGNvZGU6ICcgKyBleGl0Q29kZSArICcgc2lnbmFsOiAnICsgc2lnbmFsKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hpbGQub24oJ21lc3NhZ2UnLCBtc2dIYW5kbGVyKTtcbiAgICAgICAgICAgIGNoaWxkLm9uKCdleGl0JywgZXhpdEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGRvbmU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNoaWxkLm9mZignbWVzc2FnZScsIG1zZ0hhbmRsZXIpO1xuICAgICAgICAgICAgY2hpbGQub2ZmKCdleGl0JywgZXhpdEhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXRDb2RlICE9PSBudWxsIHx8IC9TSUcuKi8udGVzdChgJHtjaGlsZC5zaWduYWxDb2RlfWApKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRQb29sLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFBvb2wucmVsZWFzZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IHNhbmRib3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW5kYm94LmpzLm1hcCJdLCJuYW1lcyI6WyJDaGlsZENvbW1hbmQiLCJQYXJlbnRDb21tYW5kIiwic2FuZGJveCIsInByb2Nlc3NGaWxlIiwiY2hpbGRQb29sIiwicHJvY2VzcyIsImpvYiIsInRva2VuIiwiY2hpbGQiLCJyZXRhaW4iLCJtc2dIYW5kbGVyIiwiZXhpdEhhbmRsZXIiLCJzZW5kIiwiY21kIiwiU3RhcnQiLCJhc0pTT05TYW5kYm94IiwiZG9uZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibXNnIiwiX2EiLCJfYiIsIkNvbXBsZXRlZCIsInZhbHVlIiwiRmFpbGVkIiwiRXJyb3IiLCJlcnIiLCJPYmplY3QiLCJhc3NpZ24iLCJQcm9ncmVzcyIsInVwZGF0ZVByb2dyZXNzIiwiTG9nIiwibG9nIiwiTW92ZVRvRGVsYXllZCIsIm1vdmVUb0RlbGF5ZWQiLCJ0aW1lc3RhbXAiLCJVcGRhdGUiLCJ1cGRhdGVEYXRhIiwiZXhpdENvZGUiLCJzaWduYWwiLCJvbiIsIm9mZiIsInRlc3QiLCJzaWduYWxDb2RlIiwicmVtb3ZlIiwicmVsZWFzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/scripts.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scripts: () => (/* binding */ Scripts),\n/* harmony export */   raw2NextJobData: () => (/* binding */ raw2NextJobData)\n/* harmony export */ });\n/* harmony import */ var msgpackr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! msgpackr */ \"(rsc)/./node_modules/msgpackr/node-index.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/**\n * Includes all the scripts needed by the queue and jobs.\n */ /*eslint-env node */ \n\nconst packer = new msgpackr__WEBPACK_IMPORTED_MODULE_0__.Packr({\n    useRecords: false,\n    encodeUndefinedAsNil: true\n});\nconst pack = packer.pack;\n\n\nclass Scripts {\n    constructor(queue){\n        this.queue = queue;\n        const queueKeys = this.queue.keys;\n        this.moveToFinishedKeys = [\n            queueKeys.wait,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.events,\n            queueKeys.stalled,\n            queueKeys.limiter,\n            queueKeys.delayed,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.pc,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n    }\n    async isJobInList(listKey, jobId) {\n        const client = await this.queue.client;\n        let result;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.isRedisVersionLowerThan)(this.queue.redisVersion, \"6.0.6\")) {\n            result = await client.isJobInList([\n                listKey,\n                jobId\n            ]);\n        } else {\n            result = await client.lpos(listKey, jobId);\n        }\n        return Number.isInteger(result);\n    }\n    addDelayedJob(client, job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.delayed,\n            queueKeys.completed,\n            queueKeys.events\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return client.addDelayedJob(keys);\n    }\n    addPrioritizedJob(client, job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.prioritized,\n            queueKeys.completed,\n            queueKeys.events,\n            queueKeys.pc\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return client.addPrioritizedJob(keys);\n    }\n    addParentJob(client, job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.completed,\n            queueKeys.events\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return client.addParentJob(keys);\n    }\n    addStandardJob(client, job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.completed,\n            queueKeys.events,\n            queueKeys.marker\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return client.addStandardJob(keys);\n    }\n    async addJob(client, job, opts, jobId, parentOpts = {}) {\n        const queueKeys = this.queue.keys;\n        const parent = job.parent ? Object.assign(Object.assign({}, job.parent), {\n            fpof: opts.fpof,\n            rdof: opts.rdof\n        }) : null;\n        const args = [\n            queueKeys[\"\"],\n            typeof jobId !== \"undefined\" ? jobId : \"\",\n            job.name,\n            job.timestamp,\n            job.parentKey || null,\n            parentOpts.waitChildrenKey || null,\n            parentOpts.parentDependenciesKey || null,\n            parent,\n            job.repeatJobKey\n        ];\n        let encodedOpts;\n        if (opts.repeat) {\n            const repeat = Object.assign({}, opts.repeat);\n            if (repeat.startDate) {\n                repeat.startDate = +new Date(repeat.startDate);\n            }\n            if (repeat.endDate) {\n                repeat.endDate = +new Date(repeat.endDate);\n            }\n            encodedOpts = pack(Object.assign(Object.assign({}, opts), {\n                repeat\n            }));\n        } else {\n            encodedOpts = pack(opts);\n        }\n        let result;\n        if (parentOpts.waitChildrenKey) {\n            result = await this.addParentJob(client, job, encodedOpts, args);\n        } else if (opts.delay) {\n            result = await this.addDelayedJob(client, job, encodedOpts, args);\n        } else if (opts.priority) {\n            result = await this.addPrioritizedJob(client, job, encodedOpts, args);\n        } else {\n            result = await this.addStandardJob(client, job, encodedOpts, args);\n        }\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                parentKey: parentOpts.parentKey,\n                command: \"addJob\"\n            });\n        }\n        return result;\n    }\n    pauseArgs(pause) {\n        let src = \"wait\", dst = \"paused\";\n        if (!pause) {\n            src = \"paused\";\n            dst = \"wait\";\n        }\n        const keys = [\n            src,\n            dst,\n            \"meta\",\n            \"prioritized\"\n        ].map((name)=>this.queue.toKey(name));\n        keys.push(this.queue.keys.events, this.queue.keys.delayed, this.queue.keys.marker);\n        const args = [\n            pause ? \"paused\" : \"resumed\"\n        ];\n        return keys.concat(args);\n    }\n    async pause(pause) {\n        const client = await this.queue.client;\n        const args = this.pauseArgs(pause);\n        return client.pause(args);\n    }\n    removeRepeatableArgs(repeatJobId, repeatJobKey) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.repeat,\n            queueKeys.delayed\n        ];\n        const args = [\n            repeatJobId,\n            repeatJobKey,\n            queueKeys[\"\"]\n        ];\n        return keys.concat(args);\n    }\n    async removeRepeatable(repeatJobId, repeatJobKey) {\n        const client = await this.queue.client;\n        const args = this.removeRepeatableArgs(repeatJobId, repeatJobKey);\n        return client.removeRepeatable(args);\n    }\n    async remove(jobId, removeChildren) {\n        const client = await this.queue.client;\n        const keys = [\n            \"\"\n        ].map((name)=>this.queue.toKey(name));\n        return client.removeJob(keys.concat([\n            jobId,\n            removeChildren ? 1 : 0\n        ]));\n    }\n    async extendLock(jobId, token, duration, client) {\n        client = client || await this.queue.client;\n        const args = [\n            this.queue.toKey(jobId) + \":lock\",\n            this.queue.keys.stalled,\n            token,\n            duration,\n            jobId\n        ];\n        return client.extendLock(args);\n    }\n    async updateData(job, data) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(job.id)\n        ];\n        const dataJson = JSON.stringify(data);\n        const result = await client.updateData(keys.concat([\n            dataJson\n        ]));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId: job.id,\n                command: \"updateData\"\n            });\n        }\n    }\n    async updateProgress(jobId, progress) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(jobId),\n            this.queue.keys.events,\n            this.queue.keys.meta\n        ];\n        const progressJson = JSON.stringify(progress);\n        const result = await client.updateProgress(keys.concat([\n            jobId,\n            progressJson\n        ]));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: \"updateProgress\"\n            });\n        }\n    }\n    moveToFinishedArgs(job, val, propVal, shouldRemove, target, token, timestamp, fetchNext = true) {\n        var _a, _b, _c, _d, _e, _f;\n        const queueKeys = this.queue.keys;\n        const opts = this.queue.opts;\n        const workerKeepJobs = target === \"completed\" ? opts.removeOnComplete : opts.removeOnFail;\n        const metricsKey = this.queue.toKey(`metrics:${target}`);\n        const keys = this.moveToFinishedKeys;\n        keys[10] = queueKeys[target];\n        keys[11] = this.queue.toKey((_a = job.id) !== null && _a !== void 0 ? _a : \"\");\n        keys[12] = metricsKey;\n        keys[13] = this.queue.keys.marker;\n        const keepJobs = this.getKeepJobs(shouldRemove, workerKeepJobs);\n        const args = [\n            job.id,\n            timestamp,\n            propVal,\n            typeof val === \"undefined\" ? \"null\" : val,\n            target,\n            !fetchNext || this.queue.closing ? 0 : 1,\n            queueKeys[\"\"],\n            pack({\n                token,\n                keepJobs,\n                limiter: opts.limiter,\n                lockDuration: opts.lockDuration,\n                attempts: job.opts.attempts,\n                maxMetricsSize: ((_b = opts.metrics) === null || _b === void 0 ? void 0 : _b.maxDataPoints) ? (_c = opts.metrics) === null || _c === void 0 ? void 0 : _c.maxDataPoints : \"\",\n                fpof: !!((_d = job.opts) === null || _d === void 0 ? void 0 : _d.failParentOnFailure),\n                idof: !!((_e = job.opts) === null || _e === void 0 ? void 0 : _e.ignoreDependencyOnFailure),\n                rdof: !!((_f = job.opts) === null || _f === void 0 ? void 0 : _f.removeDependencyOnFailure)\n            })\n        ];\n        return keys.concat(args);\n    }\n    getKeepJobs(shouldRemove, workerKeepJobs) {\n        if (typeof shouldRemove === \"undefined\") {\n            return workerKeepJobs || {\n                count: shouldRemove ? 0 : -1\n            };\n        }\n        return typeof shouldRemove === \"object\" ? shouldRemove : typeof shouldRemove === \"number\" ? {\n            count: shouldRemove\n        } : {\n            count: shouldRemove ? 0 : -1\n        };\n    }\n    async moveToFinished(jobId, args) {\n        const client = await this.queue.client;\n        const result = await client.moveToFinished(args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: \"moveToFinished\",\n                state: \"active\"\n            });\n        } else {\n            if (typeof result !== \"undefined\") {\n                return raw2NextJobData(result);\n            }\n        }\n    }\n    finishedErrors({ code, jobId, parentKey, command, state }) {\n        switch(code){\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobNotExist:\n                return new Error(`Missing key for job ${jobId}. ${command}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobLockNotExist:\n                return new Error(`Missing lock for job ${jobId}. ${command}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobNotInState:\n                return new Error(`Job ${jobId} is not in the ${state} state. ${command}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobPendingDependencies:\n                return new Error(`Job ${jobId} has pending dependencies. ${command}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.ParentJobNotExist:\n                return new Error(`Missing key for parent job ${parentKey}. ${command}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobLockMismatch:\n                return new Error(`Lock mismatch for job ${jobId}. Cmd ${command} from ${state}`);\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.ParentJobCannotBeReplaced:\n                return new Error(`The parent job ${parentKey} cannot be replaced. ${command}`);\n            default:\n                return new Error(`Unknown code ${code} error for ${jobId}. ${command}`);\n        }\n    }\n    drainArgs(delayed) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.paused,\n            delayed ? queueKeys.delayed : \"\",\n            queueKeys.prioritized\n        ];\n        const args = [\n            queueKeys[\"\"]\n        ];\n        return keys.concat(args);\n    }\n    async drain(delayed) {\n        const client = await this.queue.client;\n        const args = this.drainArgs(delayed);\n        return client.drain(args);\n    }\n    removeChildDependencyArgs(jobId, parentKey) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys[\"\"]\n        ];\n        const args = [\n            this.queue.toKey(jobId),\n            parentKey\n        ];\n        return keys.concat(args);\n    }\n    async removeChildDependency(jobId, parentKey) {\n        const client = await this.queue.client;\n        const args = this.removeChildDependencyArgs(jobId, parentKey);\n        const result = await client.removeChildDependency(args);\n        switch(result){\n            case 0:\n                return true;\n            case 1:\n                return false;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId,\n                    parentKey,\n                    command: \"removeChildDependency\"\n                });\n        }\n    }\n    getRangesArgs(types, start, end, asc) {\n        const queueKeys = this.queue.keys;\n        const transformedTypes = types.map((type)=>{\n            return type === \"waiting\" ? \"wait\" : type;\n        });\n        const keys = [\n            queueKeys[\"\"]\n        ];\n        const args = [\n            start,\n            end,\n            asc ? \"1\" : \"0\",\n            ...transformedTypes\n        ];\n        return keys.concat(args);\n    }\n    async getRanges(types, start = 0, end = 1, asc = false) {\n        const client = await this.queue.client;\n        const args = this.getRangesArgs(types, start, end, asc);\n        return client.getRanges(args);\n    }\n    getCountsArgs(types) {\n        const queueKeys = this.queue.keys;\n        const transformedTypes = types.map((type)=>{\n            return type === \"waiting\" ? \"wait\" : type;\n        });\n        const keys = [\n            queueKeys[\"\"]\n        ];\n        const args = [\n            ...transformedTypes\n        ];\n        return keys.concat(args);\n    }\n    async getCounts(types) {\n        const client = await this.queue.client;\n        const args = this.getCountsArgs(types);\n        return client.getCounts(args);\n    }\n    moveToCompletedArgs(job, returnvalue, removeOnComplete, token, fetchNext = false) {\n        const timestamp = Date.now();\n        return this.moveToFinishedArgs(job, returnvalue, \"returnvalue\", removeOnComplete, \"completed\", token, timestamp, fetchNext);\n    }\n    moveToFailedArgs(job, failedReason, removeOnFailed, token, fetchNext = false) {\n        const timestamp = Date.now();\n        return this.moveToFinishedArgs(job, failedReason, \"failedReason\", removeOnFailed, \"failed\", token, timestamp, fetchNext);\n    }\n    async isFinished(jobId, returnValue = false) {\n        const client = await this.queue.client;\n        const keys = [\n            \"completed\",\n            \"failed\",\n            jobId\n        ].map((key)=>{\n            return this.queue.toKey(key);\n        });\n        return client.isFinished(keys.concat([\n            jobId,\n            returnValue ? \"1\" : \"\"\n        ]));\n    }\n    async getState(jobId) {\n        const client = await this.queue.client;\n        const keys = [\n            \"completed\",\n            \"failed\",\n            \"delayed\",\n            \"active\",\n            \"wait\",\n            \"paused\",\n            \"waiting-children\",\n            \"prioritized\"\n        ].map((key)=>{\n            return this.queue.toKey(key);\n        });\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.isRedisVersionLowerThan)(this.queue.redisVersion, \"6.0.6\")) {\n            return client.getState(keys.concat([\n                jobId\n            ]));\n        }\n        return client.getStateV2(keys.concat([\n            jobId\n        ]));\n    }\n    async changeDelay(jobId, delay) {\n        const client = await this.queue.client;\n        const args = this.changeDelayArgs(jobId, delay);\n        const result = await client.changeDelay(args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: \"changeDelay\",\n                state: \"delayed\"\n            });\n        }\n    }\n    changeDelayArgs(jobId, delay) {\n        //\n        // Bake in the job id first 12 bits into the timestamp\n        // to guarantee correct execution order of delayed jobs\n        // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n        //\n        // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n        //\n        let timestamp = Date.now() + delay;\n        if (timestamp > 0) {\n            timestamp = timestamp * 0x1000 + (+jobId & 0xfff);\n        }\n        const keys = [\n            this.queue.keys.delayed,\n            this.queue.keys.meta,\n            this.queue.keys.marker,\n            this.queue.keys.events\n        ];\n        return keys.concat([\n            delay,\n            JSON.stringify(timestamp),\n            jobId,\n            this.queue.toKey(jobId)\n        ]);\n    }\n    async changePriority(jobId, priority = 0, lifo = false) {\n        const client = await this.queue.client;\n        const args = this.changePriorityArgs(jobId, priority, lifo);\n        const result = await client.changePriority(args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: \"changePriority\"\n            });\n        }\n    }\n    changePriorityArgs(jobId, priority = 0, lifo = false) {\n        const keys = [\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.prioritized,\n            this.queue.keys.pc,\n            this.queue.keys.marker\n        ];\n        return keys.concat([\n            priority,\n            this.queue.toKey(jobId),\n            jobId,\n            lifo ? 1 : 0\n        ]);\n    }\n    // Note: We have an issue here with jobs using custom job ids\n    moveToDelayedArgs(jobId, timestamp, token, delay, opts = {}) {\n        //\n        // Bake in the job id first 12 bits into the timestamp\n        // to guarantee correct execution order of delayed jobs\n        // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n        //\n        // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n        //\n        timestamp = Math.max(0, timestamp !== null && timestamp !== void 0 ? timestamp : 0);\n        if (timestamp > 0) {\n            timestamp = timestamp * 0x1000 + (+jobId & 0xfff);\n        }\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.delayed,\n            this.queue.toKey(jobId),\n            queueKeys.events,\n            queueKeys.meta\n        ];\n        return keys.concat([\n            this.queue.keys[\"\"],\n            Date.now(),\n            JSON.stringify(timestamp),\n            jobId,\n            token,\n            delay,\n            opts.skipAttempt ? \"1\" : \"0\"\n        ]);\n    }\n    saveStacktraceArgs(jobId, stacktrace, failedReason) {\n        const keys = [\n            this.queue.toKey(jobId)\n        ];\n        return keys.concat([\n            stacktrace,\n            failedReason\n        ]);\n    }\n    moveToWaitingChildrenArgs(jobId, token, opts) {\n        const timestamp = Date.now();\n        const childKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(opts.child);\n        const keys = [\n            `${jobId}:lock`,\n            \"active\",\n            \"waiting-children\",\n            jobId\n        ].map((name)=>{\n            return this.queue.toKey(name);\n        });\n        return keys.concat([\n            token,\n            childKey !== null && childKey !== void 0 ? childKey : \"\",\n            JSON.stringify(timestamp),\n            jobId\n        ]);\n    }\n    async moveToDelayed(jobId, timestamp, delay, token = \"0\", opts = {}) {\n        const client = await this.queue.client;\n        const args = this.moveToDelayedArgs(jobId, timestamp, token, delay, opts);\n        const result = await client.moveToDelayed(args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: \"moveToDelayed\",\n                state: \"active\"\n            });\n        }\n    }\n    /**\n     * Move parent job to waiting-children state.\n     *\n     * @returns true if job is successfully moved, false if there are pending dependencies.\n     * @throws JobNotExist\n     * This exception is thrown if jobId is missing.\n     * @throws JobLockNotExist\n     * This exception is thrown if job lock is missing.\n     * @throws JobNotInState\n     * This exception is thrown if job is not in active state.\n     */ async moveToWaitingChildren(jobId, token, opts = {}) {\n        const client = await this.queue.client;\n        const args = this.moveToWaitingChildrenArgs(jobId, token, opts);\n        const result = await client.moveToWaitingChildren(args);\n        switch(result){\n            case 0:\n                return true;\n            case 1:\n                return false;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId,\n                    command: \"moveToWaitingChildren\",\n                    state: \"active\"\n                });\n        }\n    }\n    /**\n     * Remove jobs in a specific state.\n     *\n     * @returns Id jobs from the deleted records.\n     */ async cleanJobsInSet(set, timestamp, limit = 0) {\n        const client = await this.queue.client;\n        return client.cleanJobsInSet([\n            this.queue.toKey(set),\n            this.queue.toKey(\"events\"),\n            this.queue.toKey(\"\"),\n            timestamp,\n            limit,\n            set\n        ]);\n    }\n    retryJobArgs(jobId, lifo, token) {\n        const keys = [\n            this.queue.keys.active,\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.toKey(jobId),\n            this.queue.keys.meta,\n            this.queue.keys.events,\n            this.queue.keys.delayed,\n            this.queue.keys.prioritized,\n            this.queue.keys.pc,\n            this.queue.keys.marker\n        ];\n        const pushCmd = (lifo ? \"R\" : \"L\") + \"PUSH\";\n        return keys.concat([\n            this.queue.toKey(\"\"),\n            Date.now(),\n            pushCmd,\n            jobId,\n            token\n        ]);\n    }\n    moveJobsToWaitArgs(state, count, timestamp) {\n        const keys = [\n            this.queue.toKey(\"\"),\n            this.queue.keys.events,\n            this.queue.toKey(state),\n            this.queue.toKey(\"wait\"),\n            this.queue.toKey(\"paused\"),\n            this.queue.keys.meta,\n            this.queue.keys.marker\n        ];\n        const args = [\n            count,\n            timestamp,\n            state\n        ];\n        return keys.concat(args);\n    }\n    async retryJobs(state = \"failed\", count = 1000, timestamp = new Date().getTime()) {\n        const client = await this.queue.client;\n        const args = this.moveJobsToWaitArgs(state, count, timestamp);\n        return client.moveJobsToWait(args);\n    }\n    async promoteJobs(count = 1000) {\n        const client = await this.queue.client;\n        const args = this.moveJobsToWaitArgs(\"delayed\", count, Number.MAX_VALUE);\n        return client.moveJobsToWait(args);\n    }\n    /**\n     * Attempts to reprocess a job\n     *\n     * @param job -\n     * @param state - The expected job state. If the job is not found\n     * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'\n     *\n     * @returns Returns a promise that evaluates to a return code:\n     * 1 means the operation was a success\n     * 0 means the job does not exist\n     * -1 means the job is currently locked and can't be retried.\n     * -2 means the job was not found in the expected set\n     */ async reprocessJob(job, state) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(job.id),\n            this.queue.keys.events,\n            this.queue.toKey(state),\n            this.queue.keys.wait,\n            this.queue.keys.meta,\n            this.queue.keys.paused,\n            this.queue.keys.marker\n        ];\n        const args = [\n            job.id,\n            (job.opts.lifo ? \"R\" : \"L\") + \"PUSH\",\n            state === \"failed\" ? \"failedReason\" : \"returnvalue\",\n            state\n        ];\n        const result = await client.reprocessJob(keys.concat(args));\n        switch(result){\n            case 1:\n                return;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId: job.id,\n                    command: \"reprocessJob\",\n                    state\n                });\n        }\n    }\n    async moveToActive(client, token, name) {\n        const opts = this.queue.opts;\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.events,\n            queueKeys.stalled,\n            queueKeys.limiter,\n            queueKeys.delayed,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.pc,\n            queueKeys.marker\n        ];\n        const args = [\n            queueKeys[\"\"],\n            Date.now(),\n            pack({\n                token,\n                lockDuration: opts.lockDuration,\n                limiter: opts.limiter,\n                name\n            })\n        ];\n        const result = await client.moveToActive(keys.concat(args));\n        return raw2NextJobData(result);\n    }\n    async promote(jobId) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.keys.delayed,\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.prioritized,\n            this.queue.keys.pc,\n            this.queue.keys.events,\n            this.queue.keys.marker\n        ];\n        const args = [\n            this.queue.toKey(\"\"),\n            jobId\n        ];\n        const code = await client.promote(keys.concat(args));\n        if (code < 0) {\n            throw this.finishedErrors({\n                code,\n                jobId,\n                command: \"promote\",\n                state: \"delayed\"\n            });\n        }\n    }\n    /**\n     * Looks for unlocked jobs in the active queue.\n     *\n     * The job was being worked on, but the worker process died and it failed to renew the lock.\n     * We call these jobs 'stalled'. This is the most common case. We resolve these by moving them\n     * back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,\n     * (e.g. if the job handler keeps crashing),\n     * we limit the number stalled job recoveries to settings.maxStalledCount.\n     */ async moveStalledJobsToWait() {\n        const client = await this.queue.client;\n        const opts = this.queue.opts;\n        const keys = [\n            this.queue.keys.stalled,\n            this.queue.keys.wait,\n            this.queue.keys.active,\n            this.queue.keys.failed,\n            this.queue.keys[\"stalled-check\"],\n            this.queue.keys.meta,\n            this.queue.keys.paused,\n            this.queue.keys.marker,\n            this.queue.keys.events\n        ];\n        const args = [\n            opts.maxStalledCount,\n            this.queue.toKey(\"\"),\n            Date.now(),\n            opts.stalledInterval\n        ];\n        return client.moveStalledJobsToWait(keys.concat(args));\n    }\n    /**\n     * Moves a job back from Active to Wait.\n     * This script is used when a job has been manually rate limited and needs\n     * to be moved back to wait from active status.\n     *\n     * @param client - Redis client\n     * @param jobId - Job id\n     * @returns\n     */ async moveJobFromActiveToWait(jobId, token) {\n        const client = await this.queue.client;\n        const lockKey = `${this.queue.toKey(jobId)}:lock`;\n        const keys = [\n            this.queue.keys.active,\n            this.queue.keys.wait,\n            this.queue.keys.stalled,\n            lockKey,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.limiter,\n            this.queue.keys.prioritized,\n            this.queue.keys.marker,\n            this.queue.keys.events\n        ];\n        const args = [\n            jobId,\n            token,\n            this.queue.toKey(jobId)\n        ];\n        const pttl = await client.moveJobFromActiveToWait(keys.concat(args));\n        return pttl < 0 ? 0 : pttl;\n    }\n    async obliterate(opts) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.keys.meta,\n            this.queue.toKey(\"\")\n        ];\n        const args = [\n            opts.count,\n            opts.force ? \"force\" : null\n        ];\n        const result = await client.obliterate(keys.concat(args));\n        if (result < 0) {\n            switch(result){\n                case -1:\n                    throw new Error(\"Cannot obliterate non-paused queue\");\n                case -2:\n                    throw new Error(\"Cannot obliterate queue with active jobs\");\n            }\n        }\n        return result;\n    }\n    /**\n     * Paginate a set or hash keys.\n     * @param opts\n     *\n     */ async paginate(key, opts) {\n        const client = await this.queue.client;\n        const keys = [\n            key\n        ];\n        const maxIterations = 5;\n        const pageSize = opts.end >= 0 ? opts.end - opts.start + 1 : Infinity;\n        let cursor = \"0\", offset = 0, items, total, rawJobs, page = [], jobs = [];\n        do {\n            const args = [\n                opts.start + page.length,\n                opts.end,\n                cursor,\n                offset,\n                maxIterations\n            ];\n            if (opts.fetchJobs) {\n                args.push(1);\n            }\n            [cursor, offset, items, total, rawJobs] = await client.paginate(keys.concat(args));\n            page = page.concat(items);\n            if (rawJobs && rawJobs.length) {\n                jobs = jobs.concat(rawJobs.map(_utils__WEBPACK_IMPORTED_MODULE_2__.array2obj));\n            }\n        // Important to keep this coercive inequality (!=) instead of strict inequality (!==)\n        }while (cursor != \"0\" && page.length < pageSize);\n        // If we get an array of arrays, it means we are paginating a hash\n        if (page.length && Array.isArray(page[0])) {\n            const result = [];\n            for(let index = 0; index < page.length; index++){\n                const [id, value] = page[index];\n                try {\n                    result.push({\n                        id,\n                        v: JSON.parse(value)\n                    });\n                } catch (err) {\n                    result.push({\n                        id,\n                        err: err.message\n                    });\n                }\n            }\n            return {\n                cursor,\n                items: result,\n                total,\n                jobs\n            };\n        } else {\n            return {\n                cursor,\n                items: page.map((item)=>({\n                        id: item\n                    })),\n                total,\n                jobs\n            };\n        }\n    }\n}\nfunction raw2NextJobData(raw) {\n    if (raw) {\n        const result = [\n            null,\n            raw[1],\n            raw[2],\n            raw[3]\n        ];\n        if (raw[0]) {\n            result[0] = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.array2obj)(raw[0]);\n        }\n        return result;\n    }\n    return [];\n} //# sourceMappingURL=scripts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2NyaXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztDQUVDLEdBQ0Qsa0JBQWtCLEdBQ2xCO0FBQ2lDO0FBQ2pDLE1BQU1DLFNBQVMsSUFBSUQsMkNBQUtBLENBQUM7SUFDckJFLFlBQVk7SUFDWkMsc0JBQXNCO0FBQzFCO0FBQ0EsTUFBTUMsT0FBT0gsT0FBT0csSUFBSTtBQUNhO0FBQ3VDO0FBQ3JFLE1BQU1LO0lBQ1RDLFlBQVlDLEtBQUssQ0FBRTtRQUNmLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLE1BQU1DLFlBQVksSUFBSSxDQUFDRCxLQUFLLENBQUNFLElBQUk7UUFDakMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztZQUN0QkYsVUFBVUcsSUFBSTtZQUNkSCxVQUFVSSxNQUFNO1lBQ2hCSixVQUFVSyxXQUFXO1lBQ3JCTCxVQUFVTSxNQUFNO1lBQ2hCTixVQUFVTyxPQUFPO1lBQ2pCUCxVQUFVUSxPQUFPO1lBQ2pCUixVQUFVUyxPQUFPO1lBQ2pCVCxVQUFVVSxNQUFNO1lBQ2hCVixVQUFVVyxJQUFJO1lBQ2RYLFVBQVVZLEVBQUU7WUFDWkM7WUFDQUE7WUFDQUE7WUFDQUE7U0FDSDtJQUNMO0lBQ0EsTUFBTUMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDOUIsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ2xCLEtBQUssQ0FBQ2tCLE1BQU07UUFDdEMsSUFBSUM7UUFDSixJQUFJdEIsK0RBQXVCQSxDQUFDLElBQUksQ0FBQ0csS0FBSyxDQUFDb0IsWUFBWSxFQUFFLFVBQVU7WUFDM0RELFNBQVMsTUFBTUQsT0FBT0gsV0FBVyxDQUFDO2dCQUFDQztnQkFBU0M7YUFBTTtRQUN0RCxPQUNLO1lBQ0RFLFNBQVMsTUFBTUQsT0FBT0csSUFBSSxDQUFDTCxTQUFTQztRQUN4QztRQUNBLE9BQU9LLE9BQU9DLFNBQVMsQ0FBQ0o7SUFDNUI7SUFDQUssY0FB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LEdBQUc7WUFDdkMsTUFBTWhMLFNBQVMsRUFBRTtZQUNqQixJQUFLLElBQUlzTCxRQUFRLEdBQUdBLFFBQVFOLEtBQUtFLE1BQU0sRUFBRUksUUFBUztnQkFDOUMsTUFBTSxDQUFDNUssSUFBSTZLLE1BQU0sR0FBR1AsSUFBSSxDQUFDTSxNQUFNO2dCQUMvQixJQUFJO29CQUNBdEwsT0FBT1ksSUFBSSxDQUFDO3dCQUFFRjt3QkFBSThLLEdBQUc5SCxLQUFLK0gsS0FBSyxDQUFDRjtvQkFBTztnQkFDM0MsRUFDQSxPQUFPRyxLQUFLO29CQUNSMUwsT0FBT1ksSUFBSSxDQUFDO3dCQUFFRjt3QkFBSWdMLEtBQUtBLElBQUlDLE9BQU87b0JBQUM7Z0JBQ3ZDO1lBQ0o7WUFDQSxPQUFPO2dCQUNIaEI7Z0JBQ0FFLE9BQU83SztnQkFDUDhLO2dCQUNBRztZQUNKO1FBQ0osT0FDSztZQUNELE9BQU87Z0JBQ0hOO2dCQUNBRSxPQUFPRyxLQUFLcEksR0FBRyxDQUFDZ0osQ0FBQUEsT0FBUzt3QkFBRWxMLElBQUlrTDtvQkFBSztnQkFDcENkO2dCQUNBRztZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBQ08sU0FBU25GLGdCQUFnQitGLEdBQUc7SUFDL0IsSUFBSUEsS0FBSztRQUNMLE1BQU03TCxTQUFTO1lBQUM7WUFBTTZMLEdBQUcsQ0FBQyxFQUFFO1lBQUVBLEdBQUcsQ0FBQyxFQUFFO1lBQUVBLEdBQUcsQ0FBQyxFQUFFO1NBQUM7UUFDN0MsSUFBSUEsR0FBRyxDQUFDLEVBQUUsRUFBRTtZQUNSN0wsTUFBTSxDQUFDLEVBQUUsR0FBR3hCLGlEQUFTQSxDQUFDcU4sR0FBRyxDQUFDLEVBQUU7UUFDaEM7UUFDQSxPQUFPN0w7SUFDWDtJQUNBLE9BQU8sRUFBRTtBQUNiLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9zY3JpcHRzLmpzP2RjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbmNsdWRlcyBhbGwgdGhlIHNjcmlwdHMgbmVlZGVkIGJ5IHRoZSBxdWV1ZSBhbmQgam9icy5cbiAqL1xuLyplc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IFBhY2tyIH0gZnJvbSAnbXNncGFja3InO1xuY29uc3QgcGFja2VyID0gbmV3IFBhY2tyKHtcbiAgICB1c2VSZWNvcmRzOiBmYWxzZSxcbiAgICBlbmNvZGVVbmRlZmluZWRBc05pbDogdHJ1ZSxcbn0pO1xuY29uc3QgcGFjayA9IHBhY2tlci5wYWNrO1xuaW1wb3J0IHsgRXJyb3JDb2RlIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgYXJyYXkyb2JqLCBnZXRQYXJlbnRLZXksIGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuIH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGNsYXNzIFNjcmlwdHMge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICB0aGlzLm1vdmVUb0ZpbmlzaGVkS2V5cyA9IFtcbiAgICAgICAgICAgIHF1ZXVlS2V5cy53YWl0LFxuICAgICAgICAgICAgcXVldWVLZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5ldmVudHMsXG4gICAgICAgICAgICBxdWV1ZUtleXMuc3RhbGxlZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5saW1pdGVyLFxuICAgICAgICAgICAgcXVldWVLZXlzLmRlbGF5ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMucGF1c2VkLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1ldGEsXG4gICAgICAgICAgICBxdWV1ZUtleXMucGMsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuICAgIGFzeW5jIGlzSm9iSW5MaXN0KGxpc3RLZXksIGpvYklkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoaXNSZWRpc1ZlcnNpb25Mb3dlclRoYW4odGhpcy5xdWV1ZS5yZWRpc1ZlcnNpb24sICc2LjAuNicpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjbGllbnQuaXNKb2JJbkxpc3QoW2xpc3RLZXksIGpvYklkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjbGllbnQubHBvcyhsaXN0S2V5LCBqb2JJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIocmVzdWx0KTtcbiAgICB9XG4gICAgYWRkRGVsYXllZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgcXVldWVLZXlzLm1hcmtlcixcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tZXRhLFxuICAgICAgICAgICAgcXVldWVLZXlzLmlkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmRlbGF5ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuY29tcGxldGVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgXTtcbiAgICAgICAga2V5cy5wdXNoKHBhY2soYXJncyksIGpvYi5kYXRhLCBlbmNvZGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBjbGllbnQuYWRkRGVsYXllZEpvYihrZXlzKTtcbiAgICB9XG4gICAgYWRkUHJpb3JpdGl6ZWRKb2IoY2xpZW50LCBqb2IsIGVuY29kZWRPcHRzLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tYXJrZXIsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5jb21wbGV0ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLnBjLFxuICAgICAgICBdO1xuICAgICAgICBrZXlzLnB1c2gocGFjayhhcmdzKSwgam9iLmRhdGEsIGVuY29kZWRPcHRzKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5hZGRQcmlvcml0aXplZEpvYihrZXlzKTtcbiAgICB9XG4gICAgYWRkUGFyZW50Sm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5jb21wbGV0ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICBdO1xuICAgICAgICBrZXlzLnB1c2gocGFjayhhcmdzKSwgam9iLmRhdGEsIGVuY29kZWRPcHRzKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5hZGRQYXJlbnRKb2Ioa2V5cyk7XG4gICAgfVxuICAgIGFkZFN0YW5kYXJkSm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5jb21wbGV0ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAga2V5cy5wdXNoKHBhY2soYXJncyksIGpvYi5kYXRhLCBlbmNvZGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBjbGllbnQuYWRkU3RhbmRhcmRKb2Ioa2V5cyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEpvYihjbGllbnQsIGpvYiwgb3B0cywgam9iSWQsIHBhcmVudE9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGpvYi5wYXJlbnRcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqb2IucGFyZW50KSwgeyBmcG9mOiBvcHRzLmZwb2YsIHJkb2Y6IG9wdHMucmRvZiB9KSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgICAgICAgdHlwZW9mIGpvYklkICE9PSAndW5kZWZpbmVkJyA/IGpvYklkIDogJycsXG4gICAgICAgICAgICBqb2IubmFtZSxcbiAgICAgICAgICAgIGpvYi50aW1lc3RhbXAsXG4gICAgICAgICAgICBqb2IucGFyZW50S2V5IHx8IG51bGwsXG4gICAgICAgICAgICBwYXJlbnRPcHRzLndhaXRDaGlsZHJlbktleSB8fCBudWxsLFxuICAgICAgICAgICAgcGFyZW50T3B0cy5wYXJlbnREZXBlbmRlbmNpZXNLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGpvYi5yZXBlYXRKb2JLZXksXG4gICAgICAgIF07XG4gICAgICAgIGxldCBlbmNvZGVkT3B0cztcbiAgICAgICAgaWYgKG9wdHMucmVwZWF0KSB7XG4gICAgICAgICAgICBjb25zdCByZXBlYXQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLnJlcGVhdCk7XG4gICAgICAgICAgICBpZiAocmVwZWF0LnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlcGVhdC5zdGFydERhdGUgPSArbmV3IERhdGUocmVwZWF0LnN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwZWF0LmVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXBlYXQuZW5kRGF0ZSA9ICtuZXcgRGF0ZShyZXBlYXQuZW5kRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGVkT3B0cyA9IHBhY2soT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyByZXBlYXQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlZE9wdHMgPSBwYWNrKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChwYXJlbnRPcHRzLndhaXRDaGlsZHJlbktleSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGRQYXJlbnRKb2IoY2xpZW50LCBqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmRlbGF5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmFkZERlbGF5ZWRKb2IoY2xpZW50LCBqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmFkZFByaW9yaXRpemVkSm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmFkZFN0YW5kYXJkSm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IHBhcmVudE9wdHMucGFyZW50S2V5LFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRKb2InLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGF1c2VBcmdzKHBhdXNlKSB7XG4gICAgICAgIGxldCBzcmMgPSAnd2FpdCcsIGRzdCA9ICdwYXVzZWQnO1xuICAgICAgICBpZiAoIXBhdXNlKSB7XG4gICAgICAgICAgICBzcmMgPSAncGF1c2VkJztcbiAgICAgICAgICAgIGRzdCA9ICd3YWl0JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gW3NyYywgZHN0LCAnbWV0YScsICdwcmlvcml0aXplZCddLm1hcCgobmFtZSkgPT4gdGhpcy5xdWV1ZS50b0tleShuYW1lKSk7XG4gICAgICAgIGtleXMucHVzaCh0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLCB0aGlzLnF1ZXVlLmtleXMuZGVsYXllZCwgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbcGF1c2UgPyAncGF1c2VkJyA6ICdyZXN1bWVkJ107XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2UocGF1c2UpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhdXNlQXJncyhwYXVzZSk7XG4gICAgICAgIHJldHVybiBjbGllbnQucGF1c2UoYXJncyk7XG4gICAgfVxuICAgIHJlbW92ZVJlcGVhdGFibGVBcmdzKHJlcGVhdEpvYklkLCByZXBlYXRKb2JLZXkpIHtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW3F1ZXVlS2V5cy5yZXBlYXQsIHF1ZXVlS2V5cy5kZWxheWVkXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtyZXBlYXRKb2JJZCwgcmVwZWF0Sm9iS2V5LCBxdWV1ZUtleXNbJyddXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVSZXBlYXRhYmxlKHJlcGVhdEpvYklkLCByZXBlYXRKb2JLZXkpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnJlbW92ZVJlcGVhdGFibGVBcmdzKHJlcGVhdEpvYklkLCByZXBlYXRKb2JLZXkpO1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlbW92ZVJlcGVhdGFibGUoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZShqb2JJZCwgcmVtb3ZlQ2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbJyddLm1hcChuYW1lID0+IHRoaXMucXVldWUudG9LZXkobmFtZSkpO1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlbW92ZUpvYihrZXlzLmNvbmNhdChbam9iSWQsIHJlbW92ZUNoaWxkcmVuID8gMSA6IDBdKSk7XG4gICAgfVxuICAgIGFzeW5jIGV4dGVuZExvY2soam9iSWQsIHRva2VuLCBkdXJhdGlvbiwgY2xpZW50KSB7XG4gICAgICAgIGNsaWVudCA9IGNsaWVudCB8fCAoYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQpO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCkgKyAnOmxvY2snLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjbGllbnQuZXh0ZW5kTG9jayhhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YShqb2IsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbdGhpcy5xdWV1ZS50b0tleShqb2IuaWQpXTtcbiAgICAgICAgY29uc3QgZGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnVwZGF0ZURhdGEoa2V5cy5jb25jYXQoW2RhdGFKc29uXSkpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkOiBqb2IuaWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3VwZGF0ZURhdGEnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvZ3Jlc3Moam9iSWQsIHByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHByb2dyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnVwZGF0ZVByb2dyZXNzKGtleXMuY29uY2F0KFtqb2JJZCwgcHJvZ3Jlc3NKc29uXSkpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd1cGRhdGVQcm9ncmVzcycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlVG9GaW5pc2hlZEFyZ3Moam9iLCB2YWwsIHByb3BWYWwsIHNob3VsZFJlbW92ZSwgdGFyZ2V0LCB0b2tlbiwgdGltZXN0YW1wLCBmZXRjaE5leHQgPSB0cnVlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLnF1ZXVlLm9wdHM7XG4gICAgICAgIGNvbnN0IHdvcmtlcktlZXBKb2JzID0gdGFyZ2V0ID09PSAnY29tcGxldGVkJyA/IG9wdHMucmVtb3ZlT25Db21wbGV0ZSA6IG9wdHMucmVtb3ZlT25GYWlsO1xuICAgICAgICBjb25zdCBtZXRyaWNzS2V5ID0gdGhpcy5xdWV1ZS50b0tleShgbWV0cmljczoke3RhcmdldH1gKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMubW92ZVRvRmluaXNoZWRLZXlzO1xuICAgICAgICBrZXlzWzEwXSA9IHF1ZXVlS2V5c1t0YXJnZXRdO1xuICAgICAgICBrZXlzWzExXSA9IHRoaXMucXVldWUudG9LZXkoKF9hID0gam9iLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIGtleXNbMTJdID0gbWV0cmljc0tleTtcbiAgICAgICAga2V5c1sxM10gPSB0aGlzLnF1ZXVlLmtleXMubWFya2VyO1xuICAgICAgICBjb25zdCBrZWVwSm9icyA9IHRoaXMuZ2V0S2VlcEpvYnMoc2hvdWxkUmVtb3ZlLCB3b3JrZXJLZWVwSm9icyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBqb2IuaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBwcm9wVmFsLFxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAnbnVsbCcgOiB2YWwsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAhZmV0Y2hOZXh0IHx8IHRoaXMucXVldWUuY2xvc2luZyA/IDAgOiAxLFxuICAgICAgICAgICAgcXVldWVLZXlzWycnXSxcbiAgICAgICAgICAgIHBhY2soe1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGtlZXBKb2JzLFxuICAgICAgICAgICAgICAgIGxpbWl0ZXI6IG9wdHMubGltaXRlcixcbiAgICAgICAgICAgICAgICBsb2NrRHVyYXRpb246IG9wdHMubG9ja0R1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGF0dGVtcHRzOiBqb2Iub3B0cy5hdHRlbXB0cyxcbiAgICAgICAgICAgICAgICBtYXhNZXRyaWNzU2l6ZTogKChfYiA9IG9wdHMubWV0cmljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heERhdGFQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgID8gKF9jID0gb3B0cy5tZXRyaWNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4RGF0YVBvaW50c1xuICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgIGZwb2Y6ICEhKChfZCA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZmFpbFBhcmVudE9uRmFpbHVyZSksXG4gICAgICAgICAgICAgICAgaWRvZjogISEoKF9lID0gam9iLm9wdHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5pZ25vcmVEZXBlbmRlbmN5T25GYWlsdXJlKSxcbiAgICAgICAgICAgICAgICByZG9mOiAhISgoX2YgPSBqb2Iub3B0cykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnJlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgZ2V0S2VlcEpvYnMoc2hvdWxkUmVtb3ZlLCB3b3JrZXJLZWVwSm9icykge1xuICAgICAgICBpZiAodHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJLZWVwSm9icyB8fCB7IGNvdW50OiBzaG91bGRSZW1vdmUgPyAwIDogLTEgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gc2hvdWxkUmVtb3ZlXG4gICAgICAgICAgICA6IHR5cGVvZiBzaG91bGRSZW1vdmUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyB7IGNvdW50OiBzaG91bGRSZW1vdmUgfVxuICAgICAgICAgICAgICAgIDogeyBjb3VudDogc2hvdWxkUmVtb3ZlID8gMCA6IC0xIH07XG4gICAgfVxuICAgIGFzeW5jIG1vdmVUb0ZpbmlzaGVkKGpvYklkLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQubW92ZVRvRmluaXNoZWQoYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ21vdmVUb0ZpbmlzaGVkJyxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2FjdGl2ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXcyTmV4dEpvYkRhdGEocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2hlZEVycm9ycyh7IGNvZGUsIGpvYklkLCBwYXJlbnRLZXksIGNvbW1hbmQsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTm90RXhpc3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgTWlzc2luZyBrZXkgZm9yIGpvYiAke2pvYklkfS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTG9ja05vdEV4aXN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYE1pc3NpbmcgbG9jayBmb3Igam9iICR7am9iSWR9LiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5Kb2JOb3RJblN0YXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEpvYiAke2pvYklkfSBpcyBub3QgaW4gdGhlICR7c3RhdGV9IHN0YXRlLiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5Kb2JQZW5kaW5nRGVwZW5kZW5jaWVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEpvYiAke2pvYklkfSBoYXMgcGVuZGluZyBkZXBlbmRlbmNpZXMuICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlBhcmVudEpvYk5vdEV4aXN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYE1pc3Npbmcga2V5IGZvciBwYXJlbnQgam9iICR7cGFyZW50S2V5fS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTG9ja01pc21hdGNoOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYExvY2sgbWlzbWF0Y2ggZm9yIGpvYiAke2pvYklkfS4gQ21kICR7Y29tbWFuZH0gZnJvbSAke3N0YXRlfWApO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuUGFyZW50Sm9iQ2Fubm90QmVSZXBsYWNlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBUaGUgcGFyZW50IGpvYiAke3BhcmVudEtleX0gY2Fubm90IGJlIHJlcGxhY2VkLiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFVua25vd24gY29kZSAke2NvZGV9IGVycm9yIGZvciAke2pvYklkfS4gJHtjb21tYW5kfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluQXJncyhkZWxheWVkKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHF1ZXVlS2V5cy53YWl0LFxuICAgICAgICAgICAgcXVldWVLZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIGRlbGF5ZWQgPyBxdWV1ZUtleXMuZGVsYXllZCA6ICcnLFxuICAgICAgICAgICAgcXVldWVLZXlzLnByaW9yaXRpemVkLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW3F1ZXVlS2V5c1snJ11dO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGRyYWluKGRlbGF5ZWQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmRyYWluQXJncyhkZWxheWVkKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kcmFpbihhcmdzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGREZXBlbmRlbmN5QXJncyhqb2JJZCwgcGFyZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3Qga2V5cyA9IFtxdWV1ZUtleXNbJyddXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFt0aGlzLnF1ZXVlLnRvS2V5KGpvYklkKSwgcGFyZW50S2V5XTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVDaGlsZERlcGVuZGVuY3koam9iSWQsIHBhcmVudEtleSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucmVtb3ZlQ2hpbGREZXBlbmRlbmN5QXJncyhqb2JJZCwgcGFyZW50S2V5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnJlbW92ZUNoaWxkRGVwZW5kZW5jeShhcmdzKTtcbiAgICAgICAgc3dpdGNoIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdyZW1vdmVDaGlsZERlcGVuZGVuY3knLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJhbmdlc0FyZ3ModHlwZXMsIHN0YXJ0LCBlbmQsIGFzYykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVHlwZXMgPSB0eXBlcy5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3dhaXRpbmcnID8gJ3dhaXQnIDogdHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbcXVldWVLZXlzWycnXV07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnQsIGVuZCwgYXNjID8gJzEnIDogJzAnLCAuLi50cmFuc2Zvcm1lZFR5cGVzXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSYW5nZXModHlwZXMsIHN0YXJ0ID0gMCwgZW5kID0gMSwgYXNjID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmdldFJhbmdlc0FyZ3ModHlwZXMsIHN0YXJ0LCBlbmQsIGFzYyk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZ2V0UmFuZ2VzKGFyZ3MpO1xuICAgIH1cbiAgICBnZXRDb3VudHNBcmdzKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRUeXBlcyA9IHR5cGVzLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnd2FpdGluZycgPyAnd2FpdCcgOiB0eXBlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtxdWV1ZUtleXNbJyddXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFsuLi50cmFuc2Zvcm1lZFR5cGVzXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb3VudHModHlwZXMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmdldENvdW50c0FyZ3ModHlwZXMpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmdldENvdW50cyhhcmdzKTtcbiAgICB9XG4gICAgbW92ZVRvQ29tcGxldGVkQXJncyhqb2IsIHJldHVybnZhbHVlLCByZW1vdmVPbkNvbXBsZXRlLCB0b2tlbiwgZmV0Y2hOZXh0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvRmluaXNoZWRBcmdzKGpvYiwgcmV0dXJudmFsdWUsICdyZXR1cm52YWx1ZScsIHJlbW92ZU9uQ29tcGxldGUsICdjb21wbGV0ZWQnLCB0b2tlbiwgdGltZXN0YW1wLCBmZXRjaE5leHQpO1xuICAgIH1cbiAgICBtb3ZlVG9GYWlsZWRBcmdzKGpvYiwgZmFpbGVkUmVhc29uLCByZW1vdmVPbkZhaWxlZCwgdG9rZW4sIGZldGNoTmV4dCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVUb0ZpbmlzaGVkQXJncyhqb2IsIGZhaWxlZFJlYXNvbiwgJ2ZhaWxlZFJlYXNvbicsIHJlbW92ZU9uRmFpbGVkLCAnZmFpbGVkJywgdG9rZW4sIHRpbWVzdGFtcCwgZmV0Y2hOZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgaXNGaW5pc2hlZChqb2JJZCwgcmV0dXJuVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5cyA9IFsnY29tcGxldGVkJywgJ2ZhaWxlZCcsIGpvYklkXS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUudG9LZXkoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnQuaXNGaW5pc2hlZChrZXlzLmNvbmNhdChbam9iSWQsIHJldHVyblZhbHVlID8gJzEnIDogJyddKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0YXRlKGpvYklkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAnZmFpbGVkJyxcbiAgICAgICAgICAgICdkZWxheWVkJyxcbiAgICAgICAgICAgICdhY3RpdmUnLFxuICAgICAgICAgICAgJ3dhaXQnLFxuICAgICAgICAgICAgJ3BhdXNlZCcsXG4gICAgICAgICAgICAnd2FpdGluZy1jaGlsZHJlbicsXG4gICAgICAgICAgICAncHJpb3JpdGl6ZWQnLFxuICAgICAgICBdLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS50b0tleShrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMucXVldWUucmVkaXNWZXJzaW9uLCAnNi4wLjYnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRTdGF0ZShrZXlzLmNvbmNhdChbam9iSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRTdGF0ZVYyKGtleXMuY29uY2F0KFtqb2JJZF0pKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlRGVsYXkoam9iSWQsIGRlbGF5KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5jaGFuZ2VEZWxheUFyZ3Moam9iSWQsIGRlbGF5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmNoYW5nZURlbGF5KGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjaGFuZ2VEZWxheScsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdkZWxheWVkJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZURlbGF5QXJncyhqb2JJZCwgZGVsYXkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQmFrZSBpbiB0aGUgam9iIGlkIGZpcnN0IDEyIGJpdHMgaW50byB0aGUgdGltZXN0YW1wXG4gICAgICAgIC8vIHRvIGd1YXJhbnRlZSBjb3JyZWN0IGV4ZWN1dGlvbiBvcmRlciBvZiBkZWxheWVkIGpvYnNcbiAgICAgICAgLy8gKHVwIHRvIDQwOTYgam9icyBwZXIgZ2l2ZW4gdGltZXN0YW1wIG9yIDQwOTYgam9icyBhcGFydCBwZXIgdGltZXN0YW1wKVxuICAgICAgICAvL1xuICAgICAgICAvLyBXQVJOSU5HOiBKb2JzIHRoYXQgYXJlIHNvIGZhciBhcGFydCB0aGF0IHRoZXkgd3JhcCBhcm91bmQgd2lsbCBjYXVzZSBGSUZPIHRvIGZhaWxcbiAgICAgICAgLy9cbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBkZWxheTtcbiAgICAgICAgaWYgKHRpbWVzdGFtcCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCAqIDB4MTAwMCArICgram9iSWQgJiAweGZmZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmV2ZW50cyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KFtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGltZXN0YW1wKSxcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2VQcmlvcml0eShqb2JJZCwgcHJpb3JpdHkgPSAwLCBsaWZvID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNoYW5nZVByaW9yaXR5QXJncyhqb2JJZCwgcHJpb3JpdHksIGxpZm8pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuY2hhbmdlUHJpb3JpdHkoYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NoYW5nZVByaW9yaXR5JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVByaW9yaXR5QXJncyhqb2JJZCwgcHJpb3JpdHkgPSAwLCBsaWZvID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy53YWl0LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnByaW9yaXRpemVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBjLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KFtcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIGxpZm8gPyAxIDogMCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIE5vdGU6IFdlIGhhdmUgYW4gaXNzdWUgaGVyZSB3aXRoIGpvYnMgdXNpbmcgY3VzdG9tIGpvYiBpZHNcbiAgICBtb3ZlVG9EZWxheWVkQXJncyhqb2JJZCwgdGltZXN0YW1wLCB0b2tlbiwgZGVsYXksIG9wdHMgPSB7fSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBCYWtlIGluIHRoZSBqb2IgaWQgZmlyc3QgMTIgYml0cyBpbnRvIHRoZSB0aW1lc3RhbXBcbiAgICAgICAgLy8gdG8gZ3VhcmFudGVlIGNvcnJlY3QgZXhlY3V0aW9uIG9yZGVyIG9mIGRlbGF5ZWQgam9ic1xuICAgICAgICAvLyAodXAgdG8gNDA5NiBqb2JzIHBlciBnaXZlbiB0aW1lc3RhbXAgb3IgNDA5NiBqb2JzIGFwYXJ0IHBlciB0aW1lc3RhbXApXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdBUk5JTkc6IEpvYnMgdGhhdCBhcmUgc28gZmFyIGFwYXJ0IHRoYXQgdGhleSB3cmFwIGFyb3VuZCB3aWxsIGNhdXNlIEZJRk8gdG8gZmFpbFxuICAgICAgICAvL1xuICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLm1heCgwLCB0aW1lc3RhbXAgIT09IG51bGwgJiYgdGltZXN0YW1wICE9PSB2b2lkIDAgPyB0aW1lc3RhbXAgOiAwKTtcbiAgICAgICAgaWYgKHRpbWVzdGFtcCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCAqIDB4MTAwMCArICgram9iSWQgJiAweGZmZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgcXVldWVLZXlzLm1hcmtlcixcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tZXRhLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzWycnXSxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aW1lc3RhbXApLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgb3B0cy5za2lwQXR0ZW1wdCA/ICcxJyA6ICcwJyxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHNhdmVTdGFja3RyYWNlQXJncyhqb2JJZCwgc3RhY2t0cmFjZSwgZmFpbGVkUmVhc29uKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbdGhpcy5xdWV1ZS50b0tleShqb2JJZCldO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoW3N0YWNrdHJhY2UsIGZhaWxlZFJlYXNvbl0pO1xuICAgIH1cbiAgICBtb3ZlVG9XYWl0aW5nQ2hpbGRyZW5BcmdzKGpvYklkLCB0b2tlbiwgb3B0cykge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGdldFBhcmVudEtleShvcHRzLmNoaWxkKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtgJHtqb2JJZH06bG9ja2AsICdhY3RpdmUnLCAnd2FpdGluZy1jaGlsZHJlbicsIGpvYklkXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS50b0tleShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGNoaWxkS2V5ICE9PSBudWxsICYmIGNoaWxkS2V5ICE9PSB2b2lkIDAgPyBjaGlsZEtleSA6ICcnLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGltZXN0YW1wKSxcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgbW92ZVRvRGVsYXllZChqb2JJZCwgdGltZXN0YW1wLCBkZWxheSwgdG9rZW4gPSAnMCcsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMubW92ZVRvRGVsYXllZEFyZ3Moam9iSWQsIHRpbWVzdGFtcCwgdG9rZW4sIGRlbGF5LCBvcHRzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50Lm1vdmVUb0RlbGF5ZWQoYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ21vdmVUb0RlbGF5ZWQnLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnYWN0aXZlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgcGFyZW50IGpvYiB0byB3YWl0aW5nLWNoaWxkcmVuIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBqb2IgaXMgc3VjY2Vzc2Z1bGx5IG1vdmVkLCBmYWxzZSBpZiB0aGVyZSBhcmUgcGVuZGluZyBkZXBlbmRlbmNpZXMuXG4gICAgICogQHRocm93cyBKb2JOb3RFeGlzdFxuICAgICAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biBpZiBqb2JJZCBpcyBtaXNzaW5nLlxuICAgICAqIEB0aHJvd3MgSm9iTG9ja05vdEV4aXN0XG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIGpvYiBsb2NrIGlzIG1pc3NpbmcuXG4gICAgICogQHRocm93cyBKb2JOb3RJblN0YXRlXG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIGpvYiBpcyBub3QgaW4gYWN0aXZlIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb1dhaXRpbmdDaGlsZHJlbihqb2JJZCwgdG9rZW4sIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMubW92ZVRvV2FpdGluZ0NoaWxkcmVuQXJncyhqb2JJZCwgdG9rZW4sIG9wdHMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQubW92ZVRvV2FpdGluZ0NoaWxkcmVuKGFyZ3MpO1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4nLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ2FjdGl2ZScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGpvYnMgaW4gYSBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElkIGpvYnMgZnJvbSB0aGUgZGVsZXRlZCByZWNvcmRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFuSm9ic0luU2V0KHNldCwgdGltZXN0YW1wLCBsaW1pdCA9IDApIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuY2xlYW5Kb2JzSW5TZXQoW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShzZXQpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnZXZlbnRzJyksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgc2V0LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0cnlKb2JBcmdzKGpvYklkLCBsaWZvLCB0b2tlbikge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy53YWl0LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmRlbGF5ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGMsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBwdXNoQ21kID0gKGxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnJyksXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcHVzaENtZCxcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBtb3ZlSm9ic1RvV2FpdEFyZ3Moc3RhdGUsIGNvdW50LCB0aW1lc3RhbXApIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoJycpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoc3RhdGUpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnd2FpdCcpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgncGF1c2VkJyksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tYXJrZXIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbY291bnQsIHRpbWVzdGFtcCwgc3RhdGVdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5Sm9icyhzdGF0ZSA9ICdmYWlsZWQnLCBjb3VudCA9IDEwMDAsIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5tb3ZlSm9ic1RvV2FpdEFyZ3Moc3RhdGUsIGNvdW50LCB0aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gY2xpZW50Lm1vdmVKb2JzVG9XYWl0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBwcm9tb3RlSm9icyhjb3VudCA9IDEwMDApIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLm1vdmVKb2JzVG9XYWl0QXJncygnZGVsYXllZCcsIGNvdW50LCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5tb3ZlSm9ic1RvV2FpdChhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmVwcm9jZXNzIGEgam9iXG4gICAgICpcbiAgICAgKiBAcGFyYW0gam9iIC1cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBUaGUgZXhwZWN0ZWQgam9iIHN0YXRlLiBJZiB0aGUgam9iIGlzIG5vdCBmb3VuZFxuICAgICAqIG9uIHRoZSBwcm92aWRlZCBzdGF0ZSwgdGhlbiBpdCdzIG5vdCByZXByb2Nlc3NlZC4gU3VwcG9ydGVkIHN0YXRlczogJ2ZhaWxlZCcsICdjb21wbGV0ZWQnXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGV2YWx1YXRlcyB0byBhIHJldHVybiBjb2RlOlxuICAgICAqIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAgICogMCBtZWFucyB0aGUgam9iIGRvZXMgbm90IGV4aXN0XG4gICAgICogLTEgbWVhbnMgdGhlIGpvYiBpcyBjdXJyZW50bHkgbG9ja2VkIGFuZCBjYW4ndCBiZSByZXRyaWVkLlxuICAgICAqIC0yIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0XG4gICAgICovXG4gICAgYXN5bmMgcmVwcm9jZXNzSm9iKGpvYiwgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KGpvYi5pZCksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShzdGF0ZSksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMud2FpdCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tYXJrZXIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBqb2IuaWQsXG4gICAgICAgICAgICAoam9iLm9wdHMubGlmbyA/ICdSJyA6ICdMJykgKyAnUFVTSCcsXG4gICAgICAgICAgICBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyAnZmFpbGVkUmVhc29uJyA6ICdyZXR1cm52YWx1ZScsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnJlcHJvY2Vzc0pvYihrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBqb2JJZDogam9iLmlkLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAncmVwcm9jZXNzSm9iJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIG5hbWUpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMucXVldWUub3B0cztcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgcXVldWVLZXlzLndhaXQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuYWN0aXZlLFxuICAgICAgICAgICAgcXVldWVLZXlzLnByaW9yaXRpemVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5zdGFsbGVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmxpbWl0ZXIsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tYXJrZXIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgICAgICAgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHBhY2soe1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGxvY2tEdXJhdGlvbjogb3B0cy5sb2NrRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgbGltaXRlcjogb3B0cy5saW1pdGVyLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50Lm1vdmVUb0FjdGl2ZShrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHJldHVybiByYXcyTmV4dEpvYkRhdGEocmVzdWx0KTtcbiAgICB9XG4gICAgYXN5bmMgcHJvbW90ZShqb2JJZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLndhaXQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGMsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFt0aGlzLnF1ZXVlLnRvS2V5KCcnKSwgam9iSWRdO1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgY2xpZW50LnByb21vdGUoa2V5cy5jb25jYXQoYXJncykpO1xuICAgICAgICBpZiAoY29kZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Byb21vdGUnLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnZGVsYXllZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyBmb3IgdW5sb2NrZWQgam9icyBpbiB0aGUgYWN0aXZlIHF1ZXVlLlxuICAgICAqXG4gICAgICogVGhlIGpvYiB3YXMgYmVpbmcgd29ya2VkIG9uLCBidXQgdGhlIHdvcmtlciBwcm9jZXNzIGRpZWQgYW5kIGl0IGZhaWxlZCB0byByZW5ldyB0aGUgbG9jay5cbiAgICAgKiBXZSBjYWxsIHRoZXNlIGpvYnMgJ3N0YWxsZWQnLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLiBXZSByZXNvbHZlIHRoZXNlIGJ5IG1vdmluZyB0aGVtXG4gICAgICogYmFjayB0byB3YWl0IHRvIGJlIHJlLXByb2Nlc3NlZC4gVG8gcHJldmVudCBqb2JzIGZyb20gY3ljbGluZyBlbmRsZXNzbHkgYmV0d2VlbiBhY3RpdmUgYW5kIHdhaXQsXG4gICAgICogKGUuZy4gaWYgdGhlIGpvYiBoYW5kbGVyIGtlZXBzIGNyYXNoaW5nKSxcbiAgICAgKiB3ZSBsaW1pdCB0aGUgbnVtYmVyIHN0YWxsZWQgam9iIHJlY292ZXJpZXMgdG8gc2V0dGluZ3MubWF4U3RhbGxlZENvdW50LlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVTdGFsbGVkSm9ic1RvV2FpdCgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLnF1ZXVlLm9wdHM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuc3RhbGxlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy53YWl0LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5mYWlsZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXNbJ3N0YWxsZWQtY2hlY2snXSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tYXJrZXIsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgb3B0cy5tYXhTdGFsbGVkQ291bnQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBvcHRzLnN0YWxsZWRJbnRlcnZhbCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5tb3ZlU3RhbGxlZEpvYnNUb1dhaXQoa2V5cy5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGpvYiBiYWNrIGZyb20gQWN0aXZlIHRvIFdhaXQuXG4gICAgICogVGhpcyBzY3JpcHQgaXMgdXNlZCB3aGVuIGEgam9iIGhhcyBiZWVuIG1hbnVhbGx5IHJhdGUgbGltaXRlZCBhbmQgbmVlZHNcbiAgICAgKiB0byBiZSBtb3ZlZCBiYWNrIHRvIHdhaXQgZnJvbSBhY3RpdmUgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudCAtIFJlZGlzIGNsaWVudFxuICAgICAqIEBwYXJhbSBqb2JJZCAtIEpvYiBpZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQoam9iSWQsIHRva2VuKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBsb2NrS2V5ID0gYCR7dGhpcy5xdWV1ZS50b0tleShqb2JJZCl9OmxvY2tgO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy53YWl0LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICAgICAgICBsb2NrS2V5LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmxpbWl0ZXIsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmV2ZW50cyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtqb2JJZCwgdG9rZW4sIHRoaXMucXVldWUudG9LZXkoam9iSWQpXTtcbiAgICAgICAgY29uc3QgcHR0bCA9IGF3YWl0IGNsaWVudC5tb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdChrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHJldHVybiBwdHRsIDwgMCA/IDAgOiBwdHRsO1xuICAgIH1cbiAgICBhc3luYyBvYmxpdGVyYXRlKG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoJycpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW29wdHMuY291bnQsIG9wdHMuZm9yY2UgPyAnZm9yY2UnIDogbnVsbF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5vYmxpdGVyYXRlKGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2JsaXRlcmF0ZSBub24tcGF1c2VkIHF1ZXVlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2JsaXRlcmF0ZSBxdWV1ZSB3aXRoIGFjdGl2ZSBqb2JzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFnaW5hdGUgYSBzZXQgb3IgaGFzaCBrZXlzLlxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwYWdpbmF0ZShrZXksIG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBba2V5XTtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDU7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gb3B0cy5lbmQgPj0gMCA/IG9wdHMuZW5kIC0gb3B0cy5zdGFydCArIDEgOiBJbmZpbml0eTtcbiAgICAgICAgbGV0IGN1cnNvciA9ICcwJywgb2Zmc2V0ID0gMCwgaXRlbXMsIHRvdGFsLCByYXdKb2JzLCBwYWdlID0gW10sIGpvYnMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBvcHRzLnN0YXJ0ICsgcGFnZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0cy5lbmQsXG4gICAgICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZldGNoSm9icykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtjdXJzb3IsIG9mZnNldCwgaXRlbXMsIHRvdGFsLCByYXdKb2JzXSA9IGF3YWl0IGNsaWVudC5wYWdpbmF0ZShrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBwYWdlID0gcGFnZS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgaWYgKHJhd0pvYnMgJiYgcmF3Sm9icy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBqb2JzID0gam9icy5jb25jYXQocmF3Sm9icy5tYXAoYXJyYXkyb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbXBvcnRhbnQgdG8ga2VlcCB0aGlzIGNvZXJjaXZlIGluZXF1YWxpdHkgKCE9KSBpbnN0ZWFkIG9mIHN0cmljdCBpbmVxdWFsaXR5ICghPT0pXG4gICAgICAgIH0gd2hpbGUgKGN1cnNvciAhPSAnMCcgJiYgcGFnZS5sZW5ndGggPCBwYWdlU2l6ZSk7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBhcnJheSBvZiBhcnJheXMsIGl0IG1lYW5zIHdlIGFyZSBwYWdpbmF0aW5nIGEgaGFzaFxuICAgICAgICBpZiAocGFnZS5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShwYWdlWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFnZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaWQsIHZhbHVlXSA9IHBhZ2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaWQsIHY6IEpTT04ucGFyc2UodmFsdWUpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaWQsIGVycjogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBqb2JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBwYWdlLm1hcChpdGVtID0+ICh7IGlkOiBpdGVtIH0pKSxcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBqb2JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByYXcyTmV4dEpvYkRhdGEocmF3KSB7XG4gICAgaWYgKHJhdykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbbnVsbCwgcmF3WzFdLCByYXdbMl0sIHJhd1szXV07XG4gICAgICAgIGlmIChyYXdbMF0pIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IGFycmF5Mm9iaihyYXdbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcmlwdHMuanMubWFwIl0sIm5hbWVzIjpbIlBhY2tyIiwicGFja2VyIiwidXNlUmVjb3JkcyIsImVuY29kZVVuZGVmaW5lZEFzTmlsIiwicGFjayIsIkVycm9yQ29kZSIsImFycmF5Mm9iaiIsImdldFBhcmVudEtleSIsImlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuIiwiU2NyaXB0cyIsImNvbnN0cnVjdG9yIiwicXVldWUiLCJxdWV1ZUtleXMiLCJrZXlzIiwibW92ZVRvRmluaXNoZWRLZXlzIiwid2FpdCIsImFjdGl2ZSIsInByaW9yaXRpemVkIiwiZXZlbnRzIiwic3RhbGxlZCIsImxpbWl0ZXIiLCJkZWxheWVkIiwicGF1c2VkIiwibWV0YSIsInBjIiwidW5kZWZpbmVkIiwiaXNKb2JJbkxpc3QiLCJsaXN0S2V5Iiwiam9iSWQiLCJjbGllbnQiLCJyZXN1bHQiLCJyZWRpc1ZlcnNpb24iLCJscG9zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYWRkRGVsYXllZEpvYiIsImpvYiIsImVuY29kZWRPcHRzIiwiYXJncyIsIm1hcmtlciIsImlkIiwiY29tcGxldGVkIiwicHVzaCIsImRhdGEiLCJhZGRQcmlvcml0aXplZEpvYiIsImFkZFBhcmVudEpvYiIsImFkZFN0YW5kYXJkSm9iIiwiYWRkSm9iIiwib3B0cyIsInBhcmVudE9wdHMiLCJwYXJlbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJmcG9mIiwicmRvZiIsIm5hbWUiLCJ0aW1lc3RhbXAiLCJwYXJlbnRLZXkiLCJ3YWl0Q2hpbGRyZW5LZXkiLCJwYXJlbnREZXBlbmRlbmNpZXNLZXkiLCJyZXBlYXRKb2JLZXkiLCJyZXBlYXQiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsImRlbGF5IiwicHJpb3JpdHkiLCJmaW5pc2hlZEVycm9ycyIsImNvZGUiLCJjb21tYW5kIiwicGF1c2VBcmdzIiwicGF1c2UiLCJzcmMiLCJkc3QiLCJtYXAiLCJ0b0tleSIsImNvbmNhdCIsInJlbW92ZVJlcGVhdGFibGVBcmdzIiwicmVwZWF0Sm9iSWQiLCJyZW1vdmVSZXBlYXRhYmxlIiwicmVtb3ZlIiwicmVtb3ZlQ2hpbGRyZW4iLCJyZW1vdmVKb2IiLCJleHRlbmRMb2NrIiwidG9rZW4iLCJkdXJhdGlvbiIsInVwZGF0ZURhdGEiLCJkYXRhSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVQcm9ncmVzcyIsInByb2dyZXNzIiwicHJvZ3Jlc3NKc29uIiwibW92ZVRvRmluaXNoZWRBcmdzIiwidmFsIiwicHJvcFZhbCIsInNob3VsZFJlbW92ZSIsInRhcmdldCIsImZldGNoTmV4dCIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIndvcmtlcktlZXBKb2JzIiwicmVtb3ZlT25Db21wbGV0ZSIsInJlbW92ZU9uRmFpbCIsIm1ldHJpY3NLZXkiLCJrZWVwSm9icyIsImdldEtlZXBKb2JzIiwiY2xvc2luZyIsImxvY2tEdXJhdGlvbiIsImF0dGVtcHRzIiwibWF4TWV0cmljc1NpemUiLCJtZXRyaWNzIiwibWF4RGF0YVBvaW50cyIsImZhaWxQYXJlbnRPbkZhaWx1cmUiLCJpZG9mIiwiaWdub3JlRGVwZW5kZW5jeU9uRmFpbHVyZSIsInJlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUiLCJjb3VudCIsIm1vdmVUb0ZpbmlzaGVkIiwic3RhdGUiLCJyYXcyTmV4dEpvYkRhdGEiLCJKb2JOb3RFeGlzdCIsIkVycm9yIiwiSm9iTG9ja05vdEV4aXN0IiwiSm9iTm90SW5TdGF0ZSIsIkpvYlBlbmRpbmdEZXBlbmRlbmNpZXMiLCJQYXJlbnRKb2JOb3RFeGlzdCIsIkpvYkxvY2tNaXNtYXRjaCIsIlBhcmVudEpvYkNhbm5vdEJlUmVwbGFjZWQiLCJkcmFpbkFyZ3MiLCJkcmFpbiIsInJlbW92ZUNoaWxkRGVwZW5kZW5jeUFyZ3MiLCJyZW1vdmVDaGlsZERlcGVuZGVuY3kiLCJnZXRSYW5nZXNBcmdzIiwidHlwZXMiLCJzdGFydCIsImVuZCIsImFzYyIsInRyYW5zZm9ybWVkVHlwZXMiLCJ0eXBlIiwiZ2V0UmFuZ2VzIiwiZ2V0Q291bnRzQXJncyIsImdldENvdW50cyIsIm1vdmVUb0NvbXBsZXRlZEFyZ3MiLCJyZXR1cm52YWx1ZSIsIm5vdyIsIm1vdmVUb0ZhaWxlZEFyZ3MiLCJmYWlsZWRSZWFzb24iLCJyZW1vdmVPbkZhaWxlZCIsImlzRmluaXNoZWQiLCJyZXR1cm5WYWx1ZSIsImtleSIsImdldFN0YXRlIiwiZ2V0U3RhdGVWMiIsImNoYW5nZURlbGF5IiwiY2hhbmdlRGVsYXlBcmdzIiwiY2hhbmdlUHJpb3JpdHkiLCJsaWZvIiwiY2hhbmdlUHJpb3JpdHlBcmdzIiwibW92ZVRvRGVsYXllZEFyZ3MiLCJNYXRoIiwibWF4Iiwic2tpcEF0dGVtcHQiLCJzYXZlU3RhY2t0cmFjZUFyZ3MiLCJzdGFja3RyYWNlIiwibW92ZVRvV2FpdGluZ0NoaWxkcmVuQXJncyIsImNoaWxkS2V5IiwiY2hpbGQiLCJtb3ZlVG9EZWxheWVkIiwibW92ZVRvV2FpdGluZ0NoaWxkcmVuIiwiY2xlYW5Kb2JzSW5TZXQiLCJzZXQiLCJsaW1pdCIsInJldHJ5Sm9iQXJncyIsInB1c2hDbWQiLCJtb3ZlSm9ic1RvV2FpdEFyZ3MiLCJyZXRyeUpvYnMiLCJnZXRUaW1lIiwibW92ZUpvYnNUb1dhaXQiLCJwcm9tb3RlSm9icyIsIk1BWF9WQUxVRSIsInJlcHJvY2Vzc0pvYiIsIm1vdmVUb0FjdGl2ZSIsInByb21vdGUiLCJtb3ZlU3RhbGxlZEpvYnNUb1dhaXQiLCJmYWlsZWQiLCJtYXhTdGFsbGVkQ291bnQiLCJzdGFsbGVkSW50ZXJ2YWwiLCJtb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdCIsImxvY2tLZXkiLCJwdHRsIiwib2JsaXRlcmF0ZSIsImZvcmNlIiwicGFnaW5hdGUiLCJtYXhJdGVyYXRpb25zIiwicGFnZVNpemUiLCJJbmZpbml0eSIsImN1cnNvciIsIm9mZnNldCIsIml0ZW1zIiwidG90YWwiLCJyYXdKb2JzIiwicGFnZSIsImpvYnMiLCJsZW5ndGgiLCJmZXRjaEpvYnMiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleCIsInZhbHVlIiwidiIsInBhcnNlIiwiZXJyIiwibWVzc2FnZSIsIml0ZW0iLCJyYXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/worker.js ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Worker: () => (/* binding */ Worker)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var node_abort_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node-abort-controller */ \"(rsc)/./node_modules/node-abort-controller/index.js\");\n/* harmony import */ var node_abort_controller__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(node_abort_controller__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n/* harmony import */ var _child_pool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./child-pool */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _sandbox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\");\n/* harmony import */ var _async_fifo_queue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./async-fifo-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n// Note: this Polyfill is only needed for Node versions < 15.4.0\n\n\n\n\n\n\n\n\n\n\n// 10 seconds is the maximum time a BRPOPLPUSH can block.\nconst maximumBlockTimeout = 10;\n/**\n *\n * This class represents a worker that is able to process jobs from the queue.\n * As soon as the class is instantiated and a connection to Redis is established\n * it will start processing jobs.\n *\n */ class Worker extends _queue_base__WEBPACK_IMPORTED_MODULE_5__.QueueBase {\n    static RateLimitError() {\n        return new _errors__WEBPACK_IMPORTED_MODULE_12__.RateLimitError();\n    }\n    constructor(name, processor, opts, Connection){\n        super(name, Object.assign(Object.assign({}, opts), {\n            blockingConnection: true\n        }), Connection);\n        this.abortDelayController = null;\n        this.blockUntil = 0;\n        this.drained = false;\n        this.extendLocksTimer = null;\n        this.limitUntil = 0;\n        this.waiting = null;\n        this.running = false;\n        if (!opts || !opts.connection) {\n            throw new Error(\"Worker requires a connection\");\n        }\n        this.opts = Object.assign({\n            drainDelay: 5,\n            concurrency: 1,\n            lockDuration: 30000,\n            maxStalledCount: 1,\n            stalledInterval: 30000,\n            autorun: true,\n            runRetryDelay: 15000\n        }, this.opts);\n        if (this.opts.stalledInterval <= 0) {\n            throw new Error(\"stalledInterval must be greater than 0\");\n        }\n        this.concurrency = this.opts.concurrency;\n        this.opts.lockRenewTime = this.opts.lockRenewTime || this.opts.lockDuration / 2;\n        this.id = (0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n        if (processor) {\n            if (typeof processor === \"function\") {\n                this.processFn = processor;\n            } else {\n                // SANDBOXED\n                if (processor instanceof url__WEBPACK_IMPORTED_MODULE_1__.URL) {\n                    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(processor)) {\n                        throw new Error(`URL ${processor} does not exist in the local file system`);\n                    }\n                    processor = processor.href;\n                } else {\n                    const supportedFileTypes = [\n                        \".js\",\n                        \".ts\",\n                        \".flow\",\n                        \".cjs\"\n                    ];\n                    const processorFile = processor + (supportedFileTypes.includes(path__WEBPACK_IMPORTED_MODULE_2__.extname(processor)) ? \"\" : \".js\");\n                    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(processorFile)) {\n                        throw new Error(`File ${processorFile} does not exist`);\n                    }\n                }\n                // Separate paths so that bundling tools can resolve dependencies easier\n                const dirname = path__WEBPACK_IMPORTED_MODULE_2__.dirname(module.filename || __filename);\n                const workerThreadsMainFile = path__WEBPACK_IMPORTED_MODULE_2__.join(dirname, \"main-worker.js\");\n                const spawnProcessMainFile = path__WEBPACK_IMPORTED_MODULE_2__.join(dirname, \"main.js\");\n                let mainFilePath = this.opts.useWorkerThreads ? workerThreadsMainFile : spawnProcessMainFile;\n                try {\n                    fs__WEBPACK_IMPORTED_MODULE_0__.statSync(mainFilePath); // would throw if file not exists\n                } catch (_) {\n                    const mainFile = this.opts.useWorkerThreads ? \"main-worker.js\" : \"main.js\";\n                    mainFilePath = path__WEBPACK_IMPORTED_MODULE_2__.join(process.cwd(), `dist/cjs/classes/${mainFile}`);\n                    fs__WEBPACK_IMPORTED_MODULE_0__.statSync(mainFilePath);\n                }\n                this.childPool = new _child_pool__WEBPACK_IMPORTED_MODULE_7__.ChildPool({\n                    mainFile: mainFilePath,\n                    useWorkerThreads: this.opts.useWorkerThreads\n                });\n                this.processFn = (0,_sandbox__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(processor, this.childPool).bind(this);\n            }\n            if (this.opts.autorun) {\n                this.run().catch((error)=>this.emit(\"error\", error));\n            }\n        }\n        const connectionName = this.clientName() + (this.opts.name ? `:w:${this.opts.name}` : \"\");\n        this.blockingConnection = new _redis_connection__WEBPACK_IMPORTED_MODULE_9__.RedisConnection((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isRedisInstance)(opts.connection) ? opts.connection.duplicate({\n            connectionName\n        }) : Object.assign(Object.assign({}, opts.connection), {\n            connectionName\n        }), false, true, opts.skipVersionCheck);\n        this.blockingConnection.on(\"error\", (error)=>this.emit(\"error\", error));\n        this.blockingConnection.on(\"ready\", ()=>setTimeout(()=>this.emit(\"ready\"), 0));\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    callProcessJob(job, token) {\n        return this.processFn(job, token);\n    }\n    createJob(data, jobId) {\n        return this.Job.fromJSON(this, data, jobId);\n    }\n    /**\n     *\n     * Waits until the worker is ready to start processing jobs.\n     * In general only useful when writing tests.\n     *\n     */ async waitUntilReady() {\n        await super.waitUntilReady();\n        return this.blockingConnection.client;\n    }\n    set concurrency(concurrency) {\n        if (typeof concurrency !== \"number\" || concurrency < 1 || !isFinite(concurrency)) {\n            throw new Error(\"concurrency must be a finite number greater than 0\");\n        }\n        this.opts.concurrency = concurrency;\n    }\n    get repeat() {\n        return new Promise(async (resolve)=>{\n            if (!this._repeat) {\n                const connection = await this.client;\n                this._repeat = new _repeat__WEBPACK_IMPORTED_MODULE_6__.Repeat(this.name, Object.assign(Object.assign({}, this.opts), {\n                    connection\n                }));\n                this._repeat.on(\"error\", (e)=>this.emit.bind(this, e));\n            }\n            resolve(this._repeat);\n        });\n    }\n    async run() {\n        if (!this.processFn) {\n            throw new Error(\"No process function is defined.\");\n        }\n        if (this.running) {\n            throw new Error(\"Worker is already running.\");\n        }\n        try {\n            this.running = true;\n            if (this.closing) {\n                return;\n            }\n            await this.startStalledCheckTimer();\n            const jobsInProgress = new Set();\n            this.startLockExtenderTimer(jobsInProgress);\n            const asyncFifoQueue = this.asyncFifoQueue = new _async_fifo_queue__WEBPACK_IMPORTED_MODULE_11__.AsyncFifoQueue();\n            let tokenPostfix = 0;\n            const client = await this.client;\n            const bclient = await this.blockingConnection.client;\n            while(!this.closing){\n                let numTotal = asyncFifoQueue.numTotal();\n                while(!this.waiting && numTotal < this.opts.concurrency && (!this.limitUntil || numTotal == 0)){\n                    const token = `${this.id}:${tokenPostfix++}`;\n                    const fetchedJob = this.retryIfFailed(()=>this._getNextJob(client, bclient, token, {\n                            block: true\n                        }), this.opts.runRetryDelay);\n                    asyncFifoQueue.add(fetchedJob);\n                    numTotal = asyncFifoQueue.numTotal();\n                    if (this.waiting && numTotal > 1) {\n                        break;\n                    }\n                    // We await here so that we fetch jobs in sequence, this is important to avoid unnecessary calls\n                    // to Redis in high concurrency scenarios.\n                    const job = await fetchedJob;\n                    // No more jobs waiting but we have others that could start processing already\n                    if (!job && numTotal > 1) {\n                        break;\n                    }\n                    // If there are potential jobs to be processed and blockUntil is set, we should exit to avoid waiting\n                    // for processing this job.\n                    if (this.blockUntil) {\n                        break;\n                    }\n                }\n                // Since there can be undefined jobs in the queue (when a job fails or queue is empty)\n                // we iterate until we find a job.\n                let job;\n                do {\n                    job = await asyncFifoQueue.fetch();\n                }while (!job && asyncFifoQueue.numQueued() > 0);\n                if (job) {\n                    const token = job.token;\n                    asyncFifoQueue.add(this.retryIfFailed(()=>this.processJob(job, token, ()=>asyncFifoQueue.numTotal() <= this.opts.concurrency, jobsInProgress), this.opts.runRetryDelay));\n                }\n            }\n            this.running = false;\n            return asyncFifoQueue.waitAll();\n        } catch (error) {\n            this.running = false;\n            throw error;\n        }\n    }\n    /**\n     * Returns a promise that resolves to the next job in queue.\n     * @param token - worker token to be assigned to retrieved job\n     * @returns a Job or undefined if no job was available in the queue.\n     */ async getNextJob(token, { block = true } = {}) {\n        return this._getNextJob(await this.client, await this.blockingConnection.client, token, {\n            block\n        });\n    }\n    async _getNextJob(client, bclient, token, { block = true } = {}) {\n        var _a;\n        if (this.paused) {\n            if (block) {\n                await this.paused;\n            } else {\n                return;\n            }\n        }\n        if (this.closing) {\n            return;\n        }\n        if (this.drained && block && !this.limitUntil && !this.waiting) {\n            this.waiting = this.waitForJob(bclient, this.blockUntil);\n            try {\n                this.blockUntil = await this.waiting;\n                if (this.blockUntil <= 0 || this.blockUntil - Date.now() < 10) {\n                    return this.moveToActive(client, token, this.opts.name);\n                }\n            } catch (err) {\n                // Swallow error if locally paused or closing since we did force a disconnection\n                if (!(this.paused || this.closing) && (0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(err)) {\n                    throw err;\n                }\n            } finally{\n                this.waiting = null;\n            }\n        } else {\n            if (this.limitUntil) {\n                (_a = this.abortDelayController) === null || _a === void 0 ? void 0 : _a.abort();\n                this.abortDelayController = new node_abort_controller__WEBPACK_IMPORTED_MODULE_3__.AbortController();\n                await this.delay(this.limitUntil, this.abortDelayController);\n            }\n            return this.moveToActive(client, token, this.opts.name);\n        }\n    }\n    /**\n     * Overrides the rate limit to be active for the next jobs.\n     *\n     * @param expireTimeMs - expire time in ms of this rate limit.\n     */ async rateLimit(expireTimeMs) {\n        await this.client.then((client)=>client.set(this.keys.limiter, Number.MAX_SAFE_INTEGER, \"PX\", expireTimeMs));\n    }\n    async moveToActive(client, token, name) {\n        const [jobData, id, limitUntil, delayUntil] = await this.scripts.moveToActive(client, token, name);\n        this.updateDelays(limitUntil, delayUntil);\n        return this.nextJobFromJobData(jobData, id, token);\n    }\n    async waitForJob(bclient, blockUntil) {\n        if (this.paused) {\n            return Infinity;\n        }\n        try {\n            if (!this.closing) {\n                let blockTimeout = this.getBlockTimeout(blockUntil);\n                blockTimeout = this.blockingConnection.capabilities.canDoubleTimeout ? blockTimeout : Math.ceil(blockTimeout);\n                // We restrict the maximum block timeout to 10 second to avoid\n                // blocking the connection for too long in the case of reconnections\n                // reference: https://github.com/taskforcesh/bullmq/issues/1658\n                blockTimeout = Math.min(blockTimeout, maximumBlockTimeout);\n                // Markers should only be used for un-blocking, so we will handle them in this\n                // function only.\n                const result = await bclient.bzpopmin(this.keys.marker, blockTimeout);\n                if (result) {\n                    const [_key, member, score] = result;\n                    if (member) {\n                        return parseInt(score);\n                    }\n                }\n                return 0;\n            }\n        } catch (error) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(error)) {\n                this.emit(\"error\", error);\n            }\n            if (!this.closing) {\n                await this.delay();\n            }\n        } finally{\n            this.waiting = null;\n        }\n        return Infinity;\n    }\n    getBlockTimeout(blockUntil) {\n        const opts = this.opts;\n        // when there are delayed jobs\n        if (blockUntil) {\n            const blockDelay = blockUntil - Date.now();\n            // when we reach the time to get new jobs\n            if (blockDelay < 1) {\n                return 0.001;\n            } else {\n                return blockDelay / 1000;\n            }\n        } else {\n            return Math.max(opts.drainDelay, 0);\n        }\n    }\n    /**\n     *\n     * This function is exposed only for testing purposes.\n     */ async delay(milliseconds, abortController) {\n        await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.delay)(milliseconds || _utils__WEBPACK_IMPORTED_MODULE_4__.DELAY_TIME_1, abortController);\n    }\n    updateDelays(limitUntil = 0, delayUntil = 0) {\n        this.limitUntil = Math.max(limitUntil, 0) || 0;\n        this.blockUntil = Math.max(delayUntil, 0) || 0;\n    }\n    async nextJobFromJobData(jobData, jobId, token) {\n        if (!jobData) {\n            if (!this.drained) {\n                this.emit(\"drained\");\n                this.drained = true;\n            }\n        } else {\n            this.drained = false;\n            const job = this.createJob(jobData, jobId);\n            job.token = token;\n            if (job.opts.repeat) {\n                const repeat = await this.repeat;\n                await repeat.addNextRepeatableJob(job.name, job.data, job.opts);\n            }\n            return job;\n        }\n    }\n    async processJob(job, token, fetchNextCallback = ()=>true, jobsInProgress) {\n        if (!job || this.closing || this.paused) {\n            return;\n        }\n        const handleCompleted = async (result)=>{\n            if (!this.connection.closing) {\n                const completed = await job.moveToCompleted(result, token, fetchNextCallback() && !(this.closing || this.paused));\n                this.emit(\"completed\", job, result, \"active\");\n                const [jobData, jobId, limitUntil, delayUntil] = completed || [];\n                this.updateDelays(limitUntil, delayUntil);\n                return this.nextJobFromJobData(jobData, jobId, token);\n            }\n        };\n        const handleFailed = async (err)=>{\n            if (!this.connection.closing) {\n                try {\n                    if (err.message == _errors__WEBPACK_IMPORTED_MODULE_12__.RATE_LIMIT_ERROR) {\n                        this.limitUntil = await this.moveLimitedBackToWait(job, token);\n                        return;\n                    }\n                    if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_12__.DelayedError || err.message == \"DelayedError\" || err instanceof _errors__WEBPACK_IMPORTED_MODULE_12__.WaitingChildrenError || err.name == \"WaitingChildrenError\") {\n                        return;\n                    }\n                    await job.moveToFailed(err, token);\n                    this.emit(\"failed\", job, err, \"active\");\n                } catch (err) {\n                    this.emit(\"error\", err);\n                // It probably means that the job has lost the lock before completion\n                // A worker will (or already has) moved the job back\n                // to the waiting list (as stalled)\n                }\n            }\n        };\n        this.emit(\"active\", job, \"waiting\");\n        const inProgressItem = {\n            job,\n            ts: Date.now()\n        };\n        try {\n            jobsInProgress.add(inProgressItem);\n            const result = await this.callProcessJob(job, token);\n            return await handleCompleted(result);\n        } catch (err) {\n            return handleFailed(err);\n        } finally{\n            jobsInProgress.delete(inProgressItem);\n        }\n    }\n    /**\n     *\n     * Pauses the processing of this queue only for this worker.\n     */ async pause(doNotWaitActive) {\n        if (!this.paused) {\n            this.paused = new Promise((resolve)=>{\n                this.resumeWorker = function() {\n                    resolve();\n                    this.paused = null; // Allow pause to be checked externally for paused state.\n                    this.resumeWorker = null;\n                };\n            });\n            await (!doNotWaitActive && this.whenCurrentJobsFinished());\n            this.emit(\"paused\");\n        }\n    }\n    /**\n     *\n     * Resumes processing of this worker (if paused).\n     */ resume() {\n        if (this.resumeWorker) {\n            this.resumeWorker();\n            this.emit(\"resumed\");\n        }\n    }\n    /**\n     *\n     * Checks if worker is paused.\n     *\n     * @returns true if worker is paused, false otherwise.\n     */ isPaused() {\n        return !!this.paused;\n    }\n    /**\n     *\n     * Checks if worker is currently running.\n     *\n     * @returns true if worker is running, false otherwise.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     *\n     * Closes the worker and related redis connections.\n     *\n     * This method waits for current jobs to finalize before returning.\n     *\n     * @param force - Use force boolean parameter if you do not want to wait for\n     * current jobs to be processed.\n     *\n     * @returns Promise that resolves when the worker has been closed.\n     */ close(force = false) {\n        if (this.closing) {\n            return this.closing;\n        }\n        this.closing = (async ()=>{\n            var _a;\n            this.emit(\"closing\", \"closing queue\");\n            (_a = this.abortDelayController) === null || _a === void 0 ? void 0 : _a.abort();\n            const client = this.blockingConnection.status == \"ready\" ? await this.blockingConnection.client : null;\n            this.resume();\n            await Promise.resolve().finally(()=>{\n                return force || this.whenCurrentJobsFinished(false);\n            }).finally(()=>{\n                var _a;\n                const closePoolPromise = (_a = this.childPool) === null || _a === void 0 ? void 0 : _a.clean();\n                if (force) {\n                    // since we're not waiting for the job to end attach\n                    // an error handler to avoid crashing the whole process\n                    closePoolPromise === null || closePoolPromise === void 0 ? void 0 : closePoolPromise.catch((err)=>{\n                        console.error(err); // TODO: emit error in next breaking change version\n                    });\n                    return;\n                }\n                return closePoolPromise;\n            }).finally(()=>clearTimeout(this.extendLocksTimer)).finally(()=>clearTimeout(this.stalledCheckTimer)).finally(()=>client && client.disconnect()).finally(()=>this.connection.close()).finally(()=>this.emit(\"closed\"));\n            this.closed = true;\n        })();\n        return this.closing;\n    }\n    /**\n     *\n     * Manually starts the stalled checker.\n     * The check will run once as soon as this method is called, and\n     * then every opts.stalledInterval milliseconds until the worker is closed.\n     * Note: Normally you do not need to call this method, since the stalled checker\n     * is automatically started when the worker starts processing jobs after\n     * calling run. However if you want to process the jobs manually you need\n     * to call this method to start the stalled checker.\n     *\n     * @see {@link https://docs.bullmq.io/patterns/manually-fetching-jobs}\n     */ async startStalledCheckTimer() {\n        if (!this.opts.skipStalledCheck) {\n            clearTimeout(this.stalledCheckTimer);\n            if (!this.closing) {\n                try {\n                    await this.checkConnectionError(()=>this.moveStalledJobsToWait());\n                    this.stalledCheckTimer = setTimeout(async ()=>{\n                        await this.startStalledCheckTimer();\n                    }, this.opts.stalledInterval);\n                } catch (err) {\n                    this.emit(\"error\", err);\n                }\n            }\n        }\n    }\n    startLockExtenderTimer(jobsInProgress) {\n        if (!this.opts.skipLockRenewal) {\n            clearTimeout(this.extendLocksTimer);\n            if (!this.closed) {\n                this.extendLocksTimer = setTimeout(async ()=>{\n                    // Get all the jobs whose locks expire in less than 1/2 of the lockRenewTime\n                    const now = Date.now();\n                    const jobsToExtend = [];\n                    for (const item of jobsInProgress){\n                        const { job, ts } = item;\n                        if (!ts) {\n                            item.ts = now;\n                            continue;\n                        }\n                        if (ts + this.opts.lockRenewTime / 2 < now) {\n                            item.ts = now;\n                            jobsToExtend.push(job);\n                        }\n                    }\n                    try {\n                        if (jobsToExtend.length) {\n                            await this.extendLocks(jobsToExtend);\n                        }\n                    } catch (err) {\n                        this.emit(\"error\", err);\n                    }\n                    this.startLockExtenderTimer(jobsInProgress);\n                }, this.opts.lockRenewTime / 2);\n            }\n        }\n    }\n    /**\n     * Returns a promise that resolves when active jobs are cleared\n     *\n     * @returns\n     */ async whenCurrentJobsFinished(reconnect = true) {\n        //\n        // Force reconnection of blocking connection to abort blocking redis call immediately.\n        //\n        if (this.waiting) {\n            // If we are not going to reconnect, we will not wait for the disconnection.\n            await this.blockingConnection.disconnect(reconnect);\n        } else {\n            reconnect = false;\n        }\n        if (this.asyncFifoQueue) {\n            await this.asyncFifoQueue.waitAll();\n        }\n        reconnect && await this.blockingConnection.reconnect();\n    }\n    async retryIfFailed(fn, delayInMs) {\n        const retry = 1;\n        do {\n            try {\n                return await fn();\n            } catch (err) {\n                this.emit(\"error\", err);\n                if (delayInMs) {\n                    await this.delay(delayInMs);\n                } else {\n                    return;\n                }\n            }\n        }while (retry);\n    }\n    async extendLocks(jobs) {\n        try {\n            const multi = (await this.client).multi();\n            for (const job of jobs){\n                await this.scripts.extendLock(job.id, job.token, this.opts.lockDuration, multi);\n            }\n            const result = await multi.exec();\n            for (const [err, jobId] of result){\n                if (err) {\n                    // TODO: signal process function that the job has been lost.\n                    this.emit(\"error\", new Error(`could not renew lock for job ${jobId}`));\n                }\n            }\n        } catch (err) {\n            this.emit(\"error\", err);\n        }\n    }\n    async moveStalledJobsToWait() {\n        const chunkSize = 50;\n        const [failed, stalled] = await this.scripts.moveStalledJobsToWait();\n        stalled.forEach((jobId)=>this.emit(\"stalled\", jobId, \"active\"));\n        const jobPromises = [];\n        for(let i = 0; i < failed.length; i++){\n            jobPromises.push(_job__WEBPACK_IMPORTED_MODULE_8__.Job.fromId(this, failed[i]));\n            if ((i + 1) % chunkSize === 0) {\n                this.notifyFailedJobs(await Promise.all(jobPromises));\n                jobPromises.length = 0;\n            }\n        }\n        this.notifyFailedJobs(await Promise.all(jobPromises));\n    }\n    notifyFailedJobs(failedJobs) {\n        failedJobs.forEach((job)=>this.emit(\"failed\", job, new Error(\"job stalled more than allowable limit\"), \"active\"));\n    }\n    moveLimitedBackToWait(job, token) {\n        return this.scripts.moveJobFromActiveToWait(job.id, token);\n    }\n} //# sourceMappingURL=worker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlCO0FBQ0M7QUFDRztBQUNIO0FBQzFCLGdFQUFnRTtBQUNSO0FBQytCO0FBQzlDO0FBQ1A7QUFDTztBQUNiO0FBQ3lCO0FBQ3JCO0FBQ29CO0FBQzZDO0FBQ2pHLHlEQUF5RDtBQUN6RCxNQUFNb0Isc0JBQXNCO0FBQzVCOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DLGVBQWVaLGtEQUFTQTtJQUNqQyxPQUFPUSxpQkFBaUI7UUFDcEIsT0FBTyxJQUFJQSxvREFBY0E7SUFDN0I7SUFDQUssWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLElBQUksRUFBRUMsVUFBVSxDQUFFO1FBQzNDLEtBQUssQ0FBQ0gsTUFBTUksT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCxPQUFPO1lBQUVJLG9CQUFvQjtRQUFLLElBQUlIO1FBQ2xGLElBQUksQ0FBQ0ksb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNYLFFBQVEsQ0FBQ0EsS0FBS1ksVUFBVSxFQUFFO1lBQzNCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ2IsSUFBSSxHQUFHRSxPQUFPQyxNQUFNLENBQUM7WUFBRVcsWUFBWTtZQUFHQyxhQUFhO1lBQUdDLGNBQWM7WUFBT0MsaUJBQWlCO1lBQUdDLGlCQUFpQjtZQUFPQyxTQUFTO1lBQU1DLGVBQWU7UUFBTSxHQUFHLElBQUksQ0FBQ3BCLElBQUk7UUFDNUssSUFBSSxJ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UUFDekJBLFdBQVdOLE9BQU8sQ0FBQyxDQUFDM0gsTUFBUSxJQUFJLENBQUNkLElBQUksQ0FBQyxVQUFVYyxLQUFLLElBQUlsRCxNQUFNLDBDQUEwQztJQUM3RztJQUNBa0ksc0JBQXNCaEYsR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDOUIsT0FBTyxJQUFJLENBQUNrRCxPQUFPLENBQUMrRSx1QkFBdUIsQ0FBQ2xJLElBQUl6QyxFQUFFLEVBQUUwQztJQUN4RDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy93b3JrZXIuanM/NjEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG4vLyBOb3RlOiB0aGlzIFBvbHlmaWxsIGlzIG9ubHkgbmVlZGVkIGZvciBOb2RlIHZlcnNpb25zIDwgMTUuNC4wXG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICdub2RlLWFib3J0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgZGVsYXksIERFTEFZX1RJTUVfMSwgaXNOb3RDb25uZWN0aW9uRXJyb3IsIGlzUmVkaXNJbnN0YW5jZSwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBRdWV1ZUJhc2UgfSBmcm9tICcuL3F1ZXVlLWJhc2UnO1xuaW1wb3J0IHsgUmVwZWF0IH0gZnJvbSAnLi9yZXBlYXQnO1xuaW1wb3J0IHsgQ2hpbGRQb29sIH0gZnJvbSAnLi9jaGlsZC1wb29sJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IFJlZGlzQ29ubmVjdGlvbiB9IGZyb20gJy4vcmVkaXMtY29ubmVjdGlvbic7XG5pbXBvcnQgc2FuZGJveCBmcm9tICcuL3NhbmRib3gnO1xuaW1wb3J0IHsgQXN5bmNGaWZvUXVldWUgfSBmcm9tICcuL2FzeW5jLWZpZm8tcXVldWUnO1xuaW1wb3J0IHsgRGVsYXllZEVycm9yLCBSYXRlTGltaXRFcnJvciwgUkFURV9MSU1JVF9FUlJPUiwgV2FpdGluZ0NoaWxkcmVuRXJyb3IsIH0gZnJvbSAnLi9lcnJvcnMnO1xuLy8gMTAgc2Vjb25kcyBpcyB0aGUgbWF4aW11bSB0aW1lIGEgQlJQT1BMUFVTSCBjYW4gYmxvY2suXG5jb25zdCBtYXhpbXVtQmxvY2tUaW1lb3V0ID0gMTA7XG4vKipcbiAqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSB3b3JrZXIgdGhhdCBpcyBhYmxlIHRvIHByb2Nlc3Mgam9icyBmcm9tIHRoZSBxdWV1ZS5cbiAqIEFzIHNvb24gYXMgdGhlIGNsYXNzIGlzIGluc3RhbnRpYXRlZCBhbmQgYSBjb25uZWN0aW9uIHRvIFJlZGlzIGlzIGVzdGFibGlzaGVkXG4gKiBpdCB3aWxsIHN0YXJ0IHByb2Nlc3Npbmcgam9icy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrZXIgZXh0ZW5kcyBRdWV1ZUJhc2Uge1xuICAgIHN0YXRpYyBSYXRlTGltaXRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwcm9jZXNzb3IsIG9wdHMsIENvbm5lY3Rpb24pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBibG9ja2luZ0Nvbm5lY3Rpb246IHRydWUgfSksIENvbm5lY3Rpb24pO1xuICAgICAgICB0aGlzLmFib3J0RGVsYXlDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja1VudGlsID0gMDtcbiAgICAgICAgdGhpcy5kcmFpbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5kTG9ja3NUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMubGltaXRVbnRpbCA9IDA7XG4gICAgICAgIHRoaXMud2FpdGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIW9wdHMgfHwgIW9wdHMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgcmVxdWlyZXMgYSBjb25uZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7IGRyYWluRGVsYXk6IDUsIGNvbmN1cnJlbmN5OiAxLCBsb2NrRHVyYXRpb246IDMwMDAwLCBtYXhTdGFsbGVkQ291bnQ6IDEsIHN0YWxsZWRJbnRlcnZhbDogMzAwMDAsIGF1dG9ydW46IHRydWUsIHJ1blJldHJ5RGVsYXk6IDE1MDAwIH0sIHRoaXMub3B0cyk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuc3RhbGxlZEludGVydmFsIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhbGxlZEludGVydmFsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gdGhpcy5vcHRzLmNvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLm9wdHMubG9ja1JlbmV3VGltZSA9XG4gICAgICAgICAgICB0aGlzLm9wdHMubG9ja1JlbmV3VGltZSB8fCB0aGlzLm9wdHMubG9ja0R1cmF0aW9uIC8gMjtcbiAgICAgICAgdGhpcy5pZCA9IHY0KCk7XG4gICAgICAgIGlmIChwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRm4gPSBwcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTQU5EQk9YRURcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVSTCAke3Byb2Nlc3Nvcn0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxvY2FsIGZpbGUgc3lzdGVtYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc29yLmhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRGaWxlVHlwZXMgPSBbJy5qcycsICcudHMnLCAnLmZsb3cnLCAnLmNqcyddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzb3JGaWxlID0gcHJvY2Vzc29yICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdXBwb3J0ZWRGaWxlVHlwZXMuaW5jbHVkZXMocGF0aC5leHRuYW1lKHByb2Nlc3NvcikpID8gJycgOiAnLmpzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwcm9jZXNzb3JGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWxlICR7cHJvY2Vzc29yRmlsZX0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXBhcmF0ZSBwYXRocyBzbyB0aGF0IGJ1bmRsaW5nIHRvb2xzIGNhbiByZXNvbHZlIGRlcGVuZGVuY2llcyBlYXNpZXJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJuYW1lID0gcGF0aC5kaXJuYW1lKG1vZHVsZS5maWxlbmFtZSB8fCBfX2ZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXJUaHJlYWRzTWFpbkZpbGUgPSBwYXRoLmpvaW4oZGlybmFtZSwgJ21haW4td29ya2VyLmpzJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25Qcm9jZXNzTWFpbkZpbGUgPSBwYXRoLmpvaW4oZGlybmFtZSwgJ21haW4uanMnKTtcbiAgICAgICAgICAgICAgICBsZXQgbWFpbkZpbGVQYXRoID0gdGhpcy5vcHRzLnVzZVdvcmtlclRocmVhZHNcbiAgICAgICAgICAgICAgICAgICAgPyB3b3JrZXJUaHJlYWRzTWFpbkZpbGVcbiAgICAgICAgICAgICAgICAgICAgOiBzcGF3blByb2Nlc3NNYWluRmlsZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmcy5zdGF0U3luYyhtYWluRmlsZVBhdGgpOyAvLyB3b3VsZCB0aHJvdyBpZiBmaWxlIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFpbkZpbGUgPSB0aGlzLm9wdHMudXNlV29ya2VyVGhyZWFkc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbWFpbi13b3JrZXIuanMnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdtYWluLmpzJztcbiAgICAgICAgICAgICAgICAgICAgbWFpbkZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIGBkaXN0L2Nqcy9jbGFzc2VzLyR7bWFpbkZpbGV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGZzLnN0YXRTeW5jKG1haW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRQb29sID0gbmV3IENoaWxkUG9vbCh7XG4gICAgICAgICAgICAgICAgICAgIG1haW5GaWxlOiBtYWluRmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHVzZVdvcmtlclRocmVhZHM6IHRoaXMub3B0cy51c2VXb3JrZXJUaHJlYWRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZuID0gc2FuZGJveChwcm9jZXNzb3IsIHRoaXMuY2hpbGRQb29sKS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW4oKS5jYXRjaChlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uTmFtZSA9IHRoaXMuY2xpZW50TmFtZSgpICsgKHRoaXMub3B0cy5uYW1lID8gYDp3OiR7dGhpcy5vcHRzLm5hbWV9YCA6ICcnKTtcbiAgICAgICAgdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24gPSBuZXcgUmVkaXNDb25uZWN0aW9uKGlzUmVkaXNJbnN0YW5jZShvcHRzLmNvbm5lY3Rpb24pXG4gICAgICAgICAgICA/IG9wdHMuY29ubmVjdGlvbi5kdXBsaWNhdGUoeyBjb25uZWN0aW9uTmFtZSB9KVxuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMuY29ubmVjdGlvbiksIHsgY29ubmVjdGlvbk5hbWUgfSksIGZhbHNlLCB0cnVlLCBvcHRzLnNraXBWZXJzaW9uQ2hlY2spO1xuICAgICAgICB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24ub24oJ3JlYWR5JywgKCkgPT4gc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoJ3JlYWR5JyksIDApKTtcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub25jZShldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FsbFByb2Nlc3NKb2Ioam9iLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRm4oam9iLCB0b2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZUpvYihkYXRhLCBqb2JJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Kb2IuZnJvbUpTT04odGhpcywgZGF0YSwgam9iSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSB3b3JrZXIgaXMgcmVhZHkgdG8gc3RhcnQgcHJvY2Vzc2luZyBqb2JzLlxuICAgICAqIEluIGdlbmVyYWwgb25seSB1c2VmdWwgd2hlbiB3cml0aW5nIHRlc3RzLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLndhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jbGllbnQ7XG4gICAgfVxuICAgIHNldCBjb25jdXJyZW5jeShjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgY29uY3VycmVuY3kgPCAxIHx8XG4gICAgICAgICAgICAhaXNGaW5pdGUoY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbmN1cnJlbmN5IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3k7XG4gICAgfVxuICAgIGdldCByZXBlYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0ID0gbmV3IFJlcGVhdCh0aGlzLm5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKSwgeyBjb25uZWN0aW9uIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQub24oJ2Vycm9yJywgZSA9PiB0aGlzLmVtaXQuYmluZCh0aGlzLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBydW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzRm4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvY2VzcyBmdW5jdGlvbiBpcyBkZWZpbmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0U3RhbGxlZENoZWNrVGltZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGpvYnNJblByb2dyZXNzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydExvY2tFeHRlbmRlclRpbWVyKGpvYnNJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzeW5jRmlmb1F1ZXVlID0gKHRoaXMuYXN5bmNGaWZvUXVldWUgPVxuICAgICAgICAgICAgICAgIG5ldyBBc3luY0ZpZm9RdWV1ZSgpKTtcbiAgICAgICAgICAgIGxldCB0b2tlblBvc3RmaXggPSAwO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgICAgICBjb25zdCBiY2xpZW50ID0gYXdhaXQgdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24uY2xpZW50O1xuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtVG90YWwgPSBhc3luY0ZpZm9RdWV1ZS5udW1Ub3RhbCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghdGhpcy53YWl0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG51bVRvdGFsIDwgdGhpcy5vcHRzLmNvbmN1cnJlbmN5ICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5saW1pdFVudGlsIHx8IG51bVRvdGFsID09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYCR7dGhpcy5pZH06JHt0b2tlblBvc3RmaXgrK31gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkSm9iID0gdGhpcy5yZXRyeUlmRmFpbGVkKCgpID0+IHRoaXMuX2dldE5leHRKb2IoY2xpZW50LCBiY2xpZW50LCB0b2tlbiwgeyBibG9jazogdHJ1ZSB9KSwgdGhpcy5vcHRzLnJ1blJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICBhc3luY0ZpZm9RdWV1ZS5hZGQoZmV0Y2hlZEpvYik7XG4gICAgICAgICAgICAgICAgICAgIG51bVRvdGFsID0gYXN5bmNGaWZvUXVldWUubnVtVG90YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdGluZyAmJiBudW1Ub3RhbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSB3YWl0aW5nIGZvciBqb2JzIGJ1dCB3ZSBoYXZlIG90aGVycyB0aGF0IHdlIGNvdWxkIHN0YXJ0IHByb2Nlc3NpbmcgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXdhaXQgaGVyZSBzbyB0aGF0IHdlIGZldGNoIGpvYnMgaW4gc2VxdWVuY2UsIHRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIFJlZGlzIGluIGhpZ2ggY29uY3VycmVuY3kgc2NlbmFyaW9zLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSBhd2FpdCBmZXRjaGVkSm9iO1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtb3JlIGpvYnMgd2FpdGluZyBidXQgd2UgaGF2ZSBvdGhlcnMgdGhhdCBjb3VsZCBzdGFydCBwcm9jZXNzaW5nIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2IgJiYgbnVtVG90YWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgcG90ZW50aWFsIGpvYnMgdG8gYmUgcHJvY2Vzc2VkIGFuZCBibG9ja1VudGlsIGlzIHNldCwgd2Ugc2hvdWxkIGV4aXQgdG8gYXZvaWQgd2FpdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcHJvY2Vzc2luZyB0aGlzIGpvYi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlcmUgY2FuIGJlIHVuZGVmaW5lZCBqb2JzIGluIHRoZSBxdWV1ZSAod2hlbiBhIGpvYiBmYWlscyBvciBxdWV1ZSBpcyBlbXB0eSlcbiAgICAgICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIHVudGlsIHdlIGZpbmQgYSBqb2IuXG4gICAgICAgICAgICAgICAgbGV0IGpvYjtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGpvYiA9IGF3YWl0IGFzeW5jRmlmb1F1ZXVlLmZldGNoKCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIWpvYiAmJiBhc3luY0ZpZm9RdWV1ZS5udW1RdWV1ZWQoKSA+IDApO1xuICAgICAgICAgICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBqb2IudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jRmlmb1F1ZXVlLmFkZCh0aGlzLnJldHJ5SWZGYWlsZWQoKCkgPT4gdGhpcy5wcm9jZXNzSm9iKGpvYiwgdG9rZW4sICgpID0+IGFzeW5jRmlmb1F1ZXVlLm51bVRvdGFsKCkgPD0gdGhpcy5vcHRzLmNvbmN1cnJlbmN5LCBqb2JzSW5Qcm9ncmVzcyksIHRoaXMub3B0cy5ydW5SZXRyeURlbGF5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNGaWZvUXVldWUud2FpdEFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXh0IGpvYiBpbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB3b3JrZXIgdG9rZW4gdG8gYmUgYXNzaWduZWQgdG8gcmV0cmlldmVkIGpvYlxuICAgICAqIEByZXR1cm5zIGEgSm9iIG9yIHVuZGVmaW5lZCBpZiBubyBqb2Igd2FzIGF2YWlsYWJsZSBpbiB0aGUgcXVldWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TmV4dEpvYih0b2tlbiwgeyBibG9jayA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXROZXh0Sm9iKGF3YWl0IHRoaXMuY2xpZW50LCBhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jbGllbnQsIHRva2VuLCB7IGJsb2NrIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TmV4dEpvYihjbGllbnQsIGJjbGllbnQsIHRva2VuLCB7IGJsb2NrID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGF1c2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFpbmVkICYmIGJsb2NrICYmICF0aGlzLmxpbWl0VW50aWwgJiYgIXRoaXMud2FpdGluZykge1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nID0gdGhpcy53YWl0Rm9ySm9iKGJjbGllbnQsIHRoaXMuYmxvY2tVbnRpbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tVbnRpbCA9IGF3YWl0IHRoaXMud2FpdGluZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja1VudGlsIDw9IDAgfHwgdGhpcy5ibG9ja1VudGlsIC0gRGF0ZS5ub3coKSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVUb0FjdGl2ZShjbGllbnQsIHRva2VuLCB0aGlzLm9wdHMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgZXJyb3IgaWYgbG9jYWxseSBwYXVzZWQgb3IgY2xvc2luZyBzaW5jZSB3ZSBkaWQgZm9yY2UgYSBkaXNjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5wYXVzZWQgfHwgdGhpcy5jbG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc05vdENvbm5lY3Rpb25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxheSh0aGlzLmxpbWl0VW50aWwsIHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIHRoaXMub3B0cy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIHJhdGUgbGltaXQgdG8gYmUgYWN0aXZlIGZvciB0aGUgbmV4dCBqb2JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4cGlyZVRpbWVNcyAtIGV4cGlyZSB0aW1lIGluIG1zIG9mIHRoaXMgcmF0ZSBsaW1pdC5cbiAgICAgKi9cbiAgICBhc3luYyByYXRlTGltaXQoZXhwaXJlVGltZU1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnRoZW4oY2xpZW50ID0+IGNsaWVudC5zZXQodGhpcy5rZXlzLmxpbWl0ZXIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAnUFgnLCBleHBpcmVUaW1lTXMpKTtcbiAgICB9XG4gICAgYXN5bmMgbW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIG5hbWUpIHtcbiAgICAgICAgY29uc3QgW2pvYkRhdGEsIGlkLCBsaW1pdFVudGlsLCBkZWxheVVudGlsXSA9IGF3YWl0IHRoaXMuc2NyaXB0cy5tb3ZlVG9BY3RpdmUoY2xpZW50LCB0b2tlbiwgbmFtZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGVsYXlzKGxpbWl0VW50aWwsIGRlbGF5VW50aWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Sm9iRnJvbUpvYkRhdGEoam9iRGF0YSwgaWQsIHRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckpvYihiY2xpZW50LCBibG9ja1VudGlsKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgICAgIGxldCBibG9ja1RpbWVvdXQgPSB0aGlzLmdldEJsb2NrVGltZW91dChibG9ja1VudGlsKTtcbiAgICAgICAgICAgICAgICBibG9ja1RpbWVvdXQgPSB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jYXBhYmlsaXRpZXMuY2FuRG91YmxlVGltZW91dFxuICAgICAgICAgICAgICAgICAgICA/IGJsb2NrVGltZW91dFxuICAgICAgICAgICAgICAgICAgICA6IE1hdGguY2VpbChibG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlc3RyaWN0IHRoZSBtYXhpbXVtIGJsb2NrIHRpbWVvdXQgdG8gMTAgc2Vjb25kIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gYmxvY2tpbmcgdGhlIGNvbm5lY3Rpb24gZm9yIHRvbyBsb25nIGluIHRoZSBjYXNlIG9mIHJlY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS90YXNrZm9yY2VzaC9idWxsbXEvaXNzdWVzLzE2NThcbiAgICAgICAgICAgICAgICBibG9ja1RpbWVvdXQgPSBNYXRoLm1pbihibG9ja1RpbWVvdXQsIG1heGltdW1CbG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmtlcnMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdW4tYmxvY2tpbmcsIHNvIHdlIHdpbGwgaGFuZGxlIHRoZW0gaW4gdGhpc1xuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmNsaWVudC5ienBvcG1pbih0aGlzLmtleXMubWFya2VyLCBibG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW19rZXksIG1lbWJlciwgc2NvcmVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2NvcmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzTm90Q29ubmVjdGlvbkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBnZXRCbG9ja1RpbWVvdXQoYmxvY2tVbnRpbCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICAvLyB3aGVuIHRoZXJlIGFyZSBkZWxheWVkIGpvYnNcbiAgICAgICAgaWYgKGJsb2NrVW50aWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrRGVsYXkgPSBibG9ja1VudGlsIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVhY2ggdGhlIHRpbWUgdG8gZ2V0IG5ldyBqb2JzXG4gICAgICAgICAgICBpZiAoYmxvY2tEZWxheSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tEZWxheSAvIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgob3B0cy5kcmFpbkRlbGF5LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwb3NlZCBvbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGF5KG1pbGxpc2Vjb25kcywgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5KG1pbGxpc2Vjb25kcyB8fCBERUxBWV9USU1FXzEsIGFib3J0Q29udHJvbGxlcik7XG4gICAgfVxuICAgIHVwZGF0ZURlbGF5cyhsaW1pdFVudGlsID0gMCwgZGVsYXlVbnRpbCA9IDApIHtcbiAgICAgICAgdGhpcy5saW1pdFVudGlsID0gTWF0aC5tYXgobGltaXRVbnRpbCwgMCkgfHwgMDtcbiAgICAgICAgdGhpcy5ibG9ja1VudGlsID0gTWF0aC5tYXgoZGVsYXlVbnRpbCwgMCkgfHwgMDtcbiAgICB9XG4gICAgYXN5bmMgbmV4dEpvYkZyb21Kb2JEYXRhKGpvYkRhdGEsIGpvYklkLCB0b2tlbikge1xuICAgICAgICBpZiAoIWpvYkRhdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmFpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbmVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgam9iID0gdGhpcy5jcmVhdGVKb2Ioam9iRGF0YSwgam9iSWQpO1xuICAgICAgICAgICAgam9iLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBpZiAoam9iLm9wdHMucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwZWF0ID0gYXdhaXQgdGhpcy5yZXBlYXQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVwZWF0LmFkZE5leHRSZXBlYXRhYmxlSm9iKGpvYi5uYW1lLCBqb2IuZGF0YSwgam9iLm9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpvYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzSm9iKGpvYiwgdG9rZW4sIGZldGNoTmV4dENhbGxiYWNrID0gKCkgPT4gdHJ1ZSwgam9ic0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKCFqb2IgfHwgdGhpcy5jbG9zaW5nIHx8IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlQ29tcGxldGVkID0gYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2xvc2luZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IGF3YWl0IGpvYi5tb3ZlVG9Db21wbGV0ZWQocmVzdWx0LCB0b2tlbiwgZmV0Y2hOZXh0Q2FsbGJhY2soKSAmJiAhKHRoaXMuY2xvc2luZyB8fCB0aGlzLnBhdXNlZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGVkJywgam9iLCByZXN1bHQsICdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbam9iRGF0YSwgam9iSWQsIGxpbWl0VW50aWwsIGRlbGF5VW50aWxdID0gY29tcGxldGVkIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGVsYXlzKGxpbWl0VW50aWwsIGRlbGF5VW50aWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRKb2JGcm9tSm9iRGF0YShqb2JEYXRhLCBqb2JJZCwgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVGYWlsZWQgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09IFJBVEVfTElNSVRfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRVbnRpbCA9IGF3YWl0IHRoaXMubW92ZUxpbWl0ZWRCYWNrVG9XYWl0KGpvYiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBEZWxheWVkRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID09ICdEZWxheWVkRXJyb3InIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBXYWl0aW5nQ2hpbGRyZW5FcnJvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPT0gJ1dhaXRpbmdDaGlsZHJlbkVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGpvYi5tb3ZlVG9GYWlsZWQoZXJyLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgam9iLCBlcnIsICdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgam9iIGhhcyBsb3N0IHRoZSBsb2NrIGJlZm9yZSBjb21wbGV0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgd29ya2VyIHdpbGwgKG9yIGFscmVhZHkgaGFzKSBtb3ZlZCB0aGUgam9iIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHdhaXRpbmcgbGlzdCAoYXMgc3RhbGxlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZlJywgam9iLCAnd2FpdGluZycpO1xuICAgICAgICBjb25zdCBpblByb2dyZXNzSXRlbSA9IHsgam9iLCB0czogRGF0ZS5ub3coKSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgam9ic0luUHJvZ3Jlc3MuYWRkKGluUHJvZ3Jlc3NJdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFByb2Nlc3NKb2Ioam9iLCB0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlQ29tcGxldGVkKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUZhaWxlZChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgam9ic0luUHJvZ3Jlc3MuZGVsZXRlKGluUHJvZ3Jlc3NJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0aGlzIHF1ZXVlIG9ubHkgZm9yIHRoaXMgd29ya2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHBhdXNlKGRvTm90V2FpdEFjdGl2ZSkge1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlZCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VkID0gbnVsbDsgLy8gQWxsb3cgcGF1c2UgdG8gYmUgY2hlY2tlZCBleHRlcm5hbGx5IGZvciBwYXVzZWQgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lV29ya2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCAoIWRvTm90V2FpdEFjdGl2ZSAmJiB0aGlzLndoZW5DdXJyZW50Sm9ic0ZpbmlzaGVkKCkpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlc3VtZXMgcHJvY2Vzc2luZyBvZiB0aGlzIHdvcmtlciAoaWYgcGF1c2VkKS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VtZVdvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVXb3JrZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVzdW1lZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHdvcmtlciBpcyBwYXVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHdvcmtlciBpcyBwYXVzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHdvcmtlciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgd29ya2VyIGlzIHJ1bm5pbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2xvc2VzIHRoZSB3b3JrZXIgYW5kIHJlbGF0ZWQgcmVkaXMgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3YWl0cyBmb3IgY3VycmVudCBqb2JzIHRvIGZpbmFsaXplIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2UgLSBVc2UgZm9yY2UgYm9vbGVhbiBwYXJhbWV0ZXIgaWYgeW91IGRvIG5vdCB3YW50IHRvIHdhaXQgZm9yXG4gICAgICogY3VycmVudCBqb2JzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB3b3JrZXIgaGFzIGJlZW4gY2xvc2VkLlxuICAgICAqL1xuICAgIGNsb3NlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2luZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NpbmcgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zaW5nJywgJ2Nsb3NpbmcgcXVldWUnKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24uc3RhdHVzID09ICdyZWFkeSdcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuYmxvY2tpbmdDb25uZWN0aW9uLmNsaWVudFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9yY2UgfHwgdGhpcy53aGVuQ3VycmVudEpvYnNGaW5pc2hlZChmYWxzZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VQb29sUHJvbWlzZSA9IChfYSA9IHRoaXMuY2hpbGRQb29sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbm90IHdhaXRpbmcgZm9yIHRoZSBqb2IgdG8gZW5kIGF0dGFjaFxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIGNyYXNoaW5nIHRoZSB3aG9sZSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlUG9vbFByb21pc2UgPT09IG51bGwgfHwgY2xvc2VQb29sUHJvbWlzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VQb29sUHJvbWlzZS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpOyAvLyBUT0RPOiBlbWl0IGVycm9yIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlUG9vbFByb21pc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aGlzLmV4dGVuZExvY2tzVGltZXIpKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aGlzLnN0YWxsZWRDaGVja1RpbWVyKSlcbiAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiBjbGllbnQgJiYgY2xpZW50LmRpc2Nvbm5lY3QoKSlcbiAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKSlcbiAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBNYW51YWxseSBzdGFydHMgdGhlIHN0YWxsZWQgY2hlY2tlci5cbiAgICAgKiBUaGUgY2hlY2sgd2lsbCBydW4gb25jZSBhcyBzb29uIGFzIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYW5kXG4gICAgICogdGhlbiBldmVyeSBvcHRzLnN0YWxsZWRJbnRlcnZhbCBtaWxsaXNlY29uZHMgdW50aWwgdGhlIHdvcmtlciBpcyBjbG9zZWQuXG4gICAgICogTm90ZTogTm9ybWFsbHkgeW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QsIHNpbmNlIHRoZSBzdGFsbGVkIGNoZWNrZXJcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQgd2hlbiB0aGUgd29ya2VyIHN0YXJ0cyBwcm9jZXNzaW5nIGpvYnMgYWZ0ZXJcbiAgICAgKiBjYWxsaW5nIHJ1bi4gSG93ZXZlciBpZiB5b3Ugd2FudCB0byBwcm9jZXNzIHRoZSBqb2JzIG1hbnVhbGx5IHlvdSBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIG1ldGhvZCB0byBzdGFydCB0aGUgc3RhbGxlZCBjaGVja2VyLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmJ1bGxtcS5pby9wYXR0ZXJucy9tYW51YWxseS1mZXRjaGluZy1qb2JzfVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0U3RhbGxlZENoZWNrVGltZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLnNraXBTdGFsbGVkQ2hlY2spIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YWxsZWRDaGVja1RpbWVyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0Nvbm5lY3Rpb25FcnJvcigoKSA9PiB0aGlzLm1vdmVTdGFsbGVkSm9ic1RvV2FpdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkQ2hlY2tUaW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFN0YWxsZWRDaGVja1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0cy5zdGFsbGVkSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydExvY2tFeHRlbmRlclRpbWVyKGpvYnNJblByb2dyZXNzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLnNraXBMb2NrUmVuZXdhbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXh0ZW5kTG9ja3NUaW1lcik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRMb2Nrc1RpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdGhlIGpvYnMgd2hvc2UgbG9ja3MgZXhwaXJlIGluIGxlc3MgdGhhbiAxLzIgb2YgdGhlIGxvY2tSZW5ld1RpbWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgam9ic1RvRXh0ZW5kID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBqb2JzSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBqb2IsIHRzIH0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udHMgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHMgKyB0aGlzLm9wdHMubG9ja1JlbmV3VGltZSAvIDIgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRzID0gbm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYnNUb0V4dGVuZC5wdXNoKGpvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2JzVG9FeHRlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leHRlbmRMb2Nrcyhqb2JzVG9FeHRlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRMb2NrRXh0ZW5kZXJUaW1lcihqb2JzSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRzLmxvY2tSZW5ld1RpbWUgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWN0aXZlIGpvYnMgYXJlIGNsZWFyZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgd2hlbkN1cnJlbnRKb2JzRmluaXNoZWQocmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBGb3JjZSByZWNvbm5lY3Rpb24gb2YgYmxvY2tpbmcgY29ubmVjdGlvbiB0byBhYm9ydCBibG9ja2luZyByZWRpcyBjYWxsIGltbWVkaWF0ZWx5LlxuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy53YWl0aW5nKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGdvaW5nIHRvIHJlY29ubmVjdCwgd2Ugd2lsbCBub3Qgd2FpdCBmb3IgdGhlIGRpc2Nvbm5lY3Rpb24uXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5kaXNjb25uZWN0KHJlY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hc3luY0ZpZm9RdWV1ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3luY0ZpZm9RdWV1ZS53YWl0QWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb25uZWN0ICYmIChhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5yZWNvbm5lY3QoKSk7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5SWZGYWlsZWQoZm4sIGRlbGF5SW5Ncykge1xuICAgICAgICBjb25zdCByZXRyeSA9IDE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5SW5Ncykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChyZXRyeSk7XG4gICAgfVxuICAgIGFzeW5jIGV4dGVuZExvY2tzKGpvYnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpID0gKGF3YWl0IHRoaXMuY2xpZW50KS5tdWx0aSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBqb2Igb2Ygam9icykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NyaXB0cy5leHRlbmRMb2NrKGpvYi5pZCwgam9iLnRva2VuLCB0aGlzLm9wdHMubG9ja0R1cmF0aW9uLCBtdWx0aSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgbXVsdGkuZXhlYygpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2Vyciwgam9iSWRdIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc2lnbmFsIHByb2Nlc3MgZnVuY3Rpb24gdGhhdCB0aGUgam9iIGhhcyBiZWVuIGxvc3QuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYGNvdWxkIG5vdCByZW5ldyBsb2NrIGZvciBqb2IgJHtqb2JJZH1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1vdmVTdGFsbGVkSm9ic1RvV2FpdCgpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gNTA7XG4gICAgICAgIGNvbnN0IFtmYWlsZWQsIHN0YWxsZWRdID0gYXdhaXQgdGhpcy5zY3JpcHRzLm1vdmVTdGFsbGVkSm9ic1RvV2FpdCgpO1xuICAgICAgICBzdGFsbGVkLmZvckVhY2goKGpvYklkKSA9PiB0aGlzLmVtaXQoJ3N0YWxsZWQnLCBqb2JJZCwgJ2FjdGl2ZScpKTtcbiAgICAgICAgY29uc3Qgam9iUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWlsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGpvYlByb21pc2VzLnB1c2goSm9iLmZyb21JZCh0aGlzLCBmYWlsZWRbaV0pKTtcbiAgICAgICAgICAgIGlmICgoaSArIDEpICUgY2h1bmtTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlGYWlsZWRKb2JzKGF3YWl0IFByb21pc2UuYWxsKGpvYlByb21pc2VzKSk7XG4gICAgICAgICAgICAgICAgam9iUHJvbWlzZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeUZhaWxlZEpvYnMoYXdhaXQgUHJvbWlzZS5hbGwoam9iUHJvbWlzZXMpKTtcbiAgICB9XG4gICAgbm90aWZ5RmFpbGVkSm9icyhmYWlsZWRKb2JzKSB7XG4gICAgICAgIGZhaWxlZEpvYnMuZm9yRWFjaCgoam9iKSA9PiB0aGlzLmVtaXQoJ2ZhaWxlZCcsIGpvYiwgbmV3IEVycm9yKCdqb2Igc3RhbGxlZCBtb3JlIHRoYW4gYWxsb3dhYmxlIGxpbWl0JyksICdhY3RpdmUnKSk7XG4gICAgfVxuICAgIG1vdmVMaW1pdGVkQmFja1RvV2FpdChqb2IsIHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMubW92ZUpvYkZyb21BY3RpdmVUb1dhaXQoam9iLmlkLCB0b2tlbik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJmcyIsIlVSTCIsInBhdGgiLCJ2NCIsIkFib3J0Q29udHJvbGxlciIsImRlbGF5IiwiREVMQVlfVElNRV8xIiwiaXNOb3RDb25uZWN0aW9uRXJyb3IiLCJpc1JlZGlzSW5zdGFuY2UiLCJRdWV1ZUJhc2UiLCJSZXBlYXQiLCJDaGlsZFBvb2wiLCJKb2IiLCJSZWRpc0Nvbm5lY3Rpb24iLCJzYW5kYm94IiwiQXN5bmNGaWZvUXVldWUiLCJEZWxheWVkRXJyb3IiLCJSYXRlTGltaXRFcnJvciIsIlJBVEVfTElNSVRfRVJST1IiLCJXYWl0aW5nQ2hpbGRyZW5FcnJvciIsIm1heGltdW1CbG9ja1RpbWVvdXQiLCJXb3JrZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJwcm9jZXNzb3IiLCJvcHRzIiwiQ29ubmVjdGlvbiIsIk9iamVjdCIsImFzc2lnbiIsImJsb2NraW5nQ29ubmVjdGlvbiIsImFib3J0RGVsYXlDb250cm9sbGVyIiwiYmxvY2tVbnRpbCIsImRyYWluZWQiLCJleHRlbmRMb2Nrc1RpbWVyIiwibGltaXRVbnRpbCIsIndhaXRpbmciLCJydW5uaW5nIiwiY29ubmVjdGlvbiIsIkVycm9yIiwiZHJhaW5EZWxheSIsImNvbmN1cnJlbmN5IiwibG9ja0R1cmF0aW9uIiwibWF4U3RhbGxlZENvdW50Iiwic3RhbGxlZEludGVydmFsIiwiYXV0b3J1biIsInJ1blJldHJ5RGVsYXkiLCJsb2NrUmVuZXdUaW1lIiwiaWQiLCJwcm9jZXNzRm4iLCJleGlzdHNTeW5jIiwiaHJlZiIsInN1cHBvcnRlZEZpbGVUeXBlcyIsInByb2Nlc3NvckZpbGUiLCJpbmNsdWRlcyIsImV4dG5hbWUiLCJkaXJuYW1lIiwibW9kdWxlIiwiZmlsZW5hbWUiLCJfX2ZpbGVuYW1lIiwid29ya2VyVGhyZWFkc01haW5GaWxlIiwiam9pbiIsInNwYXduUHJvY2Vzc01haW5GaWxlIiwibWFpbkZpbGVQYXRoIiwidXNlV29ya2VyVGhyZWFkcyIsInN0YXRTeW5jIiwiXyIsIm1haW5GaWxlIiwicHJvY2VzcyIsImN3ZCIsImNoaWxkUG9vbCIsImJpbmQiLCJydW4iLCJjYXRjaCIsImVycm9yIiwiZW1pdCIsImNvbm5lY3Rpb25OYW1lIiwiY2xpZW50TmFtZSIsImR1cGxpY2F0ZSIsInNraXBWZXJzaW9uQ2hlY2siLCJvbiIsInNldFRpbWVvdXQiLCJldmVudCIsImFyZ3MiLCJvZmYiLCJldmVudE5hbWUiLCJsaXN0ZW5lciIsIm9uY2UiLCJjYWxsUHJvY2Vzc0pvYiIsImpvYiIsInRva2VuIiwiY3JlYXRlSm9iIiwiZGF0YSIsImpvYklkIiwiZnJvbUpTT04iLCJ3YWl0VW50aWxSZWFkeSIsImNsaWVudCIsImlzRmluaXRlIiwicmVwZWF0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJfcmVwZWF0IiwiZSIsImNsb3NpbmciLCJzdGFydFN0YWxsZWRDaGVja1RpbWVyIiwiam9ic0luUHJvZ3Jlc3MiLCJTZXQiLCJzdGFydExvY2tFeHRlbmRlclRpbWVyIiwiYXN5bmNGaWZvUXVldWUiLCJ0b2tlblBvc3RmaXgiLCJiY2xpZW50IiwibnVtVG90YWwiLCJmZXRjaGVkSm9iIiwicmV0cnlJZkZhaWxlZCIsIl9nZXROZXh0Sm9iIiwiYmxvY2siLCJhZGQiLCJmZXRjaCIsIm51bVF1ZXVlZCIsInByb2Nlc3NKb2IiLCJ3YWl0QWxsIiwiZ2V0TmV4dEpvYiIsIl9hIiwicGF1c2VkIiwid2FpdEZvckpvYiIsIkRhdGUiLCJub3ciLCJtb3ZlVG9BY3RpdmUiLCJlcnIiLCJhYm9ydCIsInJhdGVMaW1pdCIsImV4cGlyZVRpbWVNcyIsInRoZW4iLCJzZXQiLCJrZXlzIiwibGltaXRlciIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJqb2JEYXRhIiwiZGVsYXlVbnRpbCIsInNjcmlwdHMiLCJ1cGRhdGVEZWxheXMiLCJuZXh0Sm9iRnJvbUpvYkRhdGEiLCJJbmZpbml0eSIsImJsb2NrVGltZW91dCIsImdldEJsb2NrVGltZW91dCIsImNhcGFiaWxpdGllcyIsImNhbkRvdWJsZVRpbWVvdXQiLCJNYXRoIiwiY2VpbCIsIm1pbiIsInJlc3VsdCIsImJ6cG9wbWluIiwibWFya2VyIiwiX2tleSIsIm1lbWJlciIsInNjb3JlIiwicGFyc2VJbnQiLCJibG9ja0RlbGF5IiwibWF4IiwibWlsbGlzZWNvbmRzIiwiYWJvcnRDb250cm9sbGVyIiwiYWRkTmV4dFJlcGVhdGFibGVKb2IiLCJmZXRjaE5leHRDYWxsYmFjayIsImhhbmRsZUNvbXBsZXRlZCIsImNvbXBsZXRlZCIsIm1vdmVUb0NvbXBsZXRlZCIsImhhbmRsZUZhaWxlZCIsIm1lc3NhZ2UiLCJtb3ZlTGltaXRlZEJhY2tUb1dhaXQiLCJtb3ZlVG9GYWlsZWQiLCJpblByb2dyZXNzSXRlbSIsInRzIiwiZGVsZXRlIiwicGF1c2UiLCJkb05vdFdhaXRBY3RpdmUiLCJyZXN1bWVXb3JrZXIiLCJ3aGVuQ3VycmVudEpvYnNGaW5pc2hlZCIsInJlc3VtZSIsImlzUGF1c2VkIiwiaXNSdW5uaW5nIiwiY2xvc2UiLCJmb3JjZSIsInN0YXR1cyIsImZpbmFsbHkiLCJjbG9zZVBvb2xQcm9taXNlIiwiY2xlYW4iLCJjb25zb2xlIiwiY2xlYXJUaW1lb3V0Iiwic3RhbGxlZENoZWNrVGltZXIiLCJkaXNjb25uZWN0IiwiY2xvc2VkIiwic2tpcFN0YWxsZWRDaGVjayIsImNoZWNrQ29ubmVjdGlvbkVycm9yIiwibW92ZVN0YWxsZWRKb2JzVG9XYWl0Iiwic2tpcExvY2tSZW5ld2FsIiwiam9ic1RvRXh0ZW5kIiwiaXRlbSIsInB1c2giLCJsZW5ndGgiLCJleHRlbmRMb2NrcyIsInJlY29ubmVjdCIsImZuIiwiZGVsYXlJbk1zIiwicmV0cnkiLCJqb2JzIiwibXVsdGkiLCJleHRlbmRMb2NrIiwiZXhlYyIsImNodW5rU2l6ZSIsImZhaWxlZCIsInN0YWxsZWQiLCJmb3JFYWNoIiwiam9iUHJvbWlzZXMiLCJpIiwiZnJvbUlkIiwibm90aWZ5RmFpbGVkSm9icyIsImFsbCIsImZhaWxlZEpvYnMiLCJtb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/commands/index.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/commands/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScriptLoader: () => (/* reexport safe */ _script_loader__WEBPACK_IMPORTED_MODULE_0__.ScriptLoader),\n/* harmony export */   ScriptLoaderError: () => (/* reexport safe */ _script_loader__WEBPACK_IMPORTED_MODULE_0__.ScriptLoaderError),\n/* harmony export */   scriptLoader: () => (/* binding */ scriptLoader)\n/* harmony export */ });\n/* harmony import */ var _script_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script-loader */ \"(rsc)/./node_modules/bullmq/dist/esm/commands/script-loader.js\");\n\n\nconst scriptLoader = new _script_loader__WEBPACK_IMPORTED_MODULE_0__.ScriptLoader();\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NvbW1hbmRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFDSztBQUNwRCxNQUFNRSxlQUFlLElBQUlGLHdEQUFZQTtBQUNDLENBQ3RDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NvbW1hbmRzL2luZGV4LmpzP2I4NTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NyaXB0TG9hZGVyIH0gZnJvbSAnLi9zY3JpcHQtbG9hZGVyJztcbmV4cG9ydCB7IFNjcmlwdExvYWRlckVycm9yIH0gZnJvbSAnLi9zY3JpcHQtbG9hZGVyJztcbmNvbnN0IHNjcmlwdExvYWRlciA9IG5ldyBTY3JpcHRMb2FkZXIoKTtcbmV4cG9ydCB7IFNjcmlwdExvYWRlciwgc2NyaXB0TG9hZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiU2NyaXB0TG9hZGVyIiwiU2NyaXB0TG9hZGVyRXJyb3IiLCJzY3JpcHRMb2FkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/commands/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/commands/script-loader.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/commands/script-loader.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScriptLoader: () => (/* binding */ ScriptLoader),\n/* harmony export */   ScriptLoaderError: () => (/* binding */ ScriptLoaderError)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/index.js\");\n/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-glob */ \"(rsc)/./node_modules/fast-glob/out/index.js\");\n/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_glob__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\nconst readFile = (0,util__WEBPACK_IMPORTED_MODULE_5__.promisify)(fs__WEBPACK_IMPORTED_MODULE_4__.readFile);\nconst readdir = (0,util__WEBPACK_IMPORTED_MODULE_5__.promisify)(fs__WEBPACK_IMPORTED_MODULE_4__.readdir);\nconst GlobOptions = {\n    dot: true,\n    silent: false\n};\nconst IncludeRegex = /^[-]{2,3}[ \\t]*@include[ \\t]+([\"'])(.+?)\\1[; \\t\\n]*$/m;\nconst EmptyLineRegex = /^\\s*[\\r\\n]/gm;\nclass ScriptLoaderError extends Error {\n    constructor(message, path, stack = [], line, position = 0){\n        super(message);\n        // Ensure the name of this error is the same as the class name\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n        this.includes = stack;\n        this.line = line !== null && line !== void 0 ? line : 0;\n        this.position = position;\n    }\n}\nconst hasMagic = (pattern)=>{\n    if (!Array.isArray(pattern)) {\n        pattern = [\n            pattern\n        ];\n    }\n    for (const p of pattern){\n        if (new minimatch__WEBPACK_IMPORTED_MODULE_1__.Minimatch(p, GlobOptions).hasMagic()) {\n            return true;\n        }\n    }\n    return false;\n};\nconst isPossiblyMappedPath = (path)=>path && [\n        \"~\",\n        \"<\"\n    ].includes(path[0]);\nconst hasFilenamePattern = (path)=>hasMagic(path);\n/**\n * Lua script loader with include support\n */ class ScriptLoader {\n    constructor(){\n        /**\n         * Map an alias to a path\n         */ this.pathMapper = new Map();\n        this.clientScripts = new WeakMap();\n        /**\n         * Cache commands by dir\n         */ this.commandCache = new Map();\n        this.rootPath = getPkgJsonDir();\n        this.pathMapper.set(\"~\", this.rootPath);\n        this.pathMapper.set(\"rootDir\", this.rootPath);\n        this.pathMapper.set(\"base\", __dirname);\n    }\n    /**\n     * Add a script path mapping. Allows includes of the form \"<includes>/utils.lua\" where `includes` is a user\n     * defined path\n     * @param name - the name of the mapping. Note: do not include angle brackets\n     * @param mappedPath - if a relative path is passed, it's relative to the *caller* of this function.\n     * Mapped paths are also accepted, e.g. \"~/server/scripts/lua\" or \"<base>/includes\"\n     */ addPathMapping(name, mappedPath) {\n        let resolved;\n        if (isPossiblyMappedPath(mappedPath)) {\n            resolved = this.resolvePath(mappedPath);\n        } else {\n            const caller = getCallerFile();\n            const callerPath = path__WEBPACK_IMPORTED_MODULE_3__.dirname(caller);\n            resolved = path__WEBPACK_IMPORTED_MODULE_3__.normalize(path__WEBPACK_IMPORTED_MODULE_3__.resolve(callerPath, mappedPath));\n        }\n        const last = resolved.length - 1;\n        if (resolved[last] === path__WEBPACK_IMPORTED_MODULE_3__.sep) {\n            resolved = resolved.substr(0, last);\n        }\n        this.pathMapper.set(name, resolved);\n    }\n    /**\n     * Resolve the script path considering path mappings\n     * @param scriptName - the name of the script\n     * @param stack - the include stack, for nicer errors\n     */ resolvePath(scriptName, stack = []) {\n        const first = scriptName[0];\n        if (first === \"~\") {\n            scriptName = path__WEBPACK_IMPORTED_MODULE_3__.join(this.rootPath, scriptName.substr(2));\n        } else if (first === \"<\") {\n            const p = scriptName.indexOf(\">\");\n            if (p > 0) {\n                const name = scriptName.substring(1, p);\n                const mappedPath = this.pathMapper.get(name);\n                if (!mappedPath) {\n                    throw new ScriptLoaderError(`No path mapping found for \"${name}\"`, scriptName, stack);\n                }\n                scriptName = path__WEBPACK_IMPORTED_MODULE_3__.join(mappedPath, scriptName.substring(p + 1));\n            }\n        }\n        return path__WEBPACK_IMPORTED_MODULE_3__.normalize(scriptName);\n    }\n    /**\n     * Recursively collect all scripts included in a file\n     * @param file - the parent file\n     * @param cache - a cache for file metadata to increase efficiency. Since a file can be included\n     * multiple times, we make sure to load it only once.\n     * @param stack - internal stack to prevent circular references\n     */ async resolveDependencies(file, cache, isInclude = false, stack = []) {\n        cache = cache !== null && cache !== void 0 ? cache : new Map();\n        if (stack.includes(file.path)) {\n            throw new ScriptLoaderError(`circular reference: \"${file.path}\"`, file.path, stack);\n        }\n        stack.push(file.path);\n        function findPos(content, match) {\n            const pos = content.indexOf(match);\n            const arr = content.slice(0, pos).split(\"\\n\");\n            return {\n                line: arr.length,\n                column: arr[arr.length - 1].length + match.indexOf(\"@include\") + 1\n            };\n        }\n        function raiseError(msg, match) {\n            const pos = findPos(file.content, match);\n            throw new ScriptLoaderError(msg, file.path, stack, pos.line, pos.column);\n        }\n        let res;\n        let content = file.content;\n        while((res = IncludeRegex.exec(content)) !== null){\n            const [match, , reference] = res;\n            const includeFilename = isPossiblyMappedPath(reference) ? this.resolvePath(ensureExt(reference), stack) : path__WEBPACK_IMPORTED_MODULE_3__.resolve(path__WEBPACK_IMPORTED_MODULE_3__.dirname(file.path), ensureExt(reference));\n            let includePaths;\n            if (hasFilenamePattern(includeFilename)) {\n                const filesMatched = await getFilenamesByPattern(includeFilename);\n                includePaths = filesMatched.map((x)=>path__WEBPACK_IMPORTED_MODULE_3__.resolve(x));\n            } else {\n                includePaths = [\n                    includeFilename\n                ];\n            }\n            includePaths = includePaths.filter((file)=>path__WEBPACK_IMPORTED_MODULE_3__.extname(file) === \".lua\");\n            if (includePaths.length === 0) {\n                raiseError(`include not found: \"${reference}\"`, match);\n            }\n            const tokens = [];\n            for(let i = 0; i < includePaths.length; i++){\n                const includePath = includePaths[i];\n                const hasInclude = file.includes.find((x)=>x.path === includePath);\n                if (hasInclude) {\n                    /**\n                     * We have something like\n                     * --- \\@include \"a\"\n                     * ...\n                     * --- \\@include \"a\"\n                     */ raiseError(`file \"${reference}\" already included in \"${file.path}\"`, match);\n                }\n                let includeMetadata = cache.get(includePath);\n                let token;\n                if (!includeMetadata) {\n                    const { name, numberOfKeys } = splitFilename(includePath);\n                    let childContent = \"\";\n                    try {\n                        const buf = await readFile(includePath, {\n                            flag: \"r\"\n                        });\n                        childContent = buf.toString();\n                    } catch (err) {\n                        if (err.code === \"ENOENT\") {\n                            raiseError(`include not found: \"${reference}\"`, match);\n                        } else {\n                            throw err;\n                        }\n                    }\n                    // this represents a normalized version of the path to make replacement easy\n                    token = getPathHash(includePath);\n                    includeMetadata = {\n                        name,\n                        numberOfKeys,\n                        path: includePath,\n                        content: childContent,\n                        token,\n                        includes: []\n                    };\n                    cache.set(includePath, includeMetadata);\n                } else {\n                    token = includeMetadata.token;\n                }\n                tokens.push(token);\n                file.includes.push(includeMetadata);\n                await this.resolveDependencies(includeMetadata, cache, true, stack);\n            }\n            // Replace @includes with normalized path hashes\n            const substitution = tokens.join(\"\\n\");\n            content = content.replace(match, substitution);\n        }\n        file.content = content;\n        if (isInclude) {\n            cache.set(file.path, file);\n        } else {\n            cache.set(file.name, file);\n        }\n        stack.pop();\n    }\n    /**\n     * Parse a (top-level) lua script\n     * @param filename - the full path to the script\n     * @param content - the content of the script\n     * @param cache - cache\n     */ async parseScript(filename, content, cache) {\n        const { name, numberOfKeys } = splitFilename(filename);\n        const meta = cache === null || cache === void 0 ? void 0 : cache.get(name);\n        if ((meta === null || meta === void 0 ? void 0 : meta.content) === content) {\n            return meta;\n        }\n        const fileInfo = {\n            path: filename,\n            token: getPathHash(filename),\n            content,\n            name,\n            numberOfKeys,\n            includes: []\n        };\n        await this.resolveDependencies(fileInfo, cache);\n        return fileInfo;\n    }\n    /**\n     * Construct the final version of a file by interpolating its includes in dependency order.\n     * @param file - the file whose content we want to construct\n     * @param processed - a cache to keep track of which includes have already been processed\n     */ interpolate(file, processed) {\n        processed = processed || new Set();\n        let content = file.content;\n        file.includes.forEach((child)=>{\n            const emitted = processed.has(child.path);\n            const fragment = this.interpolate(child, processed);\n            const replacement = emitted ? \"\" : fragment;\n            if (!replacement) {\n                content = replaceAll(content, child.token, \"\");\n            } else {\n                // replace the first instance with the dependency\n                content = content.replace(child.token, replacement);\n                // remove the rest\n                content = replaceAll(content, child.token, \"\");\n            }\n            processed.add(child.path);\n        });\n        return content;\n    }\n    async loadCommand(filename, cache) {\n        filename = path__WEBPACK_IMPORTED_MODULE_3__.resolve(filename);\n        const { name: scriptName } = splitFilename(filename);\n        let script = cache === null || cache === void 0 ? void 0 : cache.get(scriptName);\n        if (!script) {\n            const content = (await readFile(filename)).toString();\n            script = await this.parseScript(filename, content, cache);\n        }\n        const lua = removeEmptyLines(this.interpolate(script));\n        const { name, numberOfKeys } = script;\n        return {\n            name,\n            options: {\n                numberOfKeys: numberOfKeys,\n                lua\n            }\n        };\n    }\n    /**\n     * Load redis lua scripts.\n     * The name of the script must have the following format:\n     *\n     * cmdName-numKeys.lua\n     *\n     * cmdName must be in camel case format.\n     *\n     * For example:\n     * moveToFinish-3.lua\n     *\n     */ async loadScripts(dir, cache) {\n        dir = path__WEBPACK_IMPORTED_MODULE_3__.normalize(dir || __dirname);\n        let commands = this.commandCache.get(dir);\n        if (commands) {\n            return commands;\n        }\n        const files = await readdir(dir);\n        const luaFiles = files.filter((file)=>path__WEBPACK_IMPORTED_MODULE_3__.extname(file) === \".lua\");\n        if (luaFiles.length === 0) {\n            /**\n             * To prevent unclarified runtime error \"updateDelayset is not a function\n             * @see https://github.com/OptimalBits/bull/issues/920\n             */ throw new ScriptLoaderError(\"No .lua files found!\", dir, []);\n        }\n        commands = [];\n        cache = cache !== null && cache !== void 0 ? cache : new Map();\n        for(let i = 0; i < luaFiles.length; i++){\n            const file = path__WEBPACK_IMPORTED_MODULE_3__.join(dir, luaFiles[i]);\n            const command = await this.loadCommand(file, cache);\n            commands.push(command);\n        }\n        this.commandCache.set(dir, commands);\n        return commands;\n    }\n    /**\n     * Attach all lua scripts in a given directory to a client instance\n     * @param client - redis client to attach script to\n     * @param pathname - the path to the directory containing the scripts\n     */ async load(client, pathname, cache) {\n        let paths = this.clientScripts.get(client);\n        if (!paths) {\n            paths = new Set();\n            this.clientScripts.set(client, paths);\n        }\n        if (!paths.has(pathname)) {\n            paths.add(pathname);\n            const scripts = await this.loadScripts(pathname, cache !== null && cache !== void 0 ? cache : new Map());\n            scripts.forEach((command)=>{\n                // Only define the command if not already defined\n                if (!client[command.name]) {\n                    client.defineCommand(command.name, command.options);\n                }\n            });\n        }\n    }\n    /**\n     * Clears the command cache\n     */ clearCache() {\n        this.commandCache.clear();\n    }\n}\nfunction ensureExt(filename, ext = \"lua\") {\n    const foundExt = path__WEBPACK_IMPORTED_MODULE_3__.extname(filename);\n    if (foundExt && foundExt !== \".\") {\n        return filename;\n    }\n    if (ext && ext[0] !== \".\") {\n        ext = `.${ext}`;\n    }\n    return `${filename}${ext}`;\n}\nfunction splitFilename(filePath) {\n    const longName = path__WEBPACK_IMPORTED_MODULE_3__.basename(filePath, \".lua\");\n    const [name, num] = longName.split(\"-\");\n    const numberOfKeys = num ? parseInt(num, 10) : undefined;\n    return {\n        name,\n        numberOfKeys\n    };\n}\nasync function getFilenamesByPattern(pattern) {\n    return fast_glob__WEBPACK_IMPORTED_MODULE_2__.glob(pattern, {\n        dot: true\n    });\n}\n// Determine the project root\n// https://stackoverflow.com/a/18721515\nfunction getPkgJsonDir() {\n    for (const modPath of module.paths || []){\n        try {\n            const prospectivePkgJsonDir = path__WEBPACK_IMPORTED_MODULE_3__.dirname(modPath);\n            fs__WEBPACK_IMPORTED_MODULE_4__.accessSync(modPath, fs__WEBPACK_IMPORTED_MODULE_4__.constants.F_OK);\n            return prospectivePkgJsonDir;\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n    return \"\";\n}\n// https://stackoverflow.com/a/66842927\n// some dark magic here :-)\n// this version is preferred to the simpler version because of\n// https://github.com/facebook/jest/issues/5303 -\n// tldr: dont assume you're the only one with the doing something like this\nfunction getCallerFile() {\n    var _a, _b, _c;\n    const originalFunc = Error.prepareStackTrace;\n    let callerFile = \"\";\n    try {\n        Error.prepareStackTrace = (_, stack)=>stack;\n        const sites = new Error().stack;\n        const currentFile = (_a = sites.shift()) === null || _a === void 0 ? void 0 : _a.getFileName();\n        while(sites.length){\n            callerFile = (_c = (_b = sites.shift()) === null || _b === void 0 ? void 0 : _b.getFileName()) !== null && _c !== void 0 ? _c : \"\";\n            if (currentFile !== callerFile) {\n                break;\n            }\n        }\n    // eslint-disable-next-line no-empty\n    } catch (e) {} finally{\n        Error.prepareStackTrace = originalFunc;\n    }\n    return callerFile;\n}\nfunction sha1(data) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha1\").update(data).digest(\"hex\");\n}\nfunction getPathHash(normalizedPath) {\n    return `@@${sha1(normalizedPath)}`;\n}\nfunction replaceAll(str, find, replace) {\n    return str.replace(new RegExp(find, \"g\"), replace);\n}\nfunction removeEmptyLines(str) {\n    return str.replace(EmptyLineRegex, \"\");\n} //# sourceMappingURL=script-loader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NvbW1hbmRzL3NjcmlwdC1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ0g7QUFDSjtBQUNRO0FBQ2pDLE1BQU1NLFdBQVdELCtDQUFTQSxDQUFDRCx3Q0FBVztBQUN0QyxNQUFNRyxVQUFVRiwrQ0FBU0EsQ0FBQ0QsdUNBQVU7QUFDcEMsTUFBTUksY0FBYztJQUFFQyxLQUFLO0lBQU1DLFFBQVE7QUFBTTtBQUMvQyxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGlCQUFpQjtBQUNoQixNQUFNQywwQkFBMEJDO0lBQ25DQyxZQUFZQyxPQUFPLEVBQUViLElBQUksRUFBRWMsUUFBUSxFQUFFLEVBQUVDLElBQUksRUFBRUMsV0FBVyxDQUFDLENBQUU7UUFDdkQsS0FBSyxDQUFDSDtRQUNOLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNJLElBQUksR0FBRyxJQUFJLENBQUNMLFdBQVcsQ0FBQ0ssSUFBSTtRQUNqQ04sTUFBTU8saUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ04sV0FBVztRQUM5QyxJQUFJLENBQUNPLFFBQVEsR0FBR0w7UUFDaEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUlBLE9BQU87UUFDdEQsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0lBQ3BCO0FBQ0o7QUFDQSxNQUFNSSxXQUFXLENBQUNDO0lBQ2QsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLFVBQVU7UUFDekJBLFVBQVU7WUFBQ0E7U0FBUTtJQUN2QjtJQUNBLEtBQUssTUFBTUcsS0FBS0gsUUFBUztRQUNyQixJQUFJLElBQUl2QixnREFBU0EsQ0FBQzBCLEdBQUduQixhQUFhZSxRQUFRLElBQUk7WUFDMUMsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNSyx1QkFBdUIsQ0FBQ3pCLE9BQVNBLFFBQVE7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QUFJTSxnQkFBZ0JILFlBQVk7Z0JBQzVCO1lBQ0o7UUFDSjtJQUNBLG9DQUFvQztJQUN4QyxFQUNBLE9BQU9OLEdBQUcsQ0FDVixTQUNRO1FBQ0o3SSxNQUFNa0osaUJBQWlCLEdBQUdEO0lBQzlCO0lBQ0EsT0FBT0U7QUFDWDtBQUNBLFNBQVNNLEtBQUtDLElBQUk7SUFDZCxPQUFPeEssa0RBQVVBLENBQUMsUUFBUXlLLE1BQU0sQ0FBQ0QsTUFBTUUsTUFBTSxDQUFDO0FBQ2xEO0FBQ0EsU0FBU3BFLFlBQVlxRSxjQUFjO0lBQy9CLE9BQU8sQ0FBQyxFQUFFLEVBQUVKLEtBQUtJLGdCQUFnQixDQUFDO0FBQ3RDO0FBQ0EsU0FBU3BELFdBQVdxRCxHQUFHLEVBQUVqRixJQUFJLEVBQUVhLE9BQU87SUFDbEMsT0FBT29FLElBQUlwRSxPQUFPLENBQUMsSUFBSXFFLE9BQU9sRixNQUFNLE1BQU1hO0FBQzlDO0FBQ0EsU0FBU29CLGlCQUFpQmdELEdBQUc7SUFDekIsT0FBT0EsSUFBSXBFLE9BQU8sQ0FBQzVGLGdCQUFnQjtBQUN2QyxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NvbW1hbmRzL3NjcmlwdC1sb2FkZXIuanM/ZDA2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IE1pbmltYXRjaCB9IGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgKiBhcyBmZyBmcm9tICdmYXN0LWdsb2InO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuY29uc3QgcmVhZEZpbGUgPSBwcm9taXNpZnkoZnMucmVhZEZpbGUpO1xuY29uc3QgcmVhZGRpciA9IHByb21pc2lmeShmcy5yZWFkZGlyKTtcbmNvbnN0IEdsb2JPcHRpb25zID0geyBkb3Q6IHRydWUsIHNpbGVudDogZmFsc2UgfTtcbmNvbnN0IEluY2x1ZGVSZWdleCA9IC9eWy1dezIsM31bIFxcdF0qQGluY2x1ZGVbIFxcdF0rKFtcIiddKSguKz8pXFwxWzsgXFx0XFxuXSokL207XG5jb25zdCBFbXB0eUxpbmVSZWdleCA9IC9eXFxzKltcXHJcXG5dL2dtO1xuZXhwb3J0IGNsYXNzIFNjcmlwdExvYWRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIHN0YWNrID0gW10sIGxpbmUsIHBvc2l0aW9uID0gMCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBuYW1lIG9mIHRoaXMgZXJyb3IgaXMgdGhlIHNhbWUgYXMgdGhlIGNsYXNzIG5hbWVcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlcyA9IHN0YWNrO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lICE9PSBudWxsICYmIGxpbmUgIT09IHZvaWQgMCA/IGxpbmUgOiAwO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxufVxuY29uc3QgaGFzTWFnaWMgPSAocGF0dGVybikgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0dGVybikge1xuICAgICAgICBpZiAobmV3IE1pbmltYXRjaChwLCBHbG9iT3B0aW9ucykuaGFzTWFnaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGlzUG9zc2libHlNYXBwZWRQYXRoID0gKHBhdGgpID0+IHBhdGggJiYgWyd+JywgJzwnXS5pbmNsdWRlcyhwYXRoWzBdKTtcbmNvbnN0IGhhc0ZpbGVuYW1lUGF0dGVybiA9IChwYXRoKSA9PiBoYXNNYWdpYyhwYXRoKTtcbi8qKlxuICogTHVhIHNjcmlwdCBsb2FkZXIgd2l0aCBpbmNsdWRlIHN1cHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIFNjcmlwdExvYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgYW4gYWxpYXMgdG8gYSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhNYXBwZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2xpZW50U2NyaXB0cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSBjb21tYW5kcyBieSBkaXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tbWFuZENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJvb3RQYXRoID0gZ2V0UGtnSnNvbkRpcigpO1xuICAgICAgICB0aGlzLnBhdGhNYXBwZXIuc2V0KCd+JywgdGhpcy5yb290UGF0aCk7XG4gICAgICAgIHRoaXMucGF0aE1hcHBlci5zZXQoJ3Jvb3REaXInLCB0aGlzLnJvb3RQYXRoKTtcbiAgICAgICAgdGhpcy5wYXRoTWFwcGVyLnNldCgnYmFzZScsIF9fZGlybmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNjcmlwdCBwYXRoIG1hcHBpbmcuIEFsbG93cyBpbmNsdWRlcyBvZiB0aGUgZm9ybSBcIjxpbmNsdWRlcz4vdXRpbHMubHVhXCIgd2hlcmUgYGluY2x1ZGVzYCBpcyBhIHVzZXJcbiAgICAgKiBkZWZpbmVkIHBhdGhcbiAgICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBtYXBwaW5nLiBOb3RlOiBkbyBub3QgaW5jbHVkZSBhbmdsZSBicmFja2V0c1xuICAgICAqIEBwYXJhbSBtYXBwZWRQYXRoIC0gaWYgYSByZWxhdGl2ZSBwYXRoIGlzIHBhc3NlZCwgaXQncyByZWxhdGl2ZSB0byB0aGUgKmNhbGxlciogb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBNYXBwZWQgcGF0aHMgYXJlIGFsc28gYWNjZXB0ZWQsIGUuZy4gXCJ+L3NlcnZlci9zY3JpcHRzL2x1YVwiIG9yIFwiPGJhc2U+L2luY2x1ZGVzXCJcbiAgICAgKi9cbiAgICBhZGRQYXRoTWFwcGluZyhuYW1lLCBtYXBwZWRQYXRoKSB7XG4gICAgICAgIGxldCByZXNvbHZlZDtcbiAgICAgICAgaWYgKGlzUG9zc2libHlNYXBwZWRQYXRoKG1hcHBlZFBhdGgpKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZVBhdGgobWFwcGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsZXIgPSBnZXRDYWxsZXJGaWxlKCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsZXJQYXRoID0gcGF0aC5kaXJuYW1lKGNhbGxlcik7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHBhdGgubm9ybWFsaXplKHBhdGgucmVzb2x2ZShjYWxsZXJQYXRoLCBtYXBwZWRQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdCA9IHJlc29sdmVkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChyZXNvbHZlZFtsYXN0XSA9PT0gcGF0aC5zZXApIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWQuc3Vic3RyKDAsIGxhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aE1hcHBlci5zZXQobmFtZSwgcmVzb2x2ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBzY3JpcHQgcGF0aCBjb25zaWRlcmluZyBwYXRoIG1hcHBpbmdzXG4gICAgICogQHBhcmFtIHNjcmlwdE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0XG4gICAgICogQHBhcmFtIHN0YWNrIC0gdGhlIGluY2x1ZGUgc3RhY2ssIGZvciBuaWNlciBlcnJvcnNcbiAgICAgKi9cbiAgICByZXNvbHZlUGF0aChzY3JpcHROYW1lLCBzdGFjayA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gc2NyaXB0TmFtZVswXTtcbiAgICAgICAgaWYgKGZpcnN0ID09PSAnficpIHtcbiAgICAgICAgICAgIHNjcmlwdE5hbWUgPSBwYXRoLmpvaW4odGhpcy5yb290UGF0aCwgc2NyaXB0TmFtZS5zdWJzdHIoMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBzY3JpcHROYW1lLmluZGV4T2YoJz4nKTtcbiAgICAgICAgICAgIGlmIChwID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzY3JpcHROYW1lLnN1YnN0cmluZygxLCBwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRQYXRoID0gdGhpcy5wYXRoTWFwcGVyLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcHBlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNjcmlwdExvYWRlckVycm9yKGBObyBwYXRoIG1hcHBpbmcgZm91bmQgZm9yIFwiJHtuYW1lfVwiYCwgc2NyaXB0TmFtZSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JpcHROYW1lID0gcGF0aC5qb2luKG1hcHBlZFBhdGgsIHNjcmlwdE5hbWUuc3Vic3RyaW5nKHAgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGgubm9ybWFsaXplKHNjcmlwdE5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjb2xsZWN0IGFsbCBzY3JpcHRzIGluY2x1ZGVkIGluIGEgZmlsZVxuICAgICAqIEBwYXJhbSBmaWxlIC0gdGhlIHBhcmVudCBmaWxlXG4gICAgICogQHBhcmFtIGNhY2hlIC0gYSBjYWNoZSBmb3IgZmlsZSBtZXRhZGF0YSB0byBpbmNyZWFzZSBlZmZpY2llbmN5LiBTaW5jZSBhIGZpbGUgY2FuIGJlIGluY2x1ZGVkXG4gICAgICogbXVsdGlwbGUgdGltZXMsIHdlIG1ha2Ugc3VyZSB0byBsb2FkIGl0IG9ubHkgb25jZS5cbiAgICAgKiBAcGFyYW0gc3RhY2sgLSBpbnRlcm5hbCBzdGFjayB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgKi9cbiAgICBhc3luYyByZXNvbHZlRGVwZW5kZW5jaWVzKGZpbGUsIGNhY2hlLCBpc0luY2x1ZGUgPSBmYWxzZSwgc3RhY2sgPSBbXSkge1xuICAgICAgICBjYWNoZSA9IGNhY2hlICE9PSBudWxsICYmIGNhY2hlICE9PSB2b2lkIDAgPyBjYWNoZSA6IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHN0YWNrLmluY2x1ZGVzKGZpbGUucGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTY3JpcHRMb2FkZXJFcnJvcihgY2lyY3VsYXIgcmVmZXJlbmNlOiBcIiR7ZmlsZS5wYXRofVwiYCwgZmlsZS5wYXRoLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChmaWxlLnBhdGgpO1xuICAgICAgICBmdW5jdGlvbiBmaW5kUG9zKGNvbnRlbnQsIG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBjb250ZW50LmluZGV4T2YobWF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgYXJyID0gY29udGVudC5zbGljZSgwLCBwb3MpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGluZTogYXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGFyclthcnIubGVuZ3RoIC0gMV0ubGVuZ3RoICsgbWF0Y2guaW5kZXhPZignQGluY2x1ZGUnKSArIDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlRXJyb3IobXNnLCBtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZmluZFBvcyhmaWxlLmNvbnRlbnQsIG1hdGNoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBTY3JpcHRMb2FkZXJFcnJvcihtc2csIGZpbGUucGF0aCwgc3RhY2ssIHBvcy5saW5lLCBwb3MuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBsZXQgY29udGVudCA9IGZpbGUuY29udGVudDtcbiAgICAgICAgd2hpbGUgKChyZXMgPSBJbmNsdWRlUmVnZXguZXhlYyhjb250ZW50KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IFttYXRjaCwgLCByZWZlcmVuY2VdID0gcmVzO1xuICAgICAgICAgICAgY29uc3QgaW5jbHVkZUZpbGVuYW1lID0gaXNQb3NzaWJseU1hcHBlZFBhdGgocmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgID8gLy8gbWFwcGVkIHBhdGhzIGltcGx5IGFic29sdXRlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVQYXRoKGVuc3VyZUV4dChyZWZlcmVuY2UpLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IC8vIGluY2x1ZGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgZmlsZSBiZWluZyBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShmaWxlLnBhdGgpLCBlbnN1cmVFeHQocmVmZXJlbmNlKSk7XG4gICAgICAgICAgICBsZXQgaW5jbHVkZVBhdGhzO1xuICAgICAgICAgICAgaWYgKGhhc0ZpbGVuYW1lUGF0dGVybihpbmNsdWRlRmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXNNYXRjaGVkID0gYXdhaXQgZ2V0RmlsZW5hbWVzQnlQYXR0ZXJuKGluY2x1ZGVGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVBhdGhzID0gZmlsZXNNYXRjaGVkLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVQYXRocyA9IFtpbmNsdWRlRmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5jbHVkZVBhdGhzID0gaW5jbHVkZVBhdGhzLmZpbHRlcigoZmlsZSkgPT4gcGF0aC5leHRuYW1lKGZpbGUpID09PSAnLmx1YScpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByYWlzZUVycm9yKGBpbmNsdWRlIG5vdCBmb3VuZDogXCIke3JlZmVyZW5jZX1cImAsIG1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNsdWRlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdWRlUGF0aCA9IGluY2x1ZGVQYXRoc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNJbmNsdWRlID0gZmlsZS5pbmNsdWRlcy5maW5kKCh4KSA9PiB4LnBhdGggPT09IGluY2x1ZGVQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzSW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogV2UgaGF2ZSBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgICAgICAgICAgICAgKiAtLS0gXFxAaW5jbHVkZSBcImFcIlxuICAgICAgICAgICAgICAgICAgICAgKiAuLi5cbiAgICAgICAgICAgICAgICAgICAgICogLS0tIFxcQGluY2x1ZGUgXCJhXCJcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlRXJyb3IoYGZpbGUgXCIke3JlZmVyZW5jZX1cIiBhbHJlYWR5IGluY2x1ZGVkIGluIFwiJHtmaWxlLnBhdGh9XCJgLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpbmNsdWRlTWV0YWRhdGEgPSBjYWNoZS5nZXQoaW5jbHVkZVBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIG51bWJlck9mS2V5cyB9ID0gc3BsaXRGaWxlbmFtZShpbmNsdWRlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHJlYWRGaWxlKGluY2x1ZGVQYXRoLCB7IGZsYWc6ICdyJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGVudCA9IGJ1Zi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZUVycm9yKGBpbmNsdWRlIG5vdCBmb3VuZDogXCIke3JlZmVyZW5jZX1cImAsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJlcHJlc2VudHMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIHBhdGggdG8gbWFrZSByZXBsYWNlbWVudCBlYXN5XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gZ2V0UGF0aEhhc2goaW5jbHVkZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaW5jbHVkZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjaGlsZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGluY2x1ZGVQYXRoLCBpbmNsdWRlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpbmNsdWRlTWV0YWRhdGEudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBmaWxlLmluY2x1ZGVzLnB1c2goaW5jbHVkZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmVEZXBlbmRlbmNpZXMoaW5jbHVkZU1ldGFkYXRhLCBjYWNoZSwgdHJ1ZSwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSBAaW5jbHVkZXMgd2l0aCBub3JtYWxpemVkIHBhdGggaGFzaGVzXG4gICAgICAgICAgICBjb25zdCBzdWJzdGl0dXRpb24gPSB0b2tlbnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG1hdGNoLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZpbGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmIChpc0luY2x1ZGUpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChmaWxlLnBhdGgsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGZpbGUubmFtZSwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgKHRvcC1sZXZlbCkgbHVhIHNjcmlwdFxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSAtIHRoZSBmdWxsIHBhdGggdG8gdGhlIHNjcmlwdFxuICAgICAqIEBwYXJhbSBjb250ZW50IC0gdGhlIGNvbnRlbnQgb2YgdGhlIHNjcmlwdFxuICAgICAqIEBwYXJhbSBjYWNoZSAtIGNhY2hlXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VTY3JpcHQoZmlsZW5hbWUsIGNvbnRlbnQsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgbnVtYmVyT2ZLZXlzIH0gPSBzcGxpdEZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNhY2hlID09PSBudWxsIHx8IGNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZS5nZXQobmFtZSk7XG4gICAgICAgIGlmICgobWV0YSA9PT0gbnVsbCB8fCBtZXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhLmNvbnRlbnQpID09PSBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IHtcbiAgICAgICAgICAgIHBhdGg6IGZpbGVuYW1lLFxuICAgICAgICAgICAgdG9rZW46IGdldFBhdGhIYXNoKGZpbGVuYW1lKSxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbnVtYmVyT2ZLZXlzLFxuICAgICAgICAgICAgaW5jbHVkZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmVEZXBlbmRlbmNpZXMoZmlsZUluZm8sIGNhY2hlKTtcbiAgICAgICAgcmV0dXJuIGZpbGVJbmZvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIGZpbmFsIHZlcnNpb24gb2YgYSBmaWxlIGJ5IGludGVycG9sYXRpbmcgaXRzIGluY2x1ZGVzIGluIGRlcGVuZGVuY3kgb3JkZXIuXG4gICAgICogQHBhcmFtIGZpbGUgLSB0aGUgZmlsZSB3aG9zZSBjb250ZW50IHdlIHdhbnQgdG8gY29uc3RydWN0XG4gICAgICogQHBhcmFtIHByb2Nlc3NlZCAtIGEgY2FjaGUgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBpbmNsdWRlcyBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWRcbiAgICAgKi9cbiAgICBpbnRlcnBvbGF0ZShmaWxlLCBwcm9jZXNzZWQpIHtcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBmaWxlLmNvbnRlbnQ7XG4gICAgICAgIGZpbGUuaW5jbHVkZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZWQgPSBwcm9jZXNzZWQuaGFzKGNoaWxkLnBhdGgpO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmludGVycG9sYXRlKGNoaWxkLCBwcm9jZXNzZWQpO1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBlbWl0dGVkID8gJycgOiBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVwbGFjZUFsbChjb250ZW50LCBjaGlsZC50b2tlbiwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZmlyc3QgaW5zdGFuY2Ugd2l0aCB0aGUgZGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoY2hpbGQudG9rZW4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHJlc3RcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVwbGFjZUFsbChjb250ZW50LCBjaGlsZC50b2tlbiwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc2VkLmFkZChjaGlsZC5wYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBhc3luYyBsb2FkQ29tbWFuZChmaWxlbmFtZSwgY2FjaGUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCB7IG5hbWU6IHNjcmlwdE5hbWUgfSA9IHNwbGl0RmlsZW5hbWUoZmlsZW5hbWUpO1xuICAgICAgICBsZXQgc2NyaXB0ID0gY2FjaGUgPT09IG51bGwgfHwgY2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhY2hlLmdldChzY3JpcHROYW1lKTtcbiAgICAgICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoYXdhaXQgcmVhZEZpbGUoZmlsZW5hbWUpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgc2NyaXB0ID0gYXdhaXQgdGhpcy5wYXJzZVNjcmlwdChmaWxlbmFtZSwgY29udGVudCwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGx1YSA9IHJlbW92ZUVtcHR5TGluZXModGhpcy5pbnRlcnBvbGF0ZShzY3JpcHQpKTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBudW1iZXJPZktleXMgfSA9IHNjcmlwdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB7IG51bWJlck9mS2V5czogbnVtYmVyT2ZLZXlzLCBsdWEgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCByZWRpcyBsdWEgc2NyaXB0cy5cbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2NyaXB0IG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgKlxuICAgICAqIGNtZE5hbWUtbnVtS2V5cy5sdWFcbiAgICAgKlxuICAgICAqIGNtZE5hbWUgbXVzdCBiZSBpbiBjYW1lbCBjYXNlIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqIG1vdmVUb0ZpbmlzaC0zLmx1YVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9hZFNjcmlwdHMoZGlyLCBjYWNoZSkge1xuICAgICAgICBkaXIgPSBwYXRoLm5vcm1hbGl6ZShkaXIgfHwgX19kaXJuYW1lKTtcbiAgICAgICAgbGV0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kQ2FjaGUuZ2V0KGRpcik7XG4gICAgICAgIGlmIChjb21tYW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpcihkaXIpO1xuICAgICAgICBjb25zdCBsdWFGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gcGF0aC5leHRuYW1lKGZpbGUpID09PSAnLmx1YScpO1xuICAgICAgICBpZiAobHVhRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRvIHByZXZlbnQgdW5jbGFyaWZpZWQgcnVudGltZSBlcnJvciBcInVwZGF0ZURlbGF5c2V0IGlzIG5vdCBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9PcHRpbWFsQml0cy9idWxsL2lzc3Vlcy85MjBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNjcmlwdExvYWRlckVycm9yKCdObyAubHVhIGZpbGVzIGZvdW5kIScsIGRpciwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1hbmRzID0gW107XG4gICAgICAgIGNhY2hlID0gY2FjaGUgIT09IG51bGwgJiYgY2FjaGUgIT09IHZvaWQgMCA/IGNhY2hlIDogbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGx1YUZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKGRpciwgbHVhRmlsZXNbaV0pO1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IGF3YWl0IHRoaXMubG9hZENvbW1hbmQoZmlsZSwgY2FjaGUpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmRDYWNoZS5zZXQoZGlyLCBjb21tYW5kcyk7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGFsbCBsdWEgc2NyaXB0cyBpbiBhIGdpdmVuIGRpcmVjdG9yeSB0byBhIGNsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjbGllbnQgLSByZWRpcyBjbGllbnQgdG8gYXR0YWNoIHNjcmlwdCB0b1xuICAgICAqIEBwYXJhbSBwYXRobmFtZSAtIHRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgc2NyaXB0c1xuICAgICAqL1xuICAgIGFzeW5jIGxvYWQoY2xpZW50LCBwYXRobmFtZSwgY2FjaGUpIHtcbiAgICAgICAgbGV0IHBhdGhzID0gdGhpcy5jbGllbnRTY3JpcHRzLmdldChjbGllbnQpO1xuICAgICAgICBpZiAoIXBhdGhzKSB7XG4gICAgICAgICAgICBwYXRocyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50U2NyaXB0cy5zZXQoY2xpZW50LCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRocy5oYXMocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRocy5hZGQocGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IGF3YWl0IHRoaXMubG9hZFNjcmlwdHMocGF0aG5hbWUsIGNhY2hlICE9PSBudWxsICYmIGNhY2hlICE9PSB2b2lkIDAgPyBjYWNoZSA6IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKGNvbW1hbmQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRlZmluZSB0aGUgY29tbWFuZCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgaWYgKCFjbGllbnRbY29tbWFuZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuZGVmaW5lQ29tbWFuZChjb21tYW5kLm5hbWUsIGNvbW1hbmQub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjb21tYW5kIGNhY2hlXG4gICAgICovXG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVFeHQoZmlsZW5hbWUsIGV4dCA9ICdsdWEnKSB7XG4gICAgY29uc3QgZm91bmRFeHQgPSBwYXRoLmV4dG5hbWUoZmlsZW5hbWUpO1xuICAgIGlmIChmb3VuZEV4dCAmJiBmb3VuZEV4dCAhPT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gICAgaWYgKGV4dCAmJiBleHRbMF0gIT09ICcuJykge1xuICAgICAgICBleHQgPSBgLiR7ZXh0fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtmaWxlbmFtZX0ke2V4dH1gO1xufVxuZnVuY3Rpb24gc3BsaXRGaWxlbmFtZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IGxvbmdOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlUGF0aCwgJy5sdWEnKTtcbiAgICBjb25zdCBbbmFtZSwgbnVtXSA9IGxvbmdOYW1lLnNwbGl0KCctJyk7XG4gICAgY29uc3QgbnVtYmVyT2ZLZXlzID0gbnVtID8gcGFyc2VJbnQobnVtLCAxMCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgbmFtZSwgbnVtYmVyT2ZLZXlzIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlbmFtZXNCeVBhdHRlcm4ocGF0dGVybikge1xuICAgIHJldHVybiBmZy5nbG9iKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pO1xufVxuLy8gRGV0ZXJtaW5lIHRoZSBwcm9qZWN0IHJvb3Rcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODcyMTUxNVxuZnVuY3Rpb24gZ2V0UGtnSnNvbkRpcigpIHtcbiAgICBmb3IgKGNvbnN0IG1vZFBhdGggb2YgbW9kdWxlLnBhdGhzIHx8IFtdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9zcGVjdGl2ZVBrZ0pzb25EaXIgPSBwYXRoLmRpcm5hbWUobW9kUGF0aCk7XG4gICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKG1vZFBhdGgsIGZzLmNvbnN0YW50cy5GX09LKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9zcGVjdGl2ZVBrZ0pzb25EaXI7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82Njg0MjkyN1xuLy8gc29tZSBkYXJrIG1hZ2ljIGhlcmUgOi0pXG4vLyB0aGlzIHZlcnNpb24gaXMgcHJlZmVycmVkIHRvIHRoZSBzaW1wbGVyIHZlcnNpb24gYmVjYXVzZSBvZlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzUzMDMgLVxuLy8gdGxkcjogZG9udCBhc3N1bWUgeW91J3JlIHRoZSBvbmx5IG9uZSB3aXRoIHRoZSBkb2luZyBzb21ldGhpbmcgbGlrZSB0aGlzXG5mdW5jdGlvbiBnZXRDYWxsZXJGaWxlKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG9yaWdpbmFsRnVuYyA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgIGxldCBjYWxsZXJGaWxlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoXywgc3RhY2spID0+IHN0YWNrO1xuICAgICAgICBjb25zdCBzaXRlcyA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBjb25zdCBjdXJyZW50RmlsZSA9IChfYSA9IHNpdGVzLnNoaWZ0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRGaWxlTmFtZSgpO1xuICAgICAgICB3aGlsZSAoc2l0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsZXJGaWxlID0gKF9jID0gKF9iID0gc2l0ZXMuc2hpZnQoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEZpbGVOYW1lKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlICE9PSBjYWxsZXJGaWxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9yaWdpbmFsRnVuYztcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxlckZpbGU7XG59XG5mdW5jdGlvbiBzaGExKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEhhc2gobm9ybWFsaXplZFBhdGgpIHtcbiAgICByZXR1cm4gYEBAJHtzaGExKG5vcm1hbGl6ZWRQYXRoKX1gO1xufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChmaW5kLCAnZycpLCByZXBsYWNlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5TGluZXMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEVtcHR5TGluZVJlZ2V4LCAnJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHQtbG9hZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVIYXNoIiwiTWluaW1hdGNoIiwiZmciLCJwYXRoIiwiZnMiLCJwcm9taXNpZnkiLCJyZWFkRmlsZSIsInJlYWRkaXIiLCJHbG9iT3B0aW9ucyIsImRvdCIsInNpbGVudCIsIkluY2x1ZGVSZWdleCIsIkVtcHR5TGluZVJlZ2V4IiwiU2NyaXB0TG9hZGVyRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInN0YWNrIiwibGluZSIsInBvc2l0aW9uIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW5jbHVkZXMiLCJoYXNNYWdpYyIsInBhdHRlcm4iLCJBcnJheSIsImlzQXJyYXkiLCJwIiwiaXNQb3NzaWJseU1hcHBlZFBhdGgiLCJoYXNGaWxlbmFtZVBhdHRlcm4iLCJTY3JpcHRMb2FkZXIiLCJwYXRoTWFwcGVyIiwiTWFwIiwiY2xpZW50U2NyaXB0cyIsIldlYWtNYXAiLCJjb21tYW5kQ2FjaGUiLCJyb290UGF0aCIsImdldFBrZ0pzb25EaXIiLCJzZXQiLCJfX2Rpcm5hbWUiLCJhZGRQYXRoTWFwcGluZyIsIm1hcHBlZFBhdGgiLCJyZXNvbHZlZCIsInJlc29sdmVQYXRoIiwiY2FsbGVyIiwiZ2V0Q2FsbGVyRmlsZSIsImNhbGxlclBhdGgiLCJkaXJuYW1lIiwibm9ybWFsaXplIiwicmVzb2x2ZSIsImxhc3QiLCJsZW5ndGgiLCJzZXAiLCJzdWJzdHIiLCJzY3JpcHROYW1lIiwiZmlyc3QiLCJqb2luIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsImdldCIsInJlc29sdmVEZXBlbmRlbmNpZXMiLCJmaWxlIiwiY2FjaGUiLCJpc0luY2x1ZGUiLCJwdXNoIiwiZmluZFBvcyIsImNvbnRlbnQiLCJtYXRjaCIsInBvcyIsImFyciIsInNsaWNlIiwic3BsaXQiLCJjb2x1bW4iLCJyYWlzZUVycm9yIiwibXNnIiwicmVzIiwiZXhlYyIsInJlZmVyZW5jZSIsImluY2x1ZGVGaWxlbmFtZSIsImVuc3VyZUV4dCIsImluY2x1ZGVQYXRocyIsImZpbGVzTWF0Y2hlZCIsImdldEZpbGVuYW1lc0J5UGF0dGVybiIsIm1hcCIsIngiLCJmaWx0ZXIiLCJleHRuYW1lIiwidG9rZW5zIiwiaSIsImluY2x1ZGVQYXRoIiwiaGFzSW5jbHVkZSIsImZpbmQiLCJpbmNsdWRlTWV0YWRhdGEiLCJ0b2tlbiIsIm51bWJlck9mS2V5cyIsInNwbGl0RmlsZW5hbWUiLCJjaGlsZENvbnRlbnQiLCJidWYiLCJmbGFnIiwidG9TdHJpbmciLCJlcnIiLCJjb2RlIiwiZ2V0UGF0aEhhc2giLCJzdWJzdGl0dXRpb24iLCJyZXBsYWNlIiwicG9wIiwicGFyc2VTY3JpcHQiLCJmaWxlbmFtZSIsIm1ldGEiLCJmaWxlSW5mbyIsImludGVycG9sYXRlIiwicHJvY2Vzc2VkIiwiU2V0IiwiZm9yRWFjaCIsImNoaWxkIiwiZW1pdHRlZCIsImhhcyIsImZyYWdtZW50IiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlQWxsIiwiYWRkIiwibG9hZENvbW1hbmQiLCJzY3JpcHQiLCJsdWEiLCJyZW1vdmVFbXB0eUxpbmVzIiwib3B0aW9ucyIsImxvYWRTY3JpcHRzIiwiZGlyIiwiY29tbWFuZHMiLCJmaWxlcyIsImx1YUZpbGVzIiwiY29tbWFuZCIsImxvYWQiLCJjbGllbnQiLCJwYXRobmFtZSIsInBhdGhzIiwic2NyaXB0cyIsImRlZmluZUNvbW1hbmQiLCJjbGVhckNhY2hlIiwiY2xlYXIiLCJleHQiLCJmb3VuZEV4dCIsImZpbGVQYXRoIiwibG9uZ05hbWUiLCJiYXNlbmFtZSIsIm51bSIsInBhcnNlSW50IiwidW5kZWZpbmVkIiwiZ2xvYiIsIm1vZFBhdGgiLCJtb2R1bGUiLCJwcm9zcGVjdGl2ZVBrZ0pzb25EaXIiLCJhY2Nlc3NTeW5jIiwiY29uc3RhbnRzIiwiRl9PSyIsImUiLCJfYSIsIl9iIiwiX2MiLCJvcmlnaW5hbEZ1bmMiLCJwcmVwYXJlU3RhY2tUcmFjZSIsImNhbGxlckZpbGUiLCJfIiwic2l0ZXMiLCJjdXJyZW50RmlsZSIsInNoaWZ0IiwiZ2V0RmlsZU5hbWUiLCJzaGExIiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsIm5vcm1hbGl6ZWRQYXRoIiwic3RyIiwiUmVnRXhwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/commands/script-loader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/child-command.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildCommand: () => (/* binding */ ChildCommand)\n/* harmony export */ });\nvar ChildCommand;\n(function(ChildCommand) {\n    ChildCommand[ChildCommand[\"Init\"] = 0] = \"Init\";\n    ChildCommand[ChildCommand[\"Start\"] = 1] = \"Start\";\n    ChildCommand[ChildCommand[\"Stop\"] = 2] = \"Stop\";\n})(ChildCommand || (ChildCommand = {})); //# sourceMappingURL=child-command.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2NoaWxkLWNvbW1hbmQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUlBLGFBQWE7QUFDdkIsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUM3QyxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQyxLQUNwQyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9lbnVtcy9jaGlsZC1jb21tYW5kLmpzPzMyMDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBDaGlsZENvbW1hbmQ7XG4oZnVuY3Rpb24gKENoaWxkQ29tbWFuZCkge1xuICAgIENoaWxkQ29tbWFuZFtDaGlsZENvbW1hbmRbXCJJbml0XCJdID0gMF0gPSBcIkluaXRcIjtcbiAgICBDaGlsZENvbW1hbmRbQ2hpbGRDb21tYW5kW1wiU3RhcnRcIl0gPSAxXSA9IFwiU3RhcnRcIjtcbiAgICBDaGlsZENvbW1hbmRbQ2hpbGRDb21tYW5kW1wiU3RvcFwiXSA9IDJdID0gXCJTdG9wXCI7XG59KShDaGlsZENvbW1hbmQgfHwgKENoaWxkQ29tbWFuZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZC1jb21tYW5kLmpzLm1hcCJdLCJuYW1lcyI6WyJDaGlsZENvbW1hbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/error-code.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode)\n/* harmony export */ });\nvar ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[ErrorCode[\"JobNotExist\"] = -1] = \"JobNotExist\";\n    ErrorCode[ErrorCode[\"JobLockNotExist\"] = -2] = \"JobLockNotExist\";\n    ErrorCode[ErrorCode[\"JobNotInState\"] = -3] = \"JobNotInState\";\n    ErrorCode[ErrorCode[\"JobPendingDependencies\"] = -4] = \"JobPendingDependencies\";\n    ErrorCode[ErrorCode[\"ParentJobNotExist\"] = -5] = \"ParentJobNotExist\";\n    ErrorCode[ErrorCode[\"JobLockMismatch\"] = -6] = \"JobLockMismatch\";\n    ErrorCode[ErrorCode[\"ParentJobCannotBeReplaced\"] = -7] = \"ParentJobCannotBeReplaced\";\n})(ErrorCode || (ErrorCode = {})); //# sourceMappingURL=error-code.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2Vycm9yLWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUlBLFVBQVU7QUFDcEIsVUFBVUEsU0FBUztJQUNoQkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQzNDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUMvQ0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDN0NBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHlCQUF5QixHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ3REQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNqREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDL0NBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDRCQUE0QixHQUFHLENBQUMsRUFBRSxHQUFHO0FBQzdELEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQyxLQUM5QixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9lbnVtcy9lcnJvci1jb2RlLmpzP2ZiZGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JOb3RFeGlzdFwiXSA9IC0xXSA9IFwiSm9iTm90RXhpc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSm9iTG9ja05vdEV4aXN0XCJdID0gLTJdID0gXCJKb2JMb2NrTm90RXhpc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSm9iTm90SW5TdGF0ZVwiXSA9IC0zXSA9IFwiSm9iTm90SW5TdGF0ZVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JQZW5kaW5nRGVwZW5kZW5jaWVzXCJdID0gLTRdID0gXCJKb2JQZW5kaW5nRGVwZW5kZW5jaWVzXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBhcmVudEpvYk5vdEV4aXN0XCJdID0gLTVdID0gXCJQYXJlbnRKb2JOb3RFeGlzdFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JMb2NrTWlzbWF0Y2hcIl0gPSAtNl0gPSBcIkpvYkxvY2tNaXNtYXRjaFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQYXJlbnRKb2JDYW5ub3RCZVJlcGxhY2VkXCJdID0gLTddID0gXCJQYXJlbnRKb2JDYW5ub3RCZVJlcGxhY2VkXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1jb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJFcnJvckNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildCommand: () => (/* reexport safe */ _child_command__WEBPACK_IMPORTED_MODULE_0__.ChildCommand),\n/* harmony export */   ErrorCode: () => (/* reexport safe */ _error_code__WEBPACK_IMPORTED_MODULE_1__.ErrorCode),\n/* harmony export */   MetricsTime: () => (/* reexport safe */ _metrics_time__WEBPACK_IMPORTED_MODULE_3__.MetricsTime),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _parent_command__WEBPACK_IMPORTED_MODULE_2__.ParentCommand)\n/* harmony export */ });\n/* harmony import */ var _child_command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./child-command */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js\");\n/* harmony import */ var _error_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error-code */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js\");\n/* harmony import */ var _parent_command__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parent-command */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js\");\n/* harmony import */ var _metrics_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metrics-time */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ0g7QUFDSTtBQUNGLENBQy9CLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2luZGV4LmpzP2I3ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jaGlsZC1jb21tYW5kJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3ItY29kZSc7XG5leHBvcnQgKiBmcm9tICcuL3BhcmVudC1jb21tYW5kJztcbmV4cG9ydCAqIGZyb20gJy4vbWV0cmljcy10aW1lJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/metrics-time.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MetricsTime: () => (/* binding */ MetricsTime)\n/* harmony export */ });\nvar MetricsTime;\n(function(MetricsTime) {\n    MetricsTime[MetricsTime[\"ONE_MINUTE\"] = 1] = \"ONE_MINUTE\";\n    MetricsTime[MetricsTime[\"FIVE_MINUTES\"] = 5] = \"FIVE_MINUTES\";\n    MetricsTime[MetricsTime[\"FIFTEEN_MINUTES\"] = 15] = \"FIFTEEN_MINUTES\";\n    MetricsTime[MetricsTime[\"THIRTY_MINUTES\"] = 30] = \"THIRTY_MINUTES\";\n    MetricsTime[MetricsTime[\"ONE_HOUR\"] = 60] = \"ONE_HOUR\";\n    MetricsTime[MetricsTime[\"ONE_WEEK\"] = 10080] = \"ONE_WEEK\";\n    MetricsTime[MetricsTime[\"TWO_WEEKS\"] = 20160] = \"TWO_WEEKS\";\n    MetricsTime[MetricsTime[\"ONE_MONTH\"] = 80640] = \"ONE_MONTH\";\n})(MetricsTime || (MetricsTime = {})); //# sourceMappingURL=metrics-time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL21ldHJpY3MtdGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sSUFBSUEsWUFBWTtBQUN0QixVQUFVQSxXQUFXO0lBQ2xCQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQzdDQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsR0FBRztJQUNsREEsV0FBVyxDQUFDQSxXQUFXLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUM1Q0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsV0FBVyxHQUFHLE1BQU0sR0FBRztJQUMvQ0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRztJQUNoREEsV0FBVyxDQUFDQSxXQUFXLENBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRztBQUNwRCxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDLEtBQ2xDLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL21ldHJpY3MtdGltZS5qcz84NjA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgTWV0cmljc1RpbWU7XG4oZnVuY3Rpb24gKE1ldHJpY3NUaW1lKSB7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJPTkVfTUlOVVRFXCJdID0gMV0gPSBcIk9ORV9NSU5VVEVcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIkZJVkVfTUlOVVRFU1wiXSA9IDVdID0gXCJGSVZFX01JTlVURVNcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIkZJRlRFRU5fTUlOVVRFU1wiXSA9IDE1XSA9IFwiRklGVEVFTl9NSU5VVEVTXCI7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJUSElSVFlfTUlOVVRFU1wiXSA9IDMwXSA9IFwiVEhJUlRZX01JTlVURVNcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIk9ORV9IT1VSXCJdID0gNjBdID0gXCJPTkVfSE9VUlwiO1xuICAgIE1ldHJpY3NUaW1lW01ldHJpY3NUaW1lW1wiT05FX1dFRUtcIl0gPSAxMDA4MF0gPSBcIk9ORV9XRUVLXCI7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJUV09fV0VFS1NcIl0gPSAyMDE2MF0gPSBcIlRXT19XRUVLU1wiO1xuICAgIE1ldHJpY3NUaW1lW01ldHJpY3NUaW1lW1wiT05FX01PTlRIXCJdID0gODA2NDBdID0gXCJPTkVfTU9OVEhcIjtcbn0pKE1ldHJpY3NUaW1lIHx8IChNZXRyaWNzVGltZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLXRpbWUuanMubWFwIl0sIm5hbWVzIjpbIk1ldHJpY3NUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/parent-command.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParentCommand: () => (/* binding */ ParentCommand)\n/* harmony export */ });\nvar ParentCommand;\n(function(ParentCommand) {\n    ParentCommand[ParentCommand[\"Completed\"] = 0] = \"Completed\";\n    ParentCommand[ParentCommand[\"Error\"] = 1] = \"Error\";\n    ParentCommand[ParentCommand[\"Failed\"] = 2] = \"Failed\";\n    ParentCommand[ParentCommand[\"InitFailed\"] = 3] = \"InitFailed\";\n    ParentCommand[ParentCommand[\"InitCompleted\"] = 4] = \"InitCompleted\";\n    ParentCommand[ParentCommand[\"Log\"] = 5] = \"Log\";\n    ParentCommand[ParentCommand[\"MoveToDelayed\"] = 6] = \"MoveToDelayed\";\n    ParentCommand[ParentCommand[\"Progress\"] = 7] = \"Progress\";\n    ParentCommand[ParentCommand[\"Update\"] = 8] = \"Update\";\n})(ParentCommand || (ParentCommand = {})); //# sourceMappingURL=parent-command.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL3BhcmVudC1jb21tYW5kLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDaERBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDN0NBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDakRBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsR0FBRztJQUNwREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ2pELEdBQUdBLGlCQUFrQkEsQ0FBQUEsZ0JBQWdCLENBQUMsS0FDdEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vZW51bXMvcGFyZW50LWNvbW1hbmQuanM/MjRhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIFBhcmVudENvbW1hbmQ7XG4oZnVuY3Rpb24gKFBhcmVudENvbW1hbmQpIHtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJDb21wbGV0ZWRcIl0gPSAwXSA9IFwiQ29tcGxldGVkXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiRXJyb3JcIl0gPSAxXSA9IFwiRXJyb3JcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJGYWlsZWRcIl0gPSAyXSA9IFwiRmFpbGVkXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiSW5pdEZhaWxlZFwiXSA9IDNdID0gXCJJbml0RmFpbGVkXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiSW5pdENvbXBsZXRlZFwiXSA9IDRdID0gXCJJbml0Q29tcGxldGVkXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiTG9nXCJdID0gNV0gPSBcIkxvZ1wiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIk1vdmVUb0RlbGF5ZWRcIl0gPSA2XSA9IFwiTW92ZVRvRGVsYXllZFwiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIlByb2dyZXNzXCJdID0gN10gPSBcIlByb2dyZXNzXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiVXBkYXRlXCJdID0gOF0gPSBcIlVwZGF0ZVwiO1xufSkoUGFyZW50Q29tbWFuZCB8fCAoUGFyZW50Q29tbWFuZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnQtY29tbWFuZC5qcy5tYXAiXSwibmFtZXMiOlsiUGFyZW50Q29tbWFuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/bullmq/dist/esm/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.AsyncFifoQueue),\n/* harmony export */   Backoffs: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Backoffs),\n/* harmony export */   ChildCommand: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_2__.ChildCommand),\n/* harmony export */   ChildPool: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.ChildPool),\n/* harmony export */   ChildProcessor: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.ChildProcessor),\n/* harmony export */   ClientType: () => (/* reexport safe */ _interfaces__WEBPACK_IMPORTED_MODULE_3__.ClientType),\n/* harmony export */   DELAY_TIME_1: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.DELAY_TIME_1),\n/* harmony export */   DELAY_TIME_5: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.DELAY_TIME_5),\n/* harmony export */   DelayedError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.DelayedError),\n/* harmony export */   ErrorCode: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_2__.ErrorCode),\n/* harmony export */   FlowProducer: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.FlowProducer),\n/* harmony export */   Job: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Job),\n/* harmony export */   MetricsTime: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_2__.MetricsTime),\n/* harmony export */   PRIORITY_LIMIT: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.PRIORITY_LIMIT),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_2__.ParentCommand),\n/* harmony export */   QUEUE_EVENT_SUFFIX: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.QUEUE_EVENT_SUFFIX),\n/* harmony export */   Queue: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Queue),\n/* harmony export */   QueueBase: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueBase),\n/* harmony export */   QueueEvents: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueEvents),\n/* harmony export */   QueueGetters: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueGetters),\n/* harmony export */   QueueKeys: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueKeys),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RateLimitError),\n/* harmony export */   RedisConnection: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RedisConnection),\n/* harmony export */   Repeat: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Repeat),\n/* harmony export */   ScriptLoader: () => (/* reexport safe */ _commands__WEBPACK_IMPORTED_MODULE_1__.ScriptLoader),\n/* harmony export */   ScriptLoaderError: () => (/* reexport safe */ _commands__WEBPACK_IMPORTED_MODULE_1__.ScriptLoaderError),\n/* harmony export */   Scripts: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Scripts),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.UnrecoverableError),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.WaitingChildrenError),\n/* harmony export */   Worker: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Worker),\n/* harmony export */   array2obj: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.array2obj),\n/* harmony export */   asyncSend: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.asyncSend),\n/* harmony export */   childSend: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.childSend),\n/* harmony export */   clientCommandMessageReg: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.clientCommandMessageReg),\n/* harmony export */   decreaseMaxListeners: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.decreaseMaxListeners),\n/* harmony export */   delay: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.delay),\n/* harmony export */   errorObject: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.errorObject),\n/* harmony export */   errorToJSON: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.errorToJSON),\n/* harmony export */   getNextMillis: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.getNextMillis),\n/* harmony export */   getParentKey: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.getParentKey),\n/* harmony export */   increaseMaxListeners: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.increaseMaxListeners),\n/* harmony export */   isEmpty: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.isEmpty),\n/* harmony export */   isNotConnectionError: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.isNotConnectionError),\n/* harmony export */   isRedisCluster: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.isRedisCluster),\n/* harmony export */   isRedisInstance: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.isRedisInstance),\n/* harmony export */   isRedisVersionLowerThan: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.isRedisVersionLowerThan),\n/* harmony export */   lengthInUtf8Bytes: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.lengthInUtf8Bytes),\n/* harmony export */   parseObjectValues: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.parseObjectValues),\n/* harmony export */   raw2NextJobData: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.raw2NextJobData),\n/* harmony export */   removeAllQueueData: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.removeAllQueueData),\n/* harmony export */   scriptLoader: () => (/* reexport safe */ _commands__WEBPACK_IMPORTED_MODULE_1__.scriptLoader),\n/* harmony export */   tryCatch: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_5__.tryCatch)\n/* harmony export */ });\n/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/index.js\");\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands */ \"(rsc)/./node_modules/bullmq/dist/esm/commands/index.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interfaces */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/bullmq/dist/esm/types/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils.js\");\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ0M7QUFDSDtBQUNLO0FBQ0w7QUFDQSxDQUN4QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbmRleC5qcz8wNmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vY2xhc3Nlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbW1hbmRzJztcbmV4cG9ydCAqIGZyb20gJy4vZW51bXMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/advanced-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=advanced-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYWR2YW5jZWQtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDViw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2FkdmFuY2VkLW9wdGlvbnMuanM/NTkyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZHZhbmNlZC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/backoff-options.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=backoff-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFja29mZi1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFja29mZi1vcHRpb25zLmpzPzg5MjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/base-job-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=base-job-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFzZS1qb2Itb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDViw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2Jhc2Utam9iLW9wdGlvbnMuanM/NTBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLWpvYi1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/child-message.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=child-message.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY2hpbGQtbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2NoaWxkLW1lc3NhZ2UuanM/Nzg2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZC1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/connection.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=connection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2Nvbm5lY3Rpb24uanM/MDJiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/flow-job.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=flow-job.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvZmxvdy1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1Ysb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9mbG93LWpvYi5qcz8wYzM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsb3ctam9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientType: () => (/* reexport safe */ _queue_options__WEBPACK_IMPORTED_MODULE_14__.ClientType)\n/* harmony export */ });\n/* harmony import */ var _advanced_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./advanced-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js\");\n/* harmony import */ var _backoff_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./backoff-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js\");\n/* harmony import */ var _base_job_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-job-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js\");\n/* harmony import */ var _child_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./child-message */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js\");\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js\");\n/* harmony import */ var _flow_job__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flow-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js\");\n/* harmony import */ var _ioredis_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ioredis-events */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js\");\n/* harmony import */ var _job_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./job-json */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js\");\n/* harmony import */ var _keep_jobs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./keep-jobs */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js\");\n/* harmony import */ var _metrics_options__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./metrics-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js\");\n/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./metrics */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js\");\n/* harmony import */ var _minimal_job__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./minimal-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js\");\n/* harmony import */ var _parent_message__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parent-message */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js\");\n/* harmony import */ var _parent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parent */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js\");\n/* harmony import */ var _queue_options__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./queue-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js\");\n/* harmony import */ var _rate_limiter_options__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rate-limiter-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js\");\n/* harmony import */ var _redis_options__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./redis-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js\");\n/* harmony import */ var _redis_streams__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./redis-streams */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js\");\n/* harmony import */ var _repeatable_job__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./repeatable-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js\");\n/* harmony import */ var _repeat_options__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./repeat-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js\");\n/* harmony import */ var _sandboxed_job_processor__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./sandboxed-job-processor */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js\");\n/* harmony import */ var _sandboxed_job__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./sandboxed-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js\");\n/* harmony import */ var _worker_options__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./worker-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0Q7QUFDQztBQUNIO0FBQ0g7QUFDRjtBQUNNO0FBQ047QUFDQztBQUNNO0FBQ1I7QUFDSTtBQUNHO0FBQ1I7QUFDTztBQUNPO0FBQ1A7QUFDQTtBQUNDO0FBQ0E7QUFDUztBQUNWO0FBQ0MsQ0FDakMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9pbmRleC5qcz80Yjg4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYWR2YW5jZWQtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2JhY2tvZmYtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2Jhc2Utam9iLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9jaGlsZC1tZXNzYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vY29ubmVjdGlvbic7XG5leHBvcnQgKiBmcm9tICcuL2Zsb3ctam9iJztcbmV4cG9ydCAqIGZyb20gJy4vaW9yZWRpcy1ldmVudHMnO1xuZXhwb3J0ICogZnJvbSAnLi9qb2ItanNvbic7XG5leHBvcnQgKiBmcm9tICcuL2tlZXAtam9icyc7XG5leHBvcnQgKiBmcm9tICcuL21ldHJpY3Mtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL21ldHJpY3MnO1xuZXhwb3J0ICogZnJvbSAnLi9taW5pbWFsLWpvYic7XG5leHBvcnQgKiBmcm9tICcuL3BhcmVudC1tZXNzYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vcGFyZW50JztcbmV4cG9ydCAqIGZyb20gJy4vcXVldWUtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3JhdGUtbGltaXRlci1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vcmVkaXMtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3JlZGlzLXN0cmVhbXMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXBlYXRhYmxlLWpvYic7XG5leHBvcnQgKiBmcm9tICcuL3JlcGVhdC1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vc2FuZGJveGVkLWpvYi1wcm9jZXNzb3InO1xuZXhwb3J0ICogZnJvbSAnLi9zYW5kYm94ZWQtam9iJztcbmV4cG9ydCAqIGZyb20gJy4vd29ya2VyLW9wdGlvbnMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=ioredis-events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvaW9yZWRpcy1ldmVudHMuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9pb3JlZGlzLWV2ZW50cy5qcz81YjNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlvcmVkaXMtZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/job-json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=job-json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvam9iLWpzb24uanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1Ysb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9qb2ItanNvbi5qcz8yNDEwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi1qc29uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=keep-jobs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMva2VlcC1qb2JzLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMva2VlcC1qb2JzLmpzP2RiNDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VlcC1qb2JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/metrics-options.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=metrics-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy1vcHRpb25zLmpzP2ZiMjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljcy1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/metrics.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=metrics.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL21ldHJpY3MuanM/ZTcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/minimal-job.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=minimal-job.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWluaW1hbC1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9taW5pbWFsLWpvYi5qcz9hNzA5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbmltYWwtam9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/parent-message.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=parent-message.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LW1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9wYXJlbnQtbWVzc2FnZS5qcz9jYmJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmVudC1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/parent.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=parent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LmpzP2MwNjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/queue-options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientType: () => (/* binding */ ClientType)\n/* harmony export */ });\nvar ClientType;\n(function(ClientType) {\n    ClientType[\"blocking\"] = \"blocking\";\n    ClientType[\"normal\"] = \"normal\";\n})(ClientType || (ClientType = {})); //# sourceMappingURL=queue-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcXVldWUtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sSUFBSUEsV0FBVztBQUNyQixVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUMsV0FBVyxHQUFHO0lBQ3pCQSxVQUFVLENBQUMsU0FBUyxHQUFHO0FBQzNCLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQyxLQUNoQyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3F1ZXVlLW9wdGlvbnMuanM/Yzg1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIENsaWVudFR5cGU7XG4oZnVuY3Rpb24gKENsaWVudFR5cGUpIHtcbiAgICBDbGllbnRUeXBlW1wiYmxvY2tpbmdcIl0gPSBcImJsb2NraW5nXCI7XG4gICAgQ2xpZW50VHlwZVtcIm5vcm1hbFwiXSA9IFwibm9ybWFsXCI7XG59KShDbGllbnRUeXBlIHx8IChDbGllbnRUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbIkNsaWVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=rate-limiter-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmF0ZS1saW1pdGVyLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9yYXRlLWxpbWl0ZXItb3B0aW9ucy5qcz80MGMwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGUtbGltaXRlci1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/redis-options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=redis-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JlZGlzLW9wdGlvbnMuanM/NDY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcy1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/redis-streams.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=redis-streams.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtc3RyZWFtcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JlZGlzLXN0cmVhbXMuanM/ODY0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcy1zdHJlYW1zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/repeat-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=repeat-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVwZWF0LW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9yZXBlYXQtb3B0aW9ucy5qcz81MjJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=repeatable-job.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVwZWF0YWJsZS1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9yZXBlYXRhYmxlLWpvYi5qcz9hMTY1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdGFibGUtam9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=sandboxed-job-processor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLWpvYi1wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9zYW5kYm94ZWQtam9iLXByb2Nlc3Nvci5qcz9hOTk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbmRib3hlZC1qb2ItcHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=sandboxed-job.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLWpvYi5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3NhbmRib3hlZC1qb2IuanM/NmYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW5kYm94ZWQtam9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/worker-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=worker-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvd29ya2VyLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy93b3JrZXItb3B0aW9ucy5qcz84MTcwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDelayedJob: () => (/* binding */ addDelayedJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a delayed job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - computes timestamp.\n    - adds to delayed zset.\n    - Emits a global event 'delayed' if the job is delayed.\n    Input:\n      KEYS[1] 'marker',\n      KEYS[2] 'meta'\n      KEYS[3] 'id'\n      KEYS[4] 'delayed'\n      KEYS[5] 'completed'\n      KEYS[6] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (use custom instead of one generated automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n          x [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal delayedKey = KEYS[4]\nlocal completedKey = KEYS[5]\nlocal eventsKey = KEYS[6]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal parentKey = args[5]\nlocal repeatJobKey = args[9]\nlocal parent = args[8]\nlocal parentData\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to active if needed.\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey,\n                                        parentKey, parentId, timestamp)\n    local isParentActive = rcall(\"ZSCORE\",\n                                 parentQueueKey .. \":waiting-children\", parentId)\n    if rcall(\"SCARD\", parentDependenciesKey) == 0 and isParentActive then\n        rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId)\n        local parentWaitKey = parentQueueKey .. \":wait\"\n        local parentPausedKey = parentQueueKey .. \":paused\"\n        local parentMetaKey = parentQueueKey .. \":meta\"\n        local parentMarkerKey = parentQueueKey .. \":marker\"\n        local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n        local priority = tonumber(jobAttributes[1]) or 0\n        local delay = tonumber(jobAttributes[2]) or 0\n        if delay > 0 then\n            local delayedTimestamp = tonumber(timestamp) + delay\n            local score = delayedTimestamp * 0x1000\n            local parentDelayedKey = parentQueueKey .. \":delayed\"\n            rcall(\"ZADD\", parentDelayedKey, score, parentId)\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\",\n                  \"jobId\", parentId, \"delay\", delayedTimestamp)\n            addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n        else\n            if priority == 0 then\n                local parentTarget, isParentPaused =\n                    getTargetQueueList(parentMetaKey, parentWaitKey,\n                                       parentPausedKey)\n                addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPaused, parentId)\n            else\n                local isPaused = isQueuePaused(parentMetaKey)\n                addJobWithPriority(parentMarkerKey,\n                                   parentQueueKey .. \":prioritized\", priority,\n                                   parentId, parentQueueKey .. \":pc\", isPaused)\n            end\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\",\n                  \"jobId\", parentId, \"prev\", \"waiting-children\")\n        end\n    end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) ~= false then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey ~= nil then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\n-- Store the job.\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n                                 opts, timestamp, parentKey, parentData,\n                                 repeatJobKey)\n-- Compute delayed timestamp and the score.\nlocal delayedTimestamp = (delay > 0 and (timestamp + delay)) or 0\nlocal score = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)\nrcall(\"ZADD\", delayedKey, score, jobId)\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n      \"jobId\", jobId, \"delay\", delayedTimestamp)\n-- mark that a delayed job is available\nlocal isPaused = isQueuePaused(metaKey)\nif not isPaused then\n    local markerKey = KEYS[1]\n    addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addDelayedJob = {\n    name: \"addDelayedJob\",\n    content,\n    keys: 6\n}; //# sourceMappingURL=addDelayedJob-6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkRGVsYXllZEpvYi02LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpU2pCLENBQUM7QUFDTSxNQUFNQyxnQkFBZ0I7SUFDekJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2FkZERlbGF5ZWRKb2ItNi5qcz9lODMxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgZGVsYXllZCBqb2IgdG8gdGhlIHF1ZXVlIGJ5IGRvaW5nIHRoZSBmb2xsb3dpbmc6XG4gICAgLSBJbmNyZWFzZXMgdGhlIGpvYiBjb3VudGVyIGlmIG5lZWRlZC5cbiAgICAtIENyZWF0ZXMgYSBuZXcgam9iIGtleSB3aXRoIHRoZSBqb2IgZGF0YS5cbiAgICAtIGNvbXB1dGVzIHRpbWVzdGFtcC5cbiAgICAtIGFkZHMgdG8gZGVsYXllZCB6c2V0LlxuICAgIC0gRW1pdHMgYSBnbG9iYWwgZXZlbnQgJ2RlbGF5ZWQnIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ21hcmtlcicsXG4gICAgICBLRVlTWzJdICdtZXRhJ1xuICAgICAgS0VZU1szXSAnaWQnXG4gICAgICBLRVlTWzRdICdkZWxheWVkJ1xuICAgICAgS0VZU1s1XSAnY29tcGxldGVkJ1xuICAgICAgS0VZU1s2XSBldmVudHMgc3RyZWFtIGtleVxuICAgICAgQVJHVlsxXSBtc2dwYWNrZWQgYXJndW1lbnRzIGFycmF5XG4gICAgICAgICAgICBbMV0gIGtleSBwcmVmaXgsXG4gICAgICAgICAgICBbMl0gIGN1c3RvbSBpZCAodXNlIGN1c3RvbSBpbnN0ZWFkIG9mIG9uZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSlcbiAgICAgICAgICAgIFszXSAgbmFtZVxuICAgICAgICAgICAgWzRdICB0aW1lc3RhbXBcbiAgICAgICAgICAgIFs1XSAgcGFyZW50S2V5P1xuICAgICAgICAgIHggWzZdICB3YWl0Q2hpbGRyZW5LZXkga2V5LlxuICAgICAgICAgICAgWzddICBwYXJlbnQgZGVwZW5kZW5jaWVzIGtleS5cbiAgICAgICAgICAgIFs4XSAgcGFyZW50PyB7aWQsIHF1ZXVlS2V5fVxuICAgICAgICAgICAgWzldICByZXBlYXQgam9iIGtleVxuICAgICAgQVJHVlsyXSBKc29uIHN0cmluZ2lmaWVkIGpvYiBkYXRhXG4gICAgICBBUkdWWzNdIG1zZ3BhY2tlZCBvcHRpb25zXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIGpvYklkICAtIE9LXG4gICAgICAgIC01ICAgICAtIE1pc3NpbmcgcGFyZW50IGtleVxuXV1cbmxvY2FsIG1ldGFLZXkgPSBLRVlTWzJdXG5sb2NhbCBpZEtleSA9IEtFWVNbM11cbmxvY2FsIGRlbGF5ZWRLZXkgPSBLRVlTWzRdXG5sb2NhbCBjb21wbGV0ZWRLZXkgPSBLRVlTWzVdXG5sb2NhbCBldmVudHNLZXkgPSBLRVlTWzZdXG5sb2NhbCBqb2JJZFxubG9jYWwgam9iSWRLZXlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgYXJncyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzFdKVxubG9jYWwgZGF0YSA9IEFSR1ZbMl1cbmxvY2FsIHBhcmVudEtleSA9IGFyZ3NbNV1cbmxvY2FsIHJlcGVhdEpvYktleSA9IGFyZ3NbOV1cbmxvY2FsIHBhcmVudCA9IGFyZ3NbOF1cbmxvY2FsIHBhcmVudERhdGFcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbmV4dCBkZWxheWVkIGpvYiB0aW1lc3RhbXAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkFOR0VcIiwgZGVsYXllZEtleSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgKG5leHRUaW1lc3RhbXAgfj0gbmlsKSB0aGVuIFxuICAgICAgbmV4dFRpbWVzdGFtcCA9IG5leHRUaW1lc3RhbXAgLyAweDEwMDBcbiAgICBlbmRcbiAgICByZXR1cm4gbmV4dFRpbWVzdGFtcFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgICAtLSBSZXBsYWNlIHRoZSBzY29yZSBvZiB0aGUgbWFya2VyIHdpdGggdGhlIG5ld2VzdCBrbm93blxuICAgICAgICAtLSBuZXh0IHRpbWVzdGFtcC5cbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gICAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICAgIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgICAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gICAgZW5kXG4gICAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVuIGpvYiBpcyBkdXBsaWNhdGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgcGFyZW50J3MgZGVwZW5kZW5jaWVzIGlmIHRoZSBqb2JcbiAgICBpcyBhbHJlYWR5IGNvbXBsZXRlZCBhbmQgYWJvdXQgdG8gYmUgaWdub3JlZC4gVGhlIHBhcmVudCBtdXN0IGdldCBpdHNcbiAgICBkZXBlbmRlbmNpZXMgdXBkYXRlZCB0byBhdm9pZCB0aGUgcGFyZW50IGpvYiBiZWluZyBzdHVjayBmb3JldmVyIGluIFxuICAgIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHN0YXRlLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIG9yIGFkZCBkZXBlbmRlbmNpZXMgdG8gcGFyZW50LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIHBhcmVudCB0byBhY3RpdmUgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBiaXQuYmFuZChwcmlvQ291bnRlciwgMHhmZmZmZmZmZmZmZmYpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzUXVldWVQYXVzZWQocXVldWVNZXRhS2V5KVxuICAgIHJldHVybiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSA9PSAxXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICAgIGxvY2FsIGlzUGFyZW50QWN0aXZlID0gcmNhbGwoXCJaU0NPUkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgaWYgcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpID09IDAgYW5kIGlzUGFyZW50QWN0aXZlIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIHBhcmVudFdhaXRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0XCJcbiAgICAgICAgbG9jYWwgcGFyZW50UGF1c2VkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6cGF1c2VkXCJcbiAgICAgICAgbG9jYWwgcGFyZW50TWV0YUtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1ldGFcIlxuICAgICAgICBsb2NhbCBwYXJlbnRNYXJrZXJLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptYXJrZXJcIlxuICAgICAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgICAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMV0pIG9yIDBcbiAgICAgICAgbG9jYWwgZGVsYXkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzJdKSBvciAwXG4gICAgICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gdG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5XG4gICAgICAgICAgICBsb2NhbCBzY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgICAgICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwYXJlbnREZWxheWVkS2V5LCBzY29yZSwgcGFyZW50SWQpXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLFxuICAgICAgICAgICAgICAgICAgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLCBkZWxheWVkVGltZXN0YW1wKVxuICAgICAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWQgPVxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50TWV0YUtleSwgcGFyZW50V2FpdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdXNlZEtleSlcbiAgICAgICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWQsIHBhcmVudElkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIGlzUGF1c2VkID0gaXNRdWV1ZVBhdXNlZChwYXJlbnRNZXRhS2V5KVxuICAgICAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShwYXJlbnRNYXJrZXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnByaW9yaXRpemVkXCIsIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCwgcGFyZW50UXVldWVLZXkgLi4gXCI6cGNcIiwgaXNQYXVzZWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgICAgICAgICBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVQYXJlbnREZXBzSWZOZWVkZWQocGFyZW50S2V5LCBwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LFxuICBwYXJlbnRJZCwgam9iSWRLZXksIHJldHVybnZhbHVlLCB0aW1lc3RhbXAgKVxuICBsb2NhbCBwcm9jZXNzZWRTZXQgPSBwYXJlbnRLZXkgLi4gXCI6cHJvY2Vzc2VkXCJcbiAgcmNhbGwoXCJIU0VUXCIsIHByb2Nlc3NlZFNldCwgam9iSWRLZXksIHJldHVybnZhbHVlKVxuICBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVFeGlzdGluZ0pvYnNQYXJlbnQocGFyZW50S2V5LCBwYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBjb21wbGV0ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9iSWRLZXksIGpvYklkLCB0aW1lc3RhbXApXG4gICAgaWYgcGFyZW50S2V5IH49IG5pbCB0aGVuXG4gICAgICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIGNvbXBsZXRlZEtleSwgam9iSWQpIH49IGZhbHNlIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHJldHVybnZhbHVlID0gcmNhbGwoXCJIR0VUXCIsIGpvYklkS2V5LCBcInJldHVybnZhbHVlXCIpXG4gICAgICAgICAgICB1cGRhdGVQYXJlbnREZXBzSWZOZWVkZWQocGFyZW50S2V5LCBwYXJlbnRbJ3F1ZXVlS2V5J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRbJ2lkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9iSWRLZXksIHJldHVybnZhbHVlLCB0aW1lc3RhbXApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICByY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcInBhcmVudEtleVwiLCBwYXJlbnRLZXksIFwicGFyZW50XCIsIHBhcmVudERhdGEpXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iS2V5LCBqb2JJZCwgY3VycmVudFBhcmVudEtleSwgY3VycmVudFBhcmVudCxcbiAgcGFyZW50RGF0YSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBjb21wbGV0ZWRLZXksIGV2ZW50c0tleSwgbWF4RXZlbnRzLCB0aW1lc3RhbXApXG4gIGxvY2FsIGV4aXN0ZWRQYXJlbnRLZXkgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiKVxuICBpZiBub3QgZXhpc3RlZFBhcmVudEtleSB0aGVuXG4gICAgdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgam9iS2V5LFxuICAgICAgam9iSWQsIHRpbWVzdGFtcClcbiAgZWxzZVxuICAgIGlmIGN1cnJlbnRQYXJlbnRLZXkgfj0gbmlsIGFuZCBjdXJyZW50UGFyZW50S2V5IH49IGV4aXN0ZWRQYXJlbnRLZXlcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgZXhpc3RlZFBhcmVudEtleSkgPT0gMSkgdGhlblxuICAgICAgcmV0dXJuIC03XG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLFxuICAgIFwiZHVwbGljYXRlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHN0b3JlIGEgam9iXG5dXVxubG9jYWwgZnVuY3Rpb24gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIG5hbWUsIGRhdGEsIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuICAgIGxvY2FsIGpzb25PcHRzID0gY2pzb24uZW5jb2RlKG9wdHMpXG4gICAgbG9jYWwgZGVsYXkgPSBvcHRzWydkZWxheSddIG9yIDBcbiAgICBsb2NhbCBwcmlvcml0eSA9IG9wdHNbJ3ByaW9yaXR5J10gb3IgMFxuICAgIGxvY2FsIG9wdGlvbmFsVmFsdWVzID0ge31cbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudEtleVwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudEtleSlcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudERhdGEpXG4gICAgZW5kXG4gICAgaWYgcmVwZWF0Sm9iS2V5IH49IG5pbCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJyamtcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCByZXBlYXRKb2JLZXkpXG4gICAgZW5kXG4gICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJuYW1lXCIsIG5hbWUsIFwiZGF0YVwiLCBkYXRhLCBcIm9wdHNcIiwganNvbk9wdHMsXG4gICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgdGltZXN0YW1wLCBcImRlbGF5XCIsIGRlbGF5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5LFxuICAgICAgICAgIHVucGFjayhvcHRpb25hbFZhbHVlcykpXG4gICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhZGRlZFwiLCBcImpvYklkXCIsIGpvYklkLCBcIm5hbWVcIiwgbmFtZSlcbiAgICByZXR1cm4gZGVsYXksIHByaW9yaXR5XG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBpZEtleSlcbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBvcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbM10pXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksXG4gICAgICAgICAgICBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxuLS0gU3RvcmUgdGhlIGpvYi5cbmxvY2FsIGRlbGF5LCBwcmlvcml0eSA9IHN0b3JlSm9iKGV2ZW50c0tleSwgam9iSWRLZXksIGpvYklkLCBhcmdzWzNdLCBBUkdWWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cywgdGltZXN0YW1wLCBwYXJlbnRLZXksIHBhcmVudERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRKb2JLZXkpXG4tLSBDb21wdXRlIGRlbGF5ZWQgdGltZXN0YW1wIGFuZCB0aGUgc2NvcmUuXG5sb2NhbCBkZWxheWVkVGltZXN0YW1wID0gKGRlbGF5ID4gMCBhbmQgKHRpbWVzdGFtcCArIGRlbGF5KSkgb3IgMFxubG9jYWwgc2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwICsgYml0LmJhbmQoam9iQ291bnRlciwgMHhmZmYpXG5yY2FsbChcIlpBRERcIiwgZGVsYXllZEtleSwgc2NvcmUsIGpvYklkKVxucmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWxheWVkXCIsXG4gICAgICBcImpvYklkXCIsIGpvYklkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4tLSBtYXJrIHRoYXQgYSBkZWxheWVkIGpvYiBpcyBhdmFpbGFibGVcbmxvY2FsIGlzUGF1c2VkID0gaXNRdWV1ZVBhdXNlZChtZXRhS2V5KVxuaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICBsb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzFdXG4gICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG5lbmRcbi0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGEgY2hpbGQgb2YgYW5vdGhlciBqb2IsIGlmIHNvIGFkZCBpdCB0byB0aGUgcGFyZW50cyBkZXBlbmRlbmNpZXNcbmlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbmV4cG9ydCBjb25zdCBhZGREZWxheWVkSm9iID0ge1xuICAgIG5hbWU6ICdhZGREZWxheWVkSm9iJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDYsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkRGVsYXllZEpvYi02LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwiYWRkRGVsYXllZEpvYiIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-4.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addParentJob-4.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addParentJob: () => (/* binding */ addParentJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a parent job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - adds the job to the waiting-children zset\n    Input:\n      KEYS[1] 'meta'\n      KEYS[2] 'id'\n      KEYS[3] 'completed'\n      KEYS[4] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[1]\nlocal idKey = KEYS[2]\nlocal completedKey = KEYS[3]\nlocal eventsKey = KEYS[4]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal repeatJobKey = args[9]\nlocal parent = args[8]\nlocal parentData\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to active if needed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey,\n                                        parentKey, parentId, timestamp)\n    local isParentActive = rcall(\"ZSCORE\",\n                                 parentQueueKey .. \":waiting-children\", parentId)\n    if rcall(\"SCARD\", parentDependenciesKey) == 0 and isParentActive then\n        rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId)\n        local parentWaitKey = parentQueueKey .. \":wait\"\n        local parentPausedKey = parentQueueKey .. \":paused\"\n        local parentMetaKey = parentQueueKey .. \":meta\"\n        local parentMarkerKey = parentQueueKey .. \":marker\"\n        local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n        local priority = tonumber(jobAttributes[1]) or 0\n        local delay = tonumber(jobAttributes[2]) or 0\n        if delay > 0 then\n            local delayedTimestamp = tonumber(timestamp) + delay\n            local score = delayedTimestamp * 0x1000\n            local parentDelayedKey = parentQueueKey .. \":delayed\"\n            rcall(\"ZADD\", parentDelayedKey, score, parentId)\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\",\n                  \"jobId\", parentId, \"delay\", delayedTimestamp)\n            addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n        else\n            if priority == 0 then\n                local parentTarget, isParentPaused =\n                    getTargetQueueList(parentMetaKey, parentWaitKey,\n                                       parentPausedKey)\n                addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPaused, parentId)\n            else\n                local isPaused = isQueuePaused(parentMetaKey)\n                addJobWithPriority(parentMarkerKey,\n                                   parentQueueKey .. \":prioritized\", priority,\n                                   parentId, parentQueueKey .. \":pc\", isPaused)\n            end\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\",\n                  \"jobId\", parentId, \"prev\", \"waiting-children\")\n        end\n    end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) ~= false then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey ~= nil then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal waitChildrenKey = args[6]\nrcall(\"ZADD\", waitChildrenKey, timestamp, jobId)\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n      \"waiting-children\", \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addParentJob = {\n    name: \"addParentJob\",\n    content,\n    keys: 4\n}; //# sourceMappingURL=addParentJob-4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUGFyZW50Sm9iLTQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtUmpCLENBQUM7QUFDTSxNQUFNQyxlQUFlO0lBQ3hCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGRQYXJlbnRKb2ItNC5qcz9lMTkxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgcGFyZW50IGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIEluY3JlYXNlcyB0aGUgam9iIGNvdW50ZXIgaWYgbmVlZGVkLlxuICAgIC0gQ3JlYXRlcyBhIG5ldyBqb2Iga2V5IHdpdGggdGhlIGpvYiBkYXRhLlxuICAgIC0gYWRkcyB0aGUgam9iIHRvIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHpzZXRcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ21ldGEnXG4gICAgICBLRVlTWzJdICdpZCdcbiAgICAgIEtFWVNbM10gJ2NvbXBsZXRlZCdcbiAgICAgIEtFWVNbNF0gZXZlbnRzIHN0cmVhbSBrZXlcbiAgICAgIEFSR1ZbMV0gbXNncGFja2VkIGFyZ3VtZW50cyBhcnJheVxuICAgICAgICAgICAgWzFdICBrZXkgcHJlZml4LFxuICAgICAgICAgICAgWzJdICBjdXN0b20gaWQgKHdpbGwgbm90IGdlbmVyYXRlIG9uZSBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgWzNdICBuYW1lXG4gICAgICAgICAgICBbNF0gIHRpbWVzdGFtcFxuICAgICAgICAgICAgWzVdICBwYXJlbnRLZXk/XG4gICAgICAgICAgICBbNl0gIHdhaXRDaGlsZHJlbktleSBrZXkuXG4gICAgICAgICAgICBbN10gIHBhcmVudCBkZXBlbmRlbmNpZXMga2V5LlxuICAgICAgICAgICAgWzhdICBwYXJlbnQ/IHtpZCwgcXVldWVLZXl9XG4gICAgICAgICAgICBbOV0gIHJlcGVhdCBqb2Iga2V5XG4gICAgICBBUkdWWzJdIEpzb24gc3RyaW5naWZpZWQgam9iIGRhdGFcbiAgICAgIEFSR1ZbM10gbXNncGFja2VkIG9wdGlvbnNcbiAgICAgIE91dHB1dDpcbiAgICAgICAgam9iSWQgIC0gT0tcbiAgICAgICAgLTUgICAgIC0gTWlzc2luZyBwYXJlbnQga2V5XG5dXVxubG9jYWwgbWV0YUtleSA9IEtFWVNbMV1cbmxvY2FsIGlkS2V5ID0gS0VZU1syXVxubG9jYWwgY29tcGxldGVkS2V5ID0gS0VZU1szXVxubG9jYWwgZXZlbnRzS2V5ID0gS0VZU1s0XVxubG9jYWwgam9iSWRcbmxvY2FsIGpvYklkS2V5XG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGFyZ3MgPSBjbXNncGFjay51bnBhY2soQVJHVlsxXSlcbmxvY2FsIGRhdGEgPSBBUkdWWzJdXG5sb2NhbCBvcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbM10pXG5sb2NhbCBwYXJlbnRLZXkgPSBhcmdzWzVdXG5sb2NhbCByZXBlYXRKb2JLZXkgPSBhcmdzWzldXG5sb2NhbCBwYXJlbnQgPSBhcmdzWzhdXG5sb2NhbCBwYXJlbnREYXRhXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gam9iIGlzIGR1cGxpY2F0ZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBwYXJlbnQncyBkZXBlbmRlbmNpZXMgaWYgdGhlIGpvYlxuICAgIGlzIGFscmVhZHkgY29tcGxldGVkIGFuZCBhYm91dCB0byBiZSBpZ25vcmVkLiBUaGUgcGFyZW50IG11c3QgZ2V0IGl0c1xuICAgIGRlcGVuZGVuY2llcyB1cGRhdGVkIHRvIGF2b2lkIHRoZSBwYXJlbnQgam9iIGJlaW5nIHN0dWNrIGZvcmV2ZXIgaW4gXG4gICAgdGhlIHdhaXRpbmctY2hpbGRyZW4gc3RhdGUuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgb3IgYWRkIGRlcGVuZGVuY2llcyB0byBwYXJlbnQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGFjdGl2ZSBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gXG4gICAgICBuZXh0VGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICAgIHJldHVybiBuZXh0VGltZXN0YW1wXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsIHByaW9yaXR5Q291bnRlcktleSwgaXNQYXVzZWQpXG4gIGxvY2FsIHByaW9Db3VudGVyID0gcmNhbGwoXCJJTkNSXCIsIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgc2NvcmUgPSBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgYml0LmJhbmQocHJpb0NvdW50ZXIsIDB4ZmZmZmZmZmZmZmZmKVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdGl6ZWRLZXksIHNjb3JlLCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkKHF1ZXVlTWV0YUtleSlcbiAgICByZXR1cm4gcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgPT0gMVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgICBsb2NhbCBpc1BhcmVudEFjdGl2ZSA9IHJjYWxsKFwiWlNDT1JFXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgIGlmIHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KSA9PSAwIGFuZCBpc1BhcmVudEFjdGl2ZSB0aGVuXG4gICAgICAgIHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICBsb2NhbCBwYXJlbnRXYWl0S2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdFwiXG4gICAgICAgIGxvY2FsIHBhcmVudFBhdXNlZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBhdXNlZFwiXG4gICAgICAgIGxvY2FsIHBhcmVudE1ldGFLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptZXRhXCJcbiAgICAgICAgbG9jYWwgcGFyZW50TWFya2VyS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWFya2VyXCJcbiAgICAgICAgbG9jYWwgam9iQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcGFyZW50S2V5LCBcInByaW9yaXR5XCIsIFwiZGVsYXlcIilcbiAgICAgICAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzFdKSBvciAwXG4gICAgICAgIGxvY2FsIGRlbGF5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1syXSkgb3IgMFxuICAgICAgICBpZiBkZWxheSA+IDAgdGhlblxuICAgICAgICAgICAgbG9jYWwgZGVsYXllZFRpbWVzdGFtcCA9IHRvbnVtYmVyKHRpbWVzdGFtcCkgKyBkZWxheVxuICAgICAgICAgICAgbG9jYWwgc2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gICAgICAgICAgICBsb2NhbCBwYXJlbnREZWxheWVkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6ZGVsYXllZFwiXG4gICAgICAgICAgICByY2FsbChcIlpBRERcIiwgcGFyZW50RGVsYXllZEtleSwgc2NvcmUsIHBhcmVudElkKVxuICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIixcbiAgICAgICAgICAgICAgICAgIFwiam9iSWRcIiwgcGFyZW50SWQsIFwiZGVsYXlcIiwgZGVsYXllZFRpbWVzdGFtcClcbiAgICAgICAgICAgIGFkZERlbGF5TWFya2VySWZOZWVkZWQocGFyZW50TWFya2VyS2V5LCBwYXJlbnREZWxheWVkS2V5KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgICAgICAgICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGFyZW50UGF1c2VkID1cbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudE1ldGFLZXksIHBhcmVudFdhaXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQYXVzZWRLZXkpXG4gICAgICAgICAgICAgICAgYWRkSm9iSW5UYXJnZXRMaXN0KHBhcmVudFRhcmdldCwgcGFyZW50TWFya2VyS2V5LCBcIlJQVVNIXCIsIGlzUGFyZW50UGF1c2VkLCBwYXJlbnRJZClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2NhbCBpc1BhdXNlZCA9IGlzUXVldWVQYXVzZWQocGFyZW50TWV0YUtleSlcbiAgICAgICAgICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkocGFyZW50TWFya2VyS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwcmlvcml0aXplZFwiLCBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBjXCIsIGlzUGF1c2VkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgICAgICAgICAgICAgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJwcmV2XCIsIFwid2FpdGluZy1jaGlsZHJlblwiKVxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gdXBkYXRlUGFyZW50RGVwc0lmTmVlZGVkKHBhcmVudEtleSwgcGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgcGFyZW50SWQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSwgdGltZXN0YW1wIClcbiAgbG9jYWwgcHJvY2Vzc2VkU2V0ID0gcGFyZW50S2V5IC4uIFwiOnByb2Nlc3NlZFwiXG4gIHJjYWxsKFwiSFNFVFwiLCBwcm9jZXNzZWRTZXQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSlcbiAgbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbmVuZFxubG9jYWwgZnVuY3Rpb24gdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KHBhcmVudEtleSwgcGFyZW50LCBwYXJlbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYklkS2V5LCBqb2JJZCwgdGltZXN0YW1wKVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICBpZiByY2FsbChcIlpTQ09SRVwiLCBjb21wbGV0ZWRLZXksIGpvYklkKSB+PSBmYWxzZSB0aGVuXG4gICAgICAgICAgICBsb2NhbCByZXR1cm52YWx1ZSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JJZEtleSwgXCJyZXR1cm52YWx1ZVwiKVxuICAgICAgICAgICAgdXBkYXRlUGFyZW50RGVwc0lmTmVlZGVkKHBhcmVudEtleSwgcGFyZW50WydxdWV1ZUtleSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50WydpZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYklkS2V5LCByZXR1cm52YWx1ZSwgdGltZXN0YW1wKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBwYXJlbnREZXBlbmRlbmNpZXNLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIlNBRERcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JJZEtleSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJwYXJlbnRLZXlcIiwgcGFyZW50S2V5LCBcInBhcmVudFwiLCBwYXJlbnREYXRhKVxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBoYW5kbGVEdXBsaWNhdGVkSm9iKGpvYktleSwgam9iSWQsIGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsXG4gIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksIG1heEV2ZW50cywgdGltZXN0YW1wKVxuICBsb2NhbCBleGlzdGVkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgaWYgbm90IGV4aXN0ZWRQYXJlbnRLZXkgdGhlblxuICAgIHVwZGF0ZUV4aXN0aW5nSm9ic1BhcmVudChjdXJyZW50UGFyZW50S2V5LCBjdXJyZW50UGFyZW50LCBwYXJlbnREYXRhLFxuICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBjb21wbGV0ZWRLZXksIGpvYktleSxcbiAgICAgIGpvYklkLCB0aW1lc3RhbXApXG4gIGVsc2VcbiAgICBpZiBjdXJyZW50UGFyZW50S2V5IH49IG5pbCBhbmQgY3VycmVudFBhcmVudEtleSB+PSBleGlzdGVkUGFyZW50S2V5XG4gICAgICBhbmQgKHJjYWxsKFwiRVhJU1RTXCIsIGV4aXN0ZWRQYXJlbnRLZXkpID09IDEpIHRoZW5cbiAgICAgIHJldHVybiAtN1xuICAgIGVuZFxuICBlbmRcbiAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIixcbiAgICBcImR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLCBqb2JJZClcbiAgcmV0dXJuIGpvYklkIC4uIFwiXCIgLS0gY29udmVydCB0byBzdHJpbmdcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBzdG9yZSBhIGpvYlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHN0b3JlSm9iKGV2ZW50c0tleSwgam9iSWRLZXksIGpvYklkLCBuYW1lLCBkYXRhLCBvcHRzLCB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZXksIHBhcmVudERhdGEsIHJlcGVhdEpvYktleSlcbiAgICBsb2NhbCBqc29uT3B0cyA9IGNqc29uLmVuY29kZShvcHRzKVxuICAgIGxvY2FsIGRlbGF5ID0gb3B0c1snZGVsYXknXSBvciAwXG4gICAgbG9jYWwgcHJpb3JpdHkgPSBvcHRzWydwcmlvcml0eSddIG9yIDBcbiAgICBsb2NhbCBvcHRpb25hbFZhbHVlcyA9IHt9XG4gICAgaWYgcGFyZW50S2V5IH49IG5pbCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRLZXlcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnRLZXkpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnREYXRhKVxuICAgIGVuZFxuICAgIGlmIHJlcGVhdEpvYktleSB+PSBuaWwgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicmprXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcmVwZWF0Sm9iS2V5KVxuICAgIGVuZFxuICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwibmFtZVwiLCBuYW1lLCBcImRhdGFcIiwgZGF0YSwgXCJvcHRzXCIsIGpzb25PcHRzLFxuICAgICAgICAgIFwidGltZXN0YW1wXCIsIHRpbWVzdGFtcCwgXCJkZWxheVwiLCBkZWxheSwgXCJwcmlvcml0eVwiLCBwcmlvcml0eSxcbiAgICAgICAgICB1bnBhY2sob3B0aW9uYWxWYWx1ZXMpKVxuICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiKlwiLCBcImV2ZW50XCIsIFwiYWRkZWRcIiwgXCJqb2JJZFwiLCBqb2JJZCwgXCJuYW1lXCIsIG5hbWUpXG4gICAgcmV0dXJuIGRlbGF5LCBwcmlvcml0eVxuZW5kXG5pZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICBpZiByY2FsbChcIkVYSVNUU1wiLCBwYXJlbnRLZXkpIH49IDEgdGhlbiByZXR1cm4gLTUgZW5kXG4gICAgcGFyZW50RGF0YSA9IGNqc29uLmVuY29kZShwYXJlbnQpXG5lbmRcbmxvY2FsIGpvYkNvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgaWRLZXkpXG5sb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxubG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gYXJnc1s3XVxubG9jYWwgdGltZXN0YW1wID0gYXJnc1s0XVxuaWYgYXJnc1syXSA9PSBcIlwiIHRoZW5cbiAgICBqb2JJZCA9IGpvYkNvdW50ZXJcbiAgICBqb2JJZEtleSA9IGFyZ3NbMV0gLi4gam9iSWRcbmVsc2VcbiAgICBqb2JJZCA9IGFyZ3NbMl1cbiAgICBqb2JJZEtleSA9IGFyZ3NbMV0gLi4gam9iSWRcbiAgICBpZiByY2FsbChcIkVYSVNUU1wiLCBqb2JJZEtleSkgPT0gMSB0aGVuXG4gICAgICAgIHJldHVybiBoYW5kbGVEdXBsaWNhdGVkSm9iKGpvYklkS2V5LCBqb2JJZCwgcGFyZW50S2V5LCBwYXJlbnQsXG4gICAgICAgICAgICBwYXJlbnREYXRhLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgZXZlbnRzS2V5LFxuICAgICAgICAgICAgbWF4RXZlbnRzLCB0aW1lc3RhbXApXG4gICAgZW5kXG5lbmRcbi0tIFN0b3JlIHRoZSBqb2IuXG5zdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgYXJnc1szXSwgQVJHVlsyXSwgb3B0cywgdGltZXN0YW1wLFxuICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhLCByZXBlYXRKb2JLZXkpXG5sb2NhbCB3YWl0Q2hpbGRyZW5LZXkgPSBhcmdzWzZdXG5yY2FsbChcIlpBRERcIiwgd2FpdENoaWxkcmVuS2V5LCB0aW1lc3RhbXAsIGpvYklkKVxucmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIixcbiAgICAgIFwid2FpdGluZy1jaGlsZHJlblwiLCBcImpvYklkXCIsIGpvYklkKVxuLS0gQ2hlY2sgaWYgdGhpcyBqb2IgaXMgYSBjaGlsZCBvZiBhbm90aGVyIGpvYiwgaWYgc28gYWRkIGl0IHRvIHRoZSBwYXJlbnRzIGRlcGVuZGVuY2llc1xuaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG5lbmRcbnJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG5gO1xuZXhwb3J0IGNvbnN0IGFkZFBhcmVudEpvYiA9IHtcbiAgICBuYW1lOiAnYWRkUGFyZW50Sm9iJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkUGFyZW50Sm9iLTQuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJhZGRQYXJlbnRKb2IiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-7.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-7.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addPrioritizedJob: () => (/* binding */ addPrioritizedJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a priotitized job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'marker',\n      KEYS[2] 'meta'\n      KEYS[3] 'id'\n      KEYS[4] 'prioritized'\n      KEYS[5] 'completed'\n      KEYS[6] events stream key\n      KEYS[7] 'pc' priority counter\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]] \nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal priorityKey = KEYS[4]\nlocal completedKey = KEYS[5]\nlocal eventsKey = KEYS[6]\nlocal priorityCounterKey = KEYS[7]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal repeatJobKey = args[9]\nlocal parent = args[8]\nlocal parentData\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey ~= nil then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to active if needed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey,\n                                        parentKey, parentId, timestamp)\n    local isParentActive = rcall(\"ZSCORE\",\n                                 parentQueueKey .. \":waiting-children\", parentId)\n    if rcall(\"SCARD\", parentDependenciesKey) == 0 and isParentActive then\n        rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId)\n        local parentWaitKey = parentQueueKey .. \":wait\"\n        local parentPausedKey = parentQueueKey .. \":paused\"\n        local parentMetaKey = parentQueueKey .. \":meta\"\n        local parentMarkerKey = parentQueueKey .. \":marker\"\n        local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n        local priority = tonumber(jobAttributes[1]) or 0\n        local delay = tonumber(jobAttributes[2]) or 0\n        if delay > 0 then\n            local delayedTimestamp = tonumber(timestamp) + delay\n            local score = delayedTimestamp * 0x1000\n            local parentDelayedKey = parentQueueKey .. \":delayed\"\n            rcall(\"ZADD\", parentDelayedKey, score, parentId)\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\",\n                  \"jobId\", parentId, \"delay\", delayedTimestamp)\n            addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n        else\n            if priority == 0 then\n                local parentTarget, isParentPaused =\n                    getTargetQueueList(parentMetaKey, parentWaitKey,\n                                       parentPausedKey)\n                addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPaused, parentId)\n            else\n                local isPaused = isQueuePaused(parentMetaKey)\n                addJobWithPriority(parentMarkerKey,\n                                   parentQueueKey .. \":prioritized\", priority,\n                                   parentId, parentQueueKey .. \":pc\", isPaused)\n            end\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\",\n                  \"jobId\", parentId, \"prev\", \"waiting-children\")\n        end\n    end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) ~= false then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\n-- Store the job.\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n                                 opts, timestamp, parentKey, parentData,\n                                 repeatJobKey)\n-- Add the job to the prioritized set\nlocal isPause = isQueuePaused(metaKey)\naddJobWithPriority( KEYS[1], priorityKey, priority, jobId, priorityCounterKey, isPause)\n-- Emit waiting event\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addPrioritizedJob = {\n    name: \"addPrioritizedJob\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=addPrioritizedJob-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUHJpb3JpdGl6ZWRKb2ItNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMlJqQixDQUFDO0FBQ00sTUFBTUMsb0JBQW9CO0lBQzdCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGRQcmlvcml0aXplZEpvYi03LmpzP2M2ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEFkZHMgYSBwcmlvdGl0aXplZCBqb2IgdG8gdGhlIHF1ZXVlIGJ5IGRvaW5nIHRoZSBmb2xsb3dpbmc6XG4gICAgLSBJbmNyZWFzZXMgdGhlIGpvYiBjb3VudGVyIGlmIG5lZWRlZC5cbiAgICAtIENyZWF0ZXMgYSBuZXcgam9iIGtleSB3aXRoIHRoZSBqb2IgZGF0YS5cbiAgICAtIEFkZHMgdGhlIGpvYiB0byB0aGUgXCJhZGRlZFwiIGxpc3Qgc28gdGhhdCB3b3JrZXJzIGdldHMgbm90aWZpZWQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdtYXJrZXInLFxuICAgICAgS0VZU1syXSAnbWV0YSdcbiAgICAgIEtFWVNbM10gJ2lkJ1xuICAgICAgS0VZU1s0XSAncHJpb3JpdGl6ZWQnXG4gICAgICBLRVlTWzVdICdjb21wbGV0ZWQnXG4gICAgICBLRVlTWzZdIGV2ZW50cyBzdHJlYW0ga2V5XG4gICAgICBLRVlTWzddICdwYycgcHJpb3JpdHkgY291bnRlclxuICAgICAgQVJHVlsxXSBtc2dwYWNrZWQgYXJndW1lbnRzIGFycmF5XG4gICAgICAgICAgICBbMV0gIGtleSBwcmVmaXgsXG4gICAgICAgICAgICBbMl0gIGN1c3RvbSBpZCAod2lsbCBub3QgZ2VuZXJhdGUgb25lIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICBbM10gIG5hbWVcbiAgICAgICAgICAgIFs0XSAgdGltZXN0YW1wXG4gICAgICAgICAgICBbNV0gIHBhcmVudEtleT9cbiAgICAgICAgICAgIFs2XSAgd2FpdENoaWxkcmVuS2V5IGtleS5cbiAgICAgICAgICAgIFs3XSAgcGFyZW50IGRlcGVuZGVuY2llcyBrZXkuXG4gICAgICAgICAgICBbOF0gIHBhcmVudD8ge2lkLCBxdWV1ZUtleX1cbiAgICAgICAgICAgIFs5XSAgcmVwZWF0IGpvYiBrZXlcbiAgICAgIEFSR1ZbMl0gSnNvbiBzdHJpbmdpZmllZCBqb2IgZGF0YVxuICAgICAgQVJHVlszXSBtc2dwYWNrZWQgb3B0aW9uc1xuICAgICAgT3V0cHV0OlxuICAgICAgICBqb2JJZCAgLSBPS1xuICAgICAgICAtNSAgICAgLSBNaXNzaW5nIHBhcmVudCBrZXlcbl1dIFxubG9jYWwgbWV0YUtleSA9IEtFWVNbMl1cbmxvY2FsIGlkS2V5ID0gS0VZU1szXVxubG9jYWwgcHJpb3JpdHlLZXkgPSBLRVlTWzRdXG5sb2NhbCBjb21wbGV0ZWRLZXkgPSBLRVlTWzVdXG5sb2NhbCBldmVudHNLZXkgPSBLRVlTWzZdXG5sb2NhbCBwcmlvcml0eUNvdW50ZXJLZXkgPSBLRVlTWzddXG5sb2NhbCBqb2JJZFxubG9jYWwgam9iSWRLZXlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgYXJncyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzFdKVxubG9jYWwgZGF0YSA9IEFSR1ZbMl1cbmxvY2FsIG9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVlszXSlcbmxvY2FsIHBhcmVudEtleSA9IGFyZ3NbNV1cbmxvY2FsIHJlcGVhdEpvYktleSA9IGFyZ3NbOV1cbmxvY2FsIHBhcmVudCA9IGFyZ3NbOF1cbmxvY2FsIHBhcmVudERhdGFcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsIHByaW9yaXR5Q291bnRlcktleSwgaXNQYXVzZWQpXG4gIGxvY2FsIHByaW9Db3VudGVyID0gcmNhbGwoXCJJTkNSXCIsIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgc2NvcmUgPSBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgYml0LmJhbmQocHJpb0NvdW50ZXIsIDB4ZmZmZmZmZmZmZmZmKVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdGl6ZWRLZXksIHNjb3JlLCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gc3RvcmUgYSBqb2Jcbl1dXG5sb2NhbCBmdW5jdGlvbiBzdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgbmFtZSwgZGF0YSwgb3B0cywgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhLCByZXBlYXRKb2JLZXkpXG4gICAgbG9jYWwganNvbk9wdHMgPSBjanNvbi5lbmNvZGUob3B0cylcbiAgICBsb2NhbCBkZWxheSA9IG9wdHNbJ2RlbGF5J10gb3IgMFxuICAgIGxvY2FsIHByaW9yaXR5ID0gb3B0c1sncHJpb3JpdHknXSBvciAwXG4gICAgbG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50S2V5XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50S2V5KVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50RGF0YSlcbiAgICBlbmRcbiAgICBpZiByZXBlYXRKb2JLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInJqa1wiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHJlcGVhdEpvYktleSlcbiAgICBlbmRcbiAgICByY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcIm5hbWVcIiwgbmFtZSwgXCJkYXRhXCIsIGRhdGEsIFwib3B0c1wiLCBqc29uT3B0cyxcbiAgICAgICAgICBcInRpbWVzdGFtcFwiLCB0aW1lc3RhbXAsIFwiZGVsYXlcIiwgZGVsYXksIFwicHJpb3JpdHlcIiwgcHJpb3JpdHksXG4gICAgICAgICAgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbiAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcImFkZGVkXCIsIFwiam9iSWRcIiwgam9iSWQsIFwibmFtZVwiLCBuYW1lKVxuICAgIHJldHVybiBkZWxheSwgcHJpb3JpdHlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gam9iIGlzIGR1cGxpY2F0ZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBwYXJlbnQncyBkZXBlbmRlbmNpZXMgaWYgdGhlIGpvYlxuICAgIGlzIGFscmVhZHkgY29tcGxldGVkIGFuZCBhYm91dCB0byBiZSBpZ25vcmVkLiBUaGUgcGFyZW50IG11c3QgZ2V0IGl0c1xuICAgIGRlcGVuZGVuY2llcyB1cGRhdGVkIHRvIGF2b2lkIHRoZSBwYXJlbnQgam9iIGJlaW5nIHN0dWNrIGZvcmV2ZXIgaW4gXG4gICAgdGhlIHdhaXRpbmctY2hpbGRyZW4gc3RhdGUuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgb3IgYWRkIGRlcGVuZGVuY2llcyB0byBwYXJlbnQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGFjdGl2ZSBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gXG4gICAgICBuZXh0VGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICAgIHJldHVybiBuZXh0VGltZXN0YW1wXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNRdWV1ZVBhdXNlZChxdWV1ZU1ldGFLZXkpXG4gICAgcmV0dXJuIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpID09IDFcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgbG9jYWwgaXNQYXJlbnRBY3RpdmUgPSByY2FsbChcIlpTQ09SRVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICBpZiByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSkgPT0gMCBhbmQgaXNQYXJlbnRBY3RpdmUgdGhlblxuICAgICAgICByY2FsbChcIlpSRU1cIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgcGFyZW50V2FpdEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRcIlxuICAgICAgICBsb2NhbCBwYXJlbnRQYXVzZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwYXVzZWRcIlxuICAgICAgICBsb2NhbCBwYXJlbnRNZXRhS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWV0YVwiXG4gICAgICAgIGxvY2FsIHBhcmVudE1hcmtlcktleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1hcmtlclwiXG4gICAgICAgIGxvY2FsIGpvYkF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHBhcmVudEtleSwgXCJwcmlvcml0eVwiLCBcImRlbGF5XCIpXG4gICAgICAgIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1sxXSkgb3IgMFxuICAgICAgICBsb2NhbCBkZWxheSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMl0pIG9yIDBcbiAgICAgICAgaWYgZGVsYXkgPiAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSB0b251bWJlcih0aW1lc3RhbXApICsgZGVsYXlcbiAgICAgICAgICAgIGxvY2FsIHNjb3JlID0gZGVsYXllZFRpbWVzdGFtcCAqIDB4MTAwMFxuICAgICAgICAgICAgbG9jYWwgcGFyZW50RGVsYXllZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOmRlbGF5ZWRcIlxuICAgICAgICAgICAgcmNhbGwoXCJaQUREXCIsIHBhcmVudERlbGF5ZWRLZXksIHNjb3JlLCBwYXJlbnRJZClcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWxheWVkXCIsXG4gICAgICAgICAgICAgICAgICBcImpvYklkXCIsIHBhcmVudElkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4gICAgICAgICAgICBhZGREZWxheU1hcmtlcklmTmVlZGVkKHBhcmVudE1hcmtlcktleSwgcGFyZW50RGVsYXllZEtleSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgbG9jYWwgcGFyZW50VGFyZ2V0LCBpc1BhcmVudFBhdXNlZCA9XG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRNZXRhS2V5LCBwYXJlbnRXYWl0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UGF1c2VkS2V5KVxuICAgICAgICAgICAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudE1hcmtlcktleSwgXCJSUFVTSFwiLCBpc1BhcmVudFBhdXNlZCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG9jYWwgaXNQYXVzZWQgPSBpc1F1ZXVlUGF1c2VkKHBhcmVudE1ldGFLZXkpXG4gICAgICAgICAgICAgICAgYWRkSm9iV2l0aFByaW9yaXR5KHBhcmVudE1hcmtlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UXVldWVLZXkgLi4gXCI6cHJpb3JpdGl6ZWRcIiwgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwY1wiLCBpc1BhdXNlZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIixcbiAgICAgICAgICAgICAgICAgIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gIHBhcmVudElkLCBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcCApXG4gIGxvY2FsIHByb2Nlc3NlZFNldCA9IHBhcmVudEtleSAuLiBcIjpwcm9jZXNzZWRcIlxuICByY2FsbChcIkhTRVRcIiwgcHJvY2Vzc2VkU2V0LCBqb2JJZEtleSwgcmV0dXJudmFsdWUpXG4gIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZUV4aXN0aW5nSm9ic1BhcmVudChwYXJlbnRLZXksIHBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgam9iSWQsIHRpbWVzdGFtcClcbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgaWYgcmNhbGwoXCJaU0NPUkVcIiwgY29tcGxldGVkS2V5LCBqb2JJZCkgfj0gZmFsc2UgdGhlblxuICAgICAgICAgICAgbG9jYWwgcmV0dXJudmFsdWUgPSByY2FsbChcIkhHRVRcIiwgam9iSWRLZXksIFwicmV0dXJudmFsdWVcIilcbiAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFsncXVldWVLZXknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudFsnaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwicGFyZW50S2V5XCIsIHBhcmVudEtleSwgXCJwYXJlbnRcIiwgcGFyZW50RGF0YSlcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gaGFuZGxlRHVwbGljYXRlZEpvYihqb2JLZXksIGpvYklkLCBjdXJyZW50UGFyZW50S2V5LCBjdXJyZW50UGFyZW50LFxuICBwYXJlbnREYXRhLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgbG9jYWwgZXhpc3RlZFBhcmVudEtleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIpXG4gIGlmIG5vdCBleGlzdGVkUGFyZW50S2V5IHRoZW5cbiAgICB1cGRhdGVFeGlzdGluZ0pvYnNQYXJlbnQoY3VycmVudFBhcmVudEtleSwgY3VycmVudFBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBqb2JLZXksXG4gICAgICBqb2JJZCwgdGltZXN0YW1wKVxuICBlbHNlXG4gICAgaWYgY3VycmVudFBhcmVudEtleSB+PSBuaWwgYW5kIGN1cnJlbnRQYXJlbnRLZXkgfj0gZXhpc3RlZFBhcmVudEtleVxuICAgICAgYW5kIChyY2FsbChcIkVYSVNUU1wiLCBleGlzdGVkUGFyZW50S2V5KSA9PSAxKSB0aGVuXG4gICAgICByZXR1cm4gLTdcbiAgICBlbmRcbiAgZW5kXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsXG4gICAgXCJkdXBsaWNhdGVkXCIsIFwiam9iSWRcIiwgam9iSWQpXG4gIHJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBpZEtleSlcbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksXG4gICAgICAgICAgICBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxuLS0gU3RvcmUgdGhlIGpvYi5cbmxvY2FsIGRlbGF5LCBwcmlvcml0eSA9IHN0b3JlSm9iKGV2ZW50c0tleSwgam9iSWRLZXksIGpvYklkLCBhcmdzWzNdLCBBUkdWWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cywgdGltZXN0YW1wLCBwYXJlbnRLZXksIHBhcmVudERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRKb2JLZXkpXG4tLSBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGl6ZWQgc2V0XG5sb2NhbCBpc1BhdXNlID0gaXNRdWV1ZVBhdXNlZChtZXRhS2V5KVxuYWRkSm9iV2l0aFByaW9yaXR5KCBLRVlTWzFdLCBwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2UpXG4tLSBFbWl0IHdhaXRpbmcgZXZlbnRcbnJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgXCJqb2JJZFwiLCBqb2JJZClcbi0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGEgY2hpbGQgb2YgYW5vdGhlciBqb2IsIGlmIHNvIGFkZCBpdCB0byB0aGUgcGFyZW50cyBkZXBlbmRlbmNpZXNcbmlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbmV4cG9ydCBjb25zdCBhZGRQcmlvcml0aXplZEpvYiA9IHtcbiAgICBuYW1lOiAnYWRkUHJpb3JpdGl6ZWRKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRQcmlvcml0aXplZEpvYi03LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwiYWRkUHJpb3JpdGl6ZWRKb2IiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-7.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addStandardJob-7.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addStandardJob: () => (/* binding */ addStandardJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event 'delayed' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'wait',\n      KEYS[2] 'paused'\n      KEYS[3] 'meta'\n      KEYS[4] 'id'\n      KEYS[5] 'completed'\n      KEYS[6] events stream key\n      KEYS[7] marker key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal eventsKey = KEYS[6]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal repeatJobKey = args[9]\nlocal parent = args[8]\nlocal parentData\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to active if needed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey,\n                                        parentKey, parentId, timestamp)\n    local isParentActive = rcall(\"ZSCORE\",\n                                 parentQueueKey .. \":waiting-children\", parentId)\n    if rcall(\"SCARD\", parentDependenciesKey) == 0 and isParentActive then\n        rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId)\n        local parentWaitKey = parentQueueKey .. \":wait\"\n        local parentPausedKey = parentQueueKey .. \":paused\"\n        local parentMetaKey = parentQueueKey .. \":meta\"\n        local parentMarkerKey = parentQueueKey .. \":marker\"\n        local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n        local priority = tonumber(jobAttributes[1]) or 0\n        local delay = tonumber(jobAttributes[2]) or 0\n        if delay > 0 then\n            local delayedTimestamp = tonumber(timestamp) + delay\n            local score = delayedTimestamp * 0x1000\n            local parentDelayedKey = parentQueueKey .. \":delayed\"\n            rcall(\"ZADD\", parentDelayedKey, score, parentId)\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\",\n                  \"jobId\", parentId, \"delay\", delayedTimestamp)\n            addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n        else\n            if priority == 0 then\n                local parentTarget, isParentPaused =\n                    getTargetQueueList(parentMetaKey, parentWaitKey,\n                                       parentPausedKey)\n                addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPaused, parentId)\n            else\n                local isPaused = isQueuePaused(parentMetaKey)\n                addJobWithPriority(parentMarkerKey,\n                                   parentQueueKey .. \":prioritized\", priority,\n                                   parentId, parentQueueKey .. \":pc\", isPaused)\n            end\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\",\n                  \"jobId\", parentId, \"prev\", \"waiting-children\")\n        end\n    end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) ~= false then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey ~= nil then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", KEYS[4])\nlocal metaKey = KEYS[3]\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, KEYS[5], eventsKey,\n            maxEvents, timestamp)\n    end\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal target, paused = getTargetQueueList(metaKey, KEYS[1], KEYS[2])\n-- LIFO or FIFO\nlocal pushCmd = opts['lifo'] and 'RPUSH' or 'LPUSH'\naddJobInTargetList(target, KEYS[7], pushCmd, paused, jobId)\n-- Emit waiting event\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addStandardJob = {\n    name: \"addStandardJob\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=addStandardJob-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkU3RhbmRhcmRKb2ItNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnU2pCLENBQUM7QUFDTSxNQUFNQyxpQkFBaUI7SUFDMUJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2FkZFN0YW5kYXJkSm9iLTcuanM/NzIyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkcyBhIGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIEluY3JlYXNlcyB0aGUgam9iIGNvdW50ZXIgaWYgbmVlZGVkLlxuICAgIC0gQ3JlYXRlcyBhIG5ldyBqb2Iga2V5IHdpdGggdGhlIGpvYiBkYXRhLlxuICAgIC0gaWYgZGVsYXllZDpcbiAgICAgIC0gY29tcHV0ZXMgdGltZXN0YW1wLlxuICAgICAgLSBhZGRzIHRvIGRlbGF5ZWQgenNldC5cbiAgICAgIC0gRW1pdHMgYSBnbG9iYWwgZXZlbnQgJ2RlbGF5ZWQnIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbiAgICAtIGlmIG5vdCBkZWxheWVkXG4gICAgICAtIEFkZHMgdGhlIGpvYklkIHRvIHRoZSB3YWl0L3BhdXNlZCBsaXN0IGluIG9uZSBvZiB0aHJlZSB3YXlzOlxuICAgICAgICAgLSBMSUZPXG4gICAgICAgICAtIEZJRk9cbiAgICAgICAgIC0gcHJpb3JpdGl6ZWQuXG4gICAgICAtIEFkZHMgdGhlIGpvYiB0byB0aGUgXCJhZGRlZFwiIGxpc3Qgc28gdGhhdCB3b3JrZXJzIGdldHMgbm90aWZpZWQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICd3YWl0JyxcbiAgICAgIEtFWVNbMl0gJ3BhdXNlZCdcbiAgICAgIEtFWVNbM10gJ21ldGEnXG4gICAgICBLRVlTWzRdICdpZCdcbiAgICAgIEtFWVNbNV0gJ2NvbXBsZXRlZCdcbiAgICAgIEtFWVNbNl0gZXZlbnRzIHN0cmVhbSBrZXlcbiAgICAgIEtFWVNbN10gbWFya2VyIGtleVxuICAgICAgQVJHVlsxXSBtc2dwYWNrZWQgYXJndW1lbnRzIGFycmF5XG4gICAgICAgICAgICBbMV0gIGtleSBwcmVmaXgsXG4gICAgICAgICAgICBbMl0gIGN1c3RvbSBpZCAod2lsbCBub3QgZ2VuZXJhdGUgb25lIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICBbM10gIG5hbWVcbiAgICAgICAgICAgIFs0XSAgdGltZXN0YW1wXG4gICAgICAgICAgICBbNV0gIHBhcmVudEtleT9cbiAgICAgICAgICAgIFs2XSAgd2FpdENoaWxkcmVuS2V5IGtleS5cbiAgICAgICAgICAgIFs3XSAgcGFyZW50IGRlcGVuZGVuY2llcyBrZXkuXG4gICAgICAgICAgICBbOF0gIHBhcmVudD8ge2lkLCBxdWV1ZUtleX1cbiAgICAgICAgICAgIFs5XSAgcmVwZWF0IGpvYiBrZXlcbiAgICAgIEFSR1ZbMl0gSnNvbiBzdHJpbmdpZmllZCBqb2IgZGF0YVxuICAgICAgQVJHVlszXSBtc2dwYWNrZWQgb3B0aW9uc1xuICAgICAgT3V0cHV0OlxuICAgICAgICBqb2JJZCAgLSBPS1xuICAgICAgICAtNSAgICAgLSBNaXNzaW5nIHBhcmVudCBrZXlcbl1dXG5sb2NhbCBldmVudHNLZXkgPSBLRVlTWzZdXG5sb2NhbCBqb2JJZFxubG9jYWwgam9iSWRLZXlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgYXJncyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzFdKVxubG9jYWwgZGF0YSA9IEFSR1ZbMl1cbmxvY2FsIG9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVlszXSlcbmxvY2FsIHBhcmVudEtleSA9IGFyZ3NbNV1cbmxvY2FsIHJlcGVhdEpvYktleSA9IGFyZ3NbOV1cbmxvY2FsIHBhcmVudCA9IGFyZ3NbOF1cbmxvY2FsIHBhcmVudERhdGFcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICAgIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgICAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gICAgZW5kXG4gICAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gam9iIGlzIGR1cGxpY2F0ZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBwYXJlbnQncyBkZXBlbmRlbmNpZXMgaWYgdGhlIGpvYlxuICAgIGlzIGFscmVhZHkgY29tcGxldGVkIGFuZCBhYm91dCB0byBiZSBpZ25vcmVkLiBUaGUgcGFyZW50IG11c3QgZ2V0IGl0c1xuICAgIGRlcGVuZGVuY2llcyB1cGRhdGVkIHRvIGF2b2lkIHRoZSBwYXJlbnQgam9iIGJlaW5nIHN0dWNrIGZvcmV2ZXIgaW4gXG4gICAgdGhlIHdhaXRpbmctY2hpbGRyZW4gc3RhdGUuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgb3IgYWRkIGRlcGVuZGVuY2llcyB0byBwYXJlbnQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGFjdGl2ZSBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gXG4gICAgICBuZXh0VGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICAgIHJldHVybiBuZXh0VGltZXN0YW1wXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHNjb3JlID0gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIGJpdC5iYW5kKHByaW9Db3VudGVyLCAweGZmZmZmZmZmZmZmZilcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNRdWV1ZVBhdXNlZChxdWV1ZU1ldGFLZXkpXG4gICAgcmV0dXJuIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpID09IDFcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICAgIGxvY2FsIGlzUGFyZW50QWN0aXZlID0gcmNhbGwoXCJaU0NPUkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgaWYgcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpID09IDAgYW5kIGlzUGFyZW50QWN0aXZlIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIHBhcmVudFdhaXRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0XCJcbiAgICAgICAgbG9jYWwgcGFyZW50UGF1c2VkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6cGF1c2VkXCJcbiAgICAgICAgbG9jYWwgcGFyZW50TWV0YUtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1ldGFcIlxuICAgICAgICBsb2NhbCBwYXJlbnRNYXJrZXJLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptYXJrZXJcIlxuICAgICAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgICAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMV0pIG9yIDBcbiAgICAgICAgbG9jYWwgZGVsYXkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzJdKSBvciAwXG4gICAgICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gdG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5XG4gICAgICAgICAgICBsb2NhbCBzY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgICAgICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwYXJlbnREZWxheWVkS2V5LCBzY29yZSwgcGFyZW50SWQpXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLFxuICAgICAgICAgICAgICAgICAgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLCBkZWxheWVkVGltZXN0YW1wKVxuICAgICAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWQgPVxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50TWV0YUtleSwgcGFyZW50V2FpdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdXNlZEtleSlcbiAgICAgICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWQsIHBhcmVudElkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIGlzUGF1c2VkID0gaXNRdWV1ZVBhdXNlZChwYXJlbnRNZXRhS2V5KVxuICAgICAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShwYXJlbnRNYXJrZXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnByaW9yaXRpemVkXCIsIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCwgcGFyZW50UXVldWVLZXkgLi4gXCI6cGNcIiwgaXNQYXVzZWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgICAgICAgICBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVQYXJlbnREZXBzSWZOZWVkZWQocGFyZW50S2V5LCBwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LFxuICBwYXJlbnRJZCwgam9iSWRLZXksIHJldHVybnZhbHVlLCB0aW1lc3RhbXAgKVxuICBsb2NhbCBwcm9jZXNzZWRTZXQgPSBwYXJlbnRLZXkgLi4gXCI6cHJvY2Vzc2VkXCJcbiAgcmNhbGwoXCJIU0VUXCIsIHByb2Nlc3NlZFNldCwgam9iSWRLZXksIHJldHVybnZhbHVlKVxuICBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVFeGlzdGluZ0pvYnNQYXJlbnQocGFyZW50S2V5LCBwYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBjb21wbGV0ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9iSWRLZXksIGpvYklkLCB0aW1lc3RhbXApXG4gICAgaWYgcGFyZW50S2V5IH49IG5pbCB0aGVuXG4gICAgICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIGNvbXBsZXRlZEtleSwgam9iSWQpIH49IGZhbHNlIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHJldHVybnZhbHVlID0gcmNhbGwoXCJIR0VUXCIsIGpvYklkS2V5LCBcInJldHVybnZhbHVlXCIpXG4gICAgICAgICAgICB1cGRhdGVQYXJlbnREZXBzSWZOZWVkZWQocGFyZW50S2V5LCBwYXJlbnRbJ3F1ZXVlS2V5J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRbJ2lkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9iSWRLZXksIHJldHVybnZhbHVlLCB0aW1lc3RhbXApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICByY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcInBhcmVudEtleVwiLCBwYXJlbnRLZXksIFwicGFyZW50XCIsIHBhcmVudERhdGEpXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iS2V5LCBqb2JJZCwgY3VycmVudFBhcmVudEtleSwgY3VycmVudFBhcmVudCxcbiAgcGFyZW50RGF0YSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBjb21wbGV0ZWRLZXksIGV2ZW50c0tleSwgbWF4RXZlbnRzLCB0aW1lc3RhbXApXG4gIGxvY2FsIGV4aXN0ZWRQYXJlbnRLZXkgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiKVxuICBpZiBub3QgZXhpc3RlZFBhcmVudEtleSB0aGVuXG4gICAgdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgam9iS2V5LFxuICAgICAgam9iSWQsIHRpbWVzdGFtcClcbiAgZWxzZVxuICAgIGlmIGN1cnJlbnRQYXJlbnRLZXkgfj0gbmlsIGFuZCBjdXJyZW50UGFyZW50S2V5IH49IGV4aXN0ZWRQYXJlbnRLZXlcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgZXhpc3RlZFBhcmVudEtleSkgPT0gMSkgdGhlblxuICAgICAgcmV0dXJuIC03XG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLFxuICAgIFwiZHVwbGljYXRlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHN0b3JlIGEgam9iXG5dXVxubG9jYWwgZnVuY3Rpb24gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIG5hbWUsIGRhdGEsIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuICAgIGxvY2FsIGpzb25PcHRzID0gY2pzb24uZW5jb2RlKG9wdHMpXG4gICAgbG9jYWwgZGVsYXkgPSBvcHRzWydkZWxheSddIG9yIDBcbiAgICBsb2NhbCBwcmlvcml0eSA9IG9wdHNbJ3ByaW9yaXR5J10gb3IgMFxuICAgIGxvY2FsIG9wdGlvbmFsVmFsdWVzID0ge31cbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudEtleVwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudEtleSlcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudERhdGEpXG4gICAgZW5kXG4gICAgaWYgcmVwZWF0Sm9iS2V5IH49IG5pbCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJyamtcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCByZXBlYXRKb2JLZXkpXG4gICAgZW5kXG4gICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJuYW1lXCIsIG5hbWUsIFwiZGF0YVwiLCBkYXRhLCBcIm9wdHNcIiwganNvbk9wdHMsXG4gICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgdGltZXN0YW1wLCBcImRlbGF5XCIsIGRlbGF5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5LFxuICAgICAgICAgIHVucGFjayhvcHRpb25hbFZhbHVlcykpXG4gICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhZGRlZFwiLCBcImpvYklkXCIsIGpvYklkLCBcIm5hbWVcIiwgbmFtZSlcbiAgICByZXR1cm4gZGVsYXksIHByaW9yaXR5XG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBLRVlTWzRdKVxubG9jYWwgbWV0YUtleSA9IEtFWVNbM11cbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgS0VZU1s1XSwgZXZlbnRzS2V5LFxuICAgICAgICAgICAgbWF4RXZlbnRzLCB0aW1lc3RhbXApXG4gICAgZW5kXG5lbmRcbi0tIFN0b3JlIHRoZSBqb2IuXG5zdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgYXJnc1szXSwgQVJHVlsyXSwgb3B0cywgdGltZXN0YW1wLFxuICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhLCByZXBlYXRKb2JLZXkpXG5sb2NhbCB0YXJnZXQsIHBhdXNlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChtZXRhS2V5LCBLRVlTWzFdLCBLRVlTWzJdKVxuLS0gTElGTyBvciBGSUZPXG5sb2NhbCBwdXNoQ21kID0gb3B0c1snbGlmbyddIGFuZCAnUlBVU0gnIG9yICdMUFVTSCdcbmFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIEtFWVNbN10sIHB1c2hDbWQsIHBhdXNlZCwgam9iSWQpXG4tLSBFbWl0IHdhaXRpbmcgZXZlbnRcbnJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgXCJqb2JJZFwiLCBqb2JJZClcbi0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGEgY2hpbGQgb2YgYW5vdGhlciBqb2IsIGlmIHNvIGFkZCBpdCB0byB0aGUgcGFyZW50cyBkZXBlbmRlbmNpZXNcbmlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbmV4cG9ydCBjb25zdCBhZGRTdGFuZGFyZEpvYiA9IHtcbiAgICBuYW1lOiAnYWRkU3RhbmRhcmRKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRTdGFuZGFyZEpvYi03LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwiYWRkU3RhbmRhcmRKb2IiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeDelay: () => (/* binding */ changeDelay)\n/* harmony export */ });\nconst content = `--[[\n  Change job delay when it is in delayed set.\n  Input:\n    KEYS[1] delayed key\n    KEYS[2] meta key\n    KEYS[3] marker key\n    KEYS[4] events stream\n    ARGV[1] delay\n    ARGV[2] delayedTimestamp\n    ARGV[3] the id of the job\n    ARGV[4] job key\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in delayed set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\nif rcall(\"EXISTS\", ARGV[4]) == 1 then\n  local jobId = ARGV[3]\n  local score = tonumber(ARGV[2])\n  local delayedTimestamp = (score / 0x1000)\n  local numRemovedElements = rcall(\"ZREM\", KEYS[1], jobId)\n  if numRemovedElements < 1 then\n    return -3\n  end\n  rcall(\"HSET\", ARGV[4], \"delay\", tonumber(ARGV[1]))\n  rcall(\"ZADD\", KEYS[1], score, jobId)\n  local maxEvents = getOrSetMaxEvents(KEYS[2])\n  rcall(\"XADD\", KEYS[4], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n    \"jobId\", jobId, \"delay\", delayedTimestamp)\n  -- mark that a delayed job is available\n  local isPaused = isQueuePaused(KEYS[2])\n  if not isPaused then\n    addDelayMarkerIfNeeded(KEYS[3], KEYS[1])\n  end\n  return 0\nelse\n  return -1\nend`;\nconst changeDelay = {\n    name: \"changeDelay\",\n    content,\n    keys: 4\n}; //# sourceMappingURL=changeDelay-4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlRGVsYXktNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvRmQsQ0FBQztBQUNHLE1BQU1DLGNBQWM7SUFDdkJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2NoYW5nZURlbGF5LTQuanM/NWEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQ2hhbmdlIGpvYiBkZWxheSB3aGVuIGl0IGlzIGluIGRlbGF5ZWQgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGRlbGF5ZWQga2V5XG4gICAgS0VZU1syXSBtZXRhIGtleVxuICAgIEtFWVNbM10gbWFya2VyIGtleVxuICAgIEtFWVNbNF0gZXZlbnRzIHN0cmVhbVxuICAgIEFSR1ZbMV0gZGVsYXlcbiAgICBBUkdWWzJdIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICBBUkdWWzNdIHRoZSBpZCBvZiB0aGUgam9iXG4gICAgQVJHVls0XSBqb2Iga2V5XG4gIE91dHB1dDpcbiAgICAwIC0gT0tcbiAgIC0xIC0gTWlzc2luZyBqb2IuXG4gICAtMyAtIEpvYiBub3QgaW4gZGVsYXllZCBzZXQuXG4gIEV2ZW50czpcbiAgICAtIGRlbGF5ZWQga2V5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gXG4gICAgICBuZXh0VGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICAgIHJldHVybiBuZXh0VGltZXN0YW1wXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkKHF1ZXVlTWV0YUtleSlcbiAgICByZXR1cm4gcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgPT0gMVxuZW5kXG5pZiByY2FsbChcIkVYSVNUU1wiLCBBUkdWWzRdKSA9PSAxIHRoZW5cbiAgbG9jYWwgam9iSWQgPSBBUkdWWzNdXG4gIGxvY2FsIHNjb3JlID0gdG9udW1iZXIoQVJHVlsyXSlcbiAgbG9jYWwgZGVsYXllZFRpbWVzdGFtcCA9IChzY29yZSAvIDB4MTAwMClcbiAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIGpvYklkKVxuICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPCAxIHRoZW5cbiAgICByZXR1cm4gLTNcbiAgZW5kXG4gIHJjYWxsKFwiSFNFVFwiLCBBUkdWWzRdLCBcImRlbGF5XCIsIHRvbnVtYmVyKEFSR1ZbMV0pKVxuICByY2FsbChcIlpBRERcIiwgS0VZU1sxXSwgc2NvcmUsIGpvYklkKVxuICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhLRVlTWzJdKVxuICByY2FsbChcIlhBRERcIiwgS0VZU1s0XSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWxheWVkXCIsXG4gICAgXCJqb2JJZFwiLCBqb2JJZCwgXCJkZWxheVwiLCBkZWxheWVkVGltZXN0YW1wKVxuICAtLSBtYXJrIHRoYXQgYSBkZWxheWVkIGpvYiBpcyBhdmFpbGFibGVcbiAgbG9jYWwgaXNQYXVzZWQgPSBpc1F1ZXVlUGF1c2VkKEtFWVNbMl0pXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChLRVlTWzNdLCBLRVlTWzFdKVxuICBlbmRcbiAgcmV0dXJuIDBcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRgO1xuZXhwb3J0IGNvbnN0IGNoYW5nZURlbGF5ID0ge1xuICAgIG5hbWU6ICdjaGFuZ2VEZWxheScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZURlbGF5LTQuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJjaGFuZ2VEZWxheSIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-6.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/changePriority-6.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changePriority: () => (/* binding */ changePriority)\n/* harmony export */ });\nconst content = `--[[\n  Change job priority\n  Input:\n    KEYS[1] 'wait',\n    KEYS[2] 'paused'\n    KEYS[3] 'meta'\n    KEYS[4] 'prioritized'\n    KEYS[5] 'pc' priority counter\n    KEYS[6] 'marker'\n    ARGV[1] priority value\n    ARGV[2] job key\n    ARGV[3] job id\n    ARGV[4] lifo\n    Output:\n       0  - OK\n      -1  - Missing job\n]]\nlocal jobKey = ARGV[2]\nlocal jobId = ARGV[3]\nlocal priority = tonumber(ARGV[1])\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\nif rcall(\"EXISTS\", jobKey) == 1 then\n    local metaKey = KEYS[3]\n    local isPaused = isQueuePaused(metaKey)\n    local markerKey = KEYS[6]\n    local prioritizedKey = KEYS[4]\n    -- Re-add with the new priority\n    if rcall(\"ZREM\", KEYS[4], jobId) > 0 then\n        addJobWithPriority(markerKey, prioritizedKey, priority, jobId, KEYS[5],\n                           isPaused)\n        -- If the new priority is 0, then just leave the job where it is in the wait list.\n    elseif priority > 0 then\n        -- Job is already in the wait list, we need to re-add it with the new priority.\n        local target = isPaused and KEYS[2] or KEYS[1]\n        local numRemovedElements = rcall(\"LREM\", target, -1, jobId)\n        if numRemovedElements > 0 then\n            addJobWithPriority(markerKey, prioritizedKey, priority, jobId,\n                               KEYS[5], isPaused)\n        end\n    end\n    rcall(\"HSET\", jobKey, \"priority\", priority)\n    return 0\nelse\n    return -1\nend\n`;\nconst changePriority = {\n    name: \"changePriority\",\n    content,\n    keys: 6\n}; //# sourceMappingURL=changePriority-6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlUHJpb3JpdHktNi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVFakIsQ0FBQztBQUNNLE1BQU1DLGlCQUFpQjtJQUMxQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlUHJpb3JpdHktNi5qcz9iOWVjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGFuZ2Ugam9iIHByaW9yaXR5XG4gIElucHV0OlxuICAgIEtFWVNbMV0gJ3dhaXQnLFxuICAgIEtFWVNbMl0gJ3BhdXNlZCdcbiAgICBLRVlTWzNdICdtZXRhJ1xuICAgIEtFWVNbNF0gJ3ByaW9yaXRpemVkJ1xuICAgIEtFWVNbNV0gJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgS0VZU1s2XSAnbWFya2VyJ1xuICAgIEFSR1ZbMV0gcHJpb3JpdHkgdmFsdWVcbiAgICBBUkdWWzJdIGpvYiBrZXlcbiAgICBBUkdWWzNdIGpvYiBpZFxuICAgIEFSR1ZbNF0gbGlmb1xuICAgIE91dHB1dDpcbiAgICAgICAwICAtIE9LXG4gICAgICAtMSAgLSBNaXNzaW5nIGpvYlxuXV1cbmxvY2FsIGpvYktleSA9IEFSR1ZbMl1cbmxvY2FsIGpvYklkID0gQVJHVlszXVxubG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzUXVldWVQYXVzZWQocXVldWVNZXRhS2V5KVxuICAgIHJldHVybiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSA9PSAxXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBiaXQuYmFuZChwcmlvQ291bnRlciwgMHhmZmZmZmZmZmZmZmYpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgam9iS2V5KSA9PSAxIHRoZW5cbiAgICBsb2NhbCBtZXRhS2V5ID0gS0VZU1szXVxuICAgIGxvY2FsIGlzUGF1c2VkID0gaXNRdWV1ZVBhdXNlZChtZXRhS2V5KVxuICAgIGxvY2FsIG1hcmtlcktleSA9IEtFWVNbNl1cbiAgICBsb2NhbCBwcmlvcml0aXplZEtleSA9IEtFWVNbNF1cbiAgICAtLSBSZS1hZGQgd2l0aCB0aGUgbmV3IHByaW9yaXR5XG4gICAgaWYgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNF0sIGpvYklkKSA+IDAgdGhlblxuICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBLRVlTWzVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXVzZWQpXG4gICAgICAgIC0tIElmIHRoZSBuZXcgcHJpb3JpdHkgaXMgMCwgdGhlbiBqdXN0IGxlYXZlIHRoZSBqb2Igd2hlcmUgaXQgaXMgaW4gdGhlIHdhaXQgbGlzdC5cbiAgICBlbHNlaWYgcHJpb3JpdHkgPiAwIHRoZW5cbiAgICAgICAgLS0gSm9iIGlzIGFscmVhZHkgaW4gdGhlIHdhaXQgbGlzdCwgd2UgbmVlZCB0byByZS1hZGQgaXQgd2l0aCB0aGUgbmV3IHByaW9yaXR5LlxuICAgICAgICBsb2NhbCB0YXJnZXQgPSBpc1BhdXNlZCBhbmQgS0VZU1syXSBvciBLRVlTWzFdXG4gICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCB0YXJnZXQsIC0xLCBqb2JJZClcbiAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID4gMCB0aGVuXG4gICAgICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtFWVNbNV0sIGlzUGF1c2VkKVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5KVxuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgY2hhbmdlUHJpb3JpdHkgPSB7XG4gICAgbmFtZTogJ2NoYW5nZVByaW9yaXR5JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDYsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlUHJpb3JpdHktNi5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsImNoYW5nZVByaW9yaXR5IiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-2.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-2.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanJobsInSet: () => (/* binding */ cleanJobsInSet)\n/* harmony export */ });\nconst content = `--[[\n  Remove jobs from the specific set.\n  Input:\n    KEYS[1]  set key,\n    KEYS[2]  events stream key\n    ARGV[1]  jobKey prefix\n    ARGV[2]  timestamp\n    ARGV[3]  limit the number of jobs to be removed. 0 is unlimited\n    ARGV[4]  set name, can be any of 'wait', 'active', 'paused', 'delayed', 'completed', or 'failed'\n]]\nlocal rcall = redis.call\nlocal rangeStart = 0\nlocal rangeEnd = -1\nlocal limit = tonumber(ARGV[3])\n-- If we're only deleting _n_ items, avoid retrieving all items\n-- for faster performance\n--\n-- Start from the tail of the list, since that's where oldest elements\n-- are generally added for FIFO lists\nif limit > 0 then\n  rangeStart = -1 - limit + 1\n  rangeEnd = -1\nend\n-- Includes\n--[[\n  Function to clean job list.\n  Returns jobIds and deleted count number.\n]]\n-- Includes\n--[[\n  Function to get the latest saved timestamp.\n]]\nlocal function getTimestamp(jobKey, attributes)\n  if #attributes == 1 then\n    return rcall(\"HGET\", jobKey, attributes[1])\n  end\n  local jobTs\n  for _, ts in ipairs(rcall(\"HMGET\", jobKey, unpack(attributes))) do\n    if (ts) then\n      jobTs = ts\n      break\n    end\n  end\n  return jobTs\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  removeJobKeys(jobKey)\nend\nlocal function cleanList(listKey, jobKeyPrefix, rangeStart, rangeEnd,\n  timestamp, isWaiting)\n  local jobs = rcall(\"LRANGE\", listKey, rangeStart, rangeEnd)\n  local deleted = {}\n  local deletedCount = 0\n  local jobTS\n  local deletionMarker = ''\n  local jobIdsLen = #jobs\n  for i, job in ipairs(jobs) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = jobKeyPrefix .. job\n    if (isWaiting or rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n      -- Find the right timestamp of the job to compare to maxTimestamp:\n      -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n      -- * processedOn represents when the job was last attempted, but it doesn't get populated until\n      --   the job is first tried\n      -- * timestamp is the original job submission time\n      -- Fetch all three of these (in that order) and use the first one that is set so that we'll leave jobs\n      -- that have been active within the grace period:\n      jobTS = getTimestamp(jobKey, {\"finishedOn\", \"processedOn\", \"timestamp\"})\n      if (not jobTS or jobTS <= timestamp) then\n        -- replace the entry with a deletion marker; the actual deletion will\n        -- occur at the end of the script\n        rcall(\"LSET\", listKey, rangeEnd - jobIdsLen + i, deletionMarker)\n        removeJob(job, true, jobKeyPrefix)\n        deletedCount = deletedCount + 1\n        table.insert(deleted, job)\n      end\n    end\n  end\n  rcall(\"LREM\", listKey, 0, deletionMarker)\n  return {deleted, deletedCount}\nend\n--[[\n  Function to clean job set.\n  Returns jobIds and deleted count number.\n]]\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  We use ZRANGEBYSCORE to make the case where we're deleting a limited number\n  of items in a sorted set only run a single iteration. If we simply used\n  ZRANGE, we may take a long time traversing through jobs that are within the\n  grace period.\n]]\nlocal function getJobsInZset(zsetKey, rangeEnd, limit)\n  if limit > 0 then\n    return rcall(\"ZRANGEBYSCORE\", zsetKey, 0, rangeEnd, \"LIMIT\", 0, limit)\n  else\n    return rcall(\"ZRANGEBYSCORE\", zsetKey, 0, rangeEnd)\n  end\nend\nlocal function cleanSet(setKey, jobKeyPrefix, rangeEnd, timestamp, limit, attributes, isFinished)\n  local jobs = getJobsInZset(setKey, rangeEnd, limit)\n  local deleted = {}\n  local deletedCount = 0\n  local jobTS\n  for i, job in ipairs(jobs) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = jobKeyPrefix .. job\n    if isFinished then\n      removeJob(job, true, jobKeyPrefix)\n      deletedCount = deletedCount + 1\n      table.insert(deleted, job)\n    else\n      -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n      jobTS = getTimestamp(jobKey, attributes)\n      if (not jobTS or jobTS <= timestamp) then\n        removeJob(job, true, jobKeyPrefix)\n        deletedCount = deletedCount + 1\n        table.insert(deleted, job)\n      end\n    end\n  end\n  if(#deleted > 0) then\n    for from, to in batches(#deleted, 7000) do\n      rcall(\"ZREM\", setKey, unpack(deleted, from, to))\n    end\n  end\n  return {deleted, deletedCount}\nend\nlocal result\nif ARGV[4] == \"active\" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], false)\nelseif ARGV[4] == \"delayed\" then\n  rangeEnd = \"+inf\"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"processedOn\", \"timestamp\"}, false)\nelseif ARGV[4] == \"prioritized\" then\n  rangeEnd = \"+inf\"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"timestamp\"}, false)\nelseif ARGV[4] == \"wait\" or ARGV[4] == \"paused\" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], true)\nelse\n  rangeEnd = ARGV[2]\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"finishedOn\"}, true)\nend\nrcall(\"XADD\", KEYS[2], \"*\", \"event\", \"cleaned\", \"count\", result[2])\nreturn result[1]\n`;\nconst cleanJobsInSet = {\n    name: \"cleanJobsInSet\",\n    content,\n    keys: 2\n}; //# sourceMappingURL=cleanJobsInSet-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2xlYW5Kb2JzSW5TZXQtMi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaVNqQixDQUFDO0FBQ00sTUFBTUMsaUJBQWlCO0lBQzFCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9jbGVhbkpvYnNJblNldC0yLmpzPzA2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFJlbW92ZSBqb2JzIGZyb20gdGhlIHNwZWNpZmljIHNldC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAgc2V0IGtleSxcbiAgICBLRVlTWzJdICBldmVudHMgc3RyZWFtIGtleVxuICAgIEFSR1ZbMV0gIGpvYktleSBwcmVmaXhcbiAgICBBUkdWWzJdICB0aW1lc3RhbXBcbiAgICBBUkdWWzNdICBsaW1pdCB0aGUgbnVtYmVyIG9mIGpvYnMgdG8gYmUgcmVtb3ZlZC4gMCBpcyB1bmxpbWl0ZWRcbiAgICBBUkdWWzRdICBzZXQgbmFtZSwgY2FuIGJlIGFueSBvZiAnd2FpdCcsICdhY3RpdmUnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAnY29tcGxldGVkJywgb3IgJ2ZhaWxlZCdcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJhbmdlU3RhcnQgPSAwXG5sb2NhbCByYW5nZUVuZCA9IC0xXG5sb2NhbCBsaW1pdCA9IHRvbnVtYmVyKEFSR1ZbM10pXG4tLSBJZiB3ZSdyZSBvbmx5IGRlbGV0aW5nIF9uXyBpdGVtcywgYXZvaWQgcmV0cmlldmluZyBhbGwgaXRlbXNcbi0tIGZvciBmYXN0ZXIgcGVyZm9ybWFuY2Vcbi0tXG4tLSBTdGFydCBmcm9tIHRoZSB0YWlsIG9mIHRoZSBsaXN0LCBzaW5jZSB0aGF0J3Mgd2hlcmUgb2xkZXN0IGVsZW1lbnRzXG4tLSBhcmUgZ2VuZXJhbGx5IGFkZGVkIGZvciBGSUZPIGxpc3RzXG5pZiBsaW1pdCA+IDAgdGhlblxuICByYW5nZVN0YXJ0ID0gLTEgLSBsaW1pdCArIDFcbiAgcmFuZ2VFbmQgPSAtMVxuZW5kXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBjbGVhbiBqb2IgbGlzdC5cbiAgUmV0dXJucyBqb2JJZHMgYW5kIGRlbGV0ZWQgY291bnQgbnVtYmVyLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCB0aGUgbGF0ZXN0IHNhdmVkIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUaW1lc3RhbXAoam9iS2V5LCBhdHRyaWJ1dGVzKVxuICBpZiAjYXR0cmlidXRlcyA9PSAxIHRoZW5cbiAgICByZXR1cm4gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgYXR0cmlidXRlc1sxXSlcbiAgZW5kXG4gIGxvY2FsIGpvYlRzXG4gIGZvciBfLCB0cyBpbiBpcGFpcnMocmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIHVucGFjayhhdHRyaWJ1dGVzKSkpIGRvXG4gICAgaWYgKHRzKSB0aGVuXG4gICAgICBqb2JUcyA9IHRzXG4gICAgICBicmVha1xuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGpvYlRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLFxuICAgIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcpXG5lbmRcbi0tW1tcbiAgQ2hlY2sgaWYgdGhpcyBqb2IgaGFzIGEgcGFyZW50LiBJZiBzbyB3ZSB3aWxsIGp1c3QgcmVtb3ZlIGl0IGZyb21cbiAgdGhlIHBhcmVudCBjaGlsZCBsaXN0LCBidXQgaWYgaXQgaXMgdGhlIGxhc3QgY2hpbGQgd2Ugc2hvdWxkIG1vdmUgdGhlIHBhcmVudCB0byBcIndhaXQvcGF1c2VkXCJcbiAgd2hpY2ggcmVxdWlyZXMgY29kZSBmcm9tIFwibW92ZVRvRmluaXNoZWRcIlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCBlbWl0RXZlbnQpXG4gIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXVzZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50UHJlZml4IC4uIFwibWV0YVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0XCIsXG4gICAgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkLCBwYXJlbnRJZClcbiAgaWYgZW1pdEV2ZW50IHRoZW5cbiAgICBsb2NhbCBwYXJlbnRFdmVudFN0cmVhbSA9IHBhcmVudFByZWZpeCAuLiBcImV2ZW50c1wiXG4gICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudEV2ZW50U3RyZWFtLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJwcmV2XCIsIFwid2FpdGluZy1jaGlsZHJlblwiKVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIHBhcmVudEtleSwgYmFzZUtleSlcbiAgaWYgcGFyZW50S2V5IHRoZW5cbiAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBwYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShwYXJlbnRLZXkpXG4gICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChwYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgIGlmIGhhcmQgdGhlbiAtLSByZW1vdmUgcGFyZW50IGluIHNhbWUgcXVldWVcbiAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShwYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBtaXNzZWRQYXJlbnRLZXkgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiKVxuICAgIGlmKCAodHlwZShtaXNzZWRQYXJlbnRLZXkpID09IFwic3RyaW5nXCIpIGFuZCBtaXNzZWRQYXJlbnRLZXkgfj0gXCJcIlxuICAgICAgYW5kIChyY2FsbChcIkVYSVNUU1wiLCBtaXNzZWRQYXJlbnRLZXkpID09IDEpKSB0aGVuXG4gICAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBtaXNzZWRQYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkobWlzc2VkUGFyZW50S2V5KVxuICAgICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChtaXNzZWRQYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICAgIGlmIGhhcmQgdGhlblxuICAgICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShtaXNzZWRQYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICByZW1vdmVKb2JLZXlzKGpvYktleSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gY2xlYW5MaXN0KGxpc3RLZXksIGpvYktleVByZWZpeCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsXG4gIHRpbWVzdGFtcCwgaXNXYWl0aW5nKVxuICBsb2NhbCBqb2JzID0gcmNhbGwoXCJMUkFOR0VcIiwgbGlzdEtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gIGxvY2FsIGRlbGV0ZWQgPSB7fVxuICBsb2NhbCBkZWxldGVkQ291bnQgPSAwXG4gIGxvY2FsIGpvYlRTXG4gIGxvY2FsIGRlbGV0aW9uTWFya2VyID0gJydcbiAgbG9jYWwgam9iSWRzTGVuID0gI2pvYnNcbiAgZm9yIGksIGpvYiBpbiBpcGFpcnMoam9icykgZG9cbiAgICBpZiBsaW1pdCA+IDAgYW5kIGRlbGV0ZWRDb3VudCA+PSBsaW1pdCB0aGVuXG4gICAgICBicmVha1xuICAgIGVuZFxuICAgIGxvY2FsIGpvYktleSA9IGpvYktleVByZWZpeCAuLiBqb2JcbiAgICBpZiAoaXNXYWl0aW5nIG9yIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSAuLiBcIjpsb2NrXCIpID09IDApIHRoZW5cbiAgICAgIC0tIEZpbmQgdGhlIHJpZ2h0IHRpbWVzdGFtcCBvZiB0aGUgam9iIHRvIGNvbXBhcmUgdG8gbWF4VGltZXN0YW1wOlxuICAgICAgLS0gKiBmaW5pc2hlZE9uIHNheXMgd2hlbiB0aGUgam9iIHdhcyBjb21wbGV0ZWQsIGJ1dCBpdCBpc24ndCBzZXQgdW5sZXNzIHRoZSBqb2IgaGFzIGFjdHVhbGx5IGNvbXBsZXRlZFxuICAgICAgLS0gKiBwcm9jZXNzZWRPbiByZXByZXNlbnRzIHdoZW4gdGhlIGpvYiB3YXMgbGFzdCBhdHRlbXB0ZWQsIGJ1dCBpdCBkb2Vzbid0IGdldCBwb3B1bGF0ZWQgdW50aWxcbiAgICAgIC0tICAgdGhlIGpvYiBpcyBmaXJzdCB0cmllZFxuICAgICAgLS0gKiB0aW1lc3RhbXAgaXMgdGhlIG9yaWdpbmFsIGpvYiBzdWJtaXNzaW9uIHRpbWVcbiAgICAgIC0tIEZldGNoIGFsbCB0aHJlZSBvZiB0aGVzZSAoaW4gdGhhdCBvcmRlcikgYW5kIHVzZSB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgc2V0IHNvIHRoYXQgd2UnbGwgbGVhdmUgam9ic1xuICAgICAgLS0gdGhhdCBoYXZlIGJlZW4gYWN0aXZlIHdpdGhpbiB0aGUgZ3JhY2UgcGVyaW9kOlxuICAgICAgam9iVFMgPSBnZXRUaW1lc3RhbXAoam9iS2V5LCB7XCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJ0aW1lc3RhbXBcIn0pXG4gICAgICBpZiAobm90IGpvYlRTIG9yIGpvYlRTIDw9IHRpbWVzdGFtcCkgdGhlblxuICAgICAgICAtLSByZXBsYWNlIHRoZSBlbnRyeSB3aXRoIGEgZGVsZXRpb24gbWFya2VyOyB0aGUgYWN0dWFsIGRlbGV0aW9uIHdpbGxcbiAgICAgICAgLS0gb2NjdXIgYXQgdGhlIGVuZCBvZiB0aGUgc2NyaXB0XG4gICAgICAgIHJjYWxsKFwiTFNFVFwiLCBsaXN0S2V5LCByYW5nZUVuZCAtIGpvYklkc0xlbiArIGksIGRlbGV0aW9uTWFya2VyKVxuICAgICAgICByZW1vdmVKb2Ioam9iLCB0cnVlLCBqb2JLZXlQcmVmaXgpXG4gICAgICAgIGRlbGV0ZWRDb3VudCA9IGRlbGV0ZWRDb3VudCArIDFcbiAgICAgICAgdGFibGUuaW5zZXJ0KGRlbGV0ZWQsIGpvYilcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmNhbGwoXCJMUkVNXCIsIGxpc3RLZXksIDAsIGRlbGV0aW9uTWFya2VyKVxuICByZXR1cm4ge2RlbGV0ZWQsIGRlbGV0ZWRDb3VudH1cbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjbGVhbiBqb2Igc2V0LlxuICBSZXR1cm5zIGpvYklkcyBhbmQgZGVsZXRlZCBjb3VudCBudW1iZXIuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbG9vcCBpbiBiYXRjaGVzLlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHNvbWUgY29tbWFuZHMgYXMgWlJFTVxuICBjb3VsZCByZWNlaXZlIGEgbWF4aW11bSBvZiA3MDAwIHBhcmFtZXRlcnMgcGVyIGNhbGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gYmF0Y2hlcyhuLCBiYXRjaFNpemUpXG4gIGxvY2FsIGkgPSAwXG4gIHJldHVybiBmdW5jdGlvbigpXG4gICAgbG9jYWwgZnJvbSA9IGkgKiBiYXRjaFNpemUgKyAxXG4gICAgaSA9IGkgKyAxXG4gICAgaWYgKGZyb20gPD0gbikgdGhlblxuICAgICAgbG9jYWwgdG8gPSBtYXRoLm1pbihmcm9tICsgYmF0Y2hTaXplIC0gMSwgbilcbiAgICAgIHJldHVybiBmcm9tLCB0b1xuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBXZSB1c2UgWlJBTkdFQllTQ09SRSB0byBtYWtlIHRoZSBjYXNlIHdoZXJlIHdlJ3JlIGRlbGV0aW5nIGEgbGltaXRlZCBudW1iZXJcbiAgb2YgaXRlbXMgaW4gYSBzb3J0ZWQgc2V0IG9ubHkgcnVuIGEgc2luZ2xlIGl0ZXJhdGlvbi4gSWYgd2Ugc2ltcGx5IHVzZWRcbiAgWlJBTkdFLCB3ZSBtYXkgdGFrZSBhIGxvbmcgdGltZSB0cmF2ZXJzaW5nIHRocm91Z2ggam9icyB0aGF0IGFyZSB3aXRoaW4gdGhlXG4gIGdyYWNlIHBlcmlvZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRKb2JzSW5ac2V0KHpzZXRLZXksIHJhbmdlRW5kLCBsaW1pdClcbiAgaWYgbGltaXQgPiAwIHRoZW5cbiAgICByZXR1cm4gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIHpzZXRLZXksIDAsIHJhbmdlRW5kLCBcIkxJTUlUXCIsIDAsIGxpbWl0KVxuICBlbHNlXG4gICAgcmV0dXJuIHJjYWxsKFwiWlJBTkdFQllTQ09SRVwiLCB6c2V0S2V5LCAwLCByYW5nZUVuZClcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGNsZWFuU2V0KHNldEtleSwgam9iS2V5UHJlZml4LCByYW5nZUVuZCwgdGltZXN0YW1wLCBsaW1pdCwgYXR0cmlidXRlcywgaXNGaW5pc2hlZClcbiAgbG9jYWwgam9icyA9IGdldEpvYnNJblpzZXQoc2V0S2V5LCByYW5nZUVuZCwgbGltaXQpXG4gIGxvY2FsIGRlbGV0ZWQgPSB7fVxuICBsb2NhbCBkZWxldGVkQ291bnQgPSAwXG4gIGxvY2FsIGpvYlRTXG4gIGZvciBpLCBqb2IgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgaWYgbGltaXQgPiAwIGFuZCBkZWxldGVkQ291bnQgPj0gbGltaXQgdGhlblxuICAgICAgYnJlYWtcbiAgICBlbmRcbiAgICBsb2NhbCBqb2JLZXkgPSBqb2JLZXlQcmVmaXggLi4gam9iXG4gICAgaWYgaXNGaW5pc2hlZCB0aGVuXG4gICAgICByZW1vdmVKb2Ioam9iLCB0cnVlLCBqb2JLZXlQcmVmaXgpXG4gICAgICBkZWxldGVkQ291bnQgPSBkZWxldGVkQ291bnQgKyAxXG4gICAgICB0YWJsZS5pbnNlcnQoZGVsZXRlZCwgam9iKVxuICAgIGVsc2VcbiAgICAgIC0tICogZmluaXNoZWRPbiBzYXlzIHdoZW4gdGhlIGpvYiB3YXMgY29tcGxldGVkLCBidXQgaXQgaXNuJ3Qgc2V0IHVubGVzcyB0aGUgam9iIGhhcyBhY3R1YWxseSBjb21wbGV0ZWRcbiAgICAgIGpvYlRTID0gZ2V0VGltZXN0YW1wKGpvYktleSwgYXR0cmlidXRlcylcbiAgICAgIGlmIChub3Qgam9iVFMgb3Igam9iVFMgPD0gdGltZXN0YW1wKSB0aGVuXG4gICAgICAgIHJlbW92ZUpvYihqb2IsIHRydWUsIGpvYktleVByZWZpeClcbiAgICAgICAgZGVsZXRlZENvdW50ID0gZGVsZXRlZENvdW50ICsgMVxuICAgICAgICB0YWJsZS5pbnNlcnQoZGVsZXRlZCwgam9iKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICBpZigjZGVsZXRlZCA+IDApIHRoZW5cbiAgICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjZGVsZXRlZCwgNzAwMCkgZG9cbiAgICAgIHJjYWxsKFwiWlJFTVwiLCBzZXRLZXksIHVucGFjayhkZWxldGVkLCBmcm9tLCB0bykpXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4ge2RlbGV0ZWQsIGRlbGV0ZWRDb3VudH1cbmVuZFxubG9jYWwgcmVzdWx0XG5pZiBBUkdWWzRdID09IFwiYWN0aXZlXCIgdGhlblxuICByZXN1bHQgPSBjbGVhbkxpc3QoS0VZU1sxXSwgQVJHVlsxXSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIEFSR1ZbMl0sIGZhbHNlKVxuZWxzZWlmIEFSR1ZbNF0gPT0gXCJkZWxheWVkXCIgdGhlblxuICByYW5nZUVuZCA9IFwiK2luZlwiXG4gIHJlc3VsdCA9IGNsZWFuU2V0KEtFWVNbMV0sIEFSR1ZbMV0sIHJhbmdlRW5kLCBBUkdWWzJdLCBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAge1wicHJvY2Vzc2VkT25cIiwgXCJ0aW1lc3RhbXBcIn0sIGZhbHNlKVxuZWxzZWlmIEFSR1ZbNF0gPT0gXCJwcmlvcml0aXplZFwiIHRoZW5cbiAgcmFuZ2VFbmQgPSBcIitpbmZcIlxuICByZXN1bHQgPSBjbGVhblNldChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZUVuZCwgQVJHVlsyXSwgbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHtcInRpbWVzdGFtcFwifSwgZmFsc2UpXG5lbHNlaWYgQVJHVls0XSA9PSBcIndhaXRcIiBvciBBUkdWWzRdID09IFwicGF1c2VkXCIgdGhlblxuICByZXN1bHQgPSBjbGVhbkxpc3QoS0VZU1sxXSwgQVJHVlsxXSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIEFSR1ZbMl0sIHRydWUpXG5lbHNlXG4gIHJhbmdlRW5kID0gQVJHVlsyXVxuICByZXN1bHQgPSBjbGVhblNldChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZUVuZCwgQVJHVlsyXSwgbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHtcImZpbmlzaGVkT25cIn0sIHRydWUpXG5lbmRcbnJjYWxsKFwiWEFERFwiLCBLRVlTWzJdLCBcIipcIiwgXCJldmVudFwiLCBcImNsZWFuZWRcIiwgXCJjb3VudFwiLCByZXN1bHRbMl0pXG5yZXR1cm4gcmVzdWx0WzFdXG5gO1xuZXhwb3J0IGNvbnN0IGNsZWFuSm9ic0luU2V0ID0ge1xuICAgIG5hbWU6ICdjbGVhbkpvYnNJblNldCcsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsZWFuSm9ic0luU2V0LTIuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJjbGVhbkpvYnNJblNldCIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-4.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/drain-4.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drain: () => (/* binding */ drain)\n/* harmony export */ });\nconst content = `--[[\n  Drains the queue, removes all jobs that are waiting\n  or delayed, but not active, completed or failed\n  Input:\n    KEYS[1] 'wait',\n    KEYS[2] 'paused'\n    KEYS[3] 'delayed'\n    KEYS[4] 'prioritized'\n    ARGV[1]  queue key prefix\n]]\nlocal rcall = redis.call\nlocal queueBaseKey = ARGV[1]\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey)\n  end\n  return max - #keys\nend\nlocal function getListItems(keyName, max)\n  return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max)\n  local jobs = getListItems(keyName, max)\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall(\"LTRIM\", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max)\n  local jobs = getZSetItems(keyName, max)\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall(\"ZREM\", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\nremoveListJobs(KEYS[1], true, queueBaseKey, 0) --wait\nremoveListJobs(KEYS[2], true, queueBaseKey, 0) --paused\nif KEYS[3] ~= \"\" then\n  removeZSetJobs(KEYS[3], true, queueBaseKey, 0) --delayed\nend\nremoveZSetJobs(KEYS[4], true, queueBaseKey, 0) --prioritized\n`;\nconst drain = {\n    name: \"drain\",\n    content,\n    keys: 4\n}; //# sourceMappingURL=drain-4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZHJhaW4tNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzTWpCLENBQUM7QUFDTSxNQUFNQyxRQUFRO0lBQ2pCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9kcmFpbi00LmpzP2M0ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIERyYWlucyB0aGUgcXVldWUsIHJlbW92ZXMgYWxsIGpvYnMgdGhhdCBhcmUgd2FpdGluZ1xuICBvciBkZWxheWVkLCBidXQgbm90IGFjdGl2ZSwgY29tcGxldGVkIG9yIGZhaWxlZFxuICBJbnB1dDpcbiAgICBLRVlTWzFdICd3YWl0JyxcbiAgICBLRVlTWzJdICdwYXVzZWQnXG4gICAgS0VZU1szXSAnZGVsYXllZCdcbiAgICBLRVlTWzRdICdwcmlvcml0aXplZCdcbiAgICBBUkdWWzFdICBxdWV1ZSBrZXkgcHJlZml4XG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBxdWV1ZUJhc2VLZXkgPSBBUkdWWzFdXG4tLVtbXG4gIEZ1bmN0aW9ucyB0byByZW1vdmUgam9icy5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLFxuICAgIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcpXG5lbmRcbi0tW1tcbiAgQ2hlY2sgaWYgdGhpcyBqb2IgaGFzIGEgcGFyZW50LiBJZiBzbyB3ZSB3aWxsIGp1c3QgcmVtb3ZlIGl0IGZyb21cbiAgdGhlIHBhcmVudCBjaGlsZCBsaXN0LCBidXQgaWYgaXQgaXMgdGhlIGxhc3QgY2hpbGQgd2Ugc2hvdWxkIG1vdmUgdGhlIHBhcmVudCB0byBcIndhaXQvcGF1c2VkXCJcbiAgd2hpY2ggcmVxdWlyZXMgY29kZSBmcm9tIFwibW92ZVRvRmluaXNoZWRcIlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCBlbWl0RXZlbnQpXG4gIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXVzZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50UHJlZml4IC4uIFwibWV0YVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0XCIsXG4gICAgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkLCBwYXJlbnRJZClcbiAgaWYgZW1pdEV2ZW50IHRoZW5cbiAgICBsb2NhbCBwYXJlbnRFdmVudFN0cmVhbSA9IHBhcmVudFByZWZpeCAuLiBcImV2ZW50c1wiXG4gICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudEV2ZW50U3RyZWFtLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJwcmV2XCIsIFwid2FpdGluZy1jaGlsZHJlblwiKVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIHBhcmVudEtleSwgYmFzZUtleSlcbiAgaWYgcGFyZW50S2V5IHRoZW5cbiAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBwYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShwYXJlbnRLZXkpXG4gICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChwYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgIGlmIGhhcmQgdGhlbiAtLSByZW1vdmUgcGFyZW50IGluIHNhbWUgcXVldWVcbiAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShwYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBtaXNzZWRQYXJlbnRLZXkgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiKVxuICAgIGlmKCAodHlwZShtaXNzZWRQYXJlbnRLZXkpID09IFwic3RyaW5nXCIpIGFuZCBtaXNzZWRQYXJlbnRLZXkgfj0gXCJcIlxuICAgICAgYW5kIChyY2FsbChcIkVYSVNUU1wiLCBtaXNzZWRQYXJlbnRLZXkpID09IDEpKSB0aGVuXG4gICAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBtaXNzZWRQYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkobWlzc2VkUGFyZW50S2V5KVxuICAgICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChtaXNzZWRQYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICAgIGlmIGhhcmQgdGhlblxuICAgICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShtaXNzZWRQYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICByZW1vdmVKb2JLZXlzKGpvYktleSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9icyhrZXlzLCBoYXJkLCBiYXNlS2V5LCBtYXgpXG4gIGZvciBpLCBrZXkgaW4gaXBhaXJzKGtleXMpIGRvXG4gICAgcmVtb3ZlSm9iKGtleSwgaGFyZCwgYmFzZUtleSlcbiAgZW5kXG4gIHJldHVybiBtYXggLSAja2V5c1xuZW5kXG5sb2NhbCBmdW5jdGlvbiBnZXRMaXN0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICByZXR1cm4gcmNhbGwoJ0xSQU5HRScsIGtleU5hbWUsIDAsIG1heCAtIDEpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxpc3RKb2JzKGtleU5hbWUsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgbG9jYWwgam9icyA9IGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGxvY2FsIGNvdW50ID0gcmVtb3ZlSm9icyhqb2JzLCBoYXJkLCBiYXNlS2V5LCBtYXgpXG4gIHJjYWxsKFwiTFRSSU1cIiwga2V5TmFtZSwgI2pvYnMsIC0xKVxuICByZXR1cm4gY291bnRcbmVuZFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbG9vcCBpbiBiYXRjaGVzLlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHNvbWUgY29tbWFuZHMgYXMgWlJFTVxuICBjb3VsZCByZWNlaXZlIGEgbWF4aW11bSBvZiA3MDAwIHBhcmFtZXRlcnMgcGVyIGNhbGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gYmF0Y2hlcyhuLCBiYXRjaFNpemUpXG4gIGxvY2FsIGkgPSAwXG4gIHJldHVybiBmdW5jdGlvbigpXG4gICAgbG9jYWwgZnJvbSA9IGkgKiBiYXRjaFNpemUgKyAxXG4gICAgaSA9IGkgKyAxXG4gICAgaWYgKGZyb20gPD0gbikgdGhlblxuICAgICAgbG9jYWwgdG8gPSBtYXRoLm1pbihmcm9tICsgYmF0Y2hTaXplIC0gMSwgbilcbiAgICAgIHJldHVybiBmcm9tLCB0b1xuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgWlNldCBpdGVtcy5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRaU2V0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICByZXR1cm4gcmNhbGwoJ1pSQU5HRScsIGtleU5hbWUsIDAsIG1heCAtIDEpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVpTZXRKb2JzKGtleU5hbWUsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgbG9jYWwgam9icyA9IGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGxvY2FsIGNvdW50ID0gcmVtb3ZlSm9icyhqb2JzLCBoYXJkLCBiYXNlS2V5LCBtYXgpXG4gIGlmKCNqb2JzID4gMCkgdGhlblxuICAgIGZvciBmcm9tLCB0byBpbiBiYXRjaGVzKCNqb2JzLCA3MDAwKSBkb1xuICAgICAgcmNhbGwoXCJaUkVNXCIsIGtleU5hbWUsIHVucGFjayhqb2JzLCBmcm9tLCB0bykpXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gY291bnRcbmVuZFxucmVtb3ZlTGlzdEpvYnMoS0VZU1sxXSwgdHJ1ZSwgcXVldWVCYXNlS2V5LCAwKSAtLXdhaXRcbnJlbW92ZUxpc3RKb2JzKEtFWVNbMl0sIHRydWUsIHF1ZXVlQmFzZUtleSwgMCkgLS1wYXVzZWRcbmlmIEtFWVNbM10gfj0gXCJcIiB0aGVuXG4gIHJlbW92ZVpTZXRKb2JzKEtFWVNbM10sIHRydWUsIHF1ZXVlQmFzZUtleSwgMCkgLS1kZWxheWVkXG5lbmRcbnJlbW92ZVpTZXRKb2JzKEtFWVNbNF0sIHRydWUsIHF1ZXVlQmFzZUtleSwgMCkgLS1wcmlvcml0aXplZFxuYDtcbmV4cG9ydCBjb25zdCBkcmFpbiA9IHtcbiAgICBuYW1lOiAnZHJhaW4nLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFpbi00LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwiZHJhaW4iLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/extendLock-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendLock: () => (/* binding */ extendLock)\n/* harmony export */ });\nconst content = `--[[\n  Extend lock and removes the job from the stalled set.\n  Input:\n    KEYS[1] 'lock',\n    KEYS[2] 'stalled'\n    ARGV[1]  token\n    ARGV[2]  lock duration in milliseconds\n    ARGV[3]  jobid\n  Output:\n    \"1\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  --   if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2], \"XX\") then\n  if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2]) then\n    rcall(\"SREM\", KEYS[2], ARGV[3])\n    return 1\n  end\nend\nreturn 0\n`;\nconst extendLock = {\n    name: \"extendLock\",\n    content,\n    keys: 2\n}; //# sourceMappingURL=extendLock-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZXh0ZW5kTG9jay0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JqQixDQUFDO0FBQ00sTUFBTUMsYUFBYTtJQUN0QkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZXh0ZW5kTG9jay0yLmpzP2FhZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEV4dGVuZCBsb2NrIGFuZCByZW1vdmVzIHRoZSBqb2IgZnJvbSB0aGUgc3RhbGxlZCBzZXQuXG4gIElucHV0OlxuICAgIEtFWVNbMV0gJ2xvY2snLFxuICAgIEtFWVNbMl0gJ3N0YWxsZWQnXG4gICAgQVJHVlsxXSAgdG9rZW5cbiAgICBBUkdWWzJdICBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgIEFSR1ZbM10gIGpvYmlkXG4gIE91dHB1dDpcbiAgICBcIjFcIiBpZiBsb2NrIGV4dGVudGVkIHN1Y2Nlc2Z1bGx5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJHRVRcIiwgS0VZU1sxXSkgPT0gQVJHVlsxXSB0aGVuXG4gIC0tICAgaWYgcmNhbGwoXCJTRVRcIiwgS0VZU1sxXSwgQVJHVlsxXSwgXCJQWFwiLCBBUkdWWzJdLCBcIlhYXCIpIHRoZW5cbiAgaWYgcmNhbGwoXCJTRVRcIiwgS0VZU1sxXSwgQVJHVlsxXSwgXCJQWFwiLCBBUkdWWzJdKSB0aGVuXG4gICAgcmNhbGwoXCJTUkVNXCIsIEtFWVNbMl0sIEFSR1ZbM10pXG4gICAgcmV0dXJuIDFcbiAgZW5kXG5lbmRcbnJldHVybiAwXG5gO1xuZXhwb3J0IGNvbnN0IGV4dGVuZExvY2sgPSB7XG4gICAgbmFtZTogJ2V4dGVuZExvY2snLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlbmRMb2NrLTIuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJleHRlbmRMb2NrIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getCounts-1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCounts: () => (/* binding */ getCounts)\n/* harmony export */ });\nconst content = `--[[\n  Get counts per provided states\n    Input:\n      KEYS[1]    'prefix'\n      ARGV[1...] types\n]]\nlocal rcall = redis.call;\nlocal prefix = KEYS[1]\nlocal results = {}\nfor i = 1, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == \"wait\" or ARGV[i] == \"paused\" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall(\"LINDEX\", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then\n      local count = rcall(\"LLEN\", stateKey)\n      if count > 1 then\n        rcall(\"RPOP\", stateKey)\n        results[#results+1] = count-1\n      else\n        results[#results+1] = 0\n      end\n    else\n      results[#results+1] = rcall(\"LLEN\", stateKey)\n    end\n  elseif ARGV[i] == \"active\" then\n    results[#results+1] = rcall(\"LLEN\", stateKey)\n  else\n    results[#results+1] = rcall(\"ZCARD\", stateKey)\n  end\nend\nreturn results\n`;\nconst getCounts = {\n    name: \"getCounts\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=getCounts-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0Q291bnRzLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ2pCLENBQUM7QUFDTSxNQUFNQyxZQUFZO0lBQ3JCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9nZXRDb3VudHMtMS5qcz9iNTU4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBHZXQgY291bnRzIHBlciBwcm92aWRlZCBzdGF0ZXNcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gICAgJ3ByZWZpeCdcbiAgICAgIEFSR1ZbMS4uLl0gdHlwZXNcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG5sb2NhbCBwcmVmaXggPSBLRVlTWzFdXG5sb2NhbCByZXN1bHRzID0ge31cbmZvciBpID0gMSwgI0FSR1YgZG9cbiAgbG9jYWwgc3RhdGVLZXkgPSBwcmVmaXggLi4gQVJHVltpXVxuICBpZiBBUkdWW2ldID09IFwid2FpdFwiIG9yIEFSR1ZbaV0gPT0gXCJwYXVzZWRcIiB0aGVuXG4gICAgLS0gTWFya2VycyBpbiB3YWl0bGlzdCBERVBSRUNBVEVEIGluIHY1OiBSZW1vdmUgaW4gdjYuXG4gICAgbG9jYWwgbWFya2VyID0gcmNhbGwoXCJMSU5ERVhcIiwgc3RhdGVLZXksIC0xKVxuICAgIGlmIG1hcmtlciBhbmQgc3RyaW5nLnN1YihtYXJrZXIsIDEsIDIpID09IFwiMDpcIiB0aGVuXG4gICAgICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiTExFTlwiLCBzdGF0ZUtleSlcbiAgICAgIGlmIGNvdW50ID4gMSB0aGVuXG4gICAgICAgIHJjYWxsKFwiUlBPUFwiLCBzdGF0ZUtleSlcbiAgICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IGNvdW50LTFcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IDBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIkxMRU5cIiwgc3RhdGVLZXkpXG4gICAgZW5kXG4gIGVsc2VpZiBBUkdWW2ldID09IFwiYWN0aXZlXCIgdGhlblxuICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIkxMRU5cIiwgc3RhdGVLZXkpXG4gIGVsc2VcbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJaQ0FSRFwiLCBzdGF0ZUtleSlcbiAgZW5kXG5lbmRcbnJldHVybiByZXN1bHRzXG5gO1xuZXhwb3J0IGNvbnN0IGdldENvdW50cyA9IHtcbiAgICBuYW1lOiAnZ2V0Q291bnRzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q291bnRzLTEuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJnZXRDb3VudHMiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getRanges-1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRanges: () => (/* binding */ getRanges)\n/* harmony export */ });\nconst content = `--[[\n  Get job ids per provided states\n    Input:\n      KEYS[1]    'prefix'\n      ARGV[1]    start\n      ARGV[2]    end\n      ARGV[3]    asc\n      ARGV[4...] types\n]]\nlocal rcall = redis.call\nlocal prefix = KEYS[1]\nlocal rangeStart = tonumber(ARGV[1])\nlocal rangeEnd = tonumber(ARGV[2])\nlocal asc = ARGV[3]\nlocal results = {}\nlocal function getRangeInList(listKey, asc, rangeStart, rangeEnd, results)\n  if asc == \"1\" then\n    local modifiedRangeStart\n    local modifiedRangeEnd\n    if rangeStart == -1 then\n      modifiedRangeStart = 0\n    else\n      modifiedRangeStart = -(rangeStart + 1)\n    end\n    if rangeEnd == -1 then\n      modifiedRangeEnd = 0\n    else\n      modifiedRangeEnd = -(rangeEnd + 1)\n    end\n    results[#results+1] = rcall(\"LRANGE\", listKey,\n      modifiedRangeEnd,\n      modifiedRangeStart)\n  else\n    results[#results+1] = rcall(\"LRANGE\", listKey, rangeStart, rangeEnd)\n  end\nend\nfor i = 4, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == \"wait\" or ARGV[i] == \"paused\" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall(\"LINDEX\", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then\n      local count = rcall(\"LLEN\", stateKey)\n      if count > 1 then\n        rcall(\"RPOP\", stateKey)\n        getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n      else\n        results[#results+1] = {}\n      end\n    else\n      getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n    end\n  elseif ARGV[i] == \"active\" then\n    getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n  else\n    if asc == \"1\" then\n      results[#results+1] = rcall(\"ZRANGE\", stateKey, rangeStart, rangeEnd)\n    else\n      results[#results+1] = rcall(\"ZREVRANGE\", stateKey, rangeStart, rangeEnd)\n    end\n  end\nend\nreturn results\n`;\nconst getRanges = {\n    name: \"getRanges\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=getRanges-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0UmFuZ2VzLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RqQixDQUFDO0FBQ00sTUFBTUMsWUFBWTtJQUNyQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0UmFuZ2VzLTEuanM/MzJlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IGpvYiBpZHMgcGVyIHByb3ZpZGVkIHN0YXRlc1xuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAgICAncHJlZml4J1xuICAgICAgQVJHVlsxXSAgICBzdGFydFxuICAgICAgQVJHVlsyXSAgICBlbmRcbiAgICAgIEFSR1ZbM10gICAgYXNjXG4gICAgICBBUkdWWzQuLi5dIHR5cGVzXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBwcmVmaXggPSBLRVlTWzFdXG5sb2NhbCByYW5nZVN0YXJ0ID0gdG9udW1iZXIoQVJHVlsxXSlcbmxvY2FsIHJhbmdlRW5kID0gdG9udW1iZXIoQVJHVlsyXSlcbmxvY2FsIGFzYyA9IEFSR1ZbM11cbmxvY2FsIHJlc3VsdHMgPSB7fVxubG9jYWwgZnVuY3Rpb24gZ2V0UmFuZ2VJbkxpc3QobGlzdEtleSwgYXNjLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgcmVzdWx0cylcbiAgaWYgYXNjID09IFwiMVwiIHRoZW5cbiAgICBsb2NhbCBtb2RpZmllZFJhbmdlU3RhcnRcbiAgICBsb2NhbCBtb2RpZmllZFJhbmdlRW5kXG4gICAgaWYgcmFuZ2VTdGFydCA9PSAtMSB0aGVuXG4gICAgICBtb2RpZmllZFJhbmdlU3RhcnQgPSAwXG4gICAgZWxzZVxuICAgICAgbW9kaWZpZWRSYW5nZVN0YXJ0ID0gLShyYW5nZVN0YXJ0ICsgMSlcbiAgICBlbmRcbiAgICBpZiByYW5nZUVuZCA9PSAtMSB0aGVuXG4gICAgICBtb2RpZmllZFJhbmdlRW5kID0gMFxuICAgIGVsc2VcbiAgICAgIG1vZGlmaWVkUmFuZ2VFbmQgPSAtKHJhbmdlRW5kICsgMSlcbiAgICBlbmRcbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJMUkFOR0VcIiwgbGlzdEtleSxcbiAgICAgIG1vZGlmaWVkUmFuZ2VFbmQsXG4gICAgICBtb2RpZmllZFJhbmdlU3RhcnQpXG4gIGVsc2VcbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJMUkFOR0VcIiwgbGlzdEtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gIGVuZFxuZW5kXG5mb3IgaSA9IDQsICNBUkdWIGRvXG4gIGxvY2FsIHN0YXRlS2V5ID0gcHJlZml4IC4uIEFSR1ZbaV1cbiAgaWYgQVJHVltpXSA9PSBcIndhaXRcIiBvciBBUkdWW2ldID09IFwicGF1c2VkXCIgdGhlblxuICAgIC0tIE1hcmtlcnMgaW4gd2FpdGxpc3QgREVQUkVDQVRFRCBpbiB2NTogUmVtb3ZlIGluIHY2LlxuICAgIGxvY2FsIG1hcmtlciA9IHJjYWxsKFwiTElOREVYXCIsIHN0YXRlS2V5LCAtMSlcbiAgICBpZiBtYXJrZXIgYW5kIHN0cmluZy5zdWIobWFya2VyLCAxLCAyKSA9PSBcIjA6XCIgdGhlblxuICAgICAgbG9jYWwgY291bnQgPSByY2FsbChcIkxMRU5cIiwgc3RhdGVLZXkpXG4gICAgICBpZiBjb3VudCA+IDEgdGhlblxuICAgICAgICByY2FsbChcIlJQT1BcIiwgc3RhdGVLZXkpXG4gICAgICAgIGdldFJhbmdlSW5MaXN0KHN0YXRlS2V5LCBhc2MsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCByZXN1bHRzKVxuICAgICAgZWxzZVxuICAgICAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0ge31cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGdldFJhbmdlSW5MaXN0KHN0YXRlS2V5LCBhc2MsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCByZXN1bHRzKVxuICAgIGVuZFxuICBlbHNlaWYgQVJHVltpXSA9PSBcImFjdGl2ZVwiIHRoZW5cbiAgICBnZXRSYW5nZUluTGlzdChzdGF0ZUtleSwgYXNjLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgcmVzdWx0cylcbiAgZWxzZVxuICAgIGlmIGFzYyA9PSBcIjFcIiB0aGVuXG4gICAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJaUkFOR0VcIiwgc3RhdGVLZXksIHJhbmdlU3RhcnQsIHJhbmdlRW5kKVxuICAgIGVsc2VcbiAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIlpSRVZSQU5HRVwiLCBzdGF0ZUtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5yZXR1cm4gcmVzdWx0c1xuYDtcbmV4cG9ydCBjb25zdCBnZXRSYW5nZXMgPSB7XG4gICAgbmFtZTogJ2dldFJhbmdlcycsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJhbmdlcy0xLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwiZ2V0UmFuZ2VzIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getState-8.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getState: () => (/* binding */ getState)\n/* harmony export */ });\nconst content = `--[[\n  Get a job state\n  Input: \n    KEYS[1] 'completed' key,\n    KEYS[2] 'failed' key\n    KEYS[3] 'delayed' key\n    KEYS[4] 'active' key\n    KEYS[5] 'wait' key\n    KEYS[6] 'paused' key\n    KEYS[7] 'waiting-children' key\n    KEYS[8] 'prioritized' key\n    ARGV[1] job id\n  Output:\n    'completed'\n    'failed'\n    'delayed'\n    'active'\n    'prioritized'\n    'waiting'\n    'waiting-children'\n    'unknown'\n]]\nlocal rcall = redis.call\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) ~= false then\n  return \"completed\"\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) ~= false then\n  return \"failed\"\nend\nif rcall(\"ZSCORE\", KEYS[3], ARGV[1]) ~= false then\n  return \"delayed\"\nend\nif rcall(\"ZSCORE\", KEYS[8], ARGV[1]) ~= false then\n  return \"prioritized\"\nend\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal active_items = rcall(\"LRANGE\", KEYS[4] , 0, -1)\nif checkItemInList(active_items, ARGV[1]) ~= nil then\n  return \"active\"\nend\nlocal wait_items = rcall(\"LRANGE\", KEYS[5] , 0, -1)\nif checkItemInList(wait_items, ARGV[1]) ~= nil then\n  return \"waiting\"\nend\nlocal paused_items = rcall(\"LRANGE\", KEYS[6] , 0, -1)\nif checkItemInList(paused_items, ARGV[1]) ~= nil then\n  return \"waiting\"\nend\nif rcall(\"ZSCORE\", KEYS[7], ARGV[1]) ~= false then\n  return \"waiting-children\"\nend\nreturn \"unknown\"\n`;\nconst getState = {\n    name: \"getState\",\n    content,\n    keys: 8\n}; //# sourceMappingURL=getState-8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0U3RhdGUtOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErRGpCLENBQUM7QUFDTSxNQUFNQyxXQUFXO0lBQ3BCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9nZXRTdGF0ZS04LmpzPzNkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEdldCBhIGpvYiBzdGF0ZVxuICBJbnB1dDogXG4gICAgS0VZU1sxXSAnY29tcGxldGVkJyBrZXksXG4gICAgS0VZU1syXSAnZmFpbGVkJyBrZXlcbiAgICBLRVlTWzNdICdkZWxheWVkJyBrZXlcbiAgICBLRVlTWzRdICdhY3RpdmUnIGtleVxuICAgIEtFWVNbNV0gJ3dhaXQnIGtleVxuICAgIEtFWVNbNl0gJ3BhdXNlZCcga2V5XG4gICAgS0VZU1s3XSAnd2FpdGluZy1jaGlsZHJlbicga2V5XG4gICAgS0VZU1s4XSAncHJpb3JpdGl6ZWQnIGtleVxuICAgIEFSR1ZbMV0gam9iIGlkXG4gIE91dHB1dDpcbiAgICAnY29tcGxldGVkJ1xuICAgICdmYWlsZWQnXG4gICAgJ2RlbGF5ZWQnXG4gICAgJ2FjdGl2ZSdcbiAgICAncHJpb3JpdGl6ZWQnXG4gICAgJ3dhaXRpbmcnXG4gICAgJ3dhaXRpbmctY2hpbGRyZW4nXG4gICAgJ3Vua25vd24nXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzFdLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcImNvbXBsZXRlZFwiXG5lbmRcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMl0sIEFSR1ZbMV0pIH49IGZhbHNlIHRoZW5cbiAgcmV0dXJuIFwiZmFpbGVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1szXSwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gXCJkZWxheWVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1s4XSwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gXCJwcmlvcml0aXplZFwiXG5lbmRcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9ucyB0byBjaGVjayBpZiBhIGl0ZW0gYmVsb25ncyB0byBhIGxpc3QuXG5dXVxubG9jYWwgZnVuY3Rpb24gY2hlY2tJdGVtSW5MaXN0KGxpc3QsIGl0ZW0pXG4gIGZvciBfLCB2IGluIHBhaXJzKGxpc3QpIGRvXG4gICAgaWYgdiA9PSBpdGVtIHRoZW5cbiAgICAgIHJldHVybiAxXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gbmlsXG5lbmRcbmxvY2FsIGFjdGl2ZV9pdGVtcyA9IHJjYWxsKFwiTFJBTkdFXCIsIEtFWVNbNF0gLCAwLCAtMSlcbmlmIGNoZWNrSXRlbUluTGlzdChhY3RpdmVfaXRlbXMsIEFSR1ZbMV0pIH49IG5pbCB0aGVuXG4gIHJldHVybiBcImFjdGl2ZVwiXG5lbmRcbmxvY2FsIHdhaXRfaXRlbXMgPSByY2FsbChcIkxSQU5HRVwiLCBLRVlTWzVdICwgMCwgLTEpXG5pZiBjaGVja0l0ZW1Jbkxpc3Qod2FpdF9pdGVtcywgQVJHVlsxXSkgfj0gbmlsIHRoZW5cbiAgcmV0dXJuIFwid2FpdGluZ1wiXG5lbmRcbmxvY2FsIHBhdXNlZF9pdGVtcyA9IHJjYWxsKFwiTFJBTkdFXCIsIEtFWVNbNl0gLCAwLCAtMSlcbmlmIGNoZWNrSXRlbUluTGlzdChwYXVzZWRfaXRlbXMsIEFSR1ZbMV0pIH49IG5pbCB0aGVuXG4gIHJldHVybiBcIndhaXRpbmdcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzddLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcIndhaXRpbmctY2hpbGRyZW5cIlxuZW5kXG5yZXR1cm4gXCJ1bmtub3duXCJcbmA7XG5leHBvcnQgY29uc3QgZ2V0U3RhdGUgPSB7XG4gICAgbmFtZTogJ2dldFN0YXRlJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U3RhdGUtOC5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsImdldFN0YXRlIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStateV2: () => (/* binding */ getStateV2)\n/* harmony export */ });\nconst content = `--[[\n  Get a job state\n  Input: \n    KEYS[1] 'completed' key,\n    KEYS[2] 'failed' key\n    KEYS[3] 'delayed' key\n    KEYS[4] 'active' key\n    KEYS[5] 'wait' key\n    KEYS[6] 'paused' key\n    KEYS[7] 'waiting-children' key\n    KEYS[8] 'prioritized' key\n    ARGV[1] job id\n  Output:\n    'completed'\n    'failed'\n    'delayed'\n    'active'\n    'waiting'\n    'waiting-children'\n    'unknown'\n]]\nlocal rcall = redis.call\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) ~= false then\n  return \"completed\"\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) ~= false then\n  return \"failed\"\nend\nif rcall(\"ZSCORE\", KEYS[3], ARGV[1]) ~= false then\n  return \"delayed\"\nend\nif rcall(\"ZSCORE\", KEYS[8], ARGV[1]) ~= false then\n  return \"prioritized\"\nend\nif rcall(\"LPOS\", KEYS[4] , ARGV[1]) ~= false then\n  return \"active\"\nend\nif rcall(\"LPOS\", KEYS[5] , ARGV[1]) ~= false then\n  return \"waiting\"\nend\nif rcall(\"LPOS\", KEYS[6] , ARGV[1]) ~= false then\n  return \"waiting\"\nend\nif rcall(\"ZSCORE\", KEYS[7] , ARGV[1]) ~= false then\n  return \"waiting-children\"\nend\nreturn \"unknown\"\n`;\nconst getStateV2 = {\n    name: \"getStateV2\",\n    content,\n    keys: 8\n}; //# sourceMappingURL=getStateV2-8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0U3RhdGVWMi04LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NqQixDQUFDO0FBQ00sTUFBTUMsYUFBYTtJQUN0QkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0U3RhdGVWMi04LmpzPzQ3M2YiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEdldCBhIGpvYiBzdGF0ZVxuICBJbnB1dDogXG4gICAgS0VZU1sxXSAnY29tcGxldGVkJyBrZXksXG4gICAgS0VZU1syXSAnZmFpbGVkJyBrZXlcbiAgICBLRVlTWzNdICdkZWxheWVkJyBrZXlcbiAgICBLRVlTWzRdICdhY3RpdmUnIGtleVxuICAgIEtFWVNbNV0gJ3dhaXQnIGtleVxuICAgIEtFWVNbNl0gJ3BhdXNlZCcga2V5XG4gICAgS0VZU1s3XSAnd2FpdGluZy1jaGlsZHJlbicga2V5XG4gICAgS0VZU1s4XSAncHJpb3JpdGl6ZWQnIGtleVxuICAgIEFSR1ZbMV0gam9iIGlkXG4gIE91dHB1dDpcbiAgICAnY29tcGxldGVkJ1xuICAgICdmYWlsZWQnXG4gICAgJ2RlbGF5ZWQnXG4gICAgJ2FjdGl2ZSdcbiAgICAnd2FpdGluZydcbiAgICAnd2FpdGluZy1jaGlsZHJlbidcbiAgICAndW5rbm93bidcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMV0sIEFSR1ZbMV0pIH49IGZhbHNlIHRoZW5cbiAgcmV0dXJuIFwiY29tcGxldGVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1syXSwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gXCJmYWlsZWRcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzNdLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcImRlbGF5ZWRcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzhdLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcInByaW9yaXRpemVkXCJcbmVuZFxuaWYgcmNhbGwoXCJMUE9TXCIsIEtFWVNbNF0gLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcImFjdGl2ZVwiXG5lbmRcbmlmIHJjYWxsKFwiTFBPU1wiLCBLRVlTWzVdICwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gXCJ3YWl0aW5nXCJcbmVuZFxuaWYgcmNhbGwoXCJMUE9TXCIsIEtFWVNbNl0gLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBcIndhaXRpbmdcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzddICwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gXCJ3YWl0aW5nLWNoaWxkcmVuXCJcbmVuZFxucmV0dXJuIFwidW5rbm93blwiXG5gO1xuZXhwb3J0IGNvbnN0IGdldFN0YXRlVjIgPSB7XG4gICAgbmFtZTogJ2dldFN0YXRlVjInLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogOCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTdGF0ZVYyLTguanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJnZXRTdGF0ZVYyIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDelayedJob: () => (/* reexport safe */ _addDelayedJob_6__WEBPACK_IMPORTED_MODULE_0__.addDelayedJob),\n/* harmony export */   addParentJob: () => (/* reexport safe */ _addParentJob_4__WEBPACK_IMPORTED_MODULE_1__.addParentJob),\n/* harmony export */   addPrioritizedJob: () => (/* reexport safe */ _addPrioritizedJob_7__WEBPACK_IMPORTED_MODULE_2__.addPrioritizedJob),\n/* harmony export */   addStandardJob: () => (/* reexport safe */ _addStandardJob_7__WEBPACK_IMPORTED_MODULE_3__.addStandardJob),\n/* harmony export */   changeDelay: () => (/* reexport safe */ _changeDelay_4__WEBPACK_IMPORTED_MODULE_4__.changeDelay),\n/* harmony export */   changePriority: () => (/* reexport safe */ _changePriority_6__WEBPACK_IMPORTED_MODULE_5__.changePriority),\n/* harmony export */   cleanJobsInSet: () => (/* reexport safe */ _cleanJobsInSet_2__WEBPACK_IMPORTED_MODULE_6__.cleanJobsInSet),\n/* harmony export */   drain: () => (/* reexport safe */ _drain_4__WEBPACK_IMPORTED_MODULE_7__.drain),\n/* harmony export */   extendLock: () => (/* reexport safe */ _extendLock_2__WEBPACK_IMPORTED_MODULE_8__.extendLock),\n/* harmony export */   getCounts: () => (/* reexport safe */ _getCounts_1__WEBPACK_IMPORTED_MODULE_9__.getCounts),\n/* harmony export */   getRanges: () => (/* reexport safe */ _getRanges_1__WEBPACK_IMPORTED_MODULE_10__.getRanges),\n/* harmony export */   getState: () => (/* reexport safe */ _getState_8__WEBPACK_IMPORTED_MODULE_11__.getState),\n/* harmony export */   getStateV2: () => (/* reexport safe */ _getStateV2_8__WEBPACK_IMPORTED_MODULE_12__.getStateV2),\n/* harmony export */   isFinished: () => (/* reexport safe */ _isFinished_3__WEBPACK_IMPORTED_MODULE_13__.isFinished),\n/* harmony export */   isJobInList: () => (/* reexport safe */ _isJobInList_1__WEBPACK_IMPORTED_MODULE_14__.isJobInList),\n/* harmony export */   moveJobFromActiveToWait: () => (/* reexport safe */ _moveJobFromActiveToWait_10__WEBPACK_IMPORTED_MODULE_15__.moveJobFromActiveToWait),\n/* harmony export */   moveJobsToWait: () => (/* reexport safe */ _moveJobsToWait_7__WEBPACK_IMPORTED_MODULE_16__.moveJobsToWait),\n/* harmony export */   moveStalledJobsToWait: () => (/* reexport safe */ _moveStalledJobsToWait_9__WEBPACK_IMPORTED_MODULE_17__.moveStalledJobsToWait),\n/* harmony export */   moveToActive: () => (/* reexport safe */ _moveToActive_11__WEBPACK_IMPORTED_MODULE_18__.moveToActive),\n/* harmony export */   moveToDelayed: () => (/* reexport safe */ _moveToDelayed_7__WEBPACK_IMPORTED_MODULE_19__.moveToDelayed),\n/* harmony export */   moveToFinished: () => (/* reexport safe */ _moveToFinished_14__WEBPACK_IMPORTED_MODULE_20__.moveToFinished),\n/* harmony export */   moveToWaitingChildren: () => (/* reexport safe */ _moveToWaitingChildren_4__WEBPACK_IMPORTED_MODULE_21__.moveToWaitingChildren),\n/* harmony export */   obliterate: () => (/* reexport safe */ _obliterate_2__WEBPACK_IMPORTED_MODULE_22__.obliterate),\n/* harmony export */   paginate: () => (/* reexport safe */ _paginate_1__WEBPACK_IMPORTED_MODULE_23__.paginate),\n/* harmony export */   pause: () => (/* reexport safe */ _pause_7__WEBPACK_IMPORTED_MODULE_24__.pause),\n/* harmony export */   promote: () => (/* reexport safe */ _promote_8__WEBPACK_IMPORTED_MODULE_25__.promote),\n/* harmony export */   releaseLock: () => (/* reexport safe */ _releaseLock_1__WEBPACK_IMPORTED_MODULE_26__.releaseLock),\n/* harmony export */   removeChildDependency: () => (/* reexport safe */ _removeChildDependency_1__WEBPACK_IMPORTED_MODULE_27__.removeChildDependency),\n/* harmony export */   removeJob: () => (/* reexport safe */ _removeJob_1__WEBPACK_IMPORTED_MODULE_28__.removeJob),\n/* harmony export */   removeRepeatable: () => (/* reexport safe */ _removeRepeatable_2__WEBPACK_IMPORTED_MODULE_29__.removeRepeatable),\n/* harmony export */   reprocessJob: () => (/* reexport safe */ _reprocessJob_7__WEBPACK_IMPORTED_MODULE_30__.reprocessJob),\n/* harmony export */   retryJob: () => (/* reexport safe */ _retryJob_10__WEBPACK_IMPORTED_MODULE_31__.retryJob),\n/* harmony export */   saveStacktrace: () => (/* reexport safe */ _saveStacktrace_1__WEBPACK_IMPORTED_MODULE_32__.saveStacktrace),\n/* harmony export */   updateData: () => (/* reexport safe */ _updateData_1__WEBPACK_IMPORTED_MODULE_33__.updateData),\n/* harmony export */   updateProgress: () => (/* reexport safe */ _updateProgress_3__WEBPACK_IMPORTED_MODULE_34__.updateProgress)\n/* harmony export */ });\n/* harmony import */ var _addDelayedJob_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addDelayedJob-6 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js\");\n/* harmony import */ var _addParentJob_4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addParentJob-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-4.js\");\n/* harmony import */ var _addPrioritizedJob_7__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addPrioritizedJob-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-7.js\");\n/* harmony import */ var _addStandardJob_7__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addStandardJob-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-7.js\");\n/* harmony import */ var _changeDelay_4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./changeDelay-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js\");\n/* harmony import */ var _changePriority_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./changePriority-6 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-6.js\");\n/* harmony import */ var _cleanJobsInSet_2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cleanJobsInSet-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-2.js\");\n/* harmony import */ var _drain_4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drain-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-4.js\");\n/* harmony import */ var _extendLock_2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extendLock-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js\");\n/* harmony import */ var _getCounts_1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getCounts-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js\");\n/* harmony import */ var _getRanges_1__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getRanges-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js\");\n/* harmony import */ var _getState_8__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getState-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js\");\n/* harmony import */ var _getStateV2_8__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getStateV2-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js\");\n/* harmony import */ var _isFinished_3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isFinished-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js\");\n/* harmony import */ var _isJobInList_1__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isJobInList-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js\");\n/* harmony import */ var _moveJobFromActiveToWait_10__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./moveJobFromActiveToWait-10 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-10.js\");\n/* harmony import */ var _moveJobsToWait_7__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./moveJobsToWait-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-7.js\");\n/* harmony import */ var _moveStalledJobsToWait_9__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./moveStalledJobsToWait-9 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-9.js\");\n/* harmony import */ var _moveToActive_11__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./moveToActive-11 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js\");\n/* harmony import */ var _moveToDelayed_7__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./moveToDelayed-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-7.js\");\n/* harmony import */ var _moveToFinished_14__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./moveToFinished-14 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js\");\n/* harmony import */ var _moveToWaitingChildren_4__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./moveToWaitingChildren-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-4.js\");\n/* harmony import */ var _obliterate_2__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./obliterate-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js\");\n/* harmony import */ var _paginate_1__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./paginate-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js\");\n/* harmony import */ var _pause_7__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./pause-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js\");\n/* harmony import */ var _promote_8__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./promote-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-8.js\");\n/* harmony import */ var _releaseLock_1__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./releaseLock-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js\");\n/* harmony import */ var _removeChildDependency_1__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./removeChildDependency-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js\");\n/* harmony import */ var _removeJob_1__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./removeJob-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-1.js\");\n/* harmony import */ var _removeRepeatable_2__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./removeRepeatable-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-2.js\");\n/* harmony import */ var _reprocessJob_7__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./reprocessJob-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-7.js\");\n/* harmony import */ var _retryJob_10__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./retryJob-10 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-10.js\");\n/* harmony import */ var _saveStacktrace_1__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./saveStacktrace-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js\");\n/* harmony import */ var _updateData_1__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./updateData-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js\");\n/* harmony import */ var _updateProgress_3__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./updateProgress-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNEO0FBQ0s7QUFDSDtBQUNIO0FBQ0c7QUFDQTtBQUNUO0FBQ0s7QUFDRDtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0M7QUFDYTtBQUNWO0FBQ087QUFDUjtBQUNBO0FBQ0U7QUFDTTtBQUNYO0FBQ0Y7QUFDSDtBQUNFO0FBQ0k7QUFDVTtBQUNaO0FBQ087QUFDSjtBQUNIO0FBQ0s7QUFDSjtBQUNJLENBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaW5kZXguanM/Y2Y4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FkZERlbGF5ZWRKb2ItNic7XG5leHBvcnQgKiBmcm9tICcuL2FkZFBhcmVudEpvYi00JztcbmV4cG9ydCAqIGZyb20gJy4vYWRkUHJpb3JpdGl6ZWRKb2ItNyc7XG5leHBvcnQgKiBmcm9tICcuL2FkZFN0YW5kYXJkSm9iLTcnO1xuZXhwb3J0ICogZnJvbSAnLi9jaGFuZ2VEZWxheS00JztcbmV4cG9ydCAqIGZyb20gJy4vY2hhbmdlUHJpb3JpdHktNic7XG5leHBvcnQgKiBmcm9tICcuL2NsZWFuSm9ic0luU2V0LTInO1xuZXhwb3J0ICogZnJvbSAnLi9kcmFpbi00JztcbmV4cG9ydCAqIGZyb20gJy4vZXh0ZW5kTG9jay0yJztcbmV4cG9ydCAqIGZyb20gJy4vZ2V0Q291bnRzLTEnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRSYW5nZXMtMSc7XG5leHBvcnQgKiBmcm9tICcuL2dldFN0YXRlLTgnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRTdGF0ZVYyLTgnO1xuZXhwb3J0ICogZnJvbSAnLi9pc0ZpbmlzaGVkLTMnO1xuZXhwb3J0ICogZnJvbSAnLi9pc0pvYkluTGlzdC0xJztcbmV4cG9ydCAqIGZyb20gJy4vbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtMTAnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlSm9ic1RvV2FpdC03JztcbmV4cG9ydCAqIGZyb20gJy4vbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTknO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9BY3RpdmUtMTEnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9EZWxheWVkLTcnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9GaW5pc2hlZC0xNCc7XG5leHBvcnQgKiBmcm9tICcuL21vdmVUb1dhaXRpbmdDaGlsZHJlbi00JztcbmV4cG9ydCAqIGZyb20gJy4vb2JsaXRlcmF0ZS0yJztcbmV4cG9ydCAqIGZyb20gJy4vcGFnaW5hdGUtMSc7XG5leHBvcnQgKiBmcm9tICcuL3BhdXNlLTcnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9tb3RlLTgnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWxlYXNlTG9jay0xJztcbmV4cG9ydCAqIGZyb20gJy4vcmVtb3ZlQ2hpbGREZXBlbmRlbmN5LTEnO1xuZXhwb3J0ICogZnJvbSAnLi9yZW1vdmVKb2ItMSc7XG5leHBvcnQgKiBmcm9tICcuL3JlbW92ZVJlcGVhdGFibGUtMic7XG5leHBvcnQgKiBmcm9tICcuL3JlcHJvY2Vzc0pvYi03JztcbmV4cG9ydCAqIGZyb20gJy4vcmV0cnlKb2ItMTAnO1xuZXhwb3J0ICogZnJvbSAnLi9zYXZlU3RhY2t0cmFjZS0xJztcbmV4cG9ydCAqIGZyb20gJy4vdXBkYXRlRGF0YS0xJztcbmV4cG9ydCAqIGZyb20gJy4vdXBkYXRlUHJvZ3Jlc3MtMyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/isFinished-3.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isFinished: () => (/* binding */ isFinished)\n/* harmony export */ });\nconst content = `--[[\n  Checks if a job is finished (.i.e. is in the completed or failed set)\n  Input: \n    KEYS[1] completed key\n    KEYS[2] failed key\n    KEYS[3] job key\n    ARGV[1] job id\n    ARGV[2] return value?\n  Output:\n    0 - Not finished.\n    1 - Completed.\n    2 - Failed.\n   -1 - Missing job. \n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[3]) ~= 1 then\n  if ARGV[2] == \"1\" then\n    return {-1,\"Missing key for job \" .. KEYS[3] .. \". isFinished\"}\n  end  \n  return -1\nend\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) ~= false then\n  if ARGV[2] == \"1\" then\n    local returnValue = rcall(\"HGET\", KEYS[3], \"returnvalue\")\n    return {1,returnValue}\n  end\n  return 1\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) ~= false then\n  if ARGV[2] == \"1\" then\n    local failedReason = rcall(\"HGET\", KEYS[3], \"failedReason\")\n    return {2,failedReason}\n  end\n  return 2\nend\nif ARGV[2] == \"1\" then\n  return {0}\nend\nreturn 0\n`;\nconst isFinished = {\n    name: \"isFinished\",\n    content,\n    keys: 3\n}; //# sourceMappingURL=isFinished-3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNGaW5pc2hlZC0zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDakIsQ0FBQztBQUNNLE1BQU1DLGFBQWE7SUFDdEJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2lzRmluaXNoZWQtMy5qcz82ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGVja3MgaWYgYSBqb2IgaXMgZmluaXNoZWQgKC5pLmUuIGlzIGluIHRoZSBjb21wbGV0ZWQgb3IgZmFpbGVkIHNldClcbiAgSW5wdXQ6IFxuICAgIEtFWVNbMV0gY29tcGxldGVkIGtleVxuICAgIEtFWVNbMl0gZmFpbGVkIGtleVxuICAgIEtFWVNbM10gam9iIGtleVxuICAgIEFSR1ZbMV0gam9iIGlkXG4gICAgQVJHVlsyXSByZXR1cm4gdmFsdWU/XG4gIE91dHB1dDpcbiAgICAwIC0gTm90IGZpbmlzaGVkLlxuICAgIDEgLSBDb21wbGV0ZWQuXG4gICAgMiAtIEZhaWxlZC5cbiAgIC0xIC0gTWlzc2luZyBqb2IuIFxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1szXSkgfj0gMSB0aGVuXG4gIGlmIEFSR1ZbMl0gPT0gXCIxXCIgdGhlblxuICAgIHJldHVybiB7LTEsXCJNaXNzaW5nIGtleSBmb3Igam9iIFwiIC4uIEtFWVNbM10gLi4gXCIuIGlzRmluaXNoZWRcIn1cbiAgZW5kICBcbiAgcmV0dXJuIC0xXG5lbmRcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMV0sIEFSR1ZbMV0pIH49IGZhbHNlIHRoZW5cbiAgaWYgQVJHVlsyXSA9PSBcIjFcIiB0aGVuXG4gICAgbG9jYWwgcmV0dXJuVmFsdWUgPSByY2FsbChcIkhHRVRcIiwgS0VZU1szXSwgXCJyZXR1cm52YWx1ZVwiKVxuICAgIHJldHVybiB7MSxyZXR1cm5WYWx1ZX1cbiAgZW5kXG4gIHJldHVybiAxXG5lbmRcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMl0sIEFSR1ZbMV0pIH49IGZhbHNlIHRoZW5cbiAgaWYgQVJHVlsyXSA9PSBcIjFcIiB0aGVuXG4gICAgbG9jYWwgZmFpbGVkUmVhc29uID0gcmNhbGwoXCJIR0VUXCIsIEtFWVNbM10sIFwiZmFpbGVkUmVhc29uXCIpXG4gICAgcmV0dXJuIHsyLGZhaWxlZFJlYXNvbn1cbiAgZW5kXG4gIHJldHVybiAyXG5lbmRcbmlmIEFSR1ZbMl0gPT0gXCIxXCIgdGhlblxuICByZXR1cm4gezB9XG5lbmRcbnJldHVybiAwXG5gO1xuZXhwb3J0IGNvbnN0IGlzRmluaXNoZWQgPSB7XG4gICAgbmFtZTogJ2lzRmluaXNoZWQnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ZpbmlzaGVkLTMuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJpc0ZpbmlzaGVkIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isJobInList: () => (/* binding */ isJobInList)\n/* harmony export */ });\nconst content = `--[[\n  Checks if job is in a given list.\n  Input:\n    KEYS[1]\n    ARGV[1]\n  Output:\n    1 if element found in the list.\n]]\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal items = redis.call(\"LRANGE\", KEYS[1] , 0, -1)\nreturn checkItemInList(items, ARGV[1])\n`;\nconst isJobInList = {\n    name: \"isJobInList\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=isJobInList-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNKb2JJbkxpc3QtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JqQixDQUFDO0FBQ00sTUFBTUMsY0FBYztJQUN2QkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNKb2JJbkxpc3QtMS5qcz85ZTMzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGVja3MgaWYgam9iIGlzIGluIGEgZ2l2ZW4gbGlzdC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXVxuICAgIEFSR1ZbMV1cbiAgT3V0cHV0OlxuICAgIDEgaWYgZWxlbWVudCBmb3VuZCBpbiB0aGUgbGlzdC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gY2hlY2sgaWYgYSBpdGVtIGJlbG9uZ3MgdG8gYSBsaXN0LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGNoZWNrSXRlbUluTGlzdChsaXN0LCBpdGVtKVxuICBmb3IgXywgdiBpbiBwYWlycyhsaXN0KSBkb1xuICAgIGlmIHYgPT0gaXRlbSB0aGVuXG4gICAgICByZXR1cm4gMVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIG5pbFxuZW5kXG5sb2NhbCBpdGVtcyA9IHJlZGlzLmNhbGwoXCJMUkFOR0VcIiwgS0VZU1sxXSAsIDAsIC0xKVxucmV0dXJuIGNoZWNrSXRlbUluTGlzdChpdGVtcywgQVJHVlsxXSlcbmA7XG5leHBvcnQgY29uc3QgaXNKb2JJbkxpc3QgPSB7XG4gICAgbmFtZTogJ2lzSm9iSW5MaXN0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNKb2JJbkxpc3QtMS5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsImlzSm9iSW5MaXN0IiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-10.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-10.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveJobFromActiveToWait: () => (/* binding */ moveJobFromActiveToWait)\n/* harmony export */ });\nconst content = `--[[\n  Function to move job from active state to wait.\n  Input:\n    KEYS[1]  active key\n    KEYS[2]  wait key\n    KEYS[3]  stalled key\n    KEYS[4]  job lock key\n    KEYS[5]  paused key\n    KEYS[6]  meta key\n    KEYS[7]  limiter key\n    KEYS[8]  prioritized key\n    KEYS[9]  marker key\n    KEYS[10] event key\n    ARGV[1] job id\n    ARGV[2] lock token\n    ARGV[3] job id key\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to push back job considering priority in front of same prioritized jobs.\n]]\nlocal function pushBackJobWithPriority(prioritizedKey, priority, jobId)\n  -- in order to put it at front of same prioritized jobs\n  -- we consider prioritized counter as 0\n  local score = priority * 0x100000000\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal jobId = ARGV[1]\nlocal token = ARGV[2]\nlocal lockKey = KEYS[4]\nlocal lockToken = rcall(\"GET\", lockKey)\nlocal pttl = rcall(\"PTTL\", KEYS[7])\nif lockToken == token then\n  local metaKey = KEYS[6]\n  local removed = rcall(\"LREM\", KEYS[1], 1, jobId)\n  if removed > 0 then\n    local target, isPaused = getTargetQueueList(metaKey, KEYS[2], KEYS[5])\n    rcall(\"SREM\", KEYS[3], jobId)\n    local priority = tonumber(rcall(\"HGET\", ARGV[3], \"priority\")) or 0\n    if priority > 0 then\n      pushBackJobWithPriority(KEYS[8], priority, jobId)\n    else\n      addJobInTargetList(target, KEYS[9], \"RPUSH\", isPaused, jobId)\n    end\n    rcall(\"DEL\", lockKey)\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    -- Emit waiting event\n    rcall(\"XADD\", KEYS[10], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId)\n  end\nend\nreturn pttl\n`;\nconst moveJobFromActiveToWait = {\n    name: \"moveJobFromActiveToWait\",\n    content,\n    keys: 10\n}; //# sourceMappingURL=moveJobFromActiveToWait-10.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtMTAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJGakIsQ0FBQztBQUNNLE1BQU1DLDBCQUEwQjtJQUNuQ0MsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtMTAuanM/MDY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgRnVuY3Rpb24gdG8gbW92ZSBqb2IgZnJvbSBhY3RpdmUgc3RhdGUgdG8gd2FpdC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAgYWN0aXZlIGtleVxuICAgIEtFWVNbMl0gIHdhaXQga2V5XG4gICAgS0VZU1szXSAgc3RhbGxlZCBrZXlcbiAgICBLRVlTWzRdICBqb2IgbG9jayBrZXlcbiAgICBLRVlTWzVdICBwYXVzZWQga2V5XG4gICAgS0VZU1s2XSAgbWV0YSBrZXlcbiAgICBLRVlTWzddICBsaW1pdGVyIGtleVxuICAgIEtFWVNbOF0gIHByaW9yaXRpemVkIGtleVxuICAgIEtFWVNbOV0gIG1hcmtlciBrZXlcbiAgICBLRVlTWzEwXSBldmVudCBrZXlcbiAgICBBUkdWWzFdIGpvYiBpZFxuICAgIEFSR1ZbMl0gbG9jayB0b2tlblxuICAgIEFSR1ZbM10gam9iIGlkIGtleVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBwdXNoIGJhY2sgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5IGluIGZyb250IG9mIHNhbWUgcHJpb3JpdGl6ZWQgam9icy5cbl1dXG5sb2NhbCBmdW5jdGlvbiBwdXNoQmFja0pvYldpdGhQcmlvcml0eShwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkKVxuICAtLSBpbiBvcmRlciB0byBwdXQgaXQgYXQgZnJvbnQgb2Ygc2FtZSBwcmlvcml0aXplZCBqb2JzXG4gIC0tIHdlIGNvbnNpZGVyIHByaW9yaXRpemVkIGNvdW50ZXIgYXMgMFxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDBcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICAgIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgICAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gICAgZW5kXG4gICAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmxvY2FsIGpvYklkID0gQVJHVlsxXVxubG9jYWwgdG9rZW4gPSBBUkdWWzJdXG5sb2NhbCBsb2NrS2V5ID0gS0VZU1s0XVxubG9jYWwgbG9ja1Rva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbmxvY2FsIHB0dGwgPSByY2FsbChcIlBUVExcIiwgS0VZU1s3XSlcbmlmIGxvY2tUb2tlbiA9PSB0b2tlbiB0aGVuXG4gIGxvY2FsIG1ldGFLZXkgPSBLRVlTWzZdXG4gIGxvY2FsIHJlbW92ZWQgPSByY2FsbChcIkxSRU1cIiwgS0VZU1sxXSwgMSwgam9iSWQpXG4gIGlmIHJlbW92ZWQgPiAwIHRoZW5cbiAgICBsb2NhbCB0YXJnZXQsIGlzUGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbMl0sIEtFWVNbNV0pXG4gICAgcmNhbGwoXCJTUkVNXCIsIEtFWVNbM10sIGpvYklkKVxuICAgIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIEFSR1ZbM10sIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgICBpZiBwcmlvcml0eSA+IDAgdGhlblxuICAgICAgcHVzaEJhY2tKb2JXaXRoUHJpb3JpdHkoS0VZU1s4XSwgcHJpb3JpdHksIGpvYklkKVxuICAgIGVsc2VcbiAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIEtFWVNbOV0sIFwiUlBVU0hcIiwgaXNQYXVzZWQsIGpvYklkKVxuICAgIGVuZFxuICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICByY2FsbChcIlhBRERcIiwgS0VZU1sxMF0sIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgXCJqb2JJZFwiLCBqb2JJZClcbiAgZW5kXG5lbmRcbnJldHVybiBwdHRsXG5gO1xuZXhwb3J0IGNvbnN0IG1vdmVKb2JGcm9tQWN0aXZlVG9XYWl0ID0ge1xuICAgIG5hbWU6ICdtb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdCcsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxMCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdC0xMC5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsIm1vdmVKb2JGcm9tQWN0aXZlVG9XYWl0IiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-10.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-7.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-7.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveJobsToWait: () => (/* binding */ moveJobsToWait)\n/* harmony export */ });\nconst content = `--[[\n  Move completed, failed or delayed jobs to wait.\n  Note: Does not support jobs with priorities.\n  Input:\n    KEYS[1] base key\n    KEYS[2] events stream\n    KEYS[3] state key (failed, completed, delayed)\n    KEYS[4] 'wait'\n    KEYS[5] 'paused'\n    KEYS[6] 'meta'\n    KEYS[7] 'marker'\n    ARGV[1] count\n    ARGV[2] timestamp\n    ARGV[3] prev state\n  Output:\n    1  means the operation is not completed\n    0  means the operation is completed\n]]\nlocal maxCount = tonumber(ARGV[1])\nlocal timestamp = tonumber(ARGV[2])\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal metaKey = KEYS[6]\nlocal target, paused = getTargetQueueList(metaKey, KEYS[4], KEYS[5])\nlocal jobs = rcall('ZRANGEBYSCORE', KEYS[3], 0, timestamp, 'LIMIT', 0, maxCount)\nif (#jobs > 0) then\n    if ARGV[3] == \"failed\" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"failedReason\")\n        end\n    elseif ARGV[3] == \"completed\" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"returnvalue\")\n        end\n    end\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    for i, key in ipairs(jobs) do\n        -- Emit waiting event\n        rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n              \"waiting\", \"jobId\", key, \"prev\", ARGV[3]);\n    end\n    for from, to in batches(#jobs, 7000) do\n        rcall(\"ZREM\", KEYS[3], unpack(jobs, from, to))\n        rcall(\"LPUSH\", target, unpack(jobs, from, to))\n    end\n    addBaseMarkerIfNeeded(KEYS[7], paused)\nend\nmaxCount = maxCount - #jobs\nif (maxCount <= 0) then return 1 end\nreturn 0\n`;\nconst moveJobsToWait = {\n    name: \"moveJobsToWait\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=moveJobsToWait-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYnNUb1dhaXQtNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtHakIsQ0FBQztBQUNNLE1BQU1DLGlCQUFpQjtJQUMxQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYnNUb1dhaXQtNy5qcz8xOTE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIGNvbXBsZXRlZCwgZmFpbGVkIG9yIGRlbGF5ZWQgam9icyB0byB3YWl0LlxuICBOb3RlOiBEb2VzIG5vdCBzdXBwb3J0IGpvYnMgd2l0aCBwcmlvcml0aWVzLlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGJhc2Uga2V5XG4gICAgS0VZU1syXSBldmVudHMgc3RyZWFtXG4gICAgS0VZU1szXSBzdGF0ZSBrZXkgKGZhaWxlZCwgY29tcGxldGVkLCBkZWxheWVkKVxuICAgIEtFWVNbNF0gJ3dhaXQnXG4gICAgS0VZU1s1XSAncGF1c2VkJ1xuICAgIEtFWVNbNl0gJ21ldGEnXG4gICAgS0VZU1s3XSAnbWFya2VyJ1xuICAgIEFSR1ZbMV0gY291bnRcbiAgICBBUkdWWzJdIHRpbWVzdGFtcFxuICAgIEFSR1ZbM10gcHJldiBzdGF0ZVxuICBPdXRwdXQ6XG4gICAgMSAgbWVhbnMgdGhlIG9wZXJhdGlvbiBpcyBub3QgY29tcGxldGVkXG4gICAgMCAgbWVhbnMgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZWRcbl1dXG5sb2NhbCBtYXhDb3VudCA9IHRvbnVtYmVyKEFSR1ZbMV0pXG5sb2NhbCB0aW1lc3RhbXAgPSB0b251bWJlcihBUkdWWzJdKVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsO1xuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbG9vcCBpbiBiYXRjaGVzLlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHNvbWUgY29tbWFuZHMgYXMgWlJFTVxuICBjb3VsZCByZWNlaXZlIGEgbWF4aW11bSBvZiA3MDAwIHBhcmFtZXRlcnMgcGVyIGNhbGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gYmF0Y2hlcyhuLCBiYXRjaFNpemUpXG4gIGxvY2FsIGkgPSAwXG4gIHJldHVybiBmdW5jdGlvbigpXG4gICAgbG9jYWwgZnJvbSA9IGkgKiBiYXRjaFNpemUgKyAxXG4gICAgaSA9IGkgKyAxXG4gICAgaWYgKGZyb20gPD0gbikgdGhlblxuICAgICAgbG9jYWwgdG8gPSBtYXRoLm1pbihmcm9tICsgYmF0Y2hTaXplIC0gMSwgbilcbiAgICAgIHJldHVybiBmcm9tLCB0b1xuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxubG9jYWwgbWV0YUtleSA9IEtFWVNbNl1cbmxvY2FsIHRhcmdldCwgcGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbNF0sIEtFWVNbNV0pXG5sb2NhbCBqb2JzID0gcmNhbGwoJ1pSQU5HRUJZU0NPUkUnLCBLRVlTWzNdLCAwLCB0aW1lc3RhbXAsICdMSU1JVCcsIDAsIG1heENvdW50KVxuaWYgKCNqb2JzID4gMCkgdGhlblxuICAgIGlmIEFSR1ZbM10gPT0gXCJmYWlsZWRcIiB0aGVuXG4gICAgICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBLRVlTWzFdIC4uIGtleVxuICAgICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJmYWlsZWRSZWFzb25cIilcbiAgICAgICAgZW5kXG4gICAgZWxzZWlmIEFSR1ZbM10gPT0gXCJjb21wbGV0ZWRcIiB0aGVuXG4gICAgICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBLRVlTWzFdIC4uIGtleVxuICAgICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJyZXR1cm52YWx1ZVwiKVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgIC0tIEVtaXQgd2FpdGluZyBldmVudFxuICAgICAgICByY2FsbChcIlhBRERcIiwgS0VZU1syXSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwga2V5LCBcInByZXZcIiwgQVJHVlszXSk7XG4gICAgZW5kXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2pvYnMsIDcwMDApIGRvXG4gICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzNdLCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgICAgICByY2FsbChcIkxQVVNIXCIsIHRhcmdldCwgdW5wYWNrKGpvYnMsIGZyb20sIHRvKSlcbiAgICBlbmRcbiAgICBhZGRCYXNlTWFya2VySWZOZWVkZWQoS0VZU1s3XSwgcGF1c2VkKVxuZW5kXG5tYXhDb3VudCA9IG1heENvdW50IC0gI2pvYnNcbmlmIChtYXhDb3VudCA8PSAwKSB0aGVuIHJldHVybiAxIGVuZFxucmV0dXJuIDBcbmA7XG5leHBvcnQgY29uc3QgbW92ZUpvYnNUb1dhaXQgPSB7XG4gICAgbmFtZTogJ21vdmVKb2JzVG9XYWl0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZUpvYnNUb1dhaXQtNy5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsIm1vdmVKb2JzVG9XYWl0IiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-9.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-9.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveStalledJobsToWait: () => (/* binding */ moveStalledJobsToWait)\n/* harmony export */ });\nconst content = `--[[\n  Move stalled jobs to wait.\n    Input:\n      KEYS[1] 'stalled' (SET)\n      KEYS[2] 'wait',   (LIST)\n      KEYS[3] 'active', (LIST)\n      KEYS[4] 'failed', (ZSET)\n      KEYS[5] 'stalled-check', (KEY)\n      KEYS[6] 'meta', (KEY)\n      KEYS[7] 'paused', (LIST)\n      KEYS[8] 'marker'\n      KEYS[9] 'event stream' (STREAM)\n      ARGV[1]  Max stalled job count\n      ARGV[2]  queue.toKey('')\n      ARGV[3]  timestamp\n      ARGV[4]  max check time\n    Events:\n      'stalled' with stalled job id.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  removeJobKeys(jobKey)\nend\n--[[\n  Functions to remove jobs by max age.\n]]\n-- Includes\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix)\n  end\n  rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\nend\n--[[\n  Functions to remove jobs by max count.\n]]\n-- Includes\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix)\n  end\n  rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1))\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents ~= false then\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", maxEvents)\n  else\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", 10000)\n  end\nend\nlocal stalledKey = KEYS[1]\nlocal waitKey = KEYS[2]\nlocal activeKey = KEYS[3]\nlocal failedKey = KEYS[4]\nlocal stalledCheckKey = KEYS[5]\nlocal metaKey = KEYS[6]\nlocal pausedKey = KEYS[7]\nlocal markerKey = KEYS[8]\nlocal eventStreamKey = KEYS[9]\nlocal maxStalledJobCount = ARGV[1]\nlocal queueKeyPrefix = ARGV[2]\nlocal timestamp = ARGV[3]\nlocal maxCheckTime = ARGV[4]\nif rcall(\"EXISTS\", stalledCheckKey) == 1 then return {{}, {}} end\nrcall(\"SET\", stalledCheckKey, timestamp, \"PX\", maxCheckTime)\n-- Trim events before emiting them to avoid trimming events emitted in this script\ntrimEvents(metaKey, eventStreamKey)\n-- Move all stalled jobs to wait\nlocal stalling = rcall('SMEMBERS', stalledKey)\nlocal stalled = {}\nlocal failed = {}\nif (#stalling > 0) then\n    rcall('DEL', stalledKey)\n    local MAX_STALLED_JOB_COUNT = tonumber(maxStalledJobCount)\n    -- Remove from active list\n    for i, jobId in ipairs(stalling) do\n        -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n        if string.sub(jobId, 1, 2) == \"0:\" then\n            -- If the jobId is a delay marker ID we just remove it.\n            rcall(\"LREM\", activeKey, 1, jobId)\n        else\n            local jobKey = queueKeyPrefix .. jobId\n            -- Check that the lock is also missing, then we can handle this job as really stalled.\n            if (rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n                --  Remove from the active queue.\n                local removed = rcall(\"LREM\", activeKey, 1, jobId)\n                if (removed > 0) then\n                    -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.\n                    local stalledCount =\n                        rcall(\"HINCRBY\", jobKey, \"stalledCounter\", 1)\n                    if (stalledCount > MAX_STALLED_JOB_COUNT) then\n                        local rawOpts = rcall(\"HGET\", jobKey, \"opts\")\n                        local opts = cjson.decode(rawOpts)\n                        local removeOnFailType = type(opts[\"removeOnFail\"])\n                        rcall(\"ZADD\", failedKey, timestamp, jobId)\n                        local failedReason =\n                            \"job stalled more than allowable limit\"\n                        rcall(\"HMSET\", jobKey, \"failedReason\", failedReason,\n                              \"finishedOn\", timestamp)\n                        rcall(\"XADD\", eventStreamKey, \"*\", \"event\",\n                              \"failed\", \"jobId\", jobId, 'prev', 'active',\n                              'failedReason', failedReason)\n                        if removeOnFailType == \"number\" then\n                            removeJobsByMaxCount(opts[\"removeOnFail\"],\n                                                  failedKey, queueKeyPrefix)\n                        elseif removeOnFailType == \"boolean\" then\n                            if opts[\"removeOnFail\"] then\n                                removeJob(jobId, false, queueKeyPrefix)\n                                rcall(\"ZREM\", failedKey, jobId)\n                            end\n                        elseif removeOnFailType ~= \"nil\" then\n                            local maxAge = opts[\"removeOnFail\"][\"age\"]\n                            local maxCount = opts[\"removeOnFail\"][\"count\"]\n                            if maxAge ~= nil then\n                                removeJobsByMaxAge(timestamp, maxAge,\n                                                    failedKey, queueKeyPrefix)\n                            end\n                            if maxCount ~= nil and maxCount > 0 then\n                                removeJobsByMaxCount(maxCount, failedKey,\n                                                      queueKeyPrefix)\n                            end\n                        end\n                        table.insert(failed, jobId)\n                    else\n                        local target, isPaused=\n                            getTargetQueueList(metaKey, waitKey, pausedKey)\n                        -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n                        addJobInTargetList(target, markerKey, \"RPUSH\", isPaused, jobId)\n                        rcall(\"XADD\", eventStreamKey, \"*\", \"event\",\n                              \"waiting\", \"jobId\", jobId, 'prev', 'active')\n                        -- Emit the stalled event\n                        rcall(\"XADD\", eventStreamKey, \"*\", \"event\",\n                              \"stalled\", \"jobId\", jobId)\n                        table.insert(stalled, jobId)\n                    end\n                end\n            end\n        end\n    end\nend\n-- Mark potentially stalled jobs\nlocal active = rcall('LRANGE', activeKey, 0, -1)\nif (#active > 0) then\n    for from, to in batches(#active, 7000) do\n        rcall('SADD', stalledKey, unpack(active, from, to))\n    end\nend\nreturn {failed, stalled}`;\nconst moveStalledJobsToWait = {\n    name: \"moveStalledJobsToWait\",\n    content,\n    keys: 9\n}; //# sourceMappingURL=moveStalledJobsToWait-9.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBaVRPLENBQUM7QUFDbEIsTUFBTUMsd0JBQXdCO0lBQ2pDQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9tb3ZlU3RhbGxlZEpvYnNUb1dhaXQtOS5qcz8xOWNhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIHN0YWxsZWQgam9icyB0byB3YWl0LlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnc3RhbGxlZCcgKFNFVClcbiAgICAgIEtFWVNbMl0gJ3dhaXQnLCAgIChMSVNUKVxuICAgICAgS0VZU1szXSAnYWN0aXZlJywgKExJU1QpXG4gICAgICBLRVlTWzRdICdmYWlsZWQnLCAoWlNFVClcbiAgICAgIEtFWVNbNV0gJ3N0YWxsZWQtY2hlY2snLCAoS0VZKVxuICAgICAgS0VZU1s2XSAnbWV0YScsIChLRVkpXG4gICAgICBLRVlTWzddICdwYXVzZWQnLCAoTElTVClcbiAgICAgIEtFWVNbOF0gJ21hcmtlcidcbiAgICAgIEtFWVNbOV0gJ2V2ZW50IHN0cmVhbScgKFNUUkVBTSlcbiAgICAgIEFSR1ZbMV0gIE1heCBzdGFsbGVkIGpvYiBjb3VudFxuICAgICAgQVJHVlsyXSAgcXVldWUudG9LZXkoJycpXG4gICAgICBBUkdWWzNdICB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbNF0gIG1heCBjaGVjayB0aW1lXG4gICAgRXZlbnRzOlxuICAgICAgJ3N0YWxsZWQnIHdpdGggc3RhbGxlZCBqb2IgaWQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsXG4gICAgam9iS2V5IC4uICc6ZGVwZW5kZW5jaWVzJywgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudFByZWZpeCAuLiBcIm1ldGFcIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdFwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXkpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgbWlzc2VkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2Ioam9iSWQsIGhhcmQsIGJhc2VLZXkpXG4gIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4gam9iSWRcbiAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIHJlbW92ZSBqb2JzIGJ5IG1heCBhZ2UuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYnNCeU1heEFnZSh0aW1lc3RhbXAsIG1heEFnZSwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gdGltZXN0YW1wIC0gbWF4QWdlICogMTAwMFxuICBsb2NhbCBqb2JJZHMgPSByY2FsbChcIlpSRVZSQU5HRUJZU0NPUkVcIiwgdGFyZ2V0U2V0LCBzdGFydCwgXCItaW5mXCIpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIFwiLWluZlwiLCBzdGFydClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMgYnkgbWF4IGNvdW50LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzQnlNYXhDb3VudChtYXhDb3VudCwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gbWF4Q291bnRcbiAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VcIiwgdGFyZ2V0U2V0LCBzdGFydCwgLTEpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllSQU5LXCIsIHRhcmdldFNldCwgMCwgLShtYXhDb3VudCArIDEpKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHRyaW0gZXZlbnRzLCBkZWZhdWx0IDEwMDAwLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICAgICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICAgIGVuZFxuICAgIHJldHVybiBtYXhFdmVudHNcbmVuZFxubG9jYWwgZnVuY3Rpb24gdHJpbUV2ZW50cyhtZXRhS2V5LCBldmVudFN0cmVhbUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgaWYgbWF4RXZlbnRzIH49IGZhbHNlIHRoZW5cbiAgICByY2FsbChcIlhUUklNXCIsIGV2ZW50U3RyZWFtS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzKVxuICBlbHNlXG4gICAgcmNhbGwoXCJYVFJJTVwiLCBldmVudFN0cmVhbUtleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIDEwMDAwKVxuICBlbmRcbmVuZFxubG9jYWwgc3RhbGxlZEtleSA9IEtFWVNbMV1cbmxvY2FsIHdhaXRLZXkgPSBLRVlTWzJdXG5sb2NhbCBhY3RpdmVLZXkgPSBLRVlTWzNdXG5sb2NhbCBmYWlsZWRLZXkgPSBLRVlTWzRdXG5sb2NhbCBzdGFsbGVkQ2hlY2tLZXkgPSBLRVlTWzVdXG5sb2NhbCBtZXRhS2V5ID0gS0VZU1s2XVxubG9jYWwgcGF1c2VkS2V5ID0gS0VZU1s3XVxubG9jYWwgbWFya2VyS2V5ID0gS0VZU1s4XVxubG9jYWwgZXZlbnRTdHJlYW1LZXkgPSBLRVlTWzldXG5sb2NhbCBtYXhTdGFsbGVkSm9iQ291bnQgPSBBUkdWWzFdXG5sb2NhbCBxdWV1ZUtleVByZWZpeCA9IEFSR1ZbMl1cbmxvY2FsIHRpbWVzdGFtcCA9IEFSR1ZbM11cbmxvY2FsIG1heENoZWNrVGltZSA9IEFSR1ZbNF1cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIHN0YWxsZWRDaGVja0tleSkgPT0gMSB0aGVuIHJldHVybiB7e30sIHt9fSBlbmRcbnJjYWxsKFwiU0VUXCIsIHN0YWxsZWRDaGVja0tleSwgdGltZXN0YW1wLCBcIlBYXCIsIG1heENoZWNrVGltZSlcbi0tIFRyaW0gZXZlbnRzIGJlZm9yZSBlbWl0aW5nIHRoZW0gdG8gYXZvaWQgdHJpbW1pbmcgZXZlbnRzIGVtaXR0ZWQgaW4gdGhpcyBzY3JpcHRcbnRyaW1FdmVudHMobWV0YUtleSwgZXZlbnRTdHJlYW1LZXkpXG4tLSBNb3ZlIGFsbCBzdGFsbGVkIGpvYnMgdG8gd2FpdFxubG9jYWwgc3RhbGxpbmcgPSByY2FsbCgnU01FTUJFUlMnLCBzdGFsbGVkS2V5KVxubG9jYWwgc3RhbGxlZCA9IHt9XG5sb2NhbCBmYWlsZWQgPSB7fVxuaWYgKCNzdGFsbGluZyA+IDApIHRoZW5cbiAgICByY2FsbCgnREVMJywgc3RhbGxlZEtleSlcbiAgICBsb2NhbCBNQVhfU1RBTExFRF9KT0JfQ09VTlQgPSB0b251bWJlcihtYXhTdGFsbGVkSm9iQ291bnQpXG4gICAgLS0gUmVtb3ZlIGZyb20gYWN0aXZlIGxpc3RcbiAgICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKHN0YWxsaW5nKSBkb1xuICAgICAgICAtLSBNYXJrZXJzIGluIHdhaXRsaXN0IERFUFJFQ0FURUQgaW4gdjU6IFJlbW92ZSBpbiB2Ni5cbiAgICAgICAgaWYgc3RyaW5nLnN1Yihqb2JJZCwgMSwgMikgPT0gXCIwOlwiIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBqb2JJZCBpcyBhIGRlbGF5IG1hcmtlciBJRCB3ZSBqdXN0IHJlbW92ZSBpdC5cbiAgICAgICAgICAgIHJjYWxsKFwiTFJFTVwiLCBhY3RpdmVLZXksIDEsIGpvYklkKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBxdWV1ZUtleVByZWZpeCAuLiBqb2JJZFxuICAgICAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGUgbG9jayBpcyBhbHNvIG1pc3NpbmcsIHRoZW4gd2UgY2FuIGhhbmRsZSB0aGlzIGpvYiBhcyByZWFsbHkgc3RhbGxlZC5cbiAgICAgICAgICAgIGlmIChyY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkgLi4gXCI6bG9ja1wiKSA9PSAwKSB0aGVuXG4gICAgICAgICAgICAgICAgLS0gIFJlbW92ZSBmcm9tIHRoZSBhY3RpdmUgcXVldWUuXG4gICAgICAgICAgICAgICAgbG9jYWwgcmVtb3ZlZCA9IHJjYWxsKFwiTFJFTVwiLCBhY3RpdmVLZXksIDEsIGpvYklkKVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkID4gMCkgdGhlblxuICAgICAgICAgICAgICAgICAgICAtLSBJZiB0aGlzIGpvYiBoYXMgYmVlbiBzdGFsbGVkIHRvbyBtYW55IHRpbWVzLCBzdWNoIGFzIGlmIGl0IGNyYXNoZXMgdGhlIHdvcmtlciwgdGhlbiBmYWlsIGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2NhbCBzdGFsbGVkQ291bnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJISU5DUkJZXCIsIGpvYktleSwgXCJzdGFsbGVkQ291bnRlclwiLCAxKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhbGxlZENvdW50ID4gTUFYX1NUQUxMRURfSk9CX0NPVU5UKSB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCByYXdPcHRzID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJvcHRzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCBvcHRzID0gY2pzb24uZGVjb2RlKHJhd09wdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCByZW1vdmVPbkZhaWxUeXBlID0gdHlwZShvcHRzW1wicmVtb3ZlT25GYWlsXCJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJaQUREXCIsIGZhaWxlZEtleSwgdGltZXN0YW1wLCBqb2JJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsIGZhaWxlZFJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJqb2Igc3RhbGxlZCBtb3JlIHRoYW4gYWxsb3dhYmxlIGxpbWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iS2V5LCBcImZhaWxlZFJlYXNvblwiLCBmYWlsZWRSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbmlzaGVkT25cIiwgdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50U3RyZWFtS2V5LCBcIipcIiwgXCJldmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmYWlsZWRcIiwgXCJqb2JJZFwiLCBqb2JJZCwgJ3ByZXYnLCAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYWlsZWRSZWFzb24nLCBmYWlsZWRSZWFzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiByZW1vdmVPbkZhaWxUeXBlID09IFwibnVtYmVyXCIgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG9wdHNbXCJyZW1vdmVPbkZhaWxcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZEtleSwgcXVldWVLZXlQcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlaWYgcmVtb3ZlT25GYWlsVHlwZSA9PSBcImJvb2xlYW5cIiB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3B0c1tcInJlbW92ZU9uRmFpbFwiXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHF1ZXVlS2V5UHJlZml4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbChcIlpSRU1cIiwgZmFpbGVkS2V5LCBqb2JJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VpZiByZW1vdmVPbkZhaWxUeXBlIH49IFwibmlsXCIgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsIG1heEFnZSA9IG9wdHNbXCJyZW1vdmVPbkZhaWxcIl1bXCJhZ2VcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCBtYXhDb3VudCA9IG9wdHNbXCJyZW1vdmVPbkZhaWxcIl1bXCJjb3VudFwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG1heEFnZSB+PSBuaWwgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVKb2JzQnlNYXhBZ2UodGltZXN0YW1wLCBtYXhBZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkS2V5LCBxdWV1ZUtleVByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBtYXhDb3VudCB+PSBuaWwgYW5kIG1heENvdW50ID4gMCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG1heENvdW50LCBmYWlsZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUtleVByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuaW5zZXJ0KGZhaWxlZCwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsIHRhcmdldCwgaXNQYXVzZWQ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tIE1vdmUgdGhlIGpvYiBiYWNrIHRvIHRoZSB3YWl0IHF1ZXVlLCB0byBpbW1lZGlhdGVseSBiZSBwaWNrZWQgdXAgYnkgYSB3YWl0aW5nIHdvcmtlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIG1hcmtlcktleSwgXCJSUFVTSFwiLCBpc1BhdXNlZCwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBqb2JJZCwgJ3ByZXYnLCAnYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tIEVtaXQgdGhlIHN0YWxsZWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhbGxlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuaW5zZXJ0KHN0YWxsZWQsIGpvYklkKVxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxuLS0gTWFyayBwb3RlbnRpYWxseSBzdGFsbGVkIGpvYnNcbmxvY2FsIGFjdGl2ZSA9IHJjYWxsKCdMUkFOR0UnLCBhY3RpdmVLZXksIDAsIC0xKVxuaWYgKCNhY3RpdmUgPiAwKSB0aGVuXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2FjdGl2ZSwgNzAwMCkgZG9cbiAgICAgICAgcmNhbGwoJ1NBREQnLCBzdGFsbGVkS2V5LCB1bnBhY2soYWN0aXZlLCBmcm9tLCB0bykpXG4gICAgZW5kXG5lbmRcbnJldHVybiB7ZmFpbGVkLCBzdGFsbGVkfWA7XG5leHBvcnQgY29uc3QgbW92ZVN0YWxsZWRKb2JzVG9XYWl0ID0ge1xuICAgIG5hbWU6ICdtb3ZlU3RhbGxlZEpvYnNUb1dhaXQnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogOSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZlU3RhbGxlZEpvYnNUb1dhaXQtOS5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsIm1vdmVTdGFsbGVkSm9ic1RvV2FpdCIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToActive: () => (/* binding */ moveToActive)\n/* harmony export */ });\nconst content = `--[[\n  Move next job to be processed to active, lock it and fetch its data. The job\n  may be delayed, in that case we need to move it to the delayed set instead.\n  This operation guarantees that the worker owns the job during the lock\n  expiration time. The worker is responsible of keeping the lock fresh\n  so that no other worker picks this job again.\n  Input:\n    KEYS[1] wait key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] stream events key\n    KEYS[5] stalled key\n    -- Rate limiting\n    KEYS[6] rate limiter key\n    KEYS[7] delayed key\n    -- Delayed jobs\n    KEYS[8] paused key\n    KEYS[9] meta key\n    KEYS[10] pc priority counter\n    -- Marker\n    KEYS[11] marker key\n    -- Arguments\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] opts\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\nlocal rcall = redis.call\nlocal waitKey = KEYS[1]\nlocal activeKey = KEYS[2]\nlocal eventStreamKey = KEYS[4]\nlocal rateLimiterKey = KEYS[6]\nlocal delayedKey = KEYS[7]\nlocal opts = cmsgpack.unpack(ARGV[3])\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall(\"GET\", rateLimiterKey) or 0) then\n    local pttl = rcall(\"PTTL\", rateLimiterKey)\n    if pttl == 0 then\n      rcall(\"DEL\", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPriorityToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall(\"ZPOPMIN\", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall(\"LPUSH\", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall(\"DEL\", priorityCounterKey)\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall(\"INCR\", rateLimiterKey))\n    if jobCounter == 1 then\n      local limiterDuration = opts['limiter'] and opts['limiter']['duration']\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall(\"PEXPIRE\", rateLimiterKey, integerDuration)\n    end\n  end\n  local lockKey = jobKey .. ':lock'\n  -- get a lock\n  if opts['token'] ~= \"0\" then\n    rcall(\"SET\", lockKey, opts['token'], \"PX\", opts['lockDuration'])\n  end\n  if opts['name'] then\n    -- Set \"processedBy\" field to the worker name\n    rcall(\"HSET\", jobKey, \"pb\", opts['name'])\n  end\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"active\", \"jobId\", jobId, \"prev\", \"waiting\")\n  rcall(\"HSET\", jobKey, \"processedOn\", processedOn)\n  rcall(\"HINCRBY\", jobKey, \"ats\", 1)\n  return {rcall(\"HGETALL\", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                addJobInTargetList(targetKey, markerKey, \"LPUSH\", isPaused, jobId)\n            else\n                addJobWithPriority(markerKey, prioritizedKey, priority,\n                  jobId, priorityCounterKey, isPaused)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n    end\nend\nlocal target, paused = getTargetQueueList(KEYS[9], waitKey, KEYS[8])\n-- Check if there are delayed jobs that we can move to wait.\nlocal markerKey = KEYS[11]\npromoteDelayedJobs(delayedKey, markerKey, target, KEYS[3], eventStreamKey, ARGV[1],\n                   ARGV[2], KEYS[10], paused)\nlocal maxJobs = tonumber(opts['limiter'] and opts['limiter']['max'])\nlocal expireTime = getRateLimitTTL(maxJobs, rateLimiterKey)\n-- Check if we are rate limited first.\nif expireTime > 0 then return {0, 0, expireTime, 0} end\n-- paused queue\nif paused then return {0, 0, 0, 0} end\n-- no job ID, try non-blocking move from wait to active\nlocal jobId = rcall(\"RPOPLPUSH\", waitKey, activeKey)\n-- Markers in waitlist DEPRECATED in v5: Will be completely removed in v6.\nif jobId and string.sub(jobId, 1, 2) == \"0:\" then\n    rcall(\"LREM\", activeKey, 1, jobId)\n    jobId = rcall(\"RPOPLPUSH\", waitKey, activeKey)\nend\nif jobId then\n    return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                   maxJobs, opts)\nelse\n    jobId = moveJobFromPriorityToActive(KEYS[3], activeKey, KEYS[10])\n    if jobId then\n        return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                       maxJobs, opts)\n    end\nend\n-- Return the timestamp for the next delayed job if any.\nlocal nextTimestamp = getNextDelayedTimestamp(delayedKey)\nif (nextTimestamp ~= nil) then return {0, 0, 0, nextTimestamp} end\nreturn {0, 0, 0, 0}\n`;\nconst moveToActive = {\n    name: \"moveToActive\",\n    content,\n    keys: 11\n}; //# sourceMappingURL=moveToActive-11.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvQWN0aXZlLTExLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtOakIsQ0FBQztBQUNNLE1BQU1DLGVBQWU7SUFDeEJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVUb0FjdGl2ZS0xMS5qcz8xMDEzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIG5leHQgam9iIHRvIGJlIHByb2Nlc3NlZCB0byBhY3RpdmUsIGxvY2sgaXQgYW5kIGZldGNoIGl0cyBkYXRhLiBUaGUgam9iXG4gIG1heSBiZSBkZWxheWVkLCBpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHRoZSBkZWxheWVkIHNldCBpbnN0ZWFkLlxuICBUaGlzIG9wZXJhdGlvbiBndWFyYW50ZWVzIHRoYXQgdGhlIHdvcmtlciBvd25zIHRoZSBqb2IgZHVyaW5nIHRoZSBsb2NrXG4gIGV4cGlyYXRpb24gdGltZS4gVGhlIHdvcmtlciBpcyByZXNwb25zaWJsZSBvZiBrZWVwaW5nIHRoZSBsb2NrIGZyZXNoXG4gIHNvIHRoYXQgbm8gb3RoZXIgd29ya2VyIHBpY2tzIHRoaXMgam9iIGFnYWluLlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgS0VZU1syXSBhY3RpdmUga2V5XG4gICAgS0VZU1szXSBwcmlvcml0aXplZCBrZXlcbiAgICBLRVlTWzRdIHN0cmVhbSBldmVudHMga2V5XG4gICAgS0VZU1s1XSBzdGFsbGVkIGtleVxuICAgIC0tIFJhdGUgbGltaXRpbmdcbiAgICBLRVlTWzZdIHJhdGUgbGltaXRlciBrZXlcbiAgICBLRVlTWzddIGRlbGF5ZWQga2V5XG4gICAgLS0gRGVsYXllZCBqb2JzXG4gICAgS0VZU1s4XSBwYXVzZWQga2V5XG4gICAgS0VZU1s5XSBtZXRhIGtleVxuICAgIEtFWVNbMTBdIHBjIHByaW9yaXR5IGNvdW50ZXJcbiAgICAtLSBNYXJrZXJcbiAgICBLRVlTWzExXSBtYXJrZXIga2V5XG4gICAgLS0gQXJndW1lbnRzXG4gICAgQVJHVlsxXSBrZXkgcHJlZml4XG4gICAgQVJHVlsyXSB0aW1lc3RhbXBcbiAgICBBUkdWWzNdIG9wdHNcbiAgICBvcHRzIC0gdG9rZW4gLSBsb2NrIHRva2VuXG4gICAgb3B0cyAtIGxvY2tEdXJhdGlvblxuICAgIG9wdHMgLSBsaW1pdGVyXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCB3YWl0S2V5ID0gS0VZU1sxXVxubG9jYWwgYWN0aXZlS2V5ID0gS0VZU1syXVxubG9jYWwgZXZlbnRTdHJlYW1LZXkgPSBLRVlTWzRdXG5sb2NhbCByYXRlTGltaXRlcktleSA9IEtFWVNbNl1cbmxvY2FsIGRlbGF5ZWRLZXkgPSBLRVlTWzddXG5sb2NhbCBvcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbM10pXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIChuZXh0VGltZXN0YW1wIH49IG5pbCkgdGhlbiBcbiAgICAgIG5leHRUaW1lc3RhbXAgPSBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gICAgcmV0dXJuIG5leHRUaW1lc3RhbXBcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgcmF0ZSBsaW1pdCB0dGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UmF0ZUxpbWl0VFRMKG1heEpvYnMsIHJhdGVMaW1pdGVyS2V5KVxuICBpZiBtYXhKb2JzIGFuZCBtYXhKb2JzIDw9IHRvbnVtYmVyKHJjYWxsKFwiR0VUXCIsIHJhdGVMaW1pdGVyS2V5KSBvciAwKSB0aGVuXG4gICAgbG9jYWwgcHR0bCA9IHJjYWxsKFwiUFRUTFwiLCByYXRlTGltaXRlcktleSlcbiAgICBpZiBwdHRsID09IDAgdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgcmF0ZUxpbWl0ZXJLZXkpXG4gICAgZW5kXG4gICAgaWYgcHR0bCA+IDAgdGhlblxuICAgICAgcmV0dXJuIHB0dGxcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiAwXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBtb3ZlIGpvYiBmcm9tIHByaW9yaXRpemVkIHN0YXRlIHRvIGFjdGl2ZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBtb3ZlSm9iRnJvbVByaW9yaXR5VG9BY3RpdmUocHJpb3JpdHlLZXksIGFjdGl2ZUtleSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvcml0aXplZEpvYiA9IHJjYWxsKFwiWlBPUE1JTlwiLCBwcmlvcml0eUtleSlcbiAgaWYgI3ByaW9yaXRpemVkSm9iID4gMCB0aGVuXG4gICAgcmNhbGwoXCJMUFVTSFwiLCBhY3RpdmVLZXksIHByaW9yaXRpemVkSm9iWzFdKVxuICAgIHJldHVybiBwcmlvcml0aXplZEpvYlsxXVxuICBlbHNlXG4gICAgcmNhbGwoXCJERUxcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBtb3ZlIGpvYiBmcm9tIHdhaXQgc3RhdGUgdG8gYWN0aXZlLlxuICBJbnB1dDpcbiAgICBvcHRzIC0gdG9rZW4gLSBsb2NrIHRva2VuXG4gICAgb3B0cyAtIGxvY2tEdXJhdGlvblxuICAgIG9wdHMgLSBsaW1pdGVyXG5dXVxubG9jYWwgZnVuY3Rpb24gcHJlcGFyZUpvYkZvclByb2Nlc3Npbmcoa2V5UHJlZml4LCByYXRlTGltaXRlcktleSwgZXZlbnRTdHJlYW1LZXksXG4gICAgam9iSWQsIHByb2Nlc3NlZE9uLCBtYXhKb2JzLCBvcHRzKVxuICBsb2NhbCBqb2JLZXkgPSBrZXlQcmVmaXggLi4gam9iSWRcbiAgLS0gQ2hlY2sgaWYgd2UgbmVlZCB0byBwZXJmb3JtIHJhdGUgbGltaXRpbmcuXG4gIGlmIG1heEpvYnMgdGhlblxuICAgIGxvY2FsIGpvYkNvdW50ZXIgPSB0b251bWJlcihyY2FsbChcIklOQ1JcIiwgcmF0ZUxpbWl0ZXJLZXkpKVxuICAgIGlmIGpvYkNvdW50ZXIgPT0gMSB0aGVuXG4gICAgICBsb2NhbCBsaW1pdGVyRHVyYXRpb24gPSBvcHRzWydsaW1pdGVyJ10gYW5kIG9wdHNbJ2xpbWl0ZXInXVsnZHVyYXRpb24nXVxuICAgICAgbG9jYWwgaW50ZWdlckR1cmF0aW9uID0gbWF0aC5mbG9vcihtYXRoLmFicyhsaW1pdGVyRHVyYXRpb24pKVxuICAgICAgcmNhbGwoXCJQRVhQSVJFXCIsIHJhdGVMaW1pdGVyS2V5LCBpbnRlZ2VyRHVyYXRpb24pXG4gICAgZW5kXG4gIGVuZFxuICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgLS0gZ2V0IGEgbG9ja1xuICBpZiBvcHRzWyd0b2tlbiddIH49IFwiMFwiIHRoZW5cbiAgICByY2FsbChcIlNFVFwiLCBsb2NrS2V5LCBvcHRzWyd0b2tlbiddLCBcIlBYXCIsIG9wdHNbJ2xvY2tEdXJhdGlvbiddKVxuICBlbmRcbiAgaWYgb3B0c1snbmFtZSddIHRoZW5cbiAgICAtLSBTZXQgXCJwcm9jZXNzZWRCeVwiIGZpZWxkIHRvIHRoZSB3b3JrZXIgbmFtZVxuICAgIHJjYWxsKFwiSFNFVFwiLCBqb2JLZXksIFwicGJcIiwgb3B0c1snbmFtZSddKVxuICBlbmRcbiAgcmNhbGwoXCJYQUREXCIsIGV2ZW50U3RyZWFtS2V5LCBcIipcIiwgXCJldmVudFwiLCBcImFjdGl2ZVwiLCBcImpvYklkXCIsIGpvYklkLCBcInByZXZcIiwgXCJ3YWl0aW5nXCIpXG4gIHJjYWxsKFwiSFNFVFwiLCBqb2JLZXksIFwicHJvY2Vzc2VkT25cIiwgcHJvY2Vzc2VkT24pXG4gIHJjYWxsKFwiSElOQ1JCWVwiLCBqb2JLZXksIFwiYXRzXCIsIDEpXG4gIHJldHVybiB7cmNhbGwoXCJIR0VUQUxMXCIsIGpvYktleSksIGpvYklkLCAwLCAwfSAtLSBnZXQgam9iIGRhdGFcbmVuZFxuLS1bW1xuICBVcGRhdGVzIHRoZSBkZWxheSBzZXQsIGJ5IG1vdmluZyBkZWxheWVkIGpvYnMgdGhhdCBzaG91bGRcbiAgYmUgcHJvY2Vzc2VkIG5vdyB0byBcIndhaXRcIi5cbiAgICAgRXZlbnRzOlxuICAgICAgJ3dhaXRpbmcnXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHNjb3JlID0gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIGJpdC5iYW5kKHByaW9Db3VudGVyLCAweGZmZmZmZmZmZmZmZilcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLSBUcnkgdG8gZ2V0IGFzIG11Y2ggYXMgMTAwMCBqb2JzIGF0IG9uY2VcbmxvY2FsIGZ1bmN0aW9uIHByb21vdGVEZWxheWVkSm9icyhkZWxheWVkS2V5LCBtYXJrZXJLZXksIHRhcmdldEtleSwgcHJpb3JpdGl6ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdHJlYW1LZXksIHByZWZpeCwgdGltZXN0YW1wLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICAgIGxvY2FsIGpvYnMgPSByY2FsbChcIlpSQU5HRUJZU0NPUkVcIiwgZGVsYXllZEtleSwgMCwgKHRpbWVzdGFtcCArIDEpICogMHgxMDAwLCBcIkxJTUlUXCIsIDAsIDEwMDApXG4gICAgaWYgKCNqb2JzID4gMCkgdGhlblxuICAgICAgICByY2FsbChcIlpSRU1cIiwgZGVsYXllZEtleSwgdW5wYWNrKGpvYnMpKVxuICAgICAgICBmb3IgXywgam9iSWQgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBwcmVmaXggLi4gam9iSWRcbiAgICAgICAgICAgIGxvY2FsIHByaW9yaXR5ID1cbiAgICAgICAgICAgICAgICB0b251bWJlcihyY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInByaW9yaXR5XCIpKSBvciAwXG4gICAgICAgICAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBMSUZPIG9yIEZJRk9cbiAgICAgICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIFwiTFBVU0hcIiwgaXNQYXVzZWQsIGpvYklkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgIGpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5sb2NhbCB0YXJnZXQsIHBhdXNlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzldLCB3YWl0S2V5LCBLRVlTWzhdKVxuLS0gQ2hlY2sgaWYgdGhlcmUgYXJlIGRlbGF5ZWQgam9icyB0aGF0IHdlIGNhbiBtb3ZlIHRvIHdhaXQuXG5sb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzExXVxucHJvbW90ZURlbGF5ZWRKb2JzKGRlbGF5ZWRLZXksIG1hcmtlcktleSwgdGFyZ2V0LCBLRVlTWzNdLCBldmVudFN0cmVhbUtleSwgQVJHVlsxXSxcbiAgICAgICAgICAgICAgICAgICBBUkdWWzJdLCBLRVlTWzEwXSwgcGF1c2VkKVxubG9jYWwgbWF4Sm9icyA9IHRvbnVtYmVyKG9wdHNbJ2xpbWl0ZXInXSBhbmQgb3B0c1snbGltaXRlciddWydtYXgnXSlcbmxvY2FsIGV4cGlyZVRpbWUgPSBnZXRSYXRlTGltaXRUVEwobWF4Sm9icywgcmF0ZUxpbWl0ZXJLZXkpXG4tLSBDaGVjayBpZiB3ZSBhcmUgcmF0ZSBsaW1pdGVkIGZpcnN0LlxuaWYgZXhwaXJlVGltZSA+IDAgdGhlbiByZXR1cm4gezAsIDAsIGV4cGlyZVRpbWUsIDB9IGVuZFxuLS0gcGF1c2VkIHF1ZXVlXG5pZiBwYXVzZWQgdGhlbiByZXR1cm4gezAsIDAsIDAsIDB9IGVuZFxuLS0gbm8gam9iIElELCB0cnkgbm9uLWJsb2NraW5nIG1vdmUgZnJvbSB3YWl0IHRvIGFjdGl2ZVxubG9jYWwgam9iSWQgPSByY2FsbChcIlJQT1BMUFVTSFwiLCB3YWl0S2V5LCBhY3RpdmVLZXkpXG4tLSBNYXJrZXJzIGluIHdhaXRsaXN0IERFUFJFQ0FURUQgaW4gdjU6IFdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkIGluIHY2LlxuaWYgam9iSWQgYW5kIHN0cmluZy5zdWIoam9iSWQsIDEsIDIpID09IFwiMDpcIiB0aGVuXG4gICAgcmNhbGwoXCJMUkVNXCIsIGFjdGl2ZUtleSwgMSwgam9iSWQpXG4gICAgam9iSWQgPSByY2FsbChcIlJQT1BMUFVTSFwiLCB3YWl0S2V5LCBhY3RpdmVLZXkpXG5lbmRcbmlmIGpvYklkIHRoZW5cbiAgICByZXR1cm4gcHJlcGFyZUpvYkZvclByb2Nlc3NpbmcoQVJHVlsxXSwgcmF0ZUxpbWl0ZXJLZXksIGV2ZW50U3RyZWFtS2V5LCBqb2JJZCwgQVJHVlsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4Sm9icywgb3B0cylcbmVsc2VcbiAgICBqb2JJZCA9IG1vdmVKb2JGcm9tUHJpb3JpdHlUb0FjdGl2ZShLRVlTWzNdLCBhY3RpdmVLZXksIEtFWVNbMTBdKVxuICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgcmV0dXJuIHByZXBhcmVKb2JGb3JQcm9jZXNzaW5nKEFSR1ZbMV0sIHJhdGVMaW1pdGVyS2V5LCBldmVudFN0cmVhbUtleSwgam9iSWQsIEFSR1ZbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhKb2JzLCBvcHRzKVxuICAgIGVuZFxuZW5kXG4tLSBSZXR1cm4gdGhlIHRpbWVzdGFtcCBmb3IgdGhlIG5leHQgZGVsYXllZCBqb2IgaWYgYW55LlxubG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG5pZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gcmV0dXJuIHswLCAwLCAwLCBuZXh0VGltZXN0YW1wfSBlbmRcbnJldHVybiB7MCwgMCwgMCwgMH1cbmA7XG5leHBvcnQgY29uc3QgbW92ZVRvQWN0aXZlID0ge1xuICAgIG5hbWU6ICdtb3ZlVG9BY3RpdmUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMTEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVRvQWN0aXZlLTExLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwibW92ZVRvQWN0aXZlIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-7.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToDelayed-7.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToDelayed: () => (/* binding */ moveToDelayed)\n/* harmony export */ });\nconst content = `--[[\n  Moves job from active to delayed set.\n  Input:\n    KEYS[1] marker key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] delayed key\n    KEYS[5] job key\n    KEYS[6] events stream\n    KEYS[7] meta key\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] delayedTimestamp\n    ARGV[4] the id of the job\n    ARGV[5] queue token\n    ARGV[6] delay value\n    ARGV[7] skip attempt\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in active set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\nlocal jobKey = KEYS[5]\nlocal metaKey = KEYS[7]\nif rcall(\"EXISTS\", jobKey) == 1 then\n    local delayedKey = KEYS[4]\n    if ARGV[5] ~= \"0\" then\n        local lockKey = jobKey .. ':lock'\n        if rcall(\"GET\", lockKey) == ARGV[5] then\n            rcall(\"DEL\", lockKey)\n        else\n            return -2\n        end\n    end\n    local jobId = ARGV[4]\n    local score = tonumber(ARGV[3])\n    local delayedTimestamp = (score / 0x1000)\n    local numRemovedElements = rcall(\"LREM\", KEYS[2], -1, jobId)\n    if numRemovedElements < 1 then return -3 end\n    if ARGV[7] == \"0\" then\n        rcall(\"HINCRBY\", jobKey, \"atm\", 1)\n    end\n    rcall(\"HSET\", jobKey, \"delay\", ARGV[6])\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    rcall(\"ZADD\", delayedKey, score, jobId)\n    rcall(\"XADD\", KEYS[6], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n          \"jobId\", jobId, \"delay\", delayedTimestamp)\n    -- Check if we need to push a marker job to wake up sleeping workers.\n    local isPaused = isQueuePaused(metaKey)\n    if not isPaused then\n        local markerKey = KEYS[1]\n        addDelayMarkerIfNeeded(markerKey, delayedKey)\n    end\n    return 0\nelse\n    return -1\nend\n`;\nconst moveToDelayed = {\n    name: \"moveToDelayed\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=moveToDelayed-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvRGVsYXllZC03LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0dqQixDQUFDO0FBQ00sTUFBTUMsZ0JBQWdCO0lBQ3pCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9tb3ZlVG9EZWxheWVkLTcuanM/ZjZkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZXMgam9iIGZyb20gYWN0aXZlIHRvIGRlbGF5ZWQgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIG1hcmtlciBrZXlcbiAgICBLRVlTWzJdIGFjdGl2ZSBrZXlcbiAgICBLRVlTWzNdIHByaW9yaXRpemVkIGtleVxuICAgIEtFWVNbNF0gZGVsYXllZCBrZXlcbiAgICBLRVlTWzVdIGpvYiBrZXlcbiAgICBLRVlTWzZdIGV2ZW50cyBzdHJlYW1cbiAgICBLRVlTWzddIG1ldGEga2V5XG4gICAgQVJHVlsxXSBrZXkgcHJlZml4XG4gICAgQVJHVlsyXSB0aW1lc3RhbXBcbiAgICBBUkdWWzNdIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICBBUkdWWzRdIHRoZSBpZCBvZiB0aGUgam9iXG4gICAgQVJHVls1XSBxdWV1ZSB0b2tlblxuICAgIEFSR1ZbNl0gZGVsYXkgdmFsdWVcbiAgICBBUkdWWzddIHNraXAgYXR0ZW1wdFxuICBPdXRwdXQ6XG4gICAgMCAtIE9LXG4gICAtMSAtIE1pc3Npbmcgam9iLlxuICAgLTMgLSBKb2Igbm90IGluIGFjdGl2ZSBzZXQuXG4gIEV2ZW50czpcbiAgICAtIGRlbGF5ZWQga2V5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiAobmV4dFRpbWVzdGFtcCB+PSBuaWwpIHRoZW4gXG4gICAgICBuZXh0VGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICAgIHJldHVybiBuZXh0VGltZXN0YW1wXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkKHF1ZXVlTWV0YUtleSlcbiAgICByZXR1cm4gcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgPT0gMVxuZW5kXG5sb2NhbCBqb2JLZXkgPSBLRVlTWzVdXG5sb2NhbCBtZXRhS2V5ID0gS0VZU1s3XVxuaWYgcmNhbGwoXCJFWElTVFNcIiwgam9iS2V5KSA9PSAxIHRoZW5cbiAgICBsb2NhbCBkZWxheWVkS2V5ID0gS0VZU1s0XVxuICAgIGlmIEFSR1ZbNV0gfj0gXCIwXCIgdGhlblxuICAgICAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICAgICAgaWYgcmNhbGwoXCJHRVRcIiwgbG9ja0tleSkgPT0gQVJHVls1XSB0aGVuXG4gICAgICAgICAgICByY2FsbChcIkRFTFwiLCBsb2NrS2V5KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gLTJcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgbG9jYWwgam9iSWQgPSBBUkdWWzRdXG4gICAgbG9jYWwgc2NvcmUgPSB0b251bWJlcihBUkdWWzNdKVxuICAgIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSAoc2NvcmUgLyAweDEwMDApXG4gICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJMUkVNXCIsIEtFWVNbMl0sIC0xLCBqb2JJZClcbiAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPCAxIHRoZW4gcmV0dXJuIC0zIGVuZFxuICAgIGlmIEFSR1ZbN10gPT0gXCIwXCIgdGhlblxuICAgICAgICByY2FsbChcIkhJTkNSQllcIiwgam9iS2V5LCBcImF0bVwiLCAxKVxuICAgIGVuZFxuICAgIHJjYWxsKFwiSFNFVFwiLCBqb2JLZXksIFwiZGVsYXlcIiwgQVJHVls2XSlcbiAgICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIHJjYWxsKFwiWkFERFwiLCBkZWxheWVkS2V5LCBzY29yZSwgam9iSWQpXG4gICAgcmNhbGwoXCJYQUREXCIsIEtFWVNbNl0sIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLFxuICAgICAgICAgIFwiam9iSWRcIiwgam9iSWQsIFwiZGVsYXlcIiwgZGVsYXllZFRpbWVzdGFtcClcbiAgICAtLSBDaGVjayBpZiB3ZSBuZWVkIHRvIHB1c2ggYSBtYXJrZXIgam9iIHRvIHdha2UgdXAgc2xlZXBpbmcgd29ya2Vycy5cbiAgICBsb2NhbCBpc1BhdXNlZCA9IGlzUXVldWVQYXVzZWQobWV0YUtleSlcbiAgICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgICAgICBsb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzFdXG4gICAgICAgIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICAgIGVuZFxuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgbW92ZVRvRGVsYXllZCA9IHtcbiAgICBuYW1lOiAnbW92ZVRvRGVsYXllZCcsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA3LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vdmVUb0RlbGF5ZWQtNy5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsIm1vdmVUb0RlbGF5ZWQiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToFinished: () => (/* binding */ moveToFinished)\n/* harmony export */ });\nconst content = `--[[\n  Move job from active to a finished status (completed o failed)\n  A job can only be moved to completed if it was active.\n  The job must be locked before it can be moved to a finished status,\n  and the lock must be released in this script.\n    Input:\n      KEYS[1] wait key\n      KEYS[2] active key\n      KEYS[3] prioritized key\n      KEYS[4] event stream key\n      KEYS[5] stalled key\n      -- Rate limiting\n      KEYS[6] rate limiter key\n      KEYS[7] delayed key\n      KEYS[8] paused key\n      KEYS[9] meta key\n      KEYS[10] pc priority counter\n      KEYS[11] completed/failed key\n      KEYS[12] jobId key\n      KEYS[13] metrics key\n      KEYS[14] marker key\n      ARGV[1]  jobId\n      ARGV[2]  timestamp\n      ARGV[3]  msg property returnvalue / failedReason\n      ARGV[4]  return value / failed reason\n      ARGV[5]  target (completed/failed)\n      ARGV[6]  fetch next?\n      ARGV[7]  keys prefix\n      ARGV[8]  opts\n      opts - token - lock token\n      opts - keepJobs\n      opts - lockDuration - lock duration in milliseconds\n      opts - attempts max attempts\n      opts - maxMetricsSize\n      opts - fpof - fail parent on fail\n      opts - idof - ignore dependency on fail\n      opts - rdof - remove dependency on fail\n    Output:\n      0 OK\n      -1 Missing key.\n      -2 Missing lock.\n      -3 Job not in active set\n      -4 Job has pending dependencies\n      -6 Lock is not owned by this client\n    Events:\n      'completed/failed'\n]]\nlocal rcall = redis.call\n--- Includes\n--[[\n  Functions to collect metrics based on a current and previous count of jobs.\n  Granualarity is fixed at 1 minute.\n]] \n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function collectMetrics(metaKey, dataPointsList, maxDataPoints,\n                                 timestamp)\n    -- Increment current count\n    local count = rcall(\"HINCRBY\", metaKey, \"count\", 1) - 1\n    -- Compute how many data points we need to add to the list, N.\n    local prevTS = rcall(\"HGET\", metaKey, \"prevTS\")\n    if not prevTS then\n        -- If prevTS is nil, set it to the current timestamp\n        rcall(\"HSET\", metaKey, \"prevTS\", timestamp, \"prevCount\", 0)\n        return\n    end\n    local N = math.floor((timestamp - prevTS) / 60000)\n    if N > 0 then\n        local delta = count - rcall(\"HGET\", metaKey, \"prevCount\")\n        -- If N > 1, add N-1 zeros to the list\n        if N > 1 then\n            local points = {}\n            points[1] = delta\n            for i = 2, N do\n                points[i] = 0\n            end\n            for from, to in batches(#points, 7000) do\n                rcall(\"LPUSH\", dataPointsList, unpack(points, from, to))\n            end\n        else\n            -- LPUSH delta to the list\n            rcall(\"LPUSH\", dataPointsList, delta)\n        end\n        -- LTRIM to keep list to its max size\n        rcall(\"LTRIM\", dataPointsList, 0, maxDataPoints - 1)\n        -- update prev count with current count\n        rcall(\"HSET\", metaKey, \"prevCount\", count, \"prevTS\", timestamp)\n    end\nend\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall(\"GET\", rateLimiterKey) or 0) then\n    local pttl = rcall(\"PTTL\", rateLimiterKey)\n    if pttl == 0 then\n      rcall(\"DEL\", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPriorityToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall(\"ZPOPMIN\", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall(\"LPUSH\", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall(\"DEL\", priorityCounterKey)\n  end\nend\n--[[\n  Function to recursively move from waitingChildren to failed.\n]]\n-- Includes\n--[[\n  Validate and move parent to active if needed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n    return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey,\n                                        parentKey, parentId, timestamp)\n    local isParentActive = rcall(\"ZSCORE\",\n                                 parentQueueKey .. \":waiting-children\", parentId)\n    if rcall(\"SCARD\", parentDependenciesKey) == 0 and isParentActive then\n        rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId)\n        local parentWaitKey = parentQueueKey .. \":wait\"\n        local parentPausedKey = parentQueueKey .. \":paused\"\n        local parentMetaKey = parentQueueKey .. \":meta\"\n        local parentMarkerKey = parentQueueKey .. \":marker\"\n        local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n        local priority = tonumber(jobAttributes[1]) or 0\n        local delay = tonumber(jobAttributes[2]) or 0\n        if delay > 0 then\n            local delayedTimestamp = tonumber(timestamp) + delay\n            local score = delayedTimestamp * 0x1000\n            local parentDelayedKey = parentQueueKey .. \":delayed\"\n            rcall(\"ZADD\", parentDelayedKey, score, parentId)\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\",\n                  \"jobId\", parentId, \"delay\", delayedTimestamp)\n            addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n        else\n            if priority == 0 then\n                local parentTarget, isParentPaused =\n                    getTargetQueueList(parentMetaKey, parentWaitKey,\n                                       parentPausedKey)\n                addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPaused, parentId)\n            else\n                local isPaused = isQueuePaused(parentMetaKey)\n                addJobWithPriority(parentMarkerKey,\n                                   parentQueueKey .. \":prioritized\", priority,\n                                   parentId, parentQueueKey .. \":pc\", isPaused)\n            end\n            rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\",\n                  \"jobId\", parentId, \"prev\", \"waiting-children\")\n        end\n    end\nend\nlocal function moveParentFromWaitingChildrenToFailed( parentQueueKey, parentKey, parentId, jobIdKey, timestamp)\n  if rcall(\"ZREM\", parentQueueKey .. \":waiting-children\", parentId) == 1 then\n    rcall(\"ZADD\", parentQueueKey .. \":failed\", timestamp, parentId)\n    local failedReason = \"child \" .. jobIdKey .. \" failed\"\n    rcall(\"HMSET\", parentKey, \"failedReason\", failedReason, \"finishedOn\", timestamp)\n    rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"failed\", \"jobId\", parentId, \"failedReason\",\n      failedReason, \"prev\", \"waiting-children\")\n    local rawParentData = rcall(\"HGET\", parentKey, \"parent\")\n    if rawParentData ~= false then\n      local parentData = cjson.decode(rawParentData)\n      if parentData['fpof'] then\n        moveParentFromWaitingChildrenToFailed(\n          parentData['queueKey'],\n          parentData['queueKey'] .. ':' .. parentData['id'],\n          parentData['id'],\n          parentKey,\n          timestamp\n        )\n      elseif parentData['rdof'] then\n        local grandParentKey = parentData['queueKey'] .. ':' .. parentData['id']\n        local grandParentDependenciesSet = grandParentKey .. \":dependencies\"\n        if rcall(\"SREM\", grandParentDependenciesSet, parentKey) == 1 then\n          moveParentToWaitIfNeeded(parentData['queueKey'], grandParentDependenciesSet,\n            grandParentKey, parentData['id'], timestamp)\n        end\n      end\n    end\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall(\"INCR\", rateLimiterKey))\n    if jobCounter == 1 then\n      local limiterDuration = opts['limiter'] and opts['limiter']['duration']\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall(\"PEXPIRE\", rateLimiterKey, integerDuration)\n    end\n  end\n  local lockKey = jobKey .. ':lock'\n  -- get a lock\n  if opts['token'] ~= \"0\" then\n    rcall(\"SET\", lockKey, opts['token'], \"PX\", opts['lockDuration'])\n  end\n  if opts['name'] then\n    -- Set \"processedBy\" field to the worker name\n    rcall(\"HSET\", jobKey, \"pb\", opts['name'])\n  end\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"active\", \"jobId\", jobId, \"prev\", \"waiting\")\n  rcall(\"HSET\", jobKey, \"processedOn\", processedOn)\n  rcall(\"HINCRBY\", jobKey, \"ats\", 1)\n  return {rcall(\"HGETALL\", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                addJobInTargetList(targetKey, markerKey, \"LPUSH\", isPaused, jobId)\n            else\n                addJobWithPriority(markerKey, prioritizedKey, priority,\n                  jobId, priorityCounterKey, isPaused)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n    end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Functions to remove jobs by max age.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  removeJobKeys(jobKey)\nend\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix)\n  end\n  rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\nend\n--[[\n  Functions to remove jobs by max count.\n]]\n-- Includes\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix)\n  end\n  rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1))\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents ~= false then\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", maxEvents)\n  else\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", 10000)\n  end\nend\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNeeded(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal jobIdKey = KEYS[12]\nif rcall(\"EXISTS\", jobIdKey) == 1 then -- // Make sure job exists\n    local opts = cmsgpack.unpack(ARGV[8])\n    local token = opts['token']\n    local attempts = opts['attempts']\n    local maxMetricsSize = opts['maxMetricsSize']\n    local maxCount = opts['keepJobs']['count']\n    local maxAge = opts['keepJobs']['age']\n    if token ~= \"0\" then\n        local lockKey = jobIdKey .. ':lock'\n        local lockToken = rcall(\"GET\", lockKey)\n        if lockToken == token then\n            rcall(\"DEL\", lockKey)\n            rcall(\"SREM\", KEYS[5], ARGV[1])\n        else\n            if lockToken then\n                -- Lock exists but token does not match\n                return -6\n            else\n                -- Lock is missing completely\n                return -2\n            end\n        end\n    end\n    if rcall(\"SCARD\", jobIdKey .. \":dependencies\") ~= 0 then -- // Make sure it does not have pending dependencies\n        return -4\n    end\n    local parentReferences = rcall(\"HMGET\", jobIdKey, \"parentKey\", \"parent\")\n    local parentKey = parentReferences[1] or \"\"\n    local parentId = \"\"\n    local parentQueueKey = \"\"\n    if parentReferences[2] ~= false then\n        local jsonDecodedParent = cjson.decode(parentReferences[2])\n        parentId = jsonDecodedParent['id']\n        parentQueueKey = jsonDecodedParent['queueKey']\n    end\n    local jobId = ARGV[1]\n    local timestamp = ARGV[2]\n    -- Remove from active list (if not active we shall return error)\n    local numRemovedElements = rcall(\"LREM\", KEYS[2], -1, jobId)\n    if (numRemovedElements < 1) then return -3 end\n    local eventStreamKey = KEYS[4]\n    local metaKey = KEYS[9]\n    -- Trim events before emiting them to avoid trimming events emitted in this script\n    trimEvents(metaKey, eventStreamKey)\n    -- If job has a parent we need to\n    -- 1) remove this job id from parents dependencies\n    -- 2) move the job Id to parent \"processed\" set\n    -- 3) push the results into parent \"results\" list\n    -- 4) if parent's dependencies is empty, then move parent to \"wait/paused\". Note it may be a different queue!.\n    if parentId == \"\" and parentKey ~= \"\" then\n        parentId = getJobIdFromKey(parentKey)\n        parentQueueKey = getJobKeyPrefix(parentKey, \":\" .. parentId)\n    end\n    if parentId ~= \"\" then\n        if ARGV[5] == \"completed\" then\n            local dependenciesSet = parentKey .. \":dependencies\"\n            if rcall(\"SREM\", dependenciesSet, jobIdKey) == 1 then\n                updateParentDepsIfNeeded(parentKey, parentQueueKey,\n                                         dependenciesSet, parentId, jobIdKey,\n                                         ARGV[4], timestamp)\n            end\n        else\n            if opts['fpof'] then\n                moveParentFromWaitingChildrenToFailed(parentQueueKey, parentKey,\n                                                      parentId, jobIdKey,\n                                                      timestamp)\n            elseif opts['idof'] or opts['rdof'] then\n                local dependenciesSet = parentKey .. \":dependencies\"\n                if rcall(\"SREM\", dependenciesSet, jobIdKey) == 1 then\n                    moveParentToWaitIfNeeded(parentQueueKey, dependenciesSet,\n                                             parentKey, parentId, timestamp)\n                    if opts['idof'] then\n                        local failedSet = parentKey .. \":failed\"\n                        rcall(\"HSET\", failedSet, jobIdKey, ARGV[4])\n                    end\n                end\n            end\n        end\n    end\n    local attemptsMade = rcall(\"HINCRBY\", jobIdKey, \"atm\", 1)\n    -- Remove job?\n    if maxCount ~= 0 then\n        local targetSet = KEYS[11]\n        -- Add to complete/failed set\n        rcall(\"ZADD\", targetSet, timestamp, jobId)\n        rcall(\"HMSET\", jobIdKey, ARGV[3], ARGV[4], \"finishedOn\", timestamp)\n        -- \"returnvalue\" / \"failedReason\" and \"finishedOn\"\n        -- Remove old jobs?\n        local prefix = ARGV[7]\n        if maxAge ~= nil then\n            removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n        end\n        if maxCount ~= nil and maxCount > 0 then\n            removeJobsByMaxCount(maxCount, targetSet, prefix)\n        end\n    else\n        removeJobKeys(jobIdKey)\n        if parentKey ~= \"\" then\n            -- TODO: when a child is removed when finished, result or failure in parent\n            -- must not be deleted, those value references should be deleted when the parent\n            -- is deleted\n            removeParentDependencyKey(jobIdKey, false, parentKey)\n        end\n    end\n    rcall(\"XADD\", eventStreamKey, \"*\", \"event\", ARGV[5], \"jobId\", jobId, ARGV[3],\n          ARGV[4])\n    if ARGV[5] == \"failed\" then\n        if tonumber(attemptsMade) >= tonumber(attempts) then\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"retries-exhausted\", \"jobId\",\n                  jobId, \"attemptsMade\", attemptsMade)\n        end\n    end\n    -- Collect metrics\n    if maxMetricsSize ~= \"\" then\n        collectMetrics(KEYS[13], KEYS[13] .. ':data', maxMetricsSize, timestamp)\n    end\n    -- Try to get next job to avoid an extra roundtrip if the queue is not closing,\n    -- and not rate limited.\n    if (ARGV[6] == \"1\") then\n        local target, paused = getTargetQueueList(metaKey, KEYS[1], KEYS[8])\n        -- Check if there are delayed jobs that can be promoted\n        promoteDelayedJobs(KEYS[7], KEYS[14], target, KEYS[3], eventStreamKey, ARGV[7],\n                           timestamp, KEYS[10], paused)\n        local maxJobs = tonumber(opts['limiter'] and opts['limiter']['max'])\n        -- Check if we are rate limited first.\n        local expireTime = getRateLimitTTL(maxJobs, KEYS[6])\n        if expireTime > 0 then return {0, 0, expireTime, 0} end\n        -- paused queue\n        if paused then return {0, 0, 0, 0} end\n        jobId = rcall(\"RPOPLPUSH\", KEYS[1], KEYS[2])\n        if jobId then\n            -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n            if string.sub(jobId, 1, 2) == \"0:\" then\n                rcall(\"LREM\", KEYS[2], 1, jobId)\n                -- If jobId is special ID 0:delay (delay greater than 0), then there is no job to process\n                -- but if ID is 0:0, then there is at least 1 prioritized job to process\n                if jobId == \"0:0\" then\n                    jobId = moveJobFromPriorityToActive(KEYS[3], KEYS[2],\n                                                        KEYS[10])\n                    return prepareJobForProcessing(ARGV[7], KEYS[6], eventStreamKey, jobId,\n                                                   timestamp, maxJobs,\n                                                   opts)\n                end\n            else\n                return prepareJobForProcessing(ARGV[7], KEYS[6], eventStreamKey, jobId,\n                                               timestamp, maxJobs,\n                                               opts)\n            end\n        else\n            jobId = moveJobFromPriorityToActive(KEYS[3], KEYS[2], KEYS[10])\n            if jobId then\n                return prepareJobForProcessing(ARGV[7], KEYS[6], eventStreamKey, jobId,\n                                               timestamp, maxJobs,\n                                               opts)\n            end\n        end\n        -- Return the timestamp for the next delayed job if any.\n        local nextTimestamp = getNextDelayedTimestamp(KEYS[7])\n        if nextTimestamp ~= nil then\n            -- The result is guaranteed to be positive, since the\n            -- ZRANGEBYSCORE command would have return a job otherwise.\n            return {0, 0, 0, nextTimestamp}\n        end\n    end\n    local waitLen = rcall(\"LLEN\", KEYS[1])\n    if waitLen == 0 then\n        local activeLen = rcall(\"LLEN\", KEYS[2])\n        if activeLen == 0 then\n            local prioritizedLen = rcall(\"ZCARD\", KEYS[3])\n            if prioritizedLen == 0 then\n                rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"drained\")\n            end\n        end\n    end\n    return 0\nelse\n    return -1\nend\n`;\nconst moveToFinished = {\n    name: \"moveToFinished\",\n    content,\n    keys: 14\n}; //# sourceMappingURL=moveToFinished-14.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvRmluaXNoZWQtMTQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErcEJqQixDQUFDO0FBQ00sTUFBTUMsaUJBQWlCO0lBQzFCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9tb3ZlVG9GaW5pc2hlZC0xNC5qcz80MjJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIGpvYiBmcm9tIGFjdGl2ZSB0byBhIGZpbmlzaGVkIHN0YXR1cyAoY29tcGxldGVkIG8gZmFpbGVkKVxuICBBIGpvYiBjYW4gb25seSBiZSBtb3ZlZCB0byBjb21wbGV0ZWQgaWYgaXQgd2FzIGFjdGl2ZS5cbiAgVGhlIGpvYiBtdXN0IGJlIGxvY2tlZCBiZWZvcmUgaXQgY2FuIGJlIG1vdmVkIHRvIGEgZmluaXNoZWQgc3RhdHVzLFxuICBhbmQgdGhlIGxvY2sgbXVzdCBiZSByZWxlYXNlZCBpbiB0aGlzIHNjcmlwdC5cbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gd2FpdCBrZXlcbiAgICAgIEtFWVNbMl0gYWN0aXZlIGtleVxuICAgICAgS0VZU1szXSBwcmlvcml0aXplZCBrZXlcbiAgICAgIEtFWVNbNF0gZXZlbnQgc3RyZWFtIGtleVxuICAgICAgS0VZU1s1XSBzdGFsbGVkIGtleVxuICAgICAgLS0gUmF0ZSBsaW1pdGluZ1xuICAgICAgS0VZU1s2XSByYXRlIGxpbWl0ZXIga2V5XG4gICAgICBLRVlTWzddIGRlbGF5ZWQga2V5XG4gICAgICBLRVlTWzhdIHBhdXNlZCBrZXlcbiAgICAgIEtFWVNbOV0gbWV0YSBrZXlcbiAgICAgIEtFWVNbMTBdIHBjIHByaW9yaXR5IGNvdW50ZXJcbiAgICAgIEtFWVNbMTFdIGNvbXBsZXRlZC9mYWlsZWQga2V5XG4gICAgICBLRVlTWzEyXSBqb2JJZCBrZXlcbiAgICAgIEtFWVNbMTNdIG1ldHJpY3Mga2V5XG4gICAgICBLRVlTWzE0XSBtYXJrZXIga2V5XG4gICAgICBBUkdWWzFdICBqb2JJZFxuICAgICAgQVJHVlsyXSAgdGltZXN0YW1wXG4gICAgICBBUkdWWzNdICBtc2cgcHJvcGVydHkgcmV0dXJudmFsdWUgLyBmYWlsZWRSZWFzb25cbiAgICAgIEFSR1ZbNF0gIHJldHVybiB2YWx1ZSAvIGZhaWxlZCByZWFzb25cbiAgICAgIEFSR1ZbNV0gIHRhcmdldCAoY29tcGxldGVkL2ZhaWxlZClcbiAgICAgIEFSR1ZbNl0gIGZldGNoIG5leHQ/XG4gICAgICBBUkdWWzddICBrZXlzIHByZWZpeFxuICAgICAgQVJHVls4XSAgb3B0c1xuICAgICAgb3B0cyAtIHRva2VuIC0gbG9jayB0b2tlblxuICAgICAgb3B0cyAtIGtlZXBKb2JzXG4gICAgICBvcHRzIC0gbG9ja0R1cmF0aW9uIC0gbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgIG9wdHMgLSBhdHRlbXB0cyBtYXggYXR0ZW1wdHNcbiAgICAgIG9wdHMgLSBtYXhNZXRyaWNzU2l6ZVxuICAgICAgb3B0cyAtIGZwb2YgLSBmYWlsIHBhcmVudCBvbiBmYWlsXG4gICAgICBvcHRzIC0gaWRvZiAtIGlnbm9yZSBkZXBlbmRlbmN5IG9uIGZhaWxcbiAgICAgIG9wdHMgLSByZG9mIC0gcmVtb3ZlIGRlcGVuZGVuY3kgb24gZmFpbFxuICAgIE91dHB1dDpcbiAgICAgIDAgT0tcbiAgICAgIC0xIE1pc3Npbmcga2V5LlxuICAgICAgLTIgTWlzc2luZyBsb2NrLlxuICAgICAgLTMgSm9iIG5vdCBpbiBhY3RpdmUgc2V0XG4gICAgICAtNCBKb2IgaGFzIHBlbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICAtNiBMb2NrIGlzIG5vdCBvd25lZCBieSB0aGlzIGNsaWVudFxuICAgIEV2ZW50czpcbiAgICAgICdjb21wbGV0ZWQvZmFpbGVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9ucyB0byBjb2xsZWN0IG1ldHJpY3MgYmFzZWQgb24gYSBjdXJyZW50IGFuZCBwcmV2aW91cyBjb3VudCBvZiBqb2JzLlxuICBHcmFudWFsYXJpdHkgaXMgZml4ZWQgYXQgMSBtaW51dGUuXG5dXSBcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbG9vcCBpbiBiYXRjaGVzLlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHNvbWUgY29tbWFuZHMgYXMgWlJFTVxuICBjb3VsZCByZWNlaXZlIGEgbWF4aW11bSBvZiA3MDAwIHBhcmFtZXRlcnMgcGVyIGNhbGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gYmF0Y2hlcyhuLCBiYXRjaFNpemUpXG4gIGxvY2FsIGkgPSAwXG4gIHJldHVybiBmdW5jdGlvbigpXG4gICAgbG9jYWwgZnJvbSA9IGkgKiBiYXRjaFNpemUgKyAxXG4gICAgaSA9IGkgKyAxXG4gICAgaWYgKGZyb20gPD0gbikgdGhlblxuICAgICAgbG9jYWwgdG8gPSBtYXRoLm1pbihmcm9tICsgYmF0Y2hTaXplIC0gMSwgbilcbiAgICAgIHJldHVybiBmcm9tLCB0b1xuICAgIGVuZFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gY29sbGVjdE1ldHJpY3MobWV0YUtleSwgZGF0YVBvaW50c0xpc3QsIG1heERhdGFQb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXApXG4gICAgLS0gSW5jcmVtZW50IGN1cnJlbnQgY291bnRcbiAgICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiSElOQ1JCWVwiLCBtZXRhS2V5LCBcImNvdW50XCIsIDEpIC0gMVxuICAgIC0tIENvbXB1dGUgaG93IG1hbnkgZGF0YSBwb2ludHMgd2UgbmVlZCB0byBhZGQgdG8gdGhlIGxpc3QsIE4uXG4gICAgbG9jYWwgcHJldlRTID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwicHJldlRTXCIpXG4gICAgaWYgbm90IHByZXZUUyB0aGVuXG4gICAgICAgIC0tIElmIHByZXZUUyBpcyBuaWwsIHNldCBpdCB0byB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwicHJldlRTXCIsIHRpbWVzdGFtcCwgXCJwcmV2Q291bnRcIiwgMClcbiAgICAgICAgcmV0dXJuXG4gICAgZW5kXG4gICAgbG9jYWwgTiA9IG1hdGguZmxvb3IoKHRpbWVzdGFtcCAtIHByZXZUUykgLyA2MDAwMClcbiAgICBpZiBOID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbHRhID0gY291bnQgLSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIilcbiAgICAgICAgLS0gSWYgTiA+IDEsIGFkZCBOLTEgemVyb3MgdG8gdGhlIGxpc3RcbiAgICAgICAgaWYgTiA+IDEgdGhlblxuICAgICAgICAgICAgbG9jYWwgcG9pbnRzID0ge31cbiAgICAgICAgICAgIHBvaW50c1sxXSA9IGRlbHRhXG4gICAgICAgICAgICBmb3IgaSA9IDIsIE4gZG9cbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAwXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGZvciBmcm9tLCB0byBpbiBiYXRjaGVzKCNwb2ludHMsIDcwMDApIGRvXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCBkYXRhUG9pbnRzTGlzdCwgdW5wYWNrKHBvaW50cywgZnJvbSwgdG8pKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIExQVVNIIGRlbHRhIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICByY2FsbChcIkxQVVNIXCIsIGRhdGFQb2ludHNMaXN0LCBkZWx0YSlcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIExUUklNIHRvIGtlZXAgbGlzdCB0byBpdHMgbWF4IHNpemVcbiAgICAgICAgcmNhbGwoXCJMVFJJTVwiLCBkYXRhUG9pbnRzTGlzdCwgMCwgbWF4RGF0YVBvaW50cyAtIDEpXG4gICAgICAgIC0tIHVwZGF0ZSBwcmV2IGNvdW50IHdpdGggY3VycmVudCBjb3VudFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIiwgY291bnQsIFwicHJldlRTXCIsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIChuZXh0VGltZXN0YW1wIH49IG5pbCkgdGhlbiBcbiAgICAgIG5leHRUaW1lc3RhbXAgPSBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gICAgcmV0dXJuIG5leHRUaW1lc3RhbXBcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgcmF0ZSBsaW1pdCB0dGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UmF0ZUxpbWl0VFRMKG1heEpvYnMsIHJhdGVMaW1pdGVyS2V5KVxuICBpZiBtYXhKb2JzIGFuZCBtYXhKb2JzIDw9IHRvbnVtYmVyKHJjYWxsKFwiR0VUXCIsIHJhdGVMaW1pdGVyS2V5KSBvciAwKSB0aGVuXG4gICAgbG9jYWwgcHR0bCA9IHJjYWxsKFwiUFRUTFwiLCByYXRlTGltaXRlcktleSlcbiAgICBpZiBwdHRsID09IDAgdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgcmF0ZUxpbWl0ZXJLZXkpXG4gICAgZW5kXG4gICAgaWYgcHR0bCA+IDAgdGhlblxuICAgICAgcmV0dXJuIHB0dGxcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiAwXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBtb3ZlIGpvYiBmcm9tIHByaW9yaXRpemVkIHN0YXRlIHRvIGFjdGl2ZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBtb3ZlSm9iRnJvbVByaW9yaXR5VG9BY3RpdmUocHJpb3JpdHlLZXksIGFjdGl2ZUtleSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvcml0aXplZEpvYiA9IHJjYWxsKFwiWlBPUE1JTlwiLCBwcmlvcml0eUtleSlcbiAgaWYgI3ByaW9yaXRpemVkSm9iID4gMCB0aGVuXG4gICAgcmNhbGwoXCJMUFVTSFwiLCBhY3RpdmVLZXksIHByaW9yaXRpemVkSm9iWzFdKVxuICAgIHJldHVybiBwcmlvcml0aXplZEpvYlsxXVxuICBlbHNlXG4gICAgcmNhbGwoXCJERUxcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZWN1cnNpdmVseSBtb3ZlIGZyb20gd2FpdGluZ0NoaWxkcmVuIHRvIGZhaWxlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBwYXJlbnQgdG8gYWN0aXZlIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgICAtLSBSZXBsYWNlIHRoZSBzY29yZSBvZiB0aGUgbWFya2VyIHdpdGggdGhlIG5ld2VzdCBrbm93blxuICAgICAgICAtLSBuZXh0IHRpbWVzdGFtcC5cbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gICAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHNjb3JlID0gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIGJpdC5iYW5kKHByaW9Db3VudGVyLCAweGZmZmZmZmZmZmZmZilcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNRdWV1ZVBhdXNlZChxdWV1ZU1ldGFLZXkpXG4gICAgcmV0dXJuIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpID09IDFcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICAgIGxvY2FsIGlzUGFyZW50QWN0aXZlID0gcmNhbGwoXCJaU0NPUkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgaWYgcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpID09IDAgYW5kIGlzUGFyZW50QWN0aXZlIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIHBhcmVudFdhaXRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0XCJcbiAgICAgICAgbG9jYWwgcGFyZW50UGF1c2VkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6cGF1c2VkXCJcbiAgICAgICAgbG9jYWwgcGFyZW50TWV0YUtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1ldGFcIlxuICAgICAgICBsb2NhbCBwYXJlbnRNYXJrZXJLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptYXJrZXJcIlxuICAgICAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgICAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMV0pIG9yIDBcbiAgICAgICAgbG9jYWwgZGVsYXkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzJdKSBvciAwXG4gICAgICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gdG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5XG4gICAgICAgICAgICBsb2NhbCBzY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgICAgICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwYXJlbnREZWxheWVkS2V5LCBzY29yZSwgcGFyZW50SWQpXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLFxuICAgICAgICAgICAgICAgICAgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLCBkZWxheWVkVGltZXN0YW1wKVxuICAgICAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWQgPVxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50TWV0YUtleSwgcGFyZW50V2FpdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdXNlZEtleSlcbiAgICAgICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWQsIHBhcmVudElkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIGlzUGF1c2VkID0gaXNRdWV1ZVBhdXNlZChwYXJlbnRNZXRhS2V5KVxuICAgICAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShwYXJlbnRNYXJrZXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnByaW9yaXRpemVkXCIsIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCwgcGFyZW50UXVldWVLZXkgLi4gXCI6cGNcIiwgaXNQYXVzZWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgICAgICAgICBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50RnJvbVdhaXRpbmdDaGlsZHJlblRvRmFpbGVkKCBwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgam9iSWRLZXksIHRpbWVzdGFtcClcbiAgaWYgcmNhbGwoXCJaUkVNXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpID09IDEgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpmYWlsZWRcIiwgdGltZXN0YW1wLCBwYXJlbnRJZClcbiAgICBsb2NhbCBmYWlsZWRSZWFzb24gPSBcImNoaWxkIFwiIC4uIGpvYklkS2V5IC4uIFwiIGZhaWxlZFwiXG4gICAgcmNhbGwoXCJITVNFVFwiLCBwYXJlbnRLZXksIFwiZmFpbGVkUmVhc29uXCIsIGZhaWxlZFJlYXNvbiwgXCJmaW5pc2hlZE9uXCIsIHRpbWVzdGFtcClcbiAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwiZmFpbGVkXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwiZmFpbGVkUmVhc29uXCIsXG4gICAgICBmYWlsZWRSZWFzb24sIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgICBsb2NhbCByYXdQYXJlbnREYXRhID0gcmNhbGwoXCJIR0VUXCIsIHBhcmVudEtleSwgXCJwYXJlbnRcIilcbiAgICBpZiByYXdQYXJlbnREYXRhIH49IGZhbHNlIHRoZW5cbiAgICAgIGxvY2FsIHBhcmVudERhdGEgPSBjanNvbi5kZWNvZGUocmF3UGFyZW50RGF0YSlcbiAgICAgIGlmIHBhcmVudERhdGFbJ2Zwb2YnXSB0aGVuXG4gICAgICAgIG1vdmVQYXJlbnRGcm9tV2FpdGluZ0NoaWxkcmVuVG9GYWlsZWQoXG4gICAgICAgICAgcGFyZW50RGF0YVsncXVldWVLZXknXSxcbiAgICAgICAgICBwYXJlbnREYXRhWydxdWV1ZUtleSddIC4uICc6JyAuLiBwYXJlbnREYXRhWydpZCddLFxuICAgICAgICAgIHBhcmVudERhdGFbJ2lkJ10sXG4gICAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICApXG4gICAgICBlbHNlaWYgcGFyZW50RGF0YVsncmRvZiddIHRoZW5cbiAgICAgICAgbG9jYWwgZ3JhbmRQYXJlbnRLZXkgPSBwYXJlbnREYXRhWydxdWV1ZUtleSddIC4uICc6JyAuLiBwYXJlbnREYXRhWydpZCddXG4gICAgICAgIGxvY2FsIGdyYW5kUGFyZW50RGVwZW5kZW5jaWVzU2V0ID0gZ3JhbmRQYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICAgICAgaWYgcmNhbGwoXCJTUkVNXCIsIGdyYW5kUGFyZW50RGVwZW5kZW5jaWVzU2V0LCBwYXJlbnRLZXkpID09IDEgdGhlblxuICAgICAgICAgIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnREYXRhWydxdWV1ZUtleSddLCBncmFuZFBhcmVudERlcGVuZGVuY2llc1NldCxcbiAgICAgICAgICAgIGdyYW5kUGFyZW50S2V5LCBwYXJlbnREYXRhWydpZCddLCB0aW1lc3RhbXApXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIG1vdmUgam9iIGZyb20gd2FpdCBzdGF0ZSB0byBhY3RpdmUuXG4gIElucHV0OlxuICAgIG9wdHMgLSB0b2tlbiAtIGxvY2sgdG9rZW5cbiAgICBvcHRzIC0gbG9ja0R1cmF0aW9uXG4gICAgb3B0cyAtIGxpbWl0ZXJcbl1dXG5sb2NhbCBmdW5jdGlvbiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhrZXlQcmVmaXgsIHJhdGVMaW1pdGVyS2V5LCBldmVudFN0cmVhbUtleSxcbiAgICBqb2JJZCwgcHJvY2Vzc2VkT24sIG1heEpvYnMsIG9wdHMpXG4gIGxvY2FsIGpvYktleSA9IGtleVByZWZpeCAuLiBqb2JJZFxuICAtLSBDaGVjayBpZiB3ZSBuZWVkIHRvIHBlcmZvcm0gcmF0ZSBsaW1pdGluZy5cbiAgaWYgbWF4Sm9icyB0aGVuXG4gICAgbG9jYWwgam9iQ291bnRlciA9IHRvbnVtYmVyKHJjYWxsKFwiSU5DUlwiLCByYXRlTGltaXRlcktleSkpXG4gICAgaWYgam9iQ291bnRlciA9PSAxIHRoZW5cbiAgICAgIGxvY2FsIGxpbWl0ZXJEdXJhdGlvbiA9IG9wdHNbJ2xpbWl0ZXInXSBhbmQgb3B0c1snbGltaXRlciddWydkdXJhdGlvbiddXG4gICAgICBsb2NhbCBpbnRlZ2VyRHVyYXRpb24gPSBtYXRoLmZsb29yKG1hdGguYWJzKGxpbWl0ZXJEdXJhdGlvbikpXG4gICAgICByY2FsbChcIlBFWFBJUkVcIiwgcmF0ZUxpbWl0ZXJLZXksIGludGVnZXJEdXJhdGlvbilcbiAgICBlbmRcbiAgZW5kXG4gIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAtLSBnZXQgYSBsb2NrXG4gIGlmIG9wdHNbJ3Rva2VuJ10gfj0gXCIwXCIgdGhlblxuICAgIHJjYWxsKFwiU0VUXCIsIGxvY2tLZXksIG9wdHNbJ3Rva2VuJ10sIFwiUFhcIiwgb3B0c1snbG9ja0R1cmF0aW9uJ10pXG4gIGVuZFxuICBpZiBvcHRzWyduYW1lJ10gdGhlblxuICAgIC0tIFNldCBcInByb2Nlc3NlZEJ5XCIgZmllbGQgdG8gdGhlIHdvcmtlciBuYW1lXG4gICAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJwYlwiLCBvcHRzWyduYW1lJ10pXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsIFwiYWN0aXZlXCIsIFwiam9iSWRcIiwgam9iSWQsIFwicHJldlwiLCBcIndhaXRpbmdcIilcbiAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJwcm9jZXNzZWRPblwiLCBwcm9jZXNzZWRPbilcbiAgcmNhbGwoXCJISU5DUkJZXCIsIGpvYktleSwgXCJhdHNcIiwgMSlcbiAgcmV0dXJuIHtyY2FsbChcIkhHRVRBTExcIiwgam9iS2V5KSwgam9iSWQsIDAsIDB9IC0tIGdldCBqb2IgZGF0YVxuZW5kXG4tLVtbXG4gIFVwZGF0ZXMgdGhlIGRlbGF5IHNldCwgYnkgbW92aW5nIGRlbGF5ZWQgam9icyB0aGF0IHNob3VsZFxuICBiZSBwcm9jZXNzZWQgbm93IHRvIFwid2FpdFwiLlxuICAgICBFdmVudHM6XG4gICAgICAnd2FpdGluZydcbl1dXG4tLSBJbmNsdWRlc1xuLS0gVHJ5IHRvIGdldCBhcyBtdWNoIGFzIDEwMDAgam9icyBhdCBvbmNlXG5sb2NhbCBmdW5jdGlvbiBwcm9tb3RlRGVsYXllZEpvYnMoZGVsYXllZEtleSwgbWFya2VyS2V5LCB0YXJnZXRLZXksIHByaW9yaXRpemVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RyZWFtS2V5LCBwcmVmaXgsIHRpbWVzdGFtcCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgICBsb2NhbCBqb2JzID0gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIGRlbGF5ZWRLZXksIDAsICh0aW1lc3RhbXAgKyAxKSAqIDB4MTAwMCwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuICAgIGlmICgjam9icyA+IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIHVucGFjayhqb2JzKSlcbiAgICAgICAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0eSA9XG4gICAgICAgICAgICAgICAgdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgICAgICAgICAgYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBcIkxQVVNIXCIsIGlzUGF1c2VkLCBqb2JJZClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50XG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsXG4gICAgICAgICAgICAgICAgICBqb2JJZCwgXCJwcmV2XCIsIFwiZGVsYXllZFwiKVxuICAgICAgICAgICAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJkZWxheVwiLCAwKVxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLFxuICAgIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIHJlbW92ZSBqb2JzIGJ5IG1heCBhZ2UuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudFByZWZpeCAuLiBcIm1ldGFcIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdFwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXkpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgbWlzc2VkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2Ioam9iSWQsIGhhcmQsIGJhc2VLZXkpXG4gIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4gam9iSWRcbiAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYnNCeU1heEFnZSh0aW1lc3RhbXAsIG1heEFnZSwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gdGltZXN0YW1wIC0gbWF4QWdlICogMTAwMFxuICBsb2NhbCBqb2JJZHMgPSByY2FsbChcIlpSRVZSQU5HRUJZU0NPUkVcIiwgdGFyZ2V0U2V0LCBzdGFydCwgXCItaW5mXCIpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIFwiLWluZlwiLCBzdGFydClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMgYnkgbWF4IGNvdW50LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzQnlNYXhDb3VudChtYXhDb3VudCwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gbWF4Q291bnRcbiAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VcIiwgdGFyZ2V0U2V0LCBzdGFydCwgLTEpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllSQU5LXCIsIHRhcmdldFNldCwgMCwgLShtYXhDb3VudCArIDEpKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHRyaW0gZXZlbnRzLCBkZWZhdWx0IDEwMDAwLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICAgICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICAgIGVuZFxuICAgIHJldHVybiBtYXhFdmVudHNcbmVuZFxubG9jYWwgZnVuY3Rpb24gdHJpbUV2ZW50cyhtZXRhS2V5LCBldmVudFN0cmVhbUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgaWYgbWF4RXZlbnRzIH49IGZhbHNlIHRoZW5cbiAgICByY2FsbChcIlhUUklNXCIsIGV2ZW50U3RyZWFtS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzKVxuICBlbHNlXG4gICAgcmNhbGwoXCJYVFJJTVwiLCBldmVudFN0cmVhbUtleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIDEwMDAwKVxuICBlbmRcbmVuZFxuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBvciBhZGQgZGVwZW5kZW5jaWVzIHRvIHBhcmVudC5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gdXBkYXRlUGFyZW50RGVwc0lmTmVlZGVkKHBhcmVudEtleSwgcGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgcGFyZW50SWQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSwgdGltZXN0YW1wIClcbiAgbG9jYWwgcHJvY2Vzc2VkU2V0ID0gcGFyZW50S2V5IC4uIFwiOnByb2Nlc3NlZFwiXG4gIHJjYWxsKFwiSFNFVFwiLCBwcm9jZXNzZWRTZXQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSlcbiAgbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbmVuZFxubG9jYWwgam9iSWRLZXkgPSBLRVlTWzEyXVxuaWYgcmNhbGwoXCJFWElTVFNcIiwgam9iSWRLZXkpID09IDEgdGhlbiAtLSAvLyBNYWtlIHN1cmUgam9iIGV4aXN0c1xuICAgIGxvY2FsIG9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVls4XSlcbiAgICBsb2NhbCB0b2tlbiA9IG9wdHNbJ3Rva2VuJ11cbiAgICBsb2NhbCBhdHRlbXB0cyA9IG9wdHNbJ2F0dGVtcHRzJ11cbiAgICBsb2NhbCBtYXhNZXRyaWNzU2l6ZSA9IG9wdHNbJ21heE1ldHJpY3NTaXplJ11cbiAgICBsb2NhbCBtYXhDb3VudCA9IG9wdHNbJ2tlZXBKb2JzJ11bJ2NvdW50J11cbiAgICBsb2NhbCBtYXhBZ2UgPSBvcHRzWydrZWVwSm9icyddWydhZ2UnXVxuICAgIGlmIHRva2VuIH49IFwiMFwiIHRoZW5cbiAgICAgICAgbG9jYWwgbG9ja0tleSA9IGpvYklkS2V5IC4uICc6bG9jaydcbiAgICAgICAgbG9jYWwgbG9ja1Rva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICAgICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICAgICAgICByY2FsbChcIlNSRU1cIiwgS0VZU1s1XSwgQVJHVlsxXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBMb2NrIGV4aXN0cyBidXQgdG9rZW4gZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gLTZcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICAgICAgICAgIHJldHVybiAtMlxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIGlmIHJjYWxsKFwiU0NBUkRcIiwgam9iSWRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCIpIH49IDAgdGhlbiAtLSAvLyBNYWtlIHN1cmUgaXQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAgICByZXR1cm4gLTRcbiAgICBlbmRcbiAgICBsb2NhbCBwYXJlbnRSZWZlcmVuY2VzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JJZEtleSwgXCJwYXJlbnRLZXlcIiwgXCJwYXJlbnRcIilcbiAgICBsb2NhbCBwYXJlbnRLZXkgPSBwYXJlbnRSZWZlcmVuY2VzWzFdIG9yIFwiXCJcbiAgICBsb2NhbCBwYXJlbnRJZCA9IFwiXCJcbiAgICBsb2NhbCBwYXJlbnRRdWV1ZUtleSA9IFwiXCJcbiAgICBpZiBwYXJlbnRSZWZlcmVuY2VzWzJdIH49IGZhbHNlIHRoZW5cbiAgICAgICAgbG9jYWwganNvbkRlY29kZWRQYXJlbnQgPSBjanNvbi5kZWNvZGUocGFyZW50UmVmZXJlbmNlc1syXSlcbiAgICAgICAgcGFyZW50SWQgPSBqc29uRGVjb2RlZFBhcmVudFsnaWQnXVxuICAgICAgICBwYXJlbnRRdWV1ZUtleSA9IGpzb25EZWNvZGVkUGFyZW50WydxdWV1ZUtleSddXG4gICAgZW5kXG4gICAgbG9jYWwgam9iSWQgPSBBUkdWWzFdXG4gICAgbG9jYWwgdGltZXN0YW1wID0gQVJHVlsyXVxuICAgIC0tIFJlbW92ZSBmcm9tIGFjdGl2ZSBsaXN0IChpZiBub3QgYWN0aXZlIHdlIHNoYWxsIHJldHVybiBlcnJvcilcbiAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIkxSRU1cIiwgS0VZU1syXSwgLTEsIGpvYklkKVxuICAgIGlmIChudW1SZW1vdmVkRWxlbWVudHMgPCAxKSB0aGVuIHJldHVybiAtMyBlbmRcbiAgICBsb2NhbCBldmVudFN0cmVhbUtleSA9IEtFWVNbNF1cbiAgICBsb2NhbCBtZXRhS2V5ID0gS0VZU1s5XVxuICAgIC0tIFRyaW0gZXZlbnRzIGJlZm9yZSBlbWl0aW5nIHRoZW0gdG8gYXZvaWQgdHJpbW1pbmcgZXZlbnRzIGVtaXR0ZWQgaW4gdGhpcyBzY3JpcHRcbiAgICB0cmltRXZlbnRzKG1ldGFLZXksIGV2ZW50U3RyZWFtS2V5KVxuICAgIC0tIElmIGpvYiBoYXMgYSBwYXJlbnQgd2UgbmVlZCB0b1xuICAgIC0tIDEpIHJlbW92ZSB0aGlzIGpvYiBpZCBmcm9tIHBhcmVudHMgZGVwZW5kZW5jaWVzXG4gICAgLS0gMikgbW92ZSB0aGUgam9iIElkIHRvIHBhcmVudCBcInByb2Nlc3NlZFwiIHNldFxuICAgIC0tIDMpIHB1c2ggdGhlIHJlc3VsdHMgaW50byBwYXJlbnQgXCJyZXN1bHRzXCIgbGlzdFxuICAgIC0tIDQpIGlmIHBhcmVudCdzIGRlcGVuZGVuY2llcyBpcyBlbXB0eSwgdGhlbiBtb3ZlIHBhcmVudCB0byBcIndhaXQvcGF1c2VkXCIuIE5vdGUgaXQgbWF5IGJlIGEgZGlmZmVyZW50IHF1ZXVlIS5cbiAgICBpZiBwYXJlbnRJZCA9PSBcIlwiIGFuZCBwYXJlbnRLZXkgfj0gXCJcIiB0aGVuXG4gICAgICAgIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KHBhcmVudEtleSlcbiAgICAgICAgcGFyZW50UXVldWVLZXkgPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBcIjpcIiAuLiBwYXJlbnRJZClcbiAgICBlbmRcbiAgICBpZiBwYXJlbnRJZCB+PSBcIlwiIHRoZW5cbiAgICAgICAgaWYgQVJHVls1XSA9PSBcImNvbXBsZXRlZFwiIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIGRlcGVuZGVuY2llc1NldCA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgICAgICAgaWYgcmNhbGwoXCJTUkVNXCIsIGRlcGVuZGVuY2llc1NldCwgam9iSWRLZXkpID09IDEgdGhlblxuICAgICAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXNTZXQsIHBhcmVudElkLCBqb2JJZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQVJHVls0XSwgdGltZXN0YW1wKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIG9wdHNbJ2Zwb2YnXSB0aGVuXG4gICAgICAgICAgICAgICAgbW92ZVBhcmVudEZyb21XYWl0aW5nQ2hpbGRyZW5Ub0ZhaWxlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQsIGpvYklkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wKVxuICAgICAgICAgICAgZWxzZWlmIG9wdHNbJ2lkb2YnXSBvciBvcHRzWydyZG9mJ10gdGhlblxuICAgICAgICAgICAgICAgIGxvY2FsIGRlcGVuZGVuY2llc1NldCA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgICAgICAgICAgIGlmIHJjYWxsKFwiU1JFTVwiLCBkZXBlbmRlbmNpZXNTZXQsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBkZXBlbmRlbmNpZXNTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIGlmIG9wdHNbJ2lkb2YnXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCBmYWlsZWRTZXQgPSBwYXJlbnRLZXkgLi4gXCI6ZmFpbGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKFwiSFNFVFwiLCBmYWlsZWRTZXQsIGpvYklkS2V5LCBBUkdWWzRdKVxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBsb2NhbCBhdHRlbXB0c01hZGUgPSByY2FsbChcIkhJTkNSQllcIiwgam9iSWRLZXksIFwiYXRtXCIsIDEpXG4gICAgLS0gUmVtb3ZlIGpvYj9cbiAgICBpZiBtYXhDb3VudCB+PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgdGFyZ2V0U2V0ID0gS0VZU1sxMV1cbiAgICAgICAgLS0gQWRkIHRvIGNvbXBsZXRlL2ZhaWxlZCBzZXRcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHRhcmdldFNldCwgdGltZXN0YW1wLCBqb2JJZClcbiAgICAgICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgQVJHVlszXSwgQVJHVls0XSwgXCJmaW5pc2hlZE9uXCIsIHRpbWVzdGFtcClcbiAgICAgICAgLS0gXCJyZXR1cm52YWx1ZVwiIC8gXCJmYWlsZWRSZWFzb25cIiBhbmQgXCJmaW5pc2hlZE9uXCJcbiAgICAgICAgLS0gUmVtb3ZlIG9sZCBqb2JzP1xuICAgICAgICBsb2NhbCBwcmVmaXggPSBBUkdWWzddXG4gICAgICAgIGlmIG1heEFnZSB+PSBuaWwgdGhlblxuICAgICAgICAgICAgcmVtb3ZlSm9ic0J5TWF4QWdlKHRpbWVzdGFtcCwgbWF4QWdlLCB0YXJnZXRTZXQsIHByZWZpeClcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIG1heENvdW50IH49IG5pbCBhbmQgbWF4Q291bnQgPiAwIHRoZW5cbiAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG1heENvdW50LCB0YXJnZXRTZXQsIHByZWZpeClcbiAgICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgICByZW1vdmVKb2JLZXlzKGpvYklkS2V5KVxuICAgICAgICBpZiBwYXJlbnRLZXkgfj0gXCJcIiB0aGVuXG4gICAgICAgICAgICAtLSBUT0RPOiB3aGVuIGEgY2hpbGQgaXMgcmVtb3ZlZCB3aGVuIGZpbmlzaGVkLCByZXN1bHQgb3IgZmFpbHVyZSBpbiBwYXJlbnRcbiAgICAgICAgICAgIC0tIG11c3Qgbm90IGJlIGRlbGV0ZWQsIHRob3NlIHZhbHVlIHJlZmVyZW5jZXMgc2hvdWxkIGJlIGRlbGV0ZWQgd2hlbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAtLSBpcyBkZWxldGVkXG4gICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYklkS2V5LCBmYWxzZSwgcGFyZW50S2V5KVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsIEFSR1ZbNV0sIFwiam9iSWRcIiwgam9iSWQsIEFSR1ZbM10sXG4gICAgICAgICAgQVJHVls0XSlcbiAgICBpZiBBUkdWWzVdID09IFwiZmFpbGVkXCIgdGhlblxuICAgICAgICBpZiB0b251bWJlcihhdHRlbXB0c01hZGUpID49IHRvbnVtYmVyKGF0dGVtcHRzKSB0aGVuXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsIFwicmV0cmllcy1leGhhdXN0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgam9iSWQsIFwiYXR0ZW1wdHNNYWRlXCIsIGF0dGVtcHRzTWFkZSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgLS0gQ29sbGVjdCBtZXRyaWNzXG4gICAgaWYgbWF4TWV0cmljc1NpemUgfj0gXCJcIiB0aGVuXG4gICAgICAgIGNvbGxlY3RNZXRyaWNzKEtFWVNbMTNdLCBLRVlTWzEzXSAuLiAnOmRhdGEnLCBtYXhNZXRyaWNzU2l6ZSwgdGltZXN0YW1wKVxuICAgIGVuZFxuICAgIC0tIFRyeSB0byBnZXQgbmV4dCBqb2IgdG8gYXZvaWQgYW4gZXh0cmEgcm91bmR0cmlwIGlmIHRoZSBxdWV1ZSBpcyBub3QgY2xvc2luZyxcbiAgICAtLSBhbmQgbm90IHJhdGUgbGltaXRlZC5cbiAgICBpZiAoQVJHVls2XSA9PSBcIjFcIikgdGhlblxuICAgICAgICBsb2NhbCB0YXJnZXQsIHBhdXNlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChtZXRhS2V5LCBLRVlTWzFdLCBLRVlTWzhdKVxuICAgICAgICAtLSBDaGVjayBpZiB0aGVyZSBhcmUgZGVsYXllZCBqb2JzIHRoYXQgY2FuIGJlIHByb21vdGVkXG4gICAgICAgIHByb21vdGVEZWxheWVkSm9icyhLRVlTWzddLCBLRVlTWzE0XSwgdGFyZ2V0LCBLRVlTWzNdLCBldmVudFN0cmVhbUtleSwgQVJHVls3XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgS0VZU1sxMF0sIHBhdXNlZClcbiAgICAgICAgbG9jYWwgbWF4Sm9icyA9IHRvbnVtYmVyKG9wdHNbJ2xpbWl0ZXInXSBhbmQgb3B0c1snbGltaXRlciddWydtYXgnXSlcbiAgICAgICAgLS0gQ2hlY2sgaWYgd2UgYXJlIHJhdGUgbGltaXRlZCBmaXJzdC5cbiAgICAgICAgbG9jYWwgZXhwaXJlVGltZSA9IGdldFJhdGVMaW1pdFRUTChtYXhKb2JzLCBLRVlTWzZdKVxuICAgICAgICBpZiBleHBpcmVUaW1lID4gMCB0aGVuIHJldHVybiB7MCwgMCwgZXhwaXJlVGltZSwgMH0gZW5kXG4gICAgICAgIC0tIHBhdXNlZCBxdWV1ZVxuICAgICAgICBpZiBwYXVzZWQgdGhlbiByZXR1cm4gezAsIDAsIDAsIDB9IGVuZFxuICAgICAgICBqb2JJZCA9IHJjYWxsKFwiUlBPUExQVVNIXCIsIEtFWVNbMV0sIEtFWVNbMl0pXG4gICAgICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgICAgIC0tIE1hcmtlcnMgaW4gd2FpdGxpc3QgREVQUkVDQVRFRCBpbiB2NTogUmVtb3ZlIGluIHY2LlxuICAgICAgICAgICAgaWYgc3RyaW5nLnN1Yihqb2JJZCwgMSwgMikgPT0gXCIwOlwiIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIkxSRU1cIiwgS0VZU1syXSwgMSwgam9iSWQpXG4gICAgICAgICAgICAgICAgLS0gSWYgam9iSWQgaXMgc3BlY2lhbCBJRCAwOmRlbGF5IChkZWxheSBncmVhdGVyIHRoYW4gMCksIHRoZW4gdGhlcmUgaXMgbm8gam9iIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAtLSBidXQgaWYgSUQgaXMgMDowLCB0aGVuIHRoZXJlIGlzIGF0IGxlYXN0IDEgcHJpb3JpdGl6ZWQgam9iIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICBpZiBqb2JJZCA9PSBcIjA6MFwiIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgam9iSWQgPSBtb3ZlSm9iRnJvbVByaW9yaXR5VG9BY3RpdmUoS0VZU1szXSwgS0VZU1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS0VZU1sxMF0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhBUkdWWzddLCBLRVlTWzZdLCBldmVudFN0cmVhbUtleSwgam9iSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsIG1heEpvYnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhBUkdWWzddLCBLRVlTWzZdLCBldmVudFN0cmVhbUtleSwgam9iSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgbWF4Sm9icyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cylcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBqb2JJZCA9IG1vdmVKb2JGcm9tUHJpb3JpdHlUb0FjdGl2ZShLRVlTWzNdLCBLRVlTWzJdLCBLRVlTWzEwXSlcbiAgICAgICAgICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZUpvYkZvclByb2Nlc3NpbmcoQVJHVls3XSwgS0VZU1s2XSwgZXZlbnRTdHJlYW1LZXksIGpvYklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsIG1heEpvYnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIFJldHVybiB0aGUgdGltZXN0YW1wIGZvciB0aGUgbmV4dCBkZWxheWVkIGpvYiBpZiBhbnkuXG4gICAgICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChLRVlTWzddKVxuICAgICAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgICAgICAtLSBUaGUgcmVzdWx0IGlzIGd1YXJhbnRlZWQgdG8gYmUgcG9zaXRpdmUsIHNpbmNlIHRoZVxuICAgICAgICAgICAgLS0gWlJBTkdFQllTQ09SRSBjb21tYW5kIHdvdWxkIGhhdmUgcmV0dXJuIGEgam9iIG90aGVyd2lzZS5cbiAgICAgICAgICAgIHJldHVybiB7MCwgMCwgMCwgbmV4dFRpbWVzdGFtcH1cbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgbG9jYWwgd2FpdExlbiA9IHJjYWxsKFwiTExFTlwiLCBLRVlTWzFdKVxuICAgIGlmIHdhaXRMZW4gPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIGFjdGl2ZUxlbiA9IHJjYWxsKFwiTExFTlwiLCBLRVlTWzJdKVxuICAgICAgICBpZiBhY3RpdmVMZW4gPT0gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0aXplZExlbiA9IHJjYWxsKFwiWkNBUkRcIiwgS0VZU1szXSlcbiAgICAgICAgICAgIGlmIHByaW9yaXRpemVkTGVuID09IDAgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJkcmFpbmVkXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBtb3ZlVG9GaW5pc2hlZCA9IHtcbiAgICBuYW1lOiAnbW92ZVRvRmluaXNoZWQnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMTQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVRvRmluaXNoZWQtMTQuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJtb3ZlVG9GaW5pc2hlZCIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-4.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-4.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToWaitingChildren: () => (/* binding */ moveToWaitingChildren)\n/* harmony export */ });\nconst content = `--[[\n  Moves job from active to waiting children set.\n  Input:\n    KEYS[1] lock key\n    KEYS[2] active key\n    KEYS[3] waitChildrenKey key\n    KEYS[4] job key\n    ARGV[1] token\n    ARGV[2] child key\n    ARGV[3] timestamp\n    ARGV[4] the id of the job\n  Output:\n    0 - OK\n    1 - There are not pending dependencies.\n   -1 - Missing job.\n   -2 - Missing lock\n   -3 - Job not in active set\n]]\nlocal rcall = redis.call\nlocal function moveToWaitingChildren (activeKey, waitingChildrenKey, jobId, timestamp,\n    lockKey, jobKey, token)\n  if token ~= \"0\" then\n    if rcall(\"GET\", lockKey) == token then\n      rcall(\"DEL\", lockKey)\n    else\n      return -2\n    end\n  end\n  local score = tonumber(timestamp)\n  local numRemovedElements = rcall(\"LREM\", activeKey, -1, jobId)\n  if(numRemovedElements < 1) then\n    return -3\n  end\n  rcall(\"ZADD\", waitingChildrenKey, score, jobId)\n  return 0\nend\nif rcall(\"EXISTS\", KEYS[4]) == 1 then\n  if ARGV[2] ~= \"\" then\n    if rcall(\"SISMEMBER\", KEYS[4] .. \":dependencies\", ARGV[2]) ~= 0 then\n      return moveToWaitingChildren(KEYS[2], KEYS[3], ARGV[4], ARGV[3], KEYS[1], KEYS[4],\n        ARGV[1])\n    end\n    return 1\n  else\n    if rcall(\"SCARD\", KEYS[4] .. \":dependencies\") ~= 0 then \n      return moveToWaitingChildren(KEYS[2], KEYS[3], ARGV[4], ARGV[3], KEYS[1], KEYS[4],\n        ARGV[1])\n    end\n    return 1\n  end\nend\nreturn -1\n`;\nconst moveToWaitingChildren = {\n    name: \"moveToWaitingChildren\",\n    content,\n    keys: 4\n}; //# sourceMappingURL=moveToWaitingChildren-4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvV2FpdGluZ0NoaWxkcmVuLTQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9EakIsQ0FBQztBQUNNLE1BQU1DLHdCQUF3QjtJQUNqQ0MsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvV2FpdGluZ0NoaWxkcmVuLTQuanM/YzFlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZXMgam9iIGZyb20gYWN0aXZlIHRvIHdhaXRpbmcgY2hpbGRyZW4gc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGxvY2sga2V5XG4gICAgS0VZU1syXSBhY3RpdmUga2V5XG4gICAgS0VZU1szXSB3YWl0Q2hpbGRyZW5LZXkga2V5XG4gICAgS0VZU1s0XSBqb2Iga2V5XG4gICAgQVJHVlsxXSB0b2tlblxuICAgIEFSR1ZbMl0gY2hpbGQga2V5XG4gICAgQVJHVlszXSB0aW1lc3RhbXBcbiAgICBBUkdWWzRdIHRoZSBpZCBvZiB0aGUgam9iXG4gIE91dHB1dDpcbiAgICAwIC0gT0tcbiAgICAxIC0gVGhlcmUgYXJlIG5vdCBwZW5kaW5nIGRlcGVuZGVuY2llcy5cbiAgIC0xIC0gTWlzc2luZyBqb2IuXG4gICAtMiAtIE1pc3NpbmcgbG9ja1xuICAgLTMgLSBKb2Igbm90IGluIGFjdGl2ZSBzZXRcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGZ1bmN0aW9uIG1vdmVUb1dhaXRpbmdDaGlsZHJlbiAoYWN0aXZlS2V5LCB3YWl0aW5nQ2hpbGRyZW5LZXksIGpvYklkLCB0aW1lc3RhbXAsXG4gICAgbG9ja0tleSwgam9iS2V5LCB0b2tlbilcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGlmIHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIC0yXG4gICAgZW5kXG4gIGVuZFxuICBsb2NhbCBzY29yZSA9IHRvbnVtYmVyKHRpbWVzdGFtcClcbiAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJMUkVNXCIsIGFjdGl2ZUtleSwgLTEsIGpvYklkKVxuICBpZihudW1SZW1vdmVkRWxlbWVudHMgPCAxKSB0aGVuXG4gICAgcmV0dXJuIC0zXG4gIGVuZFxuICByY2FsbChcIlpBRERcIiwgd2FpdGluZ0NoaWxkcmVuS2V5LCBzY29yZSwgam9iSWQpXG4gIHJldHVybiAwXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbNF0pID09IDEgdGhlblxuICBpZiBBUkdWWzJdIH49IFwiXCIgdGhlblxuICAgIGlmIHJjYWxsKFwiU0lTTUVNQkVSXCIsIEtFWVNbNF0gLi4gXCI6ZGVwZW5kZW5jaWVzXCIsIEFSR1ZbMl0pIH49IDAgdGhlblxuICAgICAgcmV0dXJuIG1vdmVUb1dhaXRpbmdDaGlsZHJlbihLRVlTWzJdLCBLRVlTWzNdLCBBUkdWWzRdLCBBUkdWWzNdLCBLRVlTWzFdLCBLRVlTWzRdLFxuICAgICAgICBBUkdWWzFdKVxuICAgIGVuZFxuICAgIHJldHVybiAxXG4gIGVsc2VcbiAgICBpZiByY2FsbChcIlNDQVJEXCIsIEtFWVNbNF0gLi4gXCI6ZGVwZW5kZW5jaWVzXCIpIH49IDAgdGhlbiBcbiAgICAgIHJldHVybiBtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4oS0VZU1syXSwgS0VZU1szXSwgQVJHVls0XSwgQVJHVlszXSwgS0VZU1sxXSwgS0VZU1s0XSxcbiAgICAgICAgQVJHVlsxXSlcbiAgICBlbmRcbiAgICByZXR1cm4gMVxuICBlbmRcbmVuZFxucmV0dXJuIC0xXG5gO1xuZXhwb3J0IGNvbnN0IG1vdmVUb1dhaXRpbmdDaGlsZHJlbiA9IHtcbiAgICBuYW1lOiAnbW92ZVRvV2FpdGluZ0NoaWxkcmVuJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVRvV2FpdGluZ0NoaWxkcmVuLTQuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4iLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/obliterate-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   obliterate: () => (/* binding */ obliterate)\n/* harmony export */ });\nconst content = `--[[\n  Completely obliterates a queue and all of its contents\n  Input:\n    KEYS[1] meta\n    KEYS[2] base\n    ARGV[1] count\n    ARGV[2] force\n]]\n-- This command completely destroys a queue including all of its jobs, current or past \n-- leaving no trace of its existence. Since this script needs to iterate to find all the job\n-- keys, consider that this call may be slow for very large queues.\n-- The queue needs to be \"paused\" or it will return an error\n-- If the queue has currently active jobs then the script by default will return error,\n-- however this behaviour can be overrided using the 'force' option.\nlocal maxCount = tonumber(ARGV[1])\nlocal baseKey = KEYS[2]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey)\n  end\n  return max - #keys\nend\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\nlocal function getListItems(keyName, max)\n  return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max)\n  local jobs = getListItems(keyName, max)\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall(\"LTRIM\", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max)\n  local jobs = getZSetItems(keyName, max)\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall(\"ZREM\", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\nlocal function removeLockKeys(keys)\n  for i, key in ipairs(keys) do\n    rcall(\"DEL\", baseKey .. key .. ':lock')\n  end\nend\n-- 1) Check if paused, if not return with error.\nif rcall(\"HEXISTS\", KEYS[1], \"paused\") ~= 1 then\n  return -1 -- Error, NotPaused\nend\n-- 2) Check if there are active jobs, if there are and not \"force\" return error.\nlocal activeKey = baseKey .. 'active'\nlocal activeJobs = getListItems(activeKey, maxCount)\nif (#activeJobs > 0) then\n  if(ARGV[2] == \"\") then \n    return -2 -- Error, ExistActiveJobs\n  end\nend\nremoveLockKeys(activeJobs)\nmaxCount = removeJobs(activeJobs, true, baseKey, maxCount)\nrcall(\"LTRIM\", activeKey, #activeJobs, -1)\nif(maxCount <= 0) then\n  return 1\nend\nlocal delayedKey = baseKey .. 'delayed'\nmaxCount = removeZSetJobs(delayedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal completedKey = baseKey .. 'completed'\nmaxCount = removeZSetJobs(completedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal waitKey = baseKey .. 'paused'\nmaxCount = removeListJobs(waitKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal prioritizedKey = baseKey .. 'prioritized'\nmaxCount = removeZSetJobs(prioritizedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal failedKey = baseKey .. 'failed'\nmaxCount = removeZSetJobs(failedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nif(maxCount > 0) then\n  rcall(\"DEL\",\n    baseKey .. 'events',\n    baseKey .. 'delay', \n    baseKey .. 'stalled-check',\n    baseKey .. 'stalled',\n    baseKey .. 'id',\n    baseKey .. 'pc',\n    baseKey .. 'meta',\n    baseKey .. 'repeat',\n    baseKey .. 'metrics:completed',\n    baseKey .. 'metrics:completed:data',\n    baseKey .. 'metrics:failed',\n    baseKey .. 'metrics:failed:data')\n  return 0\nelse\n  return 1\nend\n`;\nconst obliterate = {\n    name: \"obliterate\",\n    content,\n    keys: 2\n}; //# sourceMappingURL=obliterate-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvb2JsaXRlcmF0ZS0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdRakIsQ0FBQztBQUNNLE1BQU1DLGFBQWE7SUFDdEJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL29ibGl0ZXJhdGUtMi5qcz8xYzFiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDb21wbGV0ZWx5IG9ibGl0ZXJhdGVzIGEgcXVldWUgYW5kIGFsbCBvZiBpdHMgY29udGVudHNcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBtZXRhXG4gICAgS0VZU1syXSBiYXNlXG4gICAgQVJHVlsxXSBjb3VudFxuICAgIEFSR1ZbMl0gZm9yY2Vcbl1dXG4tLSBUaGlzIGNvbW1hbmQgY29tcGxldGVseSBkZXN0cm95cyBhIHF1ZXVlIGluY2x1ZGluZyBhbGwgb2YgaXRzIGpvYnMsIGN1cnJlbnQgb3IgcGFzdCBcbi0tIGxlYXZpbmcgbm8gdHJhY2Ugb2YgaXRzIGV4aXN0ZW5jZS4gU2luY2UgdGhpcyBzY3JpcHQgbmVlZHMgdG8gaXRlcmF0ZSB0byBmaW5kIGFsbCB0aGUgam9iXG4tLSBrZXlzLCBjb25zaWRlciB0aGF0IHRoaXMgY2FsbCBtYXkgYmUgc2xvdyBmb3IgdmVyeSBsYXJnZSBxdWV1ZXMuXG4tLSBUaGUgcXVldWUgbmVlZHMgdG8gYmUgXCJwYXVzZWRcIiBvciBpdCB3aWxsIHJldHVybiBhbiBlcnJvclxuLS0gSWYgdGhlIHF1ZXVlIGhhcyBjdXJyZW50bHkgYWN0aXZlIGpvYnMgdGhlbiB0aGUgc2NyaXB0IGJ5IGRlZmF1bHQgd2lsbCByZXR1cm4gZXJyb3IsXG4tLSBob3dldmVyIHRoaXMgYmVoYXZpb3VyIGNhbiBiZSBvdmVycmlkZWQgdXNpbmcgdGhlICdmb3JjZScgb3B0aW9uLlxubG9jYWwgbWF4Q291bnQgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgYmFzZUtleSA9IEtFWVNbMl1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIHJlbW92ZSBqb2JzLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2IuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYiBrZXlzLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYktleXMoam9iS2V5KVxuICByZXR1cm4gcmNhbGwoXCJERUxcIiwgam9iS2V5LCBqb2JLZXkgLi4gJzpsb2dzJyxcbiAgICBqb2JLZXkgLi4gJzpkZXBlbmRlbmNpZXMnLCBqb2JLZXkgLi4gJzpwcm9jZXNzZWQnLCBqb2JLZXkgLi4gJzpmYWlsZWQnKVxuZW5kXG4tLVtbXG4gIENoZWNrIGlmIHRoaXMgam9iIGhhcyBhIHBhcmVudC4gSWYgc28gd2Ugd2lsbCBqdXN0IHJlbW92ZSBpdCBmcm9tXG4gIHRoZSBwYXJlbnQgY2hpbGQgbGlzdCwgYnV0IGlmIGl0IGlzIHRoZSBsYXN0IGNoaWxkIHdlIHNob3VsZCBtb3ZlIHRoZSBwYXJlbnQgdG8gXCJ3YWl0L3BhdXNlZFwiXG4gIHdoaWNoIHJlcXVpcmVzIGNvZGUgZnJvbSBcIm1vdmVUb0ZpbmlzaGVkXCJcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9ucyB0byBkZXN0cnVjdHVyZSBqb2Iga2V5LlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHRoZXNlIGZ1bmN0aW9ucyBtYXkgYmUgYSBiaXQgc2xvdyBhbmQgYWZmZWN0IHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG5dXVxubG9jYWwgZ2V0Sm9iSWRGcm9tS2V5ID0gZnVuY3Rpb24gKGpvYktleSlcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChqb2JLZXksIFwiLio6KC4qKVwiKVxuZW5kXG5sb2NhbCBnZXRKb2JLZXlQcmVmaXggPSBmdW5jdGlvbiAoam9iS2V5LCBqb2JJZClcbiAgcmV0dXJuIHN0cmluZy5zdWIoam9iS2V5LCAwLCAjam9iS2V5IC0gI2pvYklkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudFByZWZpeCAuLiBcIm1ldGFcIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdFwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXkpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgbWlzc2VkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2Ioam9iSWQsIGhhcmQsIGJhc2VLZXkpXG4gIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4gam9iSWRcbiAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYnMoa2V5cywgaGFyZCwgYmFzZUtleSwgbWF4KVxuICBmb3IgaSwga2V5IGluIGlwYWlycyhrZXlzKSBkb1xuICAgIHJlbW92ZUpvYihrZXksIGhhcmQsIGJhc2VLZXkpXG4gIGVuZFxuICByZXR1cm4gbWF4IC0gI2tleXNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIHJldHVybiByY2FsbCgnTFJBTkdFJywga2V5TmFtZSwgMCwgbWF4IC0gMSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTGlzdEpvYnMoa2V5TmFtZSwgaGFyZCwgYmFzZUtleSwgbWF4KVxuICBsb2NhbCBqb2JzID0gZ2V0TGlzdEl0ZW1zKGtleU5hbWUsIG1heClcbiAgbG9jYWwgY291bnQgPSByZW1vdmVKb2JzKGpvYnMsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgcmNhbGwoXCJMVFJJTVwiLCBrZXlOYW1lLCAjam9icywgLTEpXG4gIHJldHVybiBjb3VudFxuZW5kXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBsb29wIGluIGJhdGNoZXMuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgc29tZSBjb21tYW5kcyBhcyBaUkVNXG4gIGNvdWxkIHJlY2VpdmUgYSBtYXhpbXVtIG9mIDcwMDAgcGFyYW1ldGVycyBwZXIgY2FsbC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBiYXRjaGVzKG4sIGJhdGNoU2l6ZSlcbiAgbG9jYWwgaSA9IDBcbiAgcmV0dXJuIGZ1bmN0aW9uKClcbiAgICBsb2NhbCBmcm9tID0gaSAqIGJhdGNoU2l6ZSArIDFcbiAgICBpID0gaSArIDFcbiAgICBpZiAoZnJvbSA8PSBuKSB0aGVuXG4gICAgICBsb2NhbCB0byA9IG1hdGgubWluKGZyb20gKyBiYXRjaFNpemUgLSAxLCBuKVxuICAgICAgcmV0dXJuIGZyb20sIHRvXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBaU2V0IGl0ZW1zLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIHJldHVybiByY2FsbCgnWlJBTkdFJywga2V5TmFtZSwgMCwgbWF4IC0gMSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlWlNldEpvYnMoa2V5TmFtZSwgaGFyZCwgYmFzZUtleSwgbWF4KVxuICBsb2NhbCBqb2JzID0gZ2V0WlNldEl0ZW1zKGtleU5hbWUsIG1heClcbiAgbG9jYWwgY291bnQgPSByZW1vdmVKb2JzKGpvYnMsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgaWYoI2pvYnMgPiAwKSB0aGVuXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2pvYnMsIDcwMDApIGRvXG4gICAgICByY2FsbChcIlpSRU1cIiwga2V5TmFtZSwgdW5wYWNrKGpvYnMsIGZyb20sIHRvKSlcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBjb3VudFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMb2NrS2V5cyhrZXlzKVxuICBmb3IgaSwga2V5IGluIGlwYWlycyhrZXlzKSBkb1xuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4ga2V5IC4uICc6bG9jaycpXG4gIGVuZFxuZW5kXG4tLSAxKSBDaGVjayBpZiBwYXVzZWQsIGlmIG5vdCByZXR1cm4gd2l0aCBlcnJvci5cbmlmIHJjYWxsKFwiSEVYSVNUU1wiLCBLRVlTWzFdLCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgcmV0dXJuIC0xIC0tIEVycm9yLCBOb3RQYXVzZWRcbmVuZFxuLS0gMikgQ2hlY2sgaWYgdGhlcmUgYXJlIGFjdGl2ZSBqb2JzLCBpZiB0aGVyZSBhcmUgYW5kIG5vdCBcImZvcmNlXCIgcmV0dXJuIGVycm9yLlxubG9jYWwgYWN0aXZlS2V5ID0gYmFzZUtleSAuLiAnYWN0aXZlJ1xubG9jYWwgYWN0aXZlSm9icyA9IGdldExpc3RJdGVtcyhhY3RpdmVLZXksIG1heENvdW50KVxuaWYgKCNhY3RpdmVKb2JzID4gMCkgdGhlblxuICBpZihBUkdWWzJdID09IFwiXCIpIHRoZW4gXG4gICAgcmV0dXJuIC0yIC0tIEVycm9yLCBFeGlzdEFjdGl2ZUpvYnNcbiAgZW5kXG5lbmRcbnJlbW92ZUxvY2tLZXlzKGFjdGl2ZUpvYnMpXG5tYXhDb3VudCA9IHJlbW92ZUpvYnMoYWN0aXZlSm9icywgdHJ1ZSwgYmFzZUtleSwgbWF4Q291bnQpXG5yY2FsbChcIkxUUklNXCIsIGFjdGl2ZUtleSwgI2FjdGl2ZUpvYnMsIC0xKVxuaWYobWF4Q291bnQgPD0gMCkgdGhlblxuICByZXR1cm4gMVxuZW5kXG5sb2NhbCBkZWxheWVkS2V5ID0gYmFzZUtleSAuLiAnZGVsYXllZCdcbm1heENvdW50ID0gcmVtb3ZlWlNldEpvYnMoZGVsYXllZEtleSwgdHJ1ZSwgYmFzZUtleSwgbWF4Q291bnQpXG5pZihtYXhDb3VudCA8PSAwKSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmxvY2FsIGNvbXBsZXRlZEtleSA9IGJhc2VLZXkgLi4gJ2NvbXBsZXRlZCdcbm1heENvdW50ID0gcmVtb3ZlWlNldEpvYnMoY29tcGxldGVkS2V5LCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbmlmKG1heENvdW50IDw9IDApIHRoZW5cbiAgcmV0dXJuIDFcbmVuZFxubG9jYWwgd2FpdEtleSA9IGJhc2VLZXkgLi4gJ3BhdXNlZCdcbm1heENvdW50ID0gcmVtb3ZlTGlzdEpvYnMod2FpdEtleSwgdHJ1ZSwgYmFzZUtleSwgbWF4Q291bnQpXG5pZihtYXhDb3VudCA8PSAwKSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmxvY2FsIHByaW9yaXRpemVkS2V5ID0gYmFzZUtleSAuLiAncHJpb3JpdGl6ZWQnXG5tYXhDb3VudCA9IHJlbW92ZVpTZXRKb2JzKHByaW9yaXRpemVkS2V5LCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbmlmKG1heENvdW50IDw9IDApIHRoZW5cbiAgcmV0dXJuIDFcbmVuZFxubG9jYWwgZmFpbGVkS2V5ID0gYmFzZUtleSAuLiAnZmFpbGVkJ1xubWF4Q291bnQgPSByZW1vdmVaU2V0Sm9icyhmYWlsZWRLZXksIHRydWUsIGJhc2VLZXksIG1heENvdW50KVxuaWYobWF4Q291bnQgPD0gMCkgdGhlblxuICByZXR1cm4gMVxuZW5kXG5pZihtYXhDb3VudCA+IDApIHRoZW5cbiAgcmNhbGwoXCJERUxcIixcbiAgICBiYXNlS2V5IC4uICdldmVudHMnLFxuICAgIGJhc2VLZXkgLi4gJ2RlbGF5JywgXG4gICAgYmFzZUtleSAuLiAnc3RhbGxlZC1jaGVjaycsXG4gICAgYmFzZUtleSAuLiAnc3RhbGxlZCcsXG4gICAgYmFzZUtleSAuLiAnaWQnLFxuICAgIGJhc2VLZXkgLi4gJ3BjJyxcbiAgICBiYXNlS2V5IC4uICdtZXRhJyxcbiAgICBiYXNlS2V5IC4uICdyZXBlYXQnLFxuICAgIGJhc2VLZXkgLi4gJ21ldHJpY3M6Y29tcGxldGVkJyxcbiAgICBiYXNlS2V5IC4uICdtZXRyaWNzOmNvbXBsZXRlZDpkYXRhJyxcbiAgICBiYXNlS2V5IC4uICdtZXRyaWNzOmZhaWxlZCcsXG4gICAgYmFzZUtleSAuLiAnbWV0cmljczpmYWlsZWQ6ZGF0YScpXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAxXG5lbmRcbmA7XG5leHBvcnQgY29uc3Qgb2JsaXRlcmF0ZSA9IHtcbiAgICBuYW1lOiAnb2JsaXRlcmF0ZScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ibGl0ZXJhdGUtMi5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsIm9ibGl0ZXJhdGUiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/paginate-1.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paginate: () => (/* binding */ paginate)\n/* harmony export */ });\nconst content = `--[[\n    Paginate a set or hash\n    Input:\n      KEYS[1] key pointing to the set or hash to be paginated.\n      ARGV[1]  page start offset\n      ARGV[2]  page end offset (-1 for all the elements)\n      ARGV[3]  cursor\n      ARGV[4]  offset\n      ARGV[5]  max iterations\n      ARGV[6]  fetch jobs?\n    Output:\n      [cursor, offset, items, numItems]\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to achieve pagination for a set or hash.\n  This function simulates pagination in the most efficient way possible\n  for a set using sscan or hscan.\n  The main limitation is that sets are not order preserving, so the\n  pagination is not stable. This means that if the set is modified\n  between pages, the same element may appear in different pages.\n]] -- Maximum number of elements to be returned by sscan per iteration.\nlocal maxCount = 100\n-- Finds the cursor, and returns the first elements available for the requested page.\nlocal function findPage(key, command, pageStart, pageSize, cursor, offset,\n                        maxIterations, fetchJobs)\n    local items = {}\n    local jobs = {}\n    local iterations = 0\n    repeat\n        -- Iterate over the set using sscan/hscan.\n        local result = rcall(command, key, cursor, \"COUNT\", maxCount)\n        cursor = result[1]\n        local members = result[2]\n        local step = 1\n        if command == \"HSCAN\" then\n            step = 2\n        end\n        if #members == 0 then\n            -- If the result is empty, we can return the result.\n            return cursor, offset, items, jobs\n        end\n        local chunkStart = offset\n        local chunkEnd = offset + #members / step\n        local pageEnd = pageStart + pageSize\n        if chunkEnd < pageStart then\n            -- If the chunk is before the page, we can skip it.\n            offset = chunkEnd\n        elseif chunkStart > pageEnd then\n            -- If the chunk is after the page, we can return the result.\n            return cursor, offset, items, jobs\n        else\n            -- If the chunk is overlapping the page, we need to add the elements to the result.\n            for i = 1, #members, step do\n                if offset >= pageEnd then\n                    return cursor, offset, items, jobs\n                end\n                if offset >= pageStart then\n                    local index = #items + 1\n                    if fetchJobs ~= nil then\n                        jobs[#jobs+1] = rcall(\"HGETALL\", members[i])\n                    end\n                    if step == 2 then\n                        items[index] = {members[i], members[i + 1]}\n                    else\n                        items[index] = members[i]\n                    end\n                end\n                offset = offset + 1\n            end\n        end\n        iterations = iterations + 1\n    until cursor == \"0\" or iterations >= maxIterations\n    return cursor, offset, items, jobs\nend\nlocal key = KEYS[1]\nlocal scanCommand = \"SSCAN\"\nlocal countCommand = \"SCARD\"\nlocal type = rcall(\"TYPE\", key)[\"ok\"]\nif type == \"none\" then\n    return {0, 0, {}, 0}\nelseif type == \"hash\" then\n    scanCommand = \"HSCAN\"\n    countCommand = \"HLEN\"\nelseif type ~= \"set\" then\n    return\n        redis.error_reply(\"Pagination is only supported for sets and hashes.\")\nend\nlocal numItems = rcall(countCommand, key)\nlocal startOffset = tonumber(ARGV[1])\nlocal endOffset = tonumber(ARGV[2])\nif endOffset == -1 then \n  endOffset = numItems\nend\nlocal pageSize = (endOffset - startOffset) + 1\nlocal cursor, offset, items, jobs = findPage(key, scanCommand, startOffset,\n                                       pageSize, ARGV[3], tonumber(ARGV[4]),\n                                       tonumber(ARGV[5]), ARGV[6])\nreturn {cursor, offset, items, numItems, jobs}\n`;\nconst paginate = {\n    name: \"paginate\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=paginate-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGFnaW5hdGUtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0dqQixDQUFDO0FBQ00sTUFBTUMsV0FBVztJQUNwQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGFnaW5hdGUtMS5qcz9jNzUwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgIFBhZ2luYXRlIGEgc2V0IG9yIGhhc2hcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0ga2V5IHBvaW50aW5nIHRvIHRoZSBzZXQgb3IgaGFzaCB0byBiZSBwYWdpbmF0ZWQuXG4gICAgICBBUkdWWzFdICBwYWdlIHN0YXJ0IG9mZnNldFxuICAgICAgQVJHVlsyXSAgcGFnZSBlbmQgb2Zmc2V0ICgtMSBmb3IgYWxsIHRoZSBlbGVtZW50cylcbiAgICAgIEFSR1ZbM10gIGN1cnNvclxuICAgICAgQVJHVls0XSAgb2Zmc2V0XG4gICAgICBBUkdWWzVdICBtYXggaXRlcmF0aW9uc1xuICAgICAgQVJHVls2XSAgZmV0Y2ggam9icz9cbiAgICBPdXRwdXQ6XG4gICAgICBbY3Vyc29yLCBvZmZzZXQsIGl0ZW1zLCBudW1JdGVtc11cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFjaGlldmUgcGFnaW5hdGlvbiBmb3IgYSBzZXQgb3IgaGFzaC5cbiAgVGhpcyBmdW5jdGlvbiBzaW11bGF0ZXMgcGFnaW5hdGlvbiBpbiB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHBvc3NpYmxlXG4gIGZvciBhIHNldCB1c2luZyBzc2NhbiBvciBoc2Nhbi5cbiAgVGhlIG1haW4gbGltaXRhdGlvbiBpcyB0aGF0IHNldHMgYXJlIG5vdCBvcmRlciBwcmVzZXJ2aW5nLCBzbyB0aGVcbiAgcGFnaW5hdGlvbiBpcyBub3Qgc3RhYmxlLiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHNldCBpcyBtb2RpZmllZFxuICBiZXR3ZWVuIHBhZ2VzLCB0aGUgc2FtZSBlbGVtZW50IG1heSBhcHBlYXIgaW4gZGlmZmVyZW50IHBhZ2VzLlxuXV0gLS0gTWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcmV0dXJuZWQgYnkgc3NjYW4gcGVyIGl0ZXJhdGlvbi5cbmxvY2FsIG1heENvdW50ID0gMTAwXG4tLSBGaW5kcyB0aGUgY3Vyc29yLCBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudHMgYXZhaWxhYmxlIGZvciB0aGUgcmVxdWVzdGVkIHBhZ2UuXG5sb2NhbCBmdW5jdGlvbiBmaW5kUGFnZShrZXksIGNvbW1hbmQsIHBhZ2VTdGFydCwgcGFnZVNpemUsIGN1cnNvciwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucywgZmV0Y2hKb2JzKVxuICAgIGxvY2FsIGl0ZW1zID0ge31cbiAgICBsb2NhbCBqb2JzID0ge31cbiAgICBsb2NhbCBpdGVyYXRpb25zID0gMFxuICAgIHJlcGVhdFxuICAgICAgICAtLSBJdGVyYXRlIG92ZXIgdGhlIHNldCB1c2luZyBzc2Nhbi9oc2Nhbi5cbiAgICAgICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoY29tbWFuZCwga2V5LCBjdXJzb3IsIFwiQ09VTlRcIiwgbWF4Q291bnQpXG4gICAgICAgIGN1cnNvciA9IHJlc3VsdFsxXVxuICAgICAgICBsb2NhbCBtZW1iZXJzID0gcmVzdWx0WzJdXG4gICAgICAgIGxvY2FsIHN0ZXAgPSAxXG4gICAgICAgIGlmIGNvbW1hbmQgPT0gXCJIU0NBTlwiIHRoZW5cbiAgICAgICAgICAgIHN0ZXAgPSAyXG4gICAgICAgIGVuZFxuICAgICAgICBpZiAjbWVtYmVycyA9PSAwIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSByZXN1bHQgaXMgZW1wdHksIHdlIGNhbiByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnNcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIGNodW5rU3RhcnQgPSBvZmZzZXRcbiAgICAgICAgbG9jYWwgY2h1bmtFbmQgPSBvZmZzZXQgKyAjbWVtYmVycyAvIHN0ZXBcbiAgICAgICAgbG9jYWwgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplXG4gICAgICAgIGlmIGNodW5rRW5kIDwgcGFnZVN0YXJ0IHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBjaHVuayBpcyBiZWZvcmUgdGhlIHBhZ2UsIHdlIGNhbiBza2lwIGl0LlxuICAgICAgICAgICAgb2Zmc2V0ID0gY2h1bmtFbmRcbiAgICAgICAgZWxzZWlmIGNodW5rU3RhcnQgPiBwYWdlRW5kIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBjaHVuayBpcyBhZnRlciB0aGUgcGFnZSwgd2UgY2FuIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvciwgb2Zmc2V0LCBpdGVtcywgam9ic1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBJZiB0aGUgY2h1bmsgaXMgb3ZlcmxhcHBpbmcgdGhlIHBhZ2UsIHdlIG5lZWQgdG8gYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjbWVtYmVycywgc3RlcCBkb1xuICAgICAgICAgICAgICAgIGlmIG9mZnNldCA+PSBwYWdlRW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvciwgb2Zmc2V0LCBpdGVtcywgam9ic1xuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGlmIG9mZnNldCA+PSBwYWdlU3RhcnQgdGhlblxuICAgICAgICAgICAgICAgICAgICBsb2NhbCBpbmRleCA9ICNpdGVtcyArIDFcbiAgICAgICAgICAgICAgICAgICAgaWYgZmV0Y2hKb2JzIH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2JzWyNqb2JzKzFdID0gcmNhbGwoXCJIR0VUQUxMXCIsIG1lbWJlcnNbaV0pXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICBpZiBzdGVwID09IDIgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdID0ge21lbWJlcnNbaV0sIG1lbWJlcnNbaSArIDFdfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBtZW1iZXJzW2ldXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnMgKyAxXG4gICAgdW50aWwgY3Vyc29yID09IFwiMFwiIG9yIGl0ZXJhdGlvbnMgPj0gbWF4SXRlcmF0aW9uc1xuICAgIHJldHVybiBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnNcbmVuZFxubG9jYWwga2V5ID0gS0VZU1sxXVxubG9jYWwgc2NhbkNvbW1hbmQgPSBcIlNTQ0FOXCJcbmxvY2FsIGNvdW50Q29tbWFuZCA9IFwiU0NBUkRcIlxubG9jYWwgdHlwZSA9IHJjYWxsKFwiVFlQRVwiLCBrZXkpW1wib2tcIl1cbmlmIHR5cGUgPT0gXCJub25lXCIgdGhlblxuICAgIHJldHVybiB7MCwgMCwge30sIDB9XG5lbHNlaWYgdHlwZSA9PSBcImhhc2hcIiB0aGVuXG4gICAgc2NhbkNvbW1hbmQgPSBcIkhTQ0FOXCJcbiAgICBjb3VudENvbW1hbmQgPSBcIkhMRU5cIlxuZWxzZWlmIHR5cGUgfj0gXCJzZXRcIiB0aGVuXG4gICAgcmV0dXJuXG4gICAgICAgIHJlZGlzLmVycm9yX3JlcGx5KFwiUGFnaW5hdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc2V0cyBhbmQgaGFzaGVzLlwiKVxuZW5kXG5sb2NhbCBudW1JdGVtcyA9IHJjYWxsKGNvdW50Q29tbWFuZCwga2V5KVxubG9jYWwgc3RhcnRPZmZzZXQgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgZW5kT2Zmc2V0ID0gdG9udW1iZXIoQVJHVlsyXSlcbmlmIGVuZE9mZnNldCA9PSAtMSB0aGVuIFxuICBlbmRPZmZzZXQgPSBudW1JdGVtc1xuZW5kXG5sb2NhbCBwYWdlU2l6ZSA9IChlbmRPZmZzZXQgLSBzdGFydE9mZnNldCkgKyAxXG5sb2NhbCBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnMgPSBmaW5kUGFnZShrZXksIHNjYW5Db21tYW5kLCBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplLCBBUkdWWzNdLCB0b251bWJlcihBUkdWWzRdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvbnVtYmVyKEFSR1ZbNV0pLCBBUkdWWzZdKVxucmV0dXJuIHtjdXJzb3IsIG9mZnNldCwgaXRlbXMsIG51bUl0ZW1zLCBqb2JzfVxuYDtcbmV4cG9ydCBjb25zdCBwYWdpbmF0ZSA9IHtcbiAgICBuYW1lOiAncGFnaW5hdGUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0ZS0xLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwicGFnaW5hdGUiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/pause-7.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pause: () => (/* binding */ pause)\n/* harmony export */ });\nconst content = `--[[\n  Pauses or resumes a queue globably.\n  Input:\n    KEYS[1] 'wait' or 'paused''\n    KEYS[2] 'paused' or 'wait'\n    KEYS[3] 'meta'\n    KEYS[4] 'prioritized'\n    KEYS[5] events stream key\n    KEYS[6] 'delayed'\n    KEYS|7] 'marker'\n    ARGV[1] 'paused' or 'resumed'\n  Event:\n    publish paused or resumed event.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if (nextTimestamp ~= nil) then \n      nextTimestamp = nextTimestamp / 0x1000\n    end\n    return nextTimestamp\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n    local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n    if nextTimestamp ~= nil then\n        -- Replace the score of the marker with the newest known\n        -- next timestamp.\n        rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n    end\nend\nlocal markerKey = KEYS[7]\nlocal hasJobs = rcall(\"EXISTS\", KEYS[1]) == 1\n--TODO: check this logic to be reused when changing a delay\nif hasJobs then rcall(\"RENAME\", KEYS[1], KEYS[2]) end\nif ARGV[1] == \"paused\" then\n    rcall(\"HSET\", KEYS[3], \"paused\", 1)\n    rcall(\"DEL\", markerKey)\nelse\n    rcall(\"HDEL\", KEYS[3], \"paused\")\n    if hasJobs or rcall(\"ZCARD\", KEYS[4]) > 0 then\n        -- Add marker if there are waiting or priority jobs\n        rcall(\"ZADD\", markerKey, 0, \"0\")\n    else\n        addDelayMarkerIfNeeded(markerKey, KEYS[6])\n    end\nend\nrcall(\"XADD\", KEYS[5], \"*\", \"event\", ARGV[1]);\n`;\nconst pause = {\n    name: \"pause\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=pause-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGF1c2UtNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMERqQixDQUFDO0FBQ00sTUFBTUMsUUFBUTtJQUNqQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGF1c2UtNy5qcz9lZjFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBQYXVzZXMgb3IgcmVzdW1lcyBhIHF1ZXVlIGdsb2JhYmx5LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICd3YWl0JyBvciAncGF1c2VkJydcbiAgICBLRVlTWzJdICdwYXVzZWQnIG9yICd3YWl0J1xuICAgIEtFWVNbM10gJ21ldGEnXG4gICAgS0VZU1s0XSAncHJpb3JpdGl6ZWQnXG4gICAgS0VZU1s1XSBldmVudHMgc3RyZWFtIGtleVxuICAgIEtFWVNbNl0gJ2RlbGF5ZWQnXG4gICAgS0VZU3w3XSAnbWFya2VyJ1xuICAgIEFSR1ZbMV0gJ3BhdXNlZCcgb3IgJ3Jlc3VtZWQnXG4gIEV2ZW50OlxuICAgIHB1Ymxpc2ggcGF1c2VkIG9yIHJlc3VtZWQgZXZlbnQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIChuZXh0VGltZXN0YW1wIH49IG5pbCkgdGhlbiBcbiAgICAgIG5leHRUaW1lc3RhbXAgPSBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gICAgcmV0dXJuIG5leHRUaW1lc3RhbXBcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICAgIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAgICAgLS0gUmVwbGFjZSB0aGUgc2NvcmUgb2YgdGhlIG1hcmtlciB3aXRoIHRoZSBuZXdlc3Qga25vd25cbiAgICAgICAgLS0gbmV4dCB0aW1lc3RhbXAuXG4gICAgICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIG5leHRUaW1lc3RhbXAsIFwiMVwiKVxuICAgIGVuZFxuZW5kXG5sb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzddXG5sb2NhbCBoYXNKb2JzID0gcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMVxuLS1UT0RPOiBjaGVjayB0aGlzIGxvZ2ljIHRvIGJlIHJldXNlZCB3aGVuIGNoYW5naW5nIGEgZGVsYXlcbmlmIGhhc0pvYnMgdGhlbiByY2FsbChcIlJFTkFNRVwiLCBLRVlTWzFdLCBLRVlTWzJdKSBlbmRcbmlmIEFSR1ZbMV0gPT0gXCJwYXVzZWRcIiB0aGVuXG4gICAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbM10sIFwicGF1c2VkXCIsIDEpXG4gICAgcmNhbGwoXCJERUxcIiwgbWFya2VyS2V5KVxuZWxzZVxuICAgIHJjYWxsKFwiSERFTFwiLCBLRVlTWzNdLCBcInBhdXNlZFwiKVxuICAgIGlmIGhhc0pvYnMgb3IgcmNhbGwoXCJaQ0FSRFwiLCBLRVlTWzRdKSA+IDAgdGhlblxuICAgICAgICAtLSBBZGQgbWFya2VyIGlmIHRoZXJlIGFyZSB3YWl0aW5nIG9yIHByaW9yaXR5IGpvYnNcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gICAgZWxzZVxuICAgICAgICBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgS0VZU1s2XSlcbiAgICBlbmRcbmVuZFxucmNhbGwoXCJYQUREXCIsIEtFWVNbNV0sIFwiKlwiLCBcImV2ZW50XCIsIEFSR1ZbMV0pO1xuYDtcbmV4cG9ydCBjb25zdCBwYXVzZSA9IHtcbiAgICBuYW1lOiAncGF1c2UnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXVzZS03LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwicGF1c2UiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-8.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/promote-8.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   promote: () => (/* binding */ promote)\n/* harmony export */ });\nconst content = `--[[\n  Promotes a job that is currently \"delayed\" to the \"waiting\" state\n    Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'wait'\n      KEYS[3] 'paused'\n      KEYS[4] 'meta'\n      KEYS[5] 'prioritized'\n      KEYS[6] 'pc' priority counter\n      KEYS[7] 'event stream'\n      KEYS[8] 'marker'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  jobId\n    Output:\n       0 - OK\n      -3 - Job not in delayed zset.\n    Events:\n      'waiting'\n]]\nlocal rcall = redis.call\nlocal jobId = ARGV[2]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nif rcall(\"ZREM\", KEYS[1], jobId) == 1 then\n    local jobKey = ARGV[1] .. jobId\n    local priority = tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n    local metaKey = KEYS[4]\n    -- Remove delayed \"marker\" from the wait list if there is any.\n    -- Since we are adding a job we do not need the marker anymore.\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local target, paused = getTargetQueueList(metaKey, KEYS[2], KEYS[3])\n    local marker = rcall(\"LINDEX\", target, 0)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then rcall(\"LPOP\", target) end\n    if priority == 0 then\n        -- LIFO or FIFO\n        addJobInTargetList(target, KEYS[8], \"LPUSH\", paused, jobId)\n    else\n        addJobWithPriority(KEYS[8], KEYS[5], priority, jobId, KEYS[6], paused)\n    end\n    -- Emit waiting event (wait..ing@token)\n    rcall(\"XADD\", KEYS[7], \"*\", \"event\", \"waiting\", \"jobId\", jobId, \"prev\",\n          \"delayed\");\n    rcall(\"HSET\", jobKey, \"delay\", 0)\n    return 0\nelse\n    return -3\nend\n`;\nconst promote = {\n    name: \"promote\",\n    content,\n    keys: 8\n}; //# sourceMappingURL=promote-8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcHJvbW90ZS04LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUZqQixDQUFDO0FBQ00sTUFBTUMsVUFBVTtJQUNuQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcHJvbW90ZS04LmpzP2IwNjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFByb21vdGVzIGEgam9iIHRoYXQgaXMgY3VycmVudGx5IFwiZGVsYXllZFwiIHRvIHRoZSBcIndhaXRpbmdcIiBzdGF0ZVxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnZGVsYXllZCdcbiAgICAgIEtFWVNbMl0gJ3dhaXQnXG4gICAgICBLRVlTWzNdICdwYXVzZWQnXG4gICAgICBLRVlTWzRdICdtZXRhJ1xuICAgICAgS0VZU1s1XSAncHJpb3JpdGl6ZWQnXG4gICAgICBLRVlTWzZdICdwYycgcHJpb3JpdHkgY291bnRlclxuICAgICAgS0VZU1s3XSAnZXZlbnQgc3RyZWFtJ1xuICAgICAgS0VZU1s4XSAnbWFya2VyJ1xuICAgICAgQVJHVlsxXSAgcXVldWUudG9LZXkoJycpXG4gICAgICBBUkdWWzJdICBqb2JJZFxuICAgIE91dHB1dDpcbiAgICAgICAwIC0gT0tcbiAgICAgIC0zIC0gSm9iIG5vdCBpbiBkZWxheWVkIHpzZXQuXG4gICAgRXZlbnRzOlxuICAgICAgJ3dhaXRpbmcnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBqb2JJZCA9IEFSR1ZbMl1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBiaXQuYmFuZChwcmlvQ291bnRlciwgMHhmZmZmZmZmZmZmZmYpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG5pZiByY2FsbChcIlpSRU1cIiwgS0VZU1sxXSwgam9iSWQpID09IDEgdGhlblxuICAgIGxvY2FsIGpvYktleSA9IEFSR1ZbMV0gLi4gam9iSWRcbiAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgICBsb2NhbCBtZXRhS2V5ID0gS0VZU1s0XVxuICAgIC0tIFJlbW92ZSBkZWxheWVkIFwibWFya2VyXCIgZnJvbSB0aGUgd2FpdCBsaXN0IGlmIHRoZXJlIGlzIGFueS5cbiAgICAtLSBTaW5jZSB3ZSBhcmUgYWRkaW5nIGEgam9iIHdlIGRvIG5vdCBuZWVkIHRoZSBtYXJrZXIgYW55bW9yZS5cbiAgICAtLSBNYXJrZXJzIGluIHdhaXRsaXN0IERFUFJFQ0FURUQgaW4gdjU6IFJlbW92ZSBpbiB2Ni5cbiAgICBsb2NhbCB0YXJnZXQsIHBhdXNlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChtZXRhS2V5LCBLRVlTWzJdLCBLRVlTWzNdKVxuICAgIGxvY2FsIG1hcmtlciA9IHJjYWxsKFwiTElOREVYXCIsIHRhcmdldCwgMClcbiAgICBpZiBtYXJrZXIgYW5kIHN0cmluZy5zdWIobWFya2VyLCAxLCAyKSA9PSBcIjA6XCIgdGhlbiByY2FsbChcIkxQT1BcIiwgdGFyZ2V0KSBlbmRcbiAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIEtFWVNbOF0sIFwiTFBVU0hcIiwgcGF1c2VkLCBqb2JJZClcbiAgICBlbHNlXG4gICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShLRVlTWzhdLCBLRVlTWzVdLCBwcmlvcml0eSwgam9iSWQsIEtFWVNbNl0sIHBhdXNlZClcbiAgICBlbmRcbiAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnQgKHdhaXQuLmluZ0B0b2tlbilcbiAgICByY2FsbChcIlhBRERcIiwgS0VZU1s3XSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgam9iSWQsIFwicHJldlwiLFxuICAgICAgICAgIFwiZGVsYXllZFwiKTtcbiAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTNcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBwcm9tb3RlID0ge1xuICAgIG5hbWU6ICdwcm9tb3RlJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbW90ZS04LmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwicHJvbW90ZSIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   releaseLock: () => (/* binding */ releaseLock)\n/* harmony export */ });\nconst content = `--[[\n  Release lock\n    Input:\n      KEYS[1] 'lock',\n      ARGV[1]  token\n      ARGV[2]  lock duration in milliseconds\n    Output:\n      \"OK\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  return rcall(\"DEL\", KEYS[1])\nelse\n  return 0\nend\n`;\nconst releaseLock = {\n    name: \"releaseLock\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=releaseLock-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVsZWFzZUxvY2stMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFlakIsQ0FBQztBQUNNLE1BQU1DLGNBQWM7SUFDdkJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbGVhc2VMb2NrLTEuanM/NzVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVsZWFzZSBsb2NrXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdsb2NrJyxcbiAgICAgIEFSR1ZbMV0gIHRva2VuXG4gICAgICBBUkdWWzJdICBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgIE91dHB1dDpcbiAgICAgIFwiT0tcIiBpZiBsb2NrIGV4dGVudGVkIHN1Y2Nlc2Z1bGx5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJHRVRcIiwgS0VZU1sxXSkgPT0gQVJHVlsxXSB0aGVuXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBLRVlTWzFdKVxuZWxzZVxuICByZXR1cm4gMFxuZW5kXG5gO1xuZXhwb3J0IGNvbnN0IHJlbGVhc2VMb2NrID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlTG9jaycsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbGVhc2VMb2NrLTEuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJyZWxlYXNlTG9jayIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeChildDependency: () => (/* binding */ removeChildDependency)\n/* harmony export */ });\nconst content = `--[[\n  Break parent-child dependency by removing\n  child reference from parent\n  Input:\n    KEYS[1] 'key' prefix,\n    ARGV[1] job key\n    ARGV[2] parent key\n    Output:\n       0  - OK\n       1  - There is not relationship.\n      -1  - Missing job key\n      -5  - Missing parent key\n]]\nlocal rcall = redis.call\nlocal jobKey = ARGV[1]\nlocal parentKey = ARGV[2]\n-- Includes\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nif rcall(\"EXISTS\", jobKey) ~= 1 then return -1 end\nif rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\nif removeParentDependencyKey(jobKey, false, parentKey, KEYS[1]) then\n  rcall(\"HDEL\", jobKey, \"parentKey\", \"parent\")\n  return 0\nelse\n  return 1\nend`;\nconst removeChildDependency = {\n    name: \"removeChildDependency\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=removeChildDependency-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlQ2hpbGREZXBlbmRlbmN5LTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJJZCxDQUFDO0FBQ0csTUFBTUMsd0JBQXdCO0lBQ2pDQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0YsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9yZW1vdmVDaGlsZERlcGVuZGVuY3ktMS5qcz8yNTlhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBCcmVhayBwYXJlbnQtY2hpbGQgZGVwZW5kZW5jeSBieSByZW1vdmluZ1xuICBjaGlsZCByZWZlcmVuY2UgZnJvbSBwYXJlbnRcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAna2V5JyBwcmVmaXgsXG4gICAgQVJHVlsxXSBqb2Iga2V5XG4gICAgQVJHVlsyXSBwYXJlbnQga2V5XG4gICAgT3V0cHV0OlxuICAgICAgIDAgIC0gT0tcbiAgICAgICAxICAtIFRoZXJlIGlzIG5vdCByZWxhdGlvbnNoaXAuXG4gICAgICAtMSAgLSBNaXNzaW5nIGpvYiBrZXlcbiAgICAgIC01ICAtIE1pc3NpbmcgcGFyZW50IGtleVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgam9iS2V5ID0gQVJHVlsxXVxubG9jYWwgcGFyZW50S2V5ID0gQVJHVlsyXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQ2hlY2sgaWYgdGhpcyBqb2IgaGFzIGEgcGFyZW50LiBJZiBzbyB3ZSB3aWxsIGp1c3QgcmVtb3ZlIGl0IGZyb21cbiAgdGhlIHBhcmVudCBjaGlsZCBsaXN0LCBidXQgaWYgaXQgaXMgdGhlIGxhc3QgY2hpbGQgd2Ugc2hvdWxkIG1vdmUgdGhlIHBhcmVudCB0byBcIndhaXQvcGF1c2VkXCJcbiAgd2hpY2ggcmVxdWlyZXMgY29kZSBmcm9tIFwibW92ZVRvRmluaXNoZWRcIlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLFxuICAgIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudFByZWZpeCAuLiBcIm1ldGFcIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdFwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXkpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgbWlzc2VkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5pZiByY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkpIH49IDEgdGhlbiByZXR1cm4gLTEgZW5kXG5pZiByY2FsbChcIkVYSVNUU1wiLCBwYXJlbnRLZXkpIH49IDEgdGhlbiByZXR1cm4gLTUgZW5kXG5pZiByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgZmFsc2UsIHBhcmVudEtleSwgS0VZU1sxXSkgdGhlblxuICByY2FsbChcIkhERUxcIiwgam9iS2V5LCBcInBhcmVudEtleVwiLCBcInBhcmVudFwiKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gMVxuZW5kYDtcbmV4cG9ydCBjb25zdCByZW1vdmVDaGlsZERlcGVuZGVuY3kgPSB7XG4gICAgbmFtZTogJ3JlbW92ZUNoaWxkRGVwZW5kZW5jeScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZUNoaWxkRGVwZW5kZW5jeS0xLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwicmVtb3ZlQ2hpbGREZXBlbmRlbmN5IiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-1.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeJob-1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeJob: () => (/* binding */ removeJob)\n/* harmony export */ });\nconst content = `--[[\n    Remove a job from all the queues it may be in as well as all its data.\n    In order to be able to remove a job, it cannot be active.\n    Input:\n      KEYS[1] queue prefix\n      ARGV[1] jobId\n      ARGV[2] remove children\n    Events:\n      'removed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to recursively check if there are no locks\n  on the jobs to be removed.\n  returns:\n    boolean\n]]\nlocal function isLocked( prefix, jobId, removeChildren)\n  local jobKey = prefix .. jobId;\n  -- Check if this job is locked\n  local lockKey = jobKey .. ':lock'\n  local lock = rcall(\"GET\", lockKey)\n  if not lock then\n    if removeChildren == \"1\" then\n      local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n      if (#dependencies > 0) then\n        for i, childJobKey in ipairs(dependencies) do\n          -- We need to get the jobId for this job.\n          local childJobId = getJobIdFromKey(childJobKey)\n          local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n          local result = isLocked( childJobPrefix, childJobId, removeChildren )\n          if result then\n            return true\n          end\n        end\n      end\n    end\n    return false\n  end\n  return true\nend\n--[[\n  Function to remove from any state.\n  returns:\n    prev state\n]]\nlocal function removeJobFromAnyState( prefix, jobId)\n  -- We start with the ZSCORE checks, since they have O(1) complexity\n  if rcall(\"ZSCORE\", prefix .. \"completed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"completed\", jobId)\n    return \"completed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"waiting-children\", jobId) then\n    rcall(\"ZREM\", prefix .. \"waiting-children\", jobId)\n    return \"waiting-children\"\n  elseif rcall(\"ZSCORE\", prefix .. \"delayed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"delayed\", jobId)\n    return \"delayed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"failed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"failed\", jobId)\n    return \"failed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"prioritized\", jobId) then\n    rcall(\"ZREM\", prefix .. \"prioritized\", jobId)\n    return \"prioritized\"\n  -- We remove only 1 element from the list, since we assume they are not added multiple times\n  elseif rcall(\"LREM\", prefix .. \"wait\", 1, jobId) == 1 then\n    return \"wait\"\n  elseif rcall(\"LREM\", prefix .. \"paused\", 1, jobId) == 1 then\n    return \"paused\"\n  elseif rcall(\"LREM\", prefix .. \"active\", 1, jobId) == 1 then\n    return \"active\"\n  end\n  return \"unknown\"\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs',\n    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPaused = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"wait\",\n    parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPaused, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey)\n              removeJobKeys(parentKey)\n            else\n              moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local missedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey)\n                removeJobKeys(missedParentKey)\n              else\n                moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob( prefix, jobId, parentKey, removeChildren)\n    local jobKey = prefix .. jobId;\n    removeParentDependencyKey(jobKey, false, parentKey)\n    if removeChildren == \"1\" then\n        -- Check if this job has children\n        -- If so, we are going to try to remove the children recursively in deep first way because\n        -- if some job is locked we must exit with and error.\n        --local countProcessed = rcall(\"HLEN\", jobKey .. \":processed\")\n        local processed = rcall(\"HGETALL\", jobKey .. \":processed\")\n        if (#processed > 0) then\n            for i = 1, #processed, 2 do\n                local childJobId = getJobIdFromKey(processed[i])\n                local childJobPrefix = getJobKeyPrefix(processed[i], childJobId)\n                removeJob( childJobPrefix, childJobId, jobKey, removeChildren )\n            end\n        end\n        local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n        if (#dependencies > 0) then\n            for i, childJobKey in ipairs(dependencies) do\n                -- We need to get the jobId for this job.\n                local childJobId = getJobIdFromKey(childJobKey)\n                local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n                removeJob( childJobPrefix, childJobId, jobKey, removeChildren )\n            end\n        end\n        local failed = rcall(\"HGETALL\", jobKey .. \":failed\")\n        if (#failed > 0) then\n            for i = 1, #failed, 2 do\n                local childJobId = getJobIdFromKey(failed[i])\n                local childJobPrefix = getJobKeyPrefix(failed[i], childJobId)\n                removeJob( childJobPrefix, childJobId, jobKey, removeChildren )\n            end\n        end\n    end\n    local prev = removeJobFromAnyState(prefix, jobId)\n    if removeJobKeys(jobKey) > 0 then\n        local maxEvents = getOrSetMaxEvents(prefix .. \"meta\")\n        rcall(\"XADD\", prefix .. \"events\", \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"removed\",\n            \"jobId\", jobId, \"prev\", prev)\n    end\nend\nlocal prefix = KEYS[1]\nif not isLocked(prefix, ARGV[1], ARGV[2]) then\n    removeJob(prefix, ARGV[1], nil, ARGV[2])\n    return 1\nend\nreturn 0\n`;\nconst removeJob = {\n    name: \"removeJob\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=removeJob-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlSm9iLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVQakIsQ0FBQztBQUNNLE1BQU1DLFlBQVk7SUFDckJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbW92ZUpvYi0xLmpzPzI4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gICAgUmVtb3ZlIGEgam9iIGZyb20gYWxsIHRoZSBxdWV1ZXMgaXQgbWF5IGJlIGluIGFzIHdlbGwgYXMgYWxsIGl0cyBkYXRhLlxuICAgIEluIG9yZGVyIHRvIGJlIGFibGUgdG8gcmVtb3ZlIGEgam9iLCBpdCBjYW5ub3QgYmUgYWN0aXZlLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSBxdWV1ZSBwcmVmaXhcbiAgICAgIEFSR1ZbMV0gam9iSWRcbiAgICAgIEFSR1ZbMl0gcmVtb3ZlIGNoaWxkcmVuXG4gICAgRXZlbnRzOlxuICAgICAgJ3JlbW92ZWQnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gZGVzdHJ1Y3R1cmUgam9iIGtleS5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCB0aGVzZSBmdW5jdGlvbnMgbWF5IGJlIGEgYml0IHNsb3cgYW5kIGFmZmVjdCBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuXV1cbmxvY2FsIGdldEpvYklkRnJvbUtleSA9IGZ1bmN0aW9uIChqb2JLZXkpXG4gIHJldHVybiBzdHJpbmcubWF0Y2goam9iS2V5LCBcIi4qOiguKilcIilcbmVuZFxubG9jYWwgZ2V0Sm9iS2V5UHJlZml4ID0gZnVuY3Rpb24gKGpvYktleSwgam9iSWQpXG4gIHJldHVybiBzdHJpbmcuc3ViKGpvYktleSwgMCwgI2pvYktleSAtICNqb2JJZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVjdXJzaXZlbHkgY2hlY2sgaWYgdGhlcmUgYXJlIG5vIGxvY2tzXG4gIG9uIHRoZSBqb2JzIHRvIGJlIHJlbW92ZWQuXG4gIHJldHVybnM6XG4gICAgYm9vbGVhblxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzTG9ja2VkKCBwcmVmaXgsIGpvYklkLCByZW1vdmVDaGlsZHJlbilcbiAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkO1xuICAtLSBDaGVjayBpZiB0aGlzIGpvYiBpcyBsb2NrZWRcbiAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gIGxvY2FsIGxvY2sgPSByY2FsbChcIkdFVFwiLCBsb2NrS2V5KVxuICBpZiBub3QgbG9jayB0aGVuXG4gICAgaWYgcmVtb3ZlQ2hpbGRyZW4gPT0gXCIxXCIgdGhlblxuICAgICAgbG9jYWwgZGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTTUVNQkVSU1wiLCBqb2JLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCIpXG4gICAgICBpZiAoI2RlcGVuZGVuY2llcyA+IDApIHRoZW5cbiAgICAgICAgZm9yIGksIGNoaWxkSm9iS2V5IGluIGlwYWlycyhkZXBlbmRlbmNpZXMpIGRvXG4gICAgICAgICAgLS0gV2UgbmVlZCB0byBnZXQgdGhlIGpvYklkIGZvciB0aGlzIGpvYi5cbiAgICAgICAgICBsb2NhbCBjaGlsZEpvYklkID0gZ2V0Sm9iSWRGcm9tS2V5KGNoaWxkSm9iS2V5KVxuICAgICAgICAgIGxvY2FsIGNoaWxkSm9iUHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KGNoaWxkSm9iS2V5LCBjaGlsZEpvYklkKVxuICAgICAgICAgIGxvY2FsIHJlc3VsdCA9IGlzTG9ja2VkKCBjaGlsZEpvYlByZWZpeCwgY2hpbGRKb2JJZCwgcmVtb3ZlQ2hpbGRyZW4gKVxuICAgICAgICAgIGlmIHJlc3VsdCB0aGVuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIHJldHVybiBmYWxzZVxuICBlbmRcbiAgcmV0dXJuIHRydWVcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZnJvbSBhbnkgc3RhdGUuXG4gIHJldHVybnM6XG4gICAgcHJldiBzdGF0ZVxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYkZyb21BbnlTdGF0ZSggcHJlZml4LCBqb2JJZClcbiAgLS0gV2Ugc3RhcnQgd2l0aCB0aGUgWlNDT1JFIGNoZWNrcywgc2luY2UgdGhleSBoYXZlIE8oMSkgY29tcGxleGl0eVxuICBpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJjb21wbGV0ZWRcIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwiY29tcGxldGVkXCIsIGpvYklkKVxuICAgIHJldHVybiBcImNvbXBsZXRlZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIGpvYklkKSB0aGVuXG4gICAgcmNhbGwoXCJaUkVNXCIsIHByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgam9iSWQpXG4gICAgcmV0dXJuIFwid2FpdGluZy1jaGlsZHJlblwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJkZWxheWVkXCIsIGpvYklkKSB0aGVuXG4gICAgcmNhbGwoXCJaUkVNXCIsIHByZWZpeCAuLiBcImRlbGF5ZWRcIiwgam9iSWQpXG4gICAgcmV0dXJuIFwiZGVsYXllZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJmYWlsZWRcIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwiZmFpbGVkXCIsIGpvYklkKVxuICAgIHJldHVybiBcImZhaWxlZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJwcmlvcml0aXplZFwiLCBqb2JJZCkgdGhlblxuICAgIHJjYWxsKFwiWlJFTVwiLCBwcmVmaXggLi4gXCJwcmlvcml0aXplZFwiLCBqb2JJZClcbiAgICByZXR1cm4gXCJwcmlvcml0aXplZFwiXG4gIC0tIFdlIHJlbW92ZSBvbmx5IDEgZWxlbWVudCBmcm9tIHRoZSBsaXN0LCBzaW5jZSB3ZSBhc3N1bWUgdGhleSBhcmUgbm90IGFkZGVkIG11bHRpcGxlIHRpbWVzXG4gIGVsc2VpZiByY2FsbChcIkxSRU1cIiwgcHJlZml4IC4uIFwid2FpdFwiLCAxLCBqb2JJZCkgPT0gMSB0aGVuXG4gICAgcmV0dXJuIFwid2FpdFwiXG4gIGVsc2VpZiByY2FsbChcIkxSRU1cIiwgcHJlZml4IC4uIFwicGF1c2VkXCIsIDEsIGpvYklkKSA9PSAxIHRoZW5cbiAgICByZXR1cm4gXCJwYXVzZWRcIlxuICBlbHNlaWYgcmNhbGwoXCJMUkVNXCIsIHByZWZpeCAuLiBcImFjdGl2ZVwiLCAxLCBqb2JJZCkgPT0gMSB0aGVuXG4gICAgcmV0dXJuIFwiYWN0aXZlXCJcbiAgZW5kXG4gIHJldHVybiBcInVua25vd25cIlxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsXG4gICAgam9iS2V5IC4uICc6ZGVwZW5kZW5jaWVzJywgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG4gIGlmIG5vdCBpc1BhdXNlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJIRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIikgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIGVtaXRFdmVudClcbiAgbG9jYWwgcGFyZW50VGFyZ2V0LCBpc1BhdXNlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIixcbiAgICBwYXJlbnRQcmVmaXggLi4gXCJwYXVzZWRcIilcbiAgYWRkSm9iSW5UYXJnZXRMaXN0KHBhcmVudFRhcmdldCwgcGFyZW50UHJlZml4IC4uIFwibWFya2VyXCIsIFwiUlBVU0hcIiwgaXNQYXVzZWQsIHBhcmVudElkKVxuICBpZiBlbWl0RXZlbnQgdGhlblxuICAgIGxvY2FsIHBhcmVudEV2ZW50U3RyZWFtID0gcGFyZW50UHJlZml4IC4uIFwiZXZlbnRzXCJcbiAgICByY2FsbChcIlhBRERcIiwgcGFyZW50RXZlbnRTdHJlYW0sIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgcGFyZW50S2V5LCBiYXNlS2V5KVxuICBpZiBwYXJlbnRLZXkgdGhlblxuICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KHBhcmVudEtleSlcbiAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KHBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgaWYgaGFyZCB0aGVuIC0tIHJlbW92ZSBwYXJlbnQgaW4gc2FtZSBxdWV1ZVxuICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KHBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKHBhcmVudEtleSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCB0cnVlKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbmRcbiAgZWxzZVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIpXG4gICAgaWYoICh0eXBlKG1pc3NlZFBhcmVudEtleSkgPT0gXCJzdHJpbmdcIikgYW5kIG1pc3NlZFBhcmVudEtleSB+PSBcIlwiXG4gICAgICBhbmQgKHJjYWxsKFwiRVhJU1RTXCIsIG1pc3NlZFBhcmVudEtleSkgPT0gMSkpIHRoZW5cbiAgICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IG1pc3NlZFBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KG1pc3NlZFBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgICAgaWYgaGFyZCB0aGVuXG4gICAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KG1pc3NlZFBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYktleXMobWlzc2VkUGFyZW50S2V5KVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCB0cnVlKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iKCBwcmVmaXgsIGpvYklkLCBwYXJlbnRLZXksIHJlbW92ZUNoaWxkcmVuKVxuICAgIGxvY2FsIGpvYktleSA9IHByZWZpeCAuLiBqb2JJZDtcbiAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgZmFsc2UsIHBhcmVudEtleSlcbiAgICBpZiByZW1vdmVDaGlsZHJlbiA9PSBcIjFcIiB0aGVuXG4gICAgICAgIC0tIENoZWNrIGlmIHRoaXMgam9iIGhhcyBjaGlsZHJlblxuICAgICAgICAtLSBJZiBzbywgd2UgYXJlIGdvaW5nIHRvIHRyeSB0byByZW1vdmUgdGhlIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IGluIGRlZXAgZmlyc3Qgd2F5IGJlY2F1c2VcbiAgICAgICAgLS0gaWYgc29tZSBqb2IgaXMgbG9ja2VkIHdlIG11c3QgZXhpdCB3aXRoIGFuZCBlcnJvci5cbiAgICAgICAgLS1sb2NhbCBjb3VudFByb2Nlc3NlZCA9IHJjYWxsKFwiSExFTlwiLCBqb2JLZXkgLi4gXCI6cHJvY2Vzc2VkXCIpXG4gICAgICAgIGxvY2FsIHByb2Nlc3NlZCA9IHJjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkgLi4gXCI6cHJvY2Vzc2VkXCIpXG4gICAgICAgIGlmICgjcHJvY2Vzc2VkID4gMCkgdGhlblxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjcHJvY2Vzc2VkLCAyIGRvXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JJZCA9IGdldEpvYklkRnJvbUtleShwcm9jZXNzZWRbaV0pXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocHJvY2Vzc2VkW2ldLCBjaGlsZEpvYklkKVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYiggY2hpbGRKb2JQcmVmaXgsIGNoaWxkSm9iSWQsIGpvYktleSwgcmVtb3ZlQ2hpbGRyZW4gKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBsb2NhbCBkZXBlbmRlbmNpZXMgPSByY2FsbChcIlNNRU1CRVJTXCIsIGpvYktleSAuLiBcIjpkZXBlbmRlbmNpZXNcIilcbiAgICAgICAgaWYgKCNkZXBlbmRlbmNpZXMgPiAwKSB0aGVuXG4gICAgICAgICAgICBmb3IgaSwgY2hpbGRKb2JLZXkgaW4gaXBhaXJzKGRlcGVuZGVuY2llcykgZG9cbiAgICAgICAgICAgICAgICAtLSBXZSBuZWVkIHRvIGdldCB0aGUgam9iSWQgZm9yIHRoaXMgam9iLlxuICAgICAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iSWQgPSBnZXRKb2JJZEZyb21LZXkoY2hpbGRKb2JLZXkpXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgoY2hpbGRKb2JLZXksIGNoaWxkSm9iSWQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iKCBjaGlsZEpvYlByZWZpeCwgY2hpbGRKb2JJZCwgam9iS2V5LCByZW1vdmVDaGlsZHJlbiApXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIGZhaWxlZCA9IHJjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkgLi4gXCI6ZmFpbGVkXCIpXG4gICAgICAgIGlmICgjZmFpbGVkID4gMCkgdGhlblxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjZmFpbGVkLCAyIGRvXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JJZCA9IGdldEpvYklkRnJvbUtleShmYWlsZWRbaV0pXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgoZmFpbGVkW2ldLCBjaGlsZEpvYklkKVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYiggY2hpbGRKb2JQcmVmaXgsIGNoaWxkSm9iSWQsIGpvYktleSwgcmVtb3ZlQ2hpbGRyZW4gKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIGxvY2FsIHByZXYgPSByZW1vdmVKb2JGcm9tQW55U3RhdGUocHJlZml4LCBqb2JJZClcbiAgICBpZiByZW1vdmVKb2JLZXlzKGpvYktleSkgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMocHJlZml4IC4uIFwibWV0YVwiKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgcHJlZml4IC4uIFwiZXZlbnRzXCIsIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLFxuICAgICAgICAgICAgXCJqb2JJZFwiLCBqb2JJZCwgXCJwcmV2XCIsIHByZXYpXG4gICAgZW5kXG5lbmRcbmxvY2FsIHByZWZpeCA9IEtFWVNbMV1cbmlmIG5vdCBpc0xvY2tlZChwcmVmaXgsIEFSR1ZbMV0sIEFSR1ZbMl0pIHRoZW5cbiAgICByZW1vdmVKb2IocHJlZml4LCBBUkdWWzFdLCBuaWwsIEFSR1ZbMl0pXG4gICAgcmV0dXJuIDFcbmVuZFxucmV0dXJuIDBcbmA7XG5leHBvcnQgY29uc3QgcmVtb3ZlSm9iID0ge1xuICAgIG5hbWU6ICdyZW1vdmVKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVKb2ItMS5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsInJlbW92ZUpvYiIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-2.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeRepeatable-2.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeRepeatable: () => (/* binding */ removeRepeatable)\n/* harmony export */ });\nconst content = `--[[\n  Removes a repeatable job\n  Input:\n    KEYS[1] repeat jobs key\n    KEYS[2] delayed jobs key\n    ARGV[1] repeat job id\n    ARGV[2] repeat job key\n    ARGV[3] queue key\n  Output:\n    0 - OK\n    1 - Missing repeat job\n  Events:\n    'removed'\n]]\nlocal rcall = redis.call\nlocal millis = rcall(\"ZSCORE\", KEYS[1], ARGV[2])\nif(millis) then\n  -- Delete next programmed job.\n  local repeatJobId = ARGV[1] .. millis\n  if(rcall(\"ZREM\", KEYS[2], repeatJobId) == 1) then\n    rcall(\"DEL\", ARGV[3] .. repeatJobId)\n    rcall(\"XADD\", ARGV[3] .. \"events\", \"*\", \"event\", \"removed\", \"jobId\", repeatJobId, \"prev\", \"delayed\");\n  end\nend\nif(rcall(\"ZREM\", KEYS[1], ARGV[2]) == 1) then\n  return 0\nend\nreturn 1\n`;\nconst removeRepeatable = {\n    name: \"removeRepeatable\",\n    content,\n    keys: 2\n}; //# sourceMappingURL=removeRepeatable-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlUmVwZWF0YWJsZS0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QmpCLENBQUM7QUFDTSxNQUFNQyxtQkFBbUI7SUFDNUJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbW92ZVJlcGVhdGFibGUtMi5qcz9jMTEzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZW1vdmVzIGEgcmVwZWF0YWJsZSBqb2JcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSByZXBlYXQgam9icyBrZXlcbiAgICBLRVlTWzJdIGRlbGF5ZWQgam9icyBrZXlcbiAgICBBUkdWWzFdIHJlcGVhdCBqb2IgaWRcbiAgICBBUkdWWzJdIHJlcGVhdCBqb2Iga2V5XG4gICAgQVJHVlszXSBxdWV1ZSBrZXlcbiAgT3V0cHV0OlxuICAgIDAgLSBPS1xuICAgIDEgLSBNaXNzaW5nIHJlcGVhdCBqb2JcbiAgRXZlbnRzOlxuICAgICdyZW1vdmVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgbWlsbGlzID0gcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1sxXSwgQVJHVlsyXSlcbmlmKG1pbGxpcykgdGhlblxuICAtLSBEZWxldGUgbmV4dCBwcm9ncmFtbWVkIGpvYi5cbiAgbG9jYWwgcmVwZWF0Sm9iSWQgPSBBUkdWWzFdIC4uIG1pbGxpc1xuICBpZihyY2FsbChcIlpSRU1cIiwgS0VZU1syXSwgcmVwZWF0Sm9iSWQpID09IDEpIHRoZW5cbiAgICByY2FsbChcIkRFTFwiLCBBUkdWWzNdIC4uIHJlcGVhdEpvYklkKVxuICAgIHJjYWxsKFwiWEFERFwiLCBBUkdWWzNdIC4uIFwiZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLCBcImpvYklkXCIsIHJlcGVhdEpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpO1xuICBlbmRcbmVuZFxuaWYocmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIEFSR1ZbMl0pID09IDEpIHRoZW5cbiAgcmV0dXJuIDBcbmVuZFxucmV0dXJuIDFcbmA7XG5leHBvcnQgY29uc3QgcmVtb3ZlUmVwZWF0YWJsZSA9IHtcbiAgICBuYW1lOiAncmVtb3ZlUmVwZWF0YWJsZScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZVJlcGVhdGFibGUtMi5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsInJlbW92ZVJlcGVhdGFibGUiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-7.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/reprocessJob-7.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reprocessJob: () => (/* binding */ reprocessJob)\n/* harmony export */ });\nconst content = `--[[\n  Attempts to reprocess a job\n  Input:\n    KEYS[1] job key\n    KEYS[2] events stream\n    KEYS[3] job state\n    KEYS[4] wait key\n    KEYS[5] meta\n    KEYS[6] paused key\n    KEYS[7] marker key\n    ARGV[1] job.id\n    ARGV[2] (job.opts.lifo ? 'R' : 'L') + 'PUSH'\n    ARGV[3] propVal - failedReason/returnvalue\n    ARGV[4] prev state - failed/completed\n  Output:\n     1 means the operation was a success\n    -1 means the job does not exist\n    -3 means the job was not found in the expected set.\n]]\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  local jobId = ARGV[1]\n  if (rcall(\"ZREM\", KEYS[3], jobId) == 1) then\n    rcall(\"HDEL\", KEYS[1], \"finishedOn\", \"processedOn\", ARGV[3])\n    local target, isPaused = getTargetQueueList(KEYS[5], KEYS[4], KEYS[6])\n    addJobInTargetList(target, KEYS[7], ARGV[2], isPaused, jobId)\n    local maxEvents = getOrSetMaxEvents(KEYS[5])\n    -- Emit waiting event\n    rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId, \"prev\", ARGV[4]);\n    return 1\n  else\n    return -3\n  end\nelse\n  return -1\nend\n`;\nconst reprocessJob = {\n    name: \"reprocessJob\",\n    content,\n    keys: 7\n}; //# sourceMappingURL=reprocessJob-7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVwcm9jZXNzSm9iLTcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRFakIsQ0FBQztBQUNNLE1BQU1DLGVBQWU7SUFDeEJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlcHJvY2Vzc0pvYi03LmpzPzA0MzAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEF0dGVtcHRzIHRvIHJlcHJvY2VzcyBhIGpvYlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGpvYiBrZXlcbiAgICBLRVlTWzJdIGV2ZW50cyBzdHJlYW1cbiAgICBLRVlTWzNdIGpvYiBzdGF0ZVxuICAgIEtFWVNbNF0gd2FpdCBrZXlcbiAgICBLRVlTWzVdIG1ldGFcbiAgICBLRVlTWzZdIHBhdXNlZCBrZXlcbiAgICBLRVlTWzddIG1hcmtlciBrZXlcbiAgICBBUkdWWzFdIGpvYi5pZFxuICAgIEFSR1ZbMl0gKGpvYi5vcHRzLmxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnXG4gICAgQVJHVlszXSBwcm9wVmFsIC0gZmFpbGVkUmVhc29uL3JldHVybnZhbHVlXG4gICAgQVJHVls0XSBwcmV2IHN0YXRlIC0gZmFpbGVkL2NvbXBsZXRlZFxuICBPdXRwdXQ6XG4gICAgIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAgLTEgbWVhbnMgdGhlIGpvYiBkb2VzIG5vdCBleGlzdFxuICAgIC0zIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbDtcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkKVxuICBpZiBub3QgaXNQYXVzZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICAgIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgICAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gICAgZW5kXG4gICAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEgdGhlblxuICBsb2NhbCBqb2JJZCA9IEFSR1ZbMV1cbiAgaWYgKHJjYWxsKFwiWlJFTVwiLCBLRVlTWzNdLCBqb2JJZCkgPT0gMSkgdGhlblxuICAgIHJjYWxsKFwiSERFTFwiLCBLRVlTWzFdLCBcImZpbmlzaGVkT25cIiwgXCJwcm9jZXNzZWRPblwiLCBBUkdWWzNdKVxuICAgIGxvY2FsIHRhcmdldCwgaXNQYXVzZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s1XSwgS0VZU1s0XSwgS0VZU1s2XSlcbiAgICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0LCBLRVlTWzddLCBBUkdWWzJdLCBpc1BhdXNlZCwgam9iSWQpXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMoS0VZU1s1XSlcbiAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICByY2FsbChcIlhBRERcIiwgS0VZU1syXSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsXG4gICAgICBcImpvYklkXCIsIGpvYklkLCBcInByZXZcIiwgQVJHVls0XSk7XG4gICAgcmV0dXJuIDFcbiAgZWxzZVxuICAgIHJldHVybiAtM1xuICBlbmRcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgcmVwcm9jZXNzSm9iID0ge1xuICAgIG5hbWU6ICdyZXByb2Nlc3NKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXByb2Nlc3NKb2ItNy5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsInJlcHJvY2Vzc0pvYiIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-10.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/retryJob-10.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   retryJob: () => (/* binding */ retryJob)\n/* harmony export */ });\nconst content = `--[[\n  Retries a failed job by moving it back to the wait queue.\n    Input:\n      KEYS[1]  'active',\n      KEYS[2]  'wait'\n      KEYS[3]  'paused'\n      KEYS[4]  job key\n      KEYS[5]  'meta'\n      KEYS[6]  events stream\n      KEYS[7]  delayed key\n      KEYS[8]  prioritized key\n      KEYS[9]  'pc' priority counter\n      KEYS[10] 'marker'\n      ARGV[1]  key prefix\n      ARGV[2]  timestamp\n      ARGV[3]  pushCmd\n      ARGV[4]  jobId\n      ARGV[5]  token\n    Events:\n      'waiting'\n    Output:\n     0  - OK\n     -1 - Missing key\n     -2 - Missing lock\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPaused)\n  if not isPaused then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey, isPaused)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  local score = priority * 0x100000000 + bit.band(prioCounter, 0xffffffffffff)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"HEXISTS\", queueMetaKey, \"paused\") ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPaused, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPaused)\nend\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                addJobInTargetList(targetKey, markerKey, \"LPUSH\", isPaused, jobId)\n            else\n                addJobWithPriority(markerKey, prioritizedKey, priority,\n                  jobId, priorityCounterKey, isPaused)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n    end\nend\nlocal target, paused = getTargetQueueList(KEYS[5], KEYS[2], KEYS[3])\nlocal markerKey = KEYS[10]\n-- Check if there are delayed jobs that we can move to wait.\n-- test example: when there are delayed jobs between retries\npromoteDelayedJobs(KEYS[7], markerKey, target, KEYS[8], KEYS[6], ARGV[1], ARGV[2], KEYS[9], paused)\nif rcall(\"EXISTS\", KEYS[4]) == 1 then\n  if ARGV[5] ~= \"0\" then\n    local lockKey = KEYS[4] .. ':lock'\n    if rcall(\"GET\", lockKey) == ARGV[5] then\n      rcall(\"DEL\", lockKey)\n    else\n      return -2\n    end\n  end\n  rcall(\"LREM\", KEYS[1], 0, ARGV[4])\n  local priority = tonumber(rcall(\"HGET\", KEYS[4], \"priority\")) or 0\n  -- Standard or priority add\n  if priority == 0 then\n    rcall(ARGV[3], target, ARGV[4])\n    -- TODO: check if we need to add marker in this case too\n  else\n    addJobWithPriority(markerKey, KEYS[8], priority, ARGV[4], KEYS[9], paused)\n  end\n  rcall(\"HINCRBY\", KEYS[4], \"atm\", 1)\n  local maxEvents = getOrSetMaxEvents(KEYS[5])\n  -- Emit waiting event\n  rcall(\"XADD\", KEYS[6], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n    \"jobId\", ARGV[4], \"prev\", \"failed\")\n  return 0\nelse\n  return -1\nend\n`;\nconst retryJob = {\n    name: \"retryJob\",\n    content,\n    keys: 10\n}; //# sourceMappingURL=retryJob-10.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmV0cnlKb2ItMTAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMElqQixDQUFDO0FBQ00sTUFBTUMsV0FBVztJQUNwQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmV0cnlKb2ItMTAuanM/ZmM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmV0cmllcyBhIGZhaWxlZCBqb2IgYnkgbW92aW5nIGl0IGJhY2sgdG8gdGhlIHdhaXQgcXVldWUuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICAnYWN0aXZlJyxcbiAgICAgIEtFWVNbMl0gICd3YWl0J1xuICAgICAgS0VZU1szXSAgJ3BhdXNlZCdcbiAgICAgIEtFWVNbNF0gIGpvYiBrZXlcbiAgICAgIEtFWVNbNV0gICdtZXRhJ1xuICAgICAgS0VZU1s2XSAgZXZlbnRzIHN0cmVhbVxuICAgICAgS0VZU1s3XSAgZGVsYXllZCBrZXlcbiAgICAgIEtFWVNbOF0gIHByaW9yaXRpemVkIGtleVxuICAgICAgS0VZU1s5XSAgJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgICBLRVlTWzEwXSAnbWFya2VyJ1xuICAgICAgQVJHVlsxXSAga2V5IHByZWZpeFxuICAgICAgQVJHVlsyXSAgdGltZXN0YW1wXG4gICAgICBBUkdWWzNdICBwdXNoQ21kXG4gICAgICBBUkdWWzRdICBqb2JJZFxuICAgICAgQVJHVls1XSAgdG9rZW5cbiAgICBFdmVudHM6XG4gICAgICAnd2FpdGluZydcbiAgICBPdXRwdXQ6XG4gICAgIDAgIC0gT0tcbiAgICAgLTEgLSBNaXNzaW5nIGtleVxuICAgICAtMiAtIE1pc3NpbmcgbG9ja1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgaWYgbm90IGlzUGF1c2VkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBiaXQuYmFuZChwcmlvQ291bnRlciwgMHhmZmZmZmZmZmZmZmYpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBVcGRhdGVzIHRoZSBkZWxheSBzZXQsIGJ5IG1vdmluZyBkZWxheWVkIGpvYnMgdGhhdCBzaG91bGRcbiAgYmUgcHJvY2Vzc2VkIG5vdyB0byBcIndhaXRcIi5cbiAgICAgRXZlbnRzOlxuICAgICAgJ3dhaXRpbmcnXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbmVuZFxuLS0gVHJ5IHRvIGdldCBhcyBtdWNoIGFzIDEwMDAgam9icyBhdCBvbmNlXG5sb2NhbCBmdW5jdGlvbiBwcm9tb3RlRGVsYXllZEpvYnMoZGVsYXllZEtleSwgbWFya2VyS2V5LCB0YXJnZXRLZXksIHByaW9yaXRpemVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RyZWFtS2V5LCBwcmVmaXgsIHRpbWVzdGFtcCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgICBsb2NhbCBqb2JzID0gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIGRlbGF5ZWRLZXksIDAsICh0aW1lc3RhbXAgKyAxKSAqIDB4MTAwMCwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuICAgIGlmICgjam9icyA+IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIHVucGFjayhqb2JzKSlcbiAgICAgICAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0eSA9XG4gICAgICAgICAgICAgICAgdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgICAgICAgICAgYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBcIkxQVVNIXCIsIGlzUGF1c2VkLCBqb2JJZClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50XG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRTdHJlYW1LZXksIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsXG4gICAgICAgICAgICAgICAgICBqb2JJZCwgXCJwcmV2XCIsIFwiZGVsYXllZFwiKVxuICAgICAgICAgICAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJkZWxheVwiLCAwKVxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxubG9jYWwgdGFyZ2V0LCBwYXVzZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s1XSwgS0VZU1syXSwgS0VZU1szXSlcbmxvY2FsIG1hcmtlcktleSA9IEtFWVNbMTBdXG4tLSBDaGVjayBpZiB0aGVyZSBhcmUgZGVsYXllZCBqb2JzIHRoYXQgd2UgY2FuIG1vdmUgdG8gd2FpdC5cbi0tIHRlc3QgZXhhbXBsZTogd2hlbiB0aGVyZSBhcmUgZGVsYXllZCBqb2JzIGJldHdlZW4gcmV0cmllc1xucHJvbW90ZURlbGF5ZWRKb2JzKEtFWVNbN10sIG1hcmtlcktleSwgdGFyZ2V0LCBLRVlTWzhdLCBLRVlTWzZdLCBBUkdWWzFdLCBBUkdWWzJdLCBLRVlTWzldLCBwYXVzZWQpXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzRdKSA9PSAxIHRoZW5cbiAgaWYgQVJHVls1XSB+PSBcIjBcIiB0aGVuXG4gICAgbG9jYWwgbG9ja0tleSA9IEtFWVNbNF0gLi4gJzpsb2NrJ1xuICAgIGlmIHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpID09IEFSR1ZbNV0gdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgbG9ja0tleSlcbiAgICBlbHNlXG4gICAgICByZXR1cm4gLTJcbiAgICBlbmRcbiAgZW5kXG4gIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAwLCBBUkdWWzRdKVxuICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKHJjYWxsKFwiSEdFVFwiLCBLRVlTWzRdLCBcInByaW9yaXR5XCIpKSBvciAwXG4gIC0tIFN0YW5kYXJkIG9yIHByaW9yaXR5IGFkZFxuICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICByY2FsbChBUkdWWzNdLCB0YXJnZXQsIEFSR1ZbNF0pXG4gICAgLS0gVE9ETzogY2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgbWFya2VyIGluIHRoaXMgY2FzZSB0b29cbiAgZWxzZVxuICAgIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIEtFWVNbOF0sIHByaW9yaXR5LCBBUkdWWzRdLCBLRVlTWzldLCBwYXVzZWQpXG4gIGVuZFxuICByY2FsbChcIkhJTkNSQllcIiwgS0VZU1s0XSwgXCJhdG1cIiwgMSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMoS0VZU1s1XSlcbiAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50XG4gIHJjYWxsKFwiWEFERFwiLCBLRVlTWzZdLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIixcbiAgICBcImpvYklkXCIsIEFSR1ZbNF0sIFwicHJldlwiLCBcImZhaWxlZFwiKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCByZXRyeUpvYiA9IHtcbiAgICBuYW1lOiAncmV0cnlKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMTAsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlKb2ItMTAuanMubWFwIl0sIm5hbWVzIjpbImNvbnRlbnQiLCJyZXRyeUpvYiIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-10.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   saveStacktrace: () => (/* binding */ saveStacktrace)\n/* harmony export */ });\nconst content = `--[[\n  Save stacktrace and failedReason.\n  Input:\n    KEYS[1] job key\n    ARGV[1]  stacktrace\n    ARGV[2]  failedReason\n  Output:\n     0 - OK\n    -1 - Missing key\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"HMSET\", KEYS[1], \"stacktrace\", ARGV[1], \"failedReason\", ARGV[2])\n  return 0\nelse\n  return -1\nend\n`;\nconst saveStacktrace = {\n    name: \"saveStacktrace\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=saveStacktrace-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvc2F2ZVN0YWNrdHJhY2UtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCakIsQ0FBQztBQUNNLE1BQU1DLGlCQUFpQjtJQUMxQkMsTUFBTTtJQUNORjtJQUNBRyxNQUFNO0FBQ1YsRUFBRSxDQUNGLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvc2F2ZVN0YWNrdHJhY2UtMS5qcz83ZWFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBTYXZlIHN0YWNrdHJhY2UgYW5kIGZhaWxlZFJlYXNvbi5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2Iga2V5XG4gICAgQVJHVlsxXSAgc3RhY2t0cmFjZVxuICAgIEFSR1ZbMl0gIGZhaWxlZFJlYXNvblxuICBPdXRwdXQ6XG4gICAgIDAgLSBPS1xuICAgIC0xIC0gTWlzc2luZyBrZXlcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEgdGhlblxuICByY2FsbChcIkhNU0VUXCIsIEtFWVNbMV0sIFwic3RhY2t0cmFjZVwiLCBBUkdWWzFdLCBcImZhaWxlZFJlYXNvblwiLCBBUkdWWzJdKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBzYXZlU3RhY2t0cmFjZSA9IHtcbiAgICBuYW1lOiAnc2F2ZVN0YWNrdHJhY2UnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYXZlU3RhY2t0cmFjZS0xLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50Iiwic2F2ZVN0YWNrdHJhY2UiLCJuYW1lIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateData-1.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateData: () => (/* binding */ updateData)\n/* harmony export */ });\nconst content = `--[[\n  Update job data\n  Input:\n    KEYS[1] Job id key\n    ARGV[1] data\n  Output:\n    0 - OK\n   -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\",KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"data\", ARGV[1])\n  return 0\nelse\n  return -1\nend\n`;\nconst updateData = {\n    name: \"updateData\",\n    content,\n    keys: 1\n}; //# sourceMappingURL=updateData-1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlRGF0YS0xLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQmpCLENBQUM7QUFDTSxNQUFNQyxhQUFhO0lBQ3RCQyxNQUFNO0lBQ05GO0lBQ0FHLE1BQU07QUFDVixFQUFFLENBQ0Ysd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy91cGRhdGVEYXRhLTEuanM/ODdmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBkYXRhXG4gIElucHV0OlxuICAgIEtFWVNbMV0gSm9iIGlkIGtleVxuICAgIEFSR1ZbMV0gZGF0YVxuICBPdXRwdXQ6XG4gICAgMCAtIE9LXG4gICAtMSAtIE1pc3Npbmcgam9iLlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIixLRVlTWzFdKSA9PSAxIHRoZW4gLS0gLy8gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwiZGF0YVwiLCBBUkdWWzFdKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCB1cGRhdGVEYXRhID0ge1xuICAgIG5hbWU6ICd1cGRhdGVEYXRhJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlRGF0YS0xLmpzLm1hcCJdLCJuYW1lcyI6WyJjb250ZW50IiwidXBkYXRlRGF0YSIsIm5hbWUiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateProgress: () => (/* binding */ updateProgress)\n/* harmony export */ });\nconst content = `--[[\n  Update job progress\n  Input:\n    KEYS[1] Job id key\n    KEYS[2] event stream key\n    KEYS[3] meta key\n    ARGV[1] id\n    ARGV[2] progress\n  Output:\n     0 - OK\n    -1 - Missing job.\n  Event:\n    progress(jobId, progress)\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n    local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n    if not maxEvents then\n        maxEvents = 10000\n        rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n    end\n    return maxEvents\nend\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n    local maxEvents = getOrSetMaxEvents(KEYS[3])\n    rcall(\"HSET\", KEYS[1], \"progress\", ARGV[2])\n    rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"progress\",\n          \"jobId\", ARGV[1], \"data\", ARGV[2]);\n    return 0\nelse\n    return -1\nend\n`;\nconst updateProgress = {\n    name: \"updateProgress\",\n    content,\n    keys: 3\n}; //# sourceMappingURL=updateProgress-3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlUHJvZ3Jlc3MtMy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ2pCLENBQUM7QUFDTSxNQUFNQyxpQkFBaUI7SUFDMUJDLE1BQU07SUFDTkY7SUFDQUcsTUFBTTtBQUNWLEVBQUUsQ0FDRiw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3VwZGF0ZVByb2dyZXNzLTMuanM/NjlmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBwcm9ncmVzc1xuICBJbnB1dDpcbiAgICBLRVlTWzFdIEpvYiBpZCBrZXlcbiAgICBLRVlTWzJdIGV2ZW50IHN0cmVhbSBrZXlcbiAgICBLRVlTWzNdIG1ldGEga2V5XG4gICAgQVJHVlsxXSBpZFxuICAgIEFSR1ZbMl0gcHJvZ3Jlc3NcbiAgT3V0cHV0OlxuICAgICAwIC0gT0tcbiAgICAtMSAtIE1pc3Npbmcgam9iLlxuICBFdmVudDpcbiAgICBwcm9ncmVzcyhqb2JJZCwgcHJvZ3Jlc3MpXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gICAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgICBlbmRcbiAgICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEgdGhlbiAtLSAvLyBNYWtlIHN1cmUgam9iIGV4aXN0c1xuICAgIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKEtFWVNbM10pXG4gICAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwicHJvZ3Jlc3NcIiwgQVJHVlsyXSlcbiAgICByY2FsbChcIlhBRERcIiwgS0VZU1syXSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJwcm9ncmVzc1wiLFxuICAgICAgICAgIFwiam9iSWRcIiwgQVJHVlsxXSwgXCJkYXRhXCIsIEFSR1ZbMl0pO1xuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgdXBkYXRlUHJvZ3Jlc3MgPSB7XG4gICAgbmFtZTogJ3VwZGF0ZVByb2dyZXNzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlUHJvZ3Jlc3MtMy5qcy5tYXAiXSwibmFtZXMiOlsiY29udGVudCIsInVwZGF0ZVByb2dyZXNzIiwibmFtZSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/backoff-strategy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=backoff-strategy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2JhY2tvZmYtc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdHlwZXMvYmFja29mZi1zdHJhdGVneS5qcz9mNWRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtc3RyYXRlZ3kuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/finished-status.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=finished-status.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2ZpbmlzaGVkLXN0YXR1cy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDViwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS90eXBlcy9maW5pc2hlZC1zdGF0dXMuanM/ZTBjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5pc2hlZC1zdGF0dXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _backoff_strategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backoff-strategy */ \"(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js\");\n/* harmony import */ var _finished_status__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./finished-status */ \"(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js\");\n/* harmony import */ var _minimal_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minimal-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/types/minimal-queue.js\");\n/* harmony import */ var _job_json_sandbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job-json-sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js\");\n/* harmony import */ var _job_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./job-options */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js\");\n/* harmony import */ var _job_type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./job-type */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js\");\n/* harmony import */ var _repeat_strategy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./repeat-strategy */ \"(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js\");\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ0Q7QUFDRjtBQUNHO0FBQ0w7QUFDSDtBQUNPLENBQ2xDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2luZGV4LmpzP2FhNzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9iYWNrb2ZmLXN0cmF0ZWd5JztcbmV4cG9ydCAqIGZyb20gJy4vZmluaXNoZWQtc3RhdHVzJztcbmV4cG9ydCAqIGZyb20gJy4vbWluaW1hbC1xdWV1ZSc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi1qc29uLXNhbmRib3gnO1xuZXhwb3J0ICogZnJvbSAnLi9qb2Itb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi10eXBlJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwZWF0LXN0cmF0ZWd5Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-json-sandbox.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=job-json-sandbox.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1qc29uLXNhbmRib3guanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdHlwZXMvam9iLWpzb24tc2FuZGJveC5qcz9kYTI0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi1qc29uLXNhbmRib3guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-options.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=job-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1vcHRpb25zLmpzPzhkN2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-type.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=job-type.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi10eXBlLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi10eXBlLmpzP2VmNmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLXR5cGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/minimal-queue.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/minimal-queue.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=minimal-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL21pbmltYWwtcXVldWUuanMiLCJtYXBwaW5ncyI6IjtBQUFVLENBQ1YseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdHlwZXMvbWluaW1hbC1xdWV1ZS5qcz9mMDlmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbmltYWwtcXVldWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/minimal-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/repeat-strategy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=repeat-strategy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL3JlcGVhdC1zdHJhdGVneS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDViwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS90eXBlcy9yZXBlYXQtc3RyYXRlZ3kuanM/OGU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQtc3RyYXRlZ3kuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/bullmq/dist/esm/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELAY_TIME_1: () => (/* binding */ DELAY_TIME_1),\n/* harmony export */   DELAY_TIME_5: () => (/* binding */ DELAY_TIME_5),\n/* harmony export */   QUEUE_EVENT_SUFFIX: () => (/* binding */ QUEUE_EVENT_SUFFIX),\n/* harmony export */   array2obj: () => (/* binding */ array2obj),\n/* harmony export */   asyncSend: () => (/* binding */ asyncSend),\n/* harmony export */   childSend: () => (/* binding */ childSend),\n/* harmony export */   clientCommandMessageReg: () => (/* binding */ clientCommandMessageReg),\n/* harmony export */   decreaseMaxListeners: () => (/* binding */ decreaseMaxListeners),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   errorObject: () => (/* binding */ errorObject),\n/* harmony export */   errorToJSON: () => (/* binding */ errorToJSON),\n/* harmony export */   getParentKey: () => (/* binding */ getParentKey),\n/* harmony export */   increaseMaxListeners: () => (/* binding */ increaseMaxListeners),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isNotConnectionError: () => (/* binding */ isNotConnectionError),\n/* harmony export */   isRedisCluster: () => (/* binding */ isRedisCluster),\n/* harmony export */   isRedisInstance: () => (/* binding */ isRedisInstance),\n/* harmony export */   isRedisVersionLowerThan: () => (/* binding */ isRedisVersionLowerThan),\n/* harmony export */   lengthInUtf8Bytes: () => (/* binding */ lengthInUtf8Bytes),\n/* harmony export */   parseObjectValues: () => (/* binding */ parseObjectValues),\n/* harmony export */   removeAllQueueData: () => (/* binding */ removeAllQueueData),\n/* harmony export */   tryCatch: () => (/* binding */ tryCatch)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"(rsc)/./node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ioredis_built_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ioredis/built/utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst errorObject = {\n    value: null\n};\nfunction tryCatch(fn, ctx, args) {\n    try {\n        return fn.apply(ctx, args);\n    } catch (e) {\n        errorObject.value = e;\n        return errorObject;\n    }\n}\n/**\n * Checks the size of string for ascii/non-ascii characters\n * @see https://stackoverflow.com/a/23318053/1347170\n * @param str -\n */ function lengthInUtf8Bytes(str) {\n    return Buffer.byteLength(str, \"utf8\");\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction array2obj(arr) {\n    const obj = {};\n    for(let i = 0; i < arr.length; i += 2){\n        obj[arr[i]] = arr[i + 1];\n    }\n    return obj;\n}\nfunction delay(ms, abortController) {\n    return new Promise((resolve)=>{\n        let timeout;\n        const callback = ()=>{\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", callback);\n            clearTimeout(timeout);\n            resolve();\n        };\n        timeout = setTimeout(callback, ms);\n        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", callback);\n    });\n}\nfunction isRedisInstance(obj) {\n    if (!obj) {\n        return false;\n    }\n    const redisApi = [\n        \"connect\",\n        \"disconnect\",\n        \"duplicate\"\n    ];\n    return redisApi.every((name)=>typeof obj[name] === \"function\");\n}\nfunction isRedisCluster(obj) {\n    return isRedisInstance(obj) && obj.isCluster;\n}\nfunction increaseMaxListeners(emitter, count) {\n    const maxListeners = emitter.getMaxListeners();\n    emitter.setMaxListeners(maxListeners + count);\n}\nfunction decreaseMaxListeners(emitter, count) {\n    increaseMaxListeners(emitter, -count);\n}\nasync function removeAllQueueData(client, queueName, prefix = process.env.BULLMQ_TEST_PREFIX || \"bull\") {\n    if (client instanceof ioredis__WEBPACK_IMPORTED_MODULE_0__.Cluster) {\n        // todo compat with cluster ?\n        // @see https://github.com/luin/ioredis/issues/175\n        return Promise.resolve(false);\n    }\n    const pattern = `${prefix}:${queueName}:*`;\n    const removing = await new Promise((resolve, reject)=>{\n        const stream = client.scanStream({\n            match: pattern\n        });\n        stream.on(\"data\", (keys)=>{\n            if (keys.length) {\n                const pipeline = client.pipeline();\n                keys.forEach((key)=>{\n                    pipeline.del(key);\n                });\n                pipeline.exec().catch((error)=>{\n                    reject(error);\n                });\n            }\n        });\n        stream.on(\"end\", ()=>resolve());\n        stream.on(\"error\", (error)=>reject(error));\n    });\n    await removing;\n    await client.quit();\n}\nfunction getParentKey(opts) {\n    if (opts) {\n        return `${opts.queue}:${opts.id}`;\n    }\n}\nconst clientCommandMessageReg = /ERR unknown command ['`]\\s*client\\s*['`]/;\nconst DELAY_TIME_5 = 5000;\nconst DELAY_TIME_1 = 100;\nfunction isNotConnectionError(error) {\n    const errorMessage = `${error.message}`;\n    return errorMessage !== ioredis_built_utils__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_CLOSED_ERROR_MSG && !errorMessage.includes(\"ECONNREFUSED\");\n}\nconst asyncSend = (proc, msg)=>{\n    return new Promise((resolve, reject)=>{\n        if (typeof proc.send === \"function\") {\n            proc.send(msg, (err)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        } else if (typeof proc.postMessage === \"function\") {\n            resolve(proc.postMessage(msg));\n        } else {\n            resolve();\n        }\n    });\n};\nconst childSend = (proc, msg)=>asyncSend(proc, msg);\nconst isRedisVersionLowerThan = (currentVersion, minimumVersion)=>{\n    const version = semver__WEBPACK_IMPORTED_MODULE_2__.valid(semver__WEBPACK_IMPORTED_MODULE_2__.coerce(currentVersion));\n    return semver__WEBPACK_IMPORTED_MODULE_2__.lt(version, minimumVersion);\n};\nconst parseObjectValues = (obj)=>{\n    const accumulator = {};\n    for (const value of Object.entries(obj)){\n        accumulator[value[0]] = JSON.parse(value[1]);\n    }\n    return accumulator;\n};\nconst errorToJSON = (value)=>{\n    const error = {};\n    Object.getOwnPropertyNames(value).forEach(function(propName) {\n        error[propName] = value[propName];\n    });\n    return error;\n};\nconst QUEUE_EVENT_SUFFIX = \":qe\"; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNsQyw2REFBNkQ7QUFDN0QsYUFBYTtBQUNxRDtBQUNqQztBQUMxQixNQUFNRyxjQUFjO0lBQUVDLE9BQU87QUFBSyxFQUFFO0FBQ3BDLFNBQVNDLFNBQVNDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxJQUFJO0lBQ2xDLElBQUk7UUFDQSxPQUFPRixHQUFHRyxLQUFLLENBQUNGLEtBQUtDO0lBQ3pCLEVBQ0EsT0FBT0UsR0FBRztRQUNOUCxZQUFZQyxLQUFLLEdBQUdNO1FBQ3BCLE9BQU9QO0lBQ1g7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTUSxrQkFBa0JDLEdBQUc7SUFDakMsT0FBT0MsT0FBT0MsVUFBVSxDQUFDRixLQUFLO0FBQ2xDO0FBQ08sU0FBU0csUUFBUUMsR0FBRztJQUN2QixJQUFLLE1BQU1DLE9BQU9ELElBQUs7UUFDbkIsSUFBSUUsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsS0FBS0MsTUFBTTtZQUNoRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNPLFNBQVNLLFVBQVVDLEdBQUc7SUFDekIsTUFBTVAsTUFBTSxDQUFDO0lBQ2IsSUFBSyxJQUFJUSxJQUFJLEdBQUdBLElBQUlELElBQUlFLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3BDUixHQUFHLENBQUNPLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDLEdBQUdELEdBQUcsQ0FBQ0MsSUFBSSxFQUFFO0lBQzVCO0lBQ0EsT0FBT1I7QUFDWDtBQUNPLFNBQVNVLE1BQU1DLEVBQUUsRUFBRUMsZUFBZTtJQUNyQyxPQUFPLElBQUlDLFFBQVFDLENBQUFBO1FBQ2YsSUFBSUM7UUFDSixNQUFNQyxXQUFXO1lBQ2JKLG9CQUFvQixRQUFRQSxvQkFBb0IsS0FBSyxJQUFJLEtBQUssSUFBSUEs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O1lBQ0o7UUFDSixPQUNLLElBQUksT0FBT3VELEtBQUtJLFdBQVcsS0FBSyxZQUFZO1lBQzdDM0QsUUFBUXVELEtBQUtJLFdBQVcsQ0FBQ0g7UUFDN0IsT0FDSztZQUNEeEQ7UUFDSjtJQUNKO0FBQ0osRUFBRTtBQUNLLE1BQU00RCxZQUFZLENBQUNMLE1BQU1DLE1BQVFGLFVBQVVDLE1BQU1DLEtBQUs7QUFDdEQsTUFBTUssMEJBQTBCLENBQUNDLGdCQUFnQkM7SUFDcEQsTUFBTUMsVUFBVTVGLHlDQUFZLENBQUNBLDBDQUFhLENBQUMwRjtJQUMzQyxPQUFPMUYsc0NBQVMsQ0FBQzRGLFNBQVNEO0FBQzlCLEVBQUU7QUFDSyxNQUFNSyxvQkFBb0IsQ0FBQ2xGO0lBQzlCLE1BQU1tRixjQUFjLENBQUM7SUFDckIsS0FBSyxNQUFNL0YsU0FBU2MsT0FBT2tGLE9BQU8sQ0FBQ3BGLEtBQU07UUFDckNtRixXQUFXLENBQUMvRixLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUdpRyxLQUFLQyxLQUFLLENBQUNsRyxLQUFLLENBQUMsRUFBRTtJQUMvQztJQUNBLE9BQU8rRjtBQUNYLEVBQUU7QUFDSyxNQUFNSSxjQUFjLENBQUNuRztJQUN4QixNQUFNbUUsUUFBUSxDQUFDO0lBQ2ZyRCxPQUFPc0YsbUJBQW1CLENBQUNwRyxPQUFPK0QsT0FBTyxDQUFDLFNBQVVzQyxRQUFRO1FBQ3hEbEMsS0FBSyxDQUFDa0MsU0FBUyxHQUFHckcsS0FBSyxDQUFDcUcsU0FBUztJQUNyQztJQUNBLE9BQU9sQztBQUNYLEVBQUU7QUFDSyxNQUFNbUMscUJBQXFCLE1BQU0sQ0FDeEMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdXRpbHMuanM/NjBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbHVzdGVyIH0gZnJvbSAnaW9yZWRpcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgfSBmcm9tICdpb3JlZGlzL2J1aWx0L3V0aWxzJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuZXhwb3J0IGNvbnN0IGVycm9yT2JqZWN0ID0geyB2YWx1ZTogbnVsbCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBjdHgsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmplY3QudmFsdWUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgdGhlIHNpemUgb2Ygc3RyaW5nIGZvciBhc2NpaS9ub24tYXNjaWkgY2hhcmFjdGVyc1xuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjMzMTgwNTMvMTM0NzE3MFxuICogQHBhcmFtIHN0ciAtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhJblV0ZjhCeXRlcyhzdHIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXkyb2JqKGFycikge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIG9ialthcnJbaV1dID0gYXJyW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWxheShtcywgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2FsbGJhY2spO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2FsbGJhY2spO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVkaXNJbnN0YW5jZShvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlzQXBpID0gWydjb25uZWN0JywgJ2Rpc2Nvbm5lY3QnLCAnZHVwbGljYXRlJ107XG4gICAgcmV0dXJuIHJlZGlzQXBpLmV2ZXJ5KG5hbWUgPT4gdHlwZW9mIG9ialtuYW1lXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZWRpc0NsdXN0ZXIob2JqKSB7XG4gICAgcmV0dXJuIGlzUmVkaXNJbnN0YW5jZShvYmopICYmIG9iai5pc0NsdXN0ZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5jcmVhc2VNYXhMaXN0ZW5lcnMoZW1pdHRlciwgY291bnQpIHtcbiAgICBjb25zdCBtYXhMaXN0ZW5lcnMgPSBlbWl0dGVyLmdldE1heExpc3RlbmVycygpO1xuICAgIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycyArIGNvdW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNyZWFzZU1heExpc3RlbmVycyhlbWl0dGVyLCBjb3VudCkge1xuICAgIGluY3JlYXNlTWF4TGlzdGVuZXJzKGVtaXR0ZXIsIC1jb3VudCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQWxsUXVldWVEYXRhKGNsaWVudCwgcXVldWVOYW1lLCBwcmVmaXggPSBwcm9jZXNzLmVudi5CVUxMTVFfVEVTVF9QUkVGSVggfHwgJ2J1bGwnKSB7XG4gICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIENsdXN0ZXIpIHtcbiAgICAgICAgLy8gdG9kbyBjb21wYXQgd2l0aCBjbHVzdGVyID9cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbHVpbi9pb3JlZGlzL2lzc3Vlcy8xNzVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhdHRlcm4gPSBgJHtwcmVmaXh9OiR7cXVldWVOYW1lfToqYDtcbiAgICBjb25zdCByZW1vdmluZyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2xpZW50LnNjYW5TdHJlYW0oe1xuICAgICAgICAgICAgbWF0Y2g6IHBhdHRlcm4sXG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAoa2V5cykgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGlwZWxpbmUuZGVsKGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGlwZWxpbmUuZXhlYygpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGVycm9yID0+IHJlamVjdChlcnJvcikpO1xuICAgIH0pO1xuICAgIGF3YWl0IHJlbW92aW5nO1xuICAgIGF3YWl0IGNsaWVudC5xdWl0KCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50S2V5KG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgICByZXR1cm4gYCR7b3B0cy5xdWV1ZX06JHtvcHRzLmlkfWA7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGNsaWVudENvbW1hbmRNZXNzYWdlUmVnID0gL0VSUiB1bmtub3duIGNvbW1hbmQgWydgXVxccypjbGllbnRcXHMqWydgXS87XG5leHBvcnQgY29uc3QgREVMQVlfVElNRV81ID0gNTAwMDtcbmV4cG9ydCBjb25zdCBERUxBWV9USU1FXzEgPSAxMDA7XG5leHBvcnQgZnVuY3Rpb24gaXNOb3RDb25uZWN0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgcmV0dXJuIChlcnJvck1lc3NhZ2UgIT09IENPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyAmJlxuICAgICAgICAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdFQ09OTlJFRlVTRUQnKSk7XG59XG5leHBvcnQgY29uc3QgYXN5bmNTZW5kID0gKHByb2MsIG1zZykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYy5zZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9jLnNlbmQobXNnLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvYy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzb2x2ZShwcm9jLnBvc3RNZXNzYWdlKG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IGNoaWxkU2VuZCA9IChwcm9jLCBtc2cpID0+IGFzeW5jU2VuZChwcm9jLCBtc2cpO1xuZXhwb3J0IGNvbnN0IGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuID0gKGN1cnJlbnRWZXJzaW9uLCBtaW5pbXVtVmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IHZlcnNpb24gPSBzZW12ZXIudmFsaWQoc2VtdmVyLmNvZXJjZShjdXJyZW50VmVyc2lvbikpO1xuICAgIHJldHVybiBzZW12ZXIubHQodmVyc2lvbiwgbWluaW11bVZlcnNpb24pO1xufTtcbmV4cG9ydCBjb25zdCBwYXJzZU9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICBjb25zdCBhY2N1bXVsYXRvciA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgICBhY2N1bXVsYXRvclt2YWx1ZVswXV0gPSBKU09OLnBhcnNlKHZhbHVlWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufTtcbmV4cG9ydCBjb25zdCBlcnJvclRvSlNPTiA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGVycm9yID0ge307XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIGVycm9yW3Byb3BOYW1lXSA9IHZhbHVlW3Byb3BOYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuZXhwb3J0IGNvbnN0IFFVRVVFX0VWRU5UX1NVRkZJWCA9ICc6cWUnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIkNsdXN0ZXIiLCJDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0ciLCJzZW12ZXIiLCJlcnJvck9iamVjdCIsInZhbHVlIiwidHJ5Q2F0Y2giLCJmbiIsImN0eCIsImFyZ3MiLCJhcHBseSIsImUiLCJsZW5ndGhJblV0ZjhCeXRlcyIsInN0ciIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJpc0VtcHR5Iiwib2JqIiwia2V5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXJyYXkyb2JqIiwiYXJyIiwiaSIsImxlbmd0aCIsImRlbGF5IiwibXMiLCJhYm9ydENvbnRyb2xsZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpbWVvdXQiLCJjYWxsYmFjayIsInNpZ25hbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzUmVkaXNJbnN0YW5jZSIsInJlZGlzQXBpIiwiZXZlcnkiLCJuYW1lIiwiaXNSZWRpc0NsdXN0ZXIiLCJpc0NsdXN0ZXIiLCJpbmNyZWFzZU1heExpc3RlbmVycyIsImVtaXR0ZXIiLCJjb3VudCIsIm1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImRlY3JlYXNlTWF4TGlzdGVuZXJzIiwicmVtb3ZlQWxsUXVldWVEYXRhIiwiY2xpZW50IiwicXVldWVOYW1lIiwicHJlZml4IiwicHJvY2VzcyIsImVudiIsIkJVTExNUV9URVNUX1BSRUZJWCIsInBhdHRlcm4iLCJyZW1vdmluZyIsInJlamVjdCIsInN0cmVhbSIsInNjYW5TdHJlYW0iLCJtYXRjaCIsIm9uIiwia2V5cyIsInBpcGVsaW5lIiwiZm9yRWFjaCIsImRlbCIsImV4ZWMiLCJjYXRjaCIsImVycm9yIiwicXVpdCIsImdldFBhcmVudEtleSIsIm9wdHMiLCJxdWV1ZSIsImlkIiwiY2xpZW50Q29tbWFuZE1lc3NhZ2VSZWciLCJERUxBWV9USU1FXzUiLCJERUxBWV9USU1FXzEiLCJpc05vdENvbm5lY3Rpb25FcnJvciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsImFzeW5jU2VuZCIsInByb2MiLCJtc2ciLCJzZW5kIiwiZXJyIiwicG9zdE1lc3NhZ2UiLCJjaGlsZFNlbmQiLCJpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbiIsImN1cnJlbnRWZXJzaW9uIiwibWluaW11bVZlcnNpb24iLCJ2ZXJzaW9uIiwidmFsaWQiLCJjb2VyY2UiLCJsdCIsInBhcnNlT2JqZWN0VmFsdWVzIiwiYWNjdW11bGF0b3IiLCJlbnRyaWVzIiwiSlNPTiIsInBhcnNlIiwiZXJyb3JUb0pTT04iLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvcE5hbWUiLCJRVUVVRV9FVkVOVF9TVUZGSVgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/brace-expansion/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/brace-expansion/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar balanced = __webpack_require__(/*! balanced-match */ \"(rsc)/./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = \"\\x00SLASH\" + Math.random() + \"\\x00\";\nvar escOpen = \"\\x00OPEN\" + Math.random() + \"\\x00\";\nvar escClose = \"\\x00CLOSE\" + Math.random() + \"\\x00\";\nvar escComma = \"\\x00COMMA\" + Math.random() + \"\\x00\";\nvar escPeriod = \"\\x00PERIOD\" + Math.random() + \"\\x00\";\nfunction numeric(str) {\n    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");\n}\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n    if (!str) return [\n        \"\"\n    ];\n    var parts = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return str.split(\",\");\n    var pre = m.pre;\n    var body = m.body;\n    var post = m.post;\n    var p = pre.split(\",\");\n    p[p.length - 1] += \"{\" + body + \"}\";\n    var postParts = parseCommaParts(post);\n    if (post.length) {\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nfunction expandTop(str) {\n    if (!str) return [];\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.substr(0, 2) === \"{}\") {\n        str = \"\\\\{\\\\}\" + str.substr(2);\n    }\n    return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return \"{\" + str + \"}\";\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand(str, isTop) {\n    var expansions = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return [\n        str\n    ];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    var pre = m.pre;\n    var post = m.post.length ? expand(m.post, false) : [\n        \"\"\n    ];\n    if (/\\$$/.test(m.pre)) {\n        for(var k = 0; k < post.length; k++){\n            var expansion = pre + \"{\" + m.body + \"}\" + post[k];\n            expansions.push(expansion);\n        }\n    } else {\n        var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isSequence = isNumericSequence || isAlphaSequence;\n        var isOptions = m.body.indexOf(\",\") >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,.*\\}/)) {\n                str = m.pre + \"{\" + m.body + escClose + m.post;\n                return expand(str);\n            }\n            return [\n                str\n            ];\n        }\n        var n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        } else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand(n[0], false).map(embrace);\n                if (n.length === 1) {\n                    return post.map(function(p) {\n                        return m.pre + n[0] + p;\n                    });\n                }\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        var N;\n        if (isSequence) {\n            var x = numeric(n[0]);\n            var y = numeric(n[1]);\n            var width = Math.max(n[0].length, n[1].length);\n            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n            var test = lte;\n            var reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            var pad = n.some(isPadded);\n            N = [];\n            for(var i = x; test(i, y); i += incr){\n                var c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === \"\\\\\") c = \"\";\n                } else {\n                    c = String(i);\n                    if (pad) {\n                        var need = width - c.length;\n                        if (need > 0) {\n                            var z = new Array(need + 1).join(\"0\");\n                            if (i < 0) c = \"-\" + z + c.slice(1);\n                            else c = z + c;\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        } else {\n            N = [];\n            for(var j = 0; j < n.length; j++){\n                N.push.apply(N, expand(n[j], false));\n            }\n        }\n        for(var j = 0; j < N.length; j++){\n            for(var k = 0; k < post.length; k++){\n                var expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) expansions.push(expansion);\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDO0FBRXZCQyxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLFdBQVcsY0FBVUMsS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlDLFVBQVUsYUFBU0YsS0FBS0MsTUFBTSxLQUFHO0FBQ3JDLElBQUlFLFdBQVcsY0FBVUgsS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlHLFdBQVcsY0FBVUosS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlJLFlBQVksZUFBV0wsS0FBS0MsTUFBTSxLQUFHO0FBRXpDLFNBQVNLLFFBQVFDLEdBQUc7SUFDbEIsT0FBT0MsU0FBU0QsS0FBSyxPQUFPQSxNQUN4QkMsU0FBU0QsS0FBSyxNQUNkQSxJQUFJRSxVQUFVLENBQUM7QUFDckI7QUFFQSxTQUFTQyxhQUFhSCxHQUFHO0lBQ3ZCLE9BQU9BLElBQUlJLEtBQUssQ0FBQyxRQUFRQyxJQUFJLENBQUNiLFVBQ25CWSxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDVixTQUNsQlMsS0FBSyxDQUFDLE9BQU9DLElBQUksQ0FBQ1QsVUFDbEJRLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNSLFVBQ2xCTyxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDUDtBQUMvQjtBQUVBLFNBQVNRLGVBQWVOLEdBQUc7SUFDekIsT0FBT0EsSUFBSUksS0FBSyxDQUFDWixVQUFVYSxJQUFJLENBQUMsTUFDckJELEtBQUssQ0FBQ1QsU0FBU1UsSUFBSSxDQUFDLEtBQ3BCRCxLQUFLLENBQUNSLFVBQVVTLElBQUksQ0FBQyxLQUNyQkQsS0FBSyxDQUFDUCxVQUFVUSxJQUFJLENBQUMsS0FDckJELEtBQUssQ0FBQ04sV0FBV08sSUFBSSxDQUFDO0FBQ25DO0FBR0Esb0RBQW9EO0FBQ3BELHdEQUF3RDtBQUN4RCxrREFB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QjtZQUNwQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qcz9hMWVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYWxhbmNlZCA9IHJlcXVpcmUoJ2JhbGFuY2VkLW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kVG9wO1xuXG52YXIgZXNjU2xhc2ggPSAnXFwwU0xBU0gnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjT3BlbiA9ICdcXDBPUEVOJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0Nsb3NlID0gJ1xcMENMT1NFJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0NvbW1hID0gJ1xcMENPTU1BJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY1BlcmlvZCA9ICdcXDBQRVJJT0QnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG5cbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKSA9PSBzdHJcbiAgICA/IHBhcnNlSW50KHN0ciwgMTApXG4gICAgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcXFxcXCcpLmpvaW4oZXNjU2xhc2gpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx7Jykuam9pbihlc2NPcGVuKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcfScpLmpvaW4oZXNjQ2xvc2UpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwsJykuam9pbihlc2NDb21tYSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXC4nKS5qb2luKGVzY1BlcmlvZCk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KGVzY1NsYXNoKS5qb2luKCdcXFxcJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NPcGVuKS5qb2luKCd7JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDbG9zZSkuam9pbignfScpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ29tbWEpLmpvaW4oJywnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY1BlcmlvZCkuam9pbignLicpO1xufVxuXG5cbi8vIEJhc2ljYWxseSBqdXN0IHN0ci5zcGxpdChcIixcIiksIGJ1dCBoYW5kbGluZyBjYXNlc1xuLy8gd2hlcmUgd2UgaGF2ZSBuZXN0ZWQgYnJhY2VkIHNlY3Rpb25zLCB3aGljaCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgYXMgaW5kaXZpZHVhbCBtZW1iZXJzLCBsaWtlIHthLHtiLGN9LGR9XG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbJyddO1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuXG4gIGlmICghbSlcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG5cbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgYm9keSA9IG0uYm9keTtcbiAgdmFyIHBvc3QgPSBtLnBvc3Q7XG4gIHZhciBwID0gcHJlLnNwbGl0KCcsJyk7XG5cbiAgcFtwLmxlbmd0aC0xXSArPSAneycgKyBib2R5ICsgJ30nO1xuICB2YXIgcG9zdFBhcnRzID0gcGFyc2VDb21tYVBhcnRzKHBvc3QpO1xuICBpZiAocG9zdC5sZW5ndGgpIHtcbiAgICBwW3AubGVuZ3RoLTFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgIHAucHVzaC5hcHBseShwLCBwb3N0UGFydHMpO1xuICB9XG5cbiAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb3Aoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbXTtcblxuICAvLyBJIGRvbid0IGtub3cgd2h5IEJhc2ggNC4zIGRvZXMgdGhpcywgYnV0IGl0IGRvZXMuXG4gIC8vIEFueXRoaW5nIHN0YXJ0aW5nIHdpdGgge30gd2lsbCBoYXZlIHRoZSBmaXJzdCB0d28gYnl0ZXMgcHJlc2VydmVkXG4gIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgLy8gYnV0IGF7fSxifWMgd2lsbCBiZSBleHBhbmRlZCB0byBbYX1jLGFiY10uXG4gIC8vIE9uZSBjb3VsZCBhcmd1ZSB0aGF0IHRoaXMgaXMgYSBidWcgaW4gQmFzaCwgYnV0IHNpbmNlIHRoZSBnb2FsIG9mXG4gIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJ3t9Jykge1xuICAgIHN0ciA9ICdcXFxce1xcXFx9JyArIHN0ci5zdWJzdHIoMik7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kKGVzY2FwZUJyYWNlcyhzdHIpLCB0cnVlKS5tYXAodW5lc2NhcGVCcmFjZXMpO1xufVxuXG5mdW5jdGlvbiBlbWJyYWNlKHN0cikge1xuICByZXR1cm4gJ3snICsgc3RyICsgJ30nO1xufVxuZnVuY3Rpb24gaXNQYWRkZWQoZWwpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cblxuZnVuY3Rpb24gbHRlKGksIHkpIHtcbiAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gIHJldHVybiBpID49IHk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdHIsIGlzVG9wKSB7XG4gIHZhciBleHBhbnNpb25zID0gW107XG5cbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgaWYgKCFtKSByZXR1cm4gW3N0cl07XG5cbiAgLy8gbm8gbmVlZCB0byBleHBhbmQgcHJlLCBzaW5jZSBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGZyZWUgb2YgYnJhY2Utc2V0c1xuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgOiBbJyddO1xuXG4gIGlmICgvXFwkJC8udGVzdChtLnByZSkpIHsgICAgXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb3N0Lmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgZXhwYW5zaW9uID0gcHJlKyAneycgKyBtLmJvZHkgKyAnfScgKyBwb3N0W2tdO1xuICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gICAgdmFyIGlzQWxwaGFTZXF1ZW5jZSA9IC9eW2EtekEtWl1cXC5cXC5bYS16QS1aXSg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICAgIHZhciBpc1NlcXVlbmNlID0gaXNOdW1lcmljU2VxdWVuY2UgfHwgaXNBbHBoYVNlcXVlbmNlO1xuICAgIHZhciBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gICAgaWYgKCFpc1NlcXVlbmNlICYmICFpc09wdGlvbnMpIHtcbiAgICAgIC8vIHthfSxifVxuICAgICAgaWYgKG0ucG9zdC5tYXRjaCgvLC4qXFx9LykpIHtcbiAgICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgICAgcmV0dXJuIGV4cGFuZChzdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtzdHJdO1xuICAgIH1cblxuICAgIHZhciBuO1xuICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICBuID0gbS5ib2R5LnNwbGl0KC9cXC5cXC4vKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIG0ucHJlICsgblswXSArIHA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgICAvLyB3aXRoIGEgc2luZ2xlIGVudHJ5LlxuICAgIHZhciBOO1xuXG4gICAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICAgIHZhciB4ID0gbnVtZXJpYyhuWzBdKTtcbiAgICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICAgIHZhciBpbmNyID0gbi5sZW5ndGggPT0gM1xuICAgICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICAgIDogMTtcbiAgICAgIHZhciB0ZXN0ID0gbHRlO1xuICAgICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIGluY3IgKj0gLTE7XG4gICAgICAgIHRlc3QgPSBndGU7XG4gICAgICB9XG4gICAgICB2YXIgcGFkID0gbi5zb21lKGlzUGFkZGVkKTtcblxuICAgICAgTiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgICAgaWYgKGMgPT09ICdcXFxcJylcbiAgICAgICAgICAgIGMgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjID0gU3RyaW5nKGkpO1xuICAgICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZWVkID4gMCkge1xuICAgICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgICAgYyA9ICctJyArIHogKyBjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBOLnB1c2goYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIE4ucHVzaC5hcHBseShOLCBleHBhbmQobltqXSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gcHJlICsgTltqXSArIHBvc3Rba107XG4gICAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cbiJdLCJuYW1lcyI6WyJiYWxhbmNlZCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXhwYW5kVG9wIiwiZXNjU2xhc2giLCJNYXRoIiwicmFuZG9tIiwiZXNjT3BlbiIsImVzY0Nsb3NlIiwiZXNjQ29tbWEiLCJlc2NQZXJpb2QiLCJudW1lcmljIiwic3RyIiwicGFyc2VJbnQiLCJjaGFyQ29kZUF0IiwiZXNjYXBlQnJhY2VzIiwic3BsaXQiLCJqb2luIiwidW5lc2NhcGVCcmFjZXMiLCJwYXJzZUNvbW1hUGFydHMiLCJwYXJ0cyIsIm0iLCJwcmUiLCJib2R5IiwicG9zdCIsInAiLCJsZW5ndGgiLCJwb3N0UGFydHMiLCJzaGlmdCIsInB1c2giLCJhcHBseSIsInN1YnN0ciIsImV4cGFuZCIsIm1hcCIsImVtYnJhY2UiLCJpc1BhZGRlZCIsImVsIiwidGVzdCIsImx0ZSIsImkiLCJ5IiwiZ3RlIiwiaXNUb3AiLCJleHBhbnNpb25zIiwiayIsImV4cGFuc2lvbiIsImlzTnVtZXJpY1NlcXVlbmNlIiwiaXNBbHBoYVNlcXVlbmNlIiwiaXNTZXF1ZW5jZSIsImlzT3B0aW9ucyIsImluZGV4T2YiLCJtYXRjaCIsIm4iLCJOIiwieCIsIndpZHRoIiwibWF4IiwiaW5jciIsImFicyIsInJldmVyc2UiLCJwYWQiLCJzb21lIiwiYyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5lZWQiLCJ6IiwiQXJyYXkiLCJzbGljZSIsImoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/assert-valid-pattern.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/assert-valid-pattern.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidPattern: () => (/* binding */ assertValidPattern)\n/* harmony export */ });\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n}; //# sourceMappingURL=assert-valid-pattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHFCQUFxQixPQUFPO0FBQzNCLE1BQU1DLHFCQUFxQixDQUFDQztJQUMvQixJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUM3QixNQUFNLElBQUlDLFVBQVU7SUFDeEI7SUFDQSxJQUFJRCxRQUFRRSxNQUFNLEdBQUdKLG9CQUFvQjtRQUNyQyxNQUFNLElBQUlHLFVBQVU7SUFDeEI7QUFDSixFQUFFLENBQ0YsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L21qcy9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcz8yZjllIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NDtcbmV4cG9ydCBjb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSAocGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJyk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJyk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC12YWxpZC1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6WyJNQVhfUEFUVEVSTl9MRU5HVEgiLCJhc3NlcnRWYWxpZFBhdHRlcm4iLCJwYXR0ZXJuIiwiVHlwZUVycm9yIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/ast.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/ast.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* binding */ AST)\n/* harmony export */ });\n/* harmony import */ var _brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/brace-expressions.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/unescape.js\");\n// parse a single path portion\n\n\nconst types = new Set([\n    \"!\",\n    \"?\",\n    \"+\",\n    \"*\",\n    \"@\"\n]);\nconst isExtglobType = (c)=>types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = \"(?!(?:^|/)\\\\.\\\\.?(?:$|/))\";\nconst startNoDot = \"(?!\\\\.)\";\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set([\n    \"[\",\n    \".\"\n]);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set([\n    \"..\",\n    \".\"\n]);\nconst reSpecials = new Set(\"().*{}+?[]^$\\\\!\");\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// any single thing other than /\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + \"+?\";\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    #root;\n    #hasMagic;\n    #uflag;\n    #parts;\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt;\n    constructor(type, parent, options = {}){\n        this.#uflag = false;\n        this.#parts = [];\n        this.#filledNegs = false;\n        this.#emptyExt = false;\n        this.type = type;\n        // extglobs are inherently magical\n        if (type) this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === \"!\" && !this.#root.#filledNegs) this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */ if (this.#hasMagic !== undefined) return this.#hasMagic;\n        /* c8 ignore stop */ for (const p of this.#parts){\n            if (typeof p === \"string\") continue;\n            if (p.type || p.hasMagic) return this.#hasMagic = true;\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined) return this.#toString;\n        if (!this.type) {\n            return this.#toString = this.#parts.map((p)=>String(p)).join(\"\");\n        } else {\n            return this.#toString = this.type + \"(\" + this.#parts.map((p)=>String(p)).join(\"|\") + \")\";\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */ if (this !== this.#root) throw new Error(\"should only call on root\");\n        if (this.#filledNegs) return this;\n        /* c8 ignore stop */ // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while(n = this.#negs.pop()){\n            if (n.type !== \"!\") continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while(pp){\n                for(let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++){\n                    for (const part of n.#parts){\n                        /* c8 ignore start */ if (typeof part === \"string\") {\n                            throw new Error(\"string part in extglob AST??\");\n                        }\n                        /* c8 ignore stop */ part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts){\n            if (p === \"\") continue;\n            /* c8 ignore start */ if (typeof p !== \"string\" && !(p instanceof AST && p.#parent === this)) {\n                throw new Error(\"invalid part: \" + p);\n            }\n            /* c8 ignore stop */ this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null ? this.#parts.slice().map((p)=>typeof p === \"string\" ? p : p.toJSON()) : [\n            this.type,\n            ...this.#parts.map((p)=>p.toJSON())\n        ];\n        if (this.isStart() && !this.type) ret.unshift([]);\n        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === \"!\")) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this) return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart()) return false;\n        if (this.#parentIndex === 0) return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for(let i = 0; i < this.#parentIndex; i++){\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === \"!\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this) return true;\n        if (this.#parent?.type === \"!\") return true;\n        if (!this.#parent?.isEnd()) return false;\n        if (!this.type) return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */ const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */ return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === \"string\") this.push(part);\n        else this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts){\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = \"\";\n            while(i < str.length){\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === \"\\\\\") {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === \"^\" || c === \"!\") {\n                            braceNeg = true;\n                        }\n                    } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                } else if (c === \"[\") {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === \"(\") {\n                    ast.push(acc);\n                    acc = \"\";\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = \"\";\n        while(i < str.length){\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === \"\\\\\") {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === \"^\" || c === \"!\") {\n                        braceNeg = true;\n                    }\n                } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            } else if (c === \"[\") {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === \"(\") {\n                part.push(acc);\n                acc = \"\";\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === \"|\") {\n                part.push(acc);\n                acc = \"\";\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === \")\") {\n                if (acc === \"\" && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = \"\";\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [\n            str.substring(pos - 1)\n        ];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */ if (this !== this.#root) return this.#root.toMMPattern();\n        /* c8 ignore stop */ const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? \"i\" : \"\") + (uflag ? \"u\" : \"\");\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob\n        });\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this) this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts.map((p)=>{\n                const [re, _, hasMagic, uflag] = typeof p === \"string\" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            }).join(\"\");\n            let start = \"\";\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === \"string\") {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = // dots are allowed, and the pattern starts with [ or .\n                        dot && aps.has(src.charAt(0)) || // the pattern starts with \\., and then [ or .\n                        src.startsWith(\"\\\\.\") && aps.has(src.charAt(2)) || // the pattern starts with \\.\\., and then [ or .\n                        src.startsWith(\"\\\\.\\\\.\") && aps.has(src.charAt(4));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : \"\";\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = \"\";\n            if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === \"!\") {\n                end = \"(?:$|\\\\/)\";\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(src),\n                this.#hasMagic = !!this.#hasMagic,\n                this.#uflag\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === \"*\" || this.type === \"+\";\n        // some kind of extglob\n        const start = this.type === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== \"!\") {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [\n                s\n            ];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [\n                s,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(this.toString()),\n                false,\n                false\n            ];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? \"\" : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = \"\";\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = \"\";\n        if (this.type === \"!\" && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : \"\") + starNoEmpty;\n        } else {\n            const close = this.type === \"!\" ? \"))\" + (this.isStart() && !dot && !allowDot ? startNoDot : \"\") + star + \")\" : this.type === \"@\" ? \")\" : this.type === \"?\" ? \")?\" : this.type === \"+\" && bodyDotAllowed ? \")\" : this.type === \"*\" && bodyDotAllowed ? `)?` : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(body),\n            this.#hasMagic = !!this.#hasMagic,\n            this.#uflag\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts.map((p)=>{\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */ if (typeof p === \"string\") {\n                throw new Error(\"string type in extglob ast??\");\n            }\n            /* c8 ignore stop */ // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        }).filter((p)=>!(this.isStart() && this.isEnd()) || !!p).join(\"|\");\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = \"\";\n        let uflag = false;\n        for(let i = 0; i < glob.length; i++){\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? \"\\\\\" : \"\") + c;\n                continue;\n            }\n            if (c === \"\\\\\") {\n                if (i === glob.length - 1) {\n                    re += \"\\\\\\\\\";\n                } else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === \"[\") {\n                const [src, needUflag, consumed, magic] = (0,_brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === \"*\") {\n                if (noEmpty && glob === \"*\") re += starNoEmpty;\n                else re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === \"?\") {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [\n            re,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(glob),\n            !!hasMagic,\n            uflag\n        ];\n    }\n} //# sourceMappingURL=ast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvYXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhCQUE4QjtBQUNzQjtBQUNYO0FBQ3pDLE1BQU1FLFFBQVEsSUFBSUMsSUFBSTtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUMvQyxNQUFNQyxnQkFBZ0IsQ0FBQ0MsSUFBTUgsTUFBTUksR0FBRyxDQUFDRDtBQUN2QyxpRUFBaUU7QUFDakUsZ0VBQWdFO0FBQ2hFLDBDQUEwQztBQUMxQyx1RUFBdUU7QUFDdkUsTUFBTUUsbUJBQW1CO0FBQ3pCLE1BQU1DLGFBQWE7QUFDbkIsdUVBQXVFO0FBQ3ZFLHFFQUFxRTtBQUNyRSxxRUFBcUU7QUFDckUsTUFBTUMsa0JBQWtCLElBQUlOLElBQUk7SUFBQztJQUFLO0NBQUk7QUFDMUMsMERBQTBEO0FBQzFELE1BQU1PLFdBQVcsSUFBSVAsSUFBSTtJQUFDO0lBQU07Q0FBSTtBQUNwQyxNQUFNUSxhQUFhLElBQUlSLElBQUk7QUFDM0IsTUFBTVMsZUFBZSxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPLENBQUMsNEJBQTRCO0FBQ2xFLGdDQUFnQztBQUNoQyxNQUFNQyxRQUFRO0FBQ2QsZ0NBQWdDO0FBQ2hDLE1BQU1DLE9BQU9ELFFBQVE7QUFDckIsMEVBQTBFO0FBQzFFLHNDQUFzQztBQUN0QyxNQUFNRSxjQUFjRixRQUFRO0FBQzVCLHlFQUF5RTtBQUN6RSwyREFBMkQ7QUFDcEQsTUFBTUc7SUFFVCxDQUFDQyxJQUFJLENBQUM7SUFDTixDQUFDQyxRQUFRLENBQUM7SUFDVixDQUFDQyxLQUFLLENBQVM7SUFDZixDQUFDQyxLQUFLLENBQU07SUFDWixDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxXQUFXLENBQUM7SUFDYixDQUFDQyxJQUFJLENBQUM7SUFDTixDQUFDQyxVQUFVLENBQVM7SUFDcEIsQ0FBQ0MsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsUUFB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LE1BQU1pQjtvQkFDTnJFLFFBQVFBLFNBQVNzRjtvQkFDakIvRCxLQUFLZ0UsV0FBVztvQkFDaEJ4RixXQUFXQSxZQUFZeUY7b0JBQ3ZCO2dCQUNKO1lBQ0o7WUFDQSxJQUFJeEcsTUFBTSxLQUFLO2dCQUNYLElBQUlvRixXQUFXakIsU0FBUyxLQUNwQkMsTUFBTXhEO3FCQUVOd0QsTUFBTXpEO2dCQUNWSSxXQUFXO2dCQUNYO1lBQ0o7WUFDQSxJQUFJZixNQUFNLEtBQUs7Z0JBQ1hvRSxNQUFNMUQ7Z0JBQ05LLFdBQVc7Z0JBQ1g7WUFDSjtZQUNBcUQsTUFBTTdELGFBQWFQO1FBQ3ZCO1FBQ0EsT0FBTztZQUFDb0U7WUFBSXhFLHNEQUFRQSxDQUFDdUU7WUFBTyxDQUFDLENBQUNwRDtZQUFVQztTQUFNO0lBQ2xEO0FBQ0osRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmF2ZWxfcGxhbmVyLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2FzdC5qcz9iOTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhcnNlIGEgc2luZ2xlIHBhdGggcG9ydGlvblxuaW1wb3J0IHsgcGFyc2VDbGFzcyB9IGZyb20gJy4vYnJhY2UtZXhwcmVzc2lvbnMuanMnO1xuaW1wb3J0IHsgdW5lc2NhcGUgfSBmcm9tICcuL3VuZXNjYXBlLmpzJztcbmNvbnN0IHR5cGVzID0gbmV3IFNldChbJyEnLCAnPycsICcrJywgJyonLCAnQCddKTtcbmNvbnN0IGlzRXh0Z2xvYlR5cGUgPSAoYykgPT4gdHlwZXMuaGFzKGMpO1xuLy8gUGF0dGVybnMgdGhhdCBnZXQgcHJlcGVuZGVkIHRvIGJpbmQgdG8gdGhlIHN0YXJ0IG9mIGVpdGhlciB0aGVcbi8vIGVudGlyZSBzdHJpbmcsIG9yIGp1c3QgYSBzaW5nbGUgcGF0aCBwb3J0aW9uLCB0byBwcmV2ZW50IGRvdHNcbi8vIGFuZC9vciB0cmF2ZXJzYWwgcGF0dGVybnMsIHdoZW4gbmVlZGVkLlxuLy8gRXh0cyBkb24ndCBuZWVkIHRoZSBeIG9yIC8gYml0LCBiZWNhdXNlIHRoZSByb290IGJpbmRzIHRoYXQgYWxyZWFkeS5cbmNvbnN0IHN0YXJ0Tm9UcmF2ZXJzYWwgPSAnKD8hKD86XnwvKVxcXFwuXFxcXC4/KD86JHwvKSknO1xuY29uc3Qgc3RhcnROb0RvdCA9ICcoPyFcXFxcLiknO1xuLy8gY2hhcmFjdGVycyB0aGF0IGluZGljYXRlIGEgc3RhcnQgb2YgcGF0dGVybiBuZWVkcyB0aGUgXCJubyBkb3RzXCIgYml0LFxuLy8gYmVjYXVzZSBhIGRvdCAqbWlnaHQqIGJlIG1hdGNoZWQuICggaXMgbm90IGluIHRoZSBsaXN0LCBiZWNhdXNlIGluXG4vLyB0aGUgY2FzZSBvZiBhIGNoaWxkIGV4dGdsb2IsIGl0IHdpbGwgaGFuZGxlIHRoZSBwcmV2ZW50aW9uIGl0c2VsZi5cbmNvbnN0IGFkZFBhdHRlcm5TdGFydCA9IG5ldyBTZXQoWydbJywgJy4nXSk7XG4vLyBjYXNlcyB3aGVyZSB0cmF2ZXJzYWwgaXMgQS1PSywgbm8gZG90IHByZXZlbnRpb24gbmVlZGVkXG5jb25zdCBqdXN0RG90cyA9IG5ldyBTZXQoWycuLicsICcuJ10pO1xuY29uc3QgcmVTcGVjaWFscyA9IG5ldyBTZXQoJygpLip7fSs/W11eJFxcXFwhJyk7XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbmNvbnN0IHFtYXJrID0gJ1teL10nO1xuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbmNvbnN0IHN0YXIgPSBxbWFyayArICcqPyc7XG4vLyB1c2UgKyB3aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgKnNvbWV0aGluZyogbWF0Y2hlcywgYmVjYXVzZSB0aGUgKiBpc1xuLy8gdGhlIG9ubHkgdGhpbmcgaW4gdGhlIHBhdGggcG9ydGlvbi5cbmNvbnN0IHN0YXJOb0VtcHR5ID0gcW1hcmsgKyAnKz8nO1xuLy8gcmVtb3ZlIHRoZSBcXCBjaGFycyB0aGF0IHdlIGFkZGVkIGlmIHdlIGVuZCB1cCBkb2luZyBhIG5vbm1hZ2ljIGNvbXBhcmVcbi8vIGNvbnN0IGRlc2xhc2ggPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbmV4cG9ydCBjbGFzcyBBU1Qge1xuICAgIHR5cGU7XG4gICAgI3Jvb3Q7XG4gICAgI2hhc01hZ2ljO1xuICAgICN1ZmxhZyA9IGZhbHNlO1xuICAgICNwYXJ0cyA9IFtdO1xuICAgICNwYXJlbnQ7XG4gICAgI3BhcmVudEluZGV4O1xuICAgICNuZWdzO1xuICAgICNmaWxsZWROZWdzID0gZmFsc2U7XG4gICAgI29wdGlvbnM7XG4gICAgI3RvU3RyaW5nO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIGl0J3MgYW4gZXh0Z2xvYiB3aXRoIG5vIGNoaWxkcmVuXG4gICAgLy8gKHdoaWNoIHJlYWxseSBtZWFucyBvbmUgY2hpbGQgb2YgJycpXG4gICAgI2VtcHR5RXh0ID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gZXh0Z2xvYnMgYXJlIGluaGVyZW50bHkgbWFnaWNhbFxuICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLiNyb290ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNyb290IDogdGhpcztcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBvcHRpb25zIDogdGhpcy4jcm9vdC4jb3B0aW9ucztcbiAgICAgICAgdGhpcy4jbmVncyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBbXSA6IHRoaXMuI3Jvb3QuI25lZ3M7XG4gICAgICAgIGlmICh0eXBlID09PSAnIScgJiYgIXRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICB0aGlzLiNuZWdzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuI3BhcmVudEluZGV4ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBnZXQgaGFzTWFnaWMoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy4jaGFzTWFnaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAudHlwZSB8fCBwLmhhc01hZ2ljKVxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jaGFzTWFnaWMgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlOiB3aWxsIGJlIHVuZGVmaW5lZCB1bnRpbCB3ZSBnZW5lcmF0ZSB0aGUgcmVnZXhwIHNyYyBhbmQgZmluZCBvdXRcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgIH1cbiAgICAvLyByZWNvbnN0cnVjdHMgdGhlIHBhdHRlcm5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3RvU3RyaW5nICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdG9TdHJpbmc7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID0gdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgKyAnKCcgKyB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJ3wnKSArICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZpbGxOZWdzKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBvbmx5IGNhbGwgb24gcm9vdCcpO1xuICAgICAgICBpZiAodGhpcy4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyBjYWxsIHRvU3RyaW5nKCkgb25jZSB0byBmaWxsIHRoaXMgb3V0XG4gICAgICAgIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy4jZmlsbGVkTmVncyA9IHRydWU7XG4gICAgICAgIGxldCBuO1xuICAgICAgICB3aGlsZSAoKG4gPSB0aGlzLiNuZWdzLnBvcCgpKSkge1xuICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJyEnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gd2FsayB1cCB0aGUgdHJlZSwgYXBwZW5kaW5nIGV2ZXJ0aGluZyB0aGF0IGNvbWVzIEFGVEVSIHBhcmVudEluZGV4XG4gICAgICAgICAgICBsZXQgcCA9IG47XG4gICAgICAgICAgICBsZXQgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcC4jcGFyZW50SW5kZXggKyAxOyAhcHAudHlwZSAmJiBpIDwgcHAuI3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBuLiNwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcGFydCBpbiBleHRnbG9iIEFTVD8/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5SW4ocHAuI3BhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcHA7XG4gICAgICAgICAgICAgICAgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2goLi4ucGFydHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycgJiYgIShwIGluc3RhbmNlb2YgQVNUICYmIHAuI3BhcmVudCA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFydDogJyArIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnR5cGUgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jcGFydHMuc2xpY2UoKS5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHAudG9KU09OKCkpKVxuICAgICAgICAgICAgOiBbdGhpcy50eXBlLCAuLi50aGlzLiNwYXJ0cy5tYXAocCA9PiBwLnRvSlNPTigpKV07XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiAhdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0LnVuc2hpZnQoW10pO1xuICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAodGhpcyA9PT0gdGhpcy4jcm9vdCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNyb290LiNmaWxsZWROZWdzICYmIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiAodGhpcy50eXBlKSByZXR1cm4gISF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKVxuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50SW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBBSEVBRCBvZiB0aGlzIGlzIGEgbmVnYXRpb24sIHRoZW4gaXQncyBzdGlsbCB0aGUgXCJzdGFydFwiXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcGFyZW50SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwLiNwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKHBwIGluc3RhbmNlb2YgQVNUICYmIHBwLnR5cGUgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzRW5kKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudD8uaXNFbmQoKTtcbiAgICAgICAgLy8gaWYgbm90IHJvb3QsIGl0J2xsIGFsd2F5cyBoYXZlIGEgcGFyZW50XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudEluZGV4ID09PSBwbCAtIDE7XG4gICAgfVxuICAgIGNvcHlJbihwYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0LmNsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgY2xvbmUocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVNUKHRoaXMudHlwZSwgcGFyZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBjLmNvcHlJbihwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUFTVChzdHIsIGFzdCwgcG9zLCBvcHQpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBicmFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgYSBleHRnbG9iLCBhcHBlbmQgdW50aWwgd2UgZmluZCBhIHN0YXJ0XG4gICAgICAgICAgICBsZXQgaSA9IHBvcztcbiAgICAgICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQubm9leHQgJiYgaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYiwgcG9zIGlzIGF0IHRoZSAoXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgfCBvciApXG4gICAgICAgIGxldCBpID0gcG9zICsgMTtcbiAgICAgICAgbGV0IHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgcGFydCk7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChhY2MgPT09ICcnICYmIGFzdC4jcGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC4jZW1wdHlFeHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QucHVzaCguLi5wYXJ0cywgcGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmZpbmlzaGVkIGV4dGdsb2JcbiAgICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIGl0IHdhcyBhIG1hbGZvcm1lZCBleHRnbG9iISBub3QgYW4gZXh0Z2xvYiwgYnV0XG4gICAgICAgIC8vIG1heWJlIHNvbWV0aGluZyBlbHNlIGluIHRoZXJlLlxuICAgICAgICBhc3QudHlwZSA9IG51bGw7XG4gICAgICAgIGFzdC4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGFzdC4jcGFydHMgPSBbc3RyLnN1YnN0cmluZyhwb3MgLSAxKV07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBBU1QobnVsbCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgQVNULiNwYXJzZUFTVChwYXR0ZXJuLCBhc3QsIDAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaWYgdGhlcmUncyBtYWdpYywgb3IgdGhlIHVuZXNjYXBlZFxuICAgIC8vIHN0cmluZyBpZiBub3QuXG4gICAgdG9NTVBhdHRlcm4oKSB7XG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiByb290XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGdsb2IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IFtyZSwgYm9keSwgaGFzTWFnaWMsIHVmbGFnXSA9IHRoaXMudG9SZWdFeHBTb3VyY2UoKTtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gbm9jYXNlIG1vZGUsIGFuZCBub3Qgbm9jYXNlTWFnaWNPbmx5LCB0aGVuIHdlIGRvXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gaWYgd2UgaGF2ZSB0byBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgICAgLy8gbWF0Y2ggY2FwaXRhbC9sb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgYW55TWFnaWMgPSBoYXNNYWdpYyB8fFxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgfHxcbiAgICAgICAgICAgICh0aGlzLiNvcHRpb25zLm5vY2FzZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNvcHRpb25zLm5vY2FzZU1hZ2ljT25seSAmJlxuICAgICAgICAgICAgICAgIGdsb2IudG9VcHBlckNhc2UoKSAhPT0gZ2xvYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFhbnlNYWdpYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJykgKyAodWZsYWcgPyAndScgOiAnJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoYF4ke3JlfSRgLCBmbGFncyksIHtcbiAgICAgICAgICAgIF9zcmM6IHJlLFxuICAgICAgICAgICAgX2dsb2I6IGdsb2IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSBzdHJpbmcgbWF0Y2gsIHRoZSByZWdleHAgc291cmNlLCB3aGV0aGVyIHRoZXJlJ3MgbWFnaWNcbiAgICAvLyBpbiB0aGUgcmVnZXhwIChzbyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyByZXF1aXJlZCkgYW5kIHdoZXRoZXIgb3JcbiAgICAvLyBub3QgdGhlIHVmbGFnIGlzIG5lZWRlZCBmb3IgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAoZm9yIHBvc2l4IGNsYXNzZXMpXG4gICAgLy8gVE9ETzogaW5zdGVhZCBvZiBpbmplY3RpbmcgdGhlIHN0YXJ0L2VuZCBhdCB0aGlzIHBvaW50LCBqdXN0IHJldHVyblxuICAgIC8vIHRoZSBCT0RZIG9mIHRoZSByZWdleHAsIGFsb25nIHdpdGggdGhlIHN0YXJ0L2VuZCBwb3J0aW9ucyBzdWl0YWJsZVxuICAgIC8vIGZvciBiaW5kaW5nIHRoZSBzdGFydC9lbmQgaW4gZWl0aGVyIGEgam9pbmVkIGZ1bGwtcGF0aCBtYWtlUmUgY29udGV4dFxuICAgIC8vICh3aGVyZSB3ZSBiaW5kIHRvIChefC8pLCBvciBhIHN0YW5kYWxvbmUgbWF0Y2hQYXJ0IGNvbnRleHQgKHdoZXJlXG4gICAgLy8gd2UgYmluZCB0byBeLCBhbmQgbm90IC8pLiAgT3RoZXJ3aXNlIHNsYXNoZXMgZ2V0IGR1cGVkIVxuICAgIC8vXG4gICAgLy8gSW4gcGFydC1tYXRjaGluZyBtb2RlLCB0aGUgc3RhcnQgaXM6XG4gICAgLy8gLSBpZiBub3QgaXNTdGFydDogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6IF4oPyFcXC5cXC4/JClcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6IF5cbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiBeKD8hXFwuKVxuICAgIC8vIGVuZCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc0VuZCgpOiBub3RoaW5nXG4gICAgLy8gLSBlbHNlOiAkXG4gICAgLy9cbiAgICAvLyBJbiBmdWxsLXBhdGggbWF0Y2hpbmcgbW9kZSwgd2UgcHV0IHRoZSBzbGFzaCBhdCB0aGUgU1RBUlQgb2YgdGhlXG4gICAgLy8gcGF0dGVybiwgc28gc3RhcnQgaXM6XG4gICAgLy8gLSBpZiBmaXJzdCBwYXR0ZXJuOiBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQoKTogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6IC8oPyFcXC5cXC4/KD86JHwvKSlcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6IC9cbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiAvKD8hXFwuKVxuICAgIC8vIGVuZCBpczpcbiAgICAvLyAtIGlmIGxhc3QgcGF0dGVybiwgc2FtZSBhcyBwYXJ0LW1hdGNoaW5nIG1vZGVcbiAgICAvLyAtIGVsc2Ugbm90aGluZ1xuICAgIC8vXG4gICAgLy8gQWx3YXlzIHB1dCB0aGUgKD86JHwvKSBvbiBuZWdhdGVkIHRhaWxzLCB0aG91Z2gsIGJlY2F1c2UgdGhhdCBoYXMgdG8gYmVcbiAgICAvLyB0aGVyZSB0byBiaW5kIHRoZSBlbmQgb2YgdGhlIG5lZ2F0ZWQgcGF0dGVybiBwb3J0aW9uLCBhbmQgaXQncyBlYXNpZXIgdG9cbiAgICAvLyBqdXN0IHN0aWNrIGl0IGluIG5vdyByYXRoZXIgdGhhbiB0cnkgdG8gaW5qZWN0IGl0IGxhdGVyIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAvLyB0aGUgcGF0dGVybi5cbiAgICAvL1xuICAgIC8vIFdlIGNhbiBqdXN0IGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgZW5kLCBhbmQgbGVhdmUgaXQgdXAgdG8gdGhlIGNhbGxlclxuICAgIC8vIHRvIGtub3cgd2hldGhlciBpdCdzIGdvaW5nIHRvIGJlIHVzZWQgam9pbmVkIG9yIGluIHBhcnRzLlxuICAgIC8vIEFuZCwgaWYgdGhlIHN0YXJ0IGlzIGFkanVzdGVkIHNsaWdodGx5LCBjYW4gZG8gdGhlIHNhbWUgdGhlcmU6XG4gICAgLy8gLSBpZiBub3QgaXNTdGFydDogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC5cXC4/JClcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6ICg/Oi98XilcbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiAoPzovfF4pKD8hXFwuKVxuICAgIC8vXG4gICAgLy8gQnV0IGl0J3MgYmV0dGVyIHRvIGhhdmUgYSBzaW1wbGVyIGJpbmRpbmcgd2l0aG91dCBhIGNvbmRpdGlvbmFsLCBmb3JcbiAgICAvLyBwZXJmb3JtYW5jZSwgc28gcHJvYmFibHkgYmV0dGVyIHRvIHJldHVybiBib3RoIHN0YXJ0IG9wdGlvbnMuXG4gICAgLy9cbiAgICAvLyBUaGVuIHRoZSBjYWxsZXIganVzdCBpZ25vcmVzIHRoZSBlbmQgaWYgaXQncyBub3QgdGhlIGZpcnN0IHBhdHRlcm4sXG4gICAgLy8gYW5kIHRoZSBzdGFydCBhbHdheXMgZ2V0cyBhcHBsaWVkLlxuICAgIC8vXG4gICAgLy8gQnV0IHRoYXQncyBhbHdheXMgZ29pbmcgdG8gYmUgJCBpZiBpdCdzIHRoZSBlbmRpbmcgcGF0dGVybiwgb3Igbm90aGluZyxcbiAgICAvLyBzbyB0aGUgY2FsbGVyIGNhbiBqdXN0IGF0dGFjaCAkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4gd2hlbiBidWlsZGluZy5cbiAgICAvL1xuICAgIC8vIFNvIHRoZSB0b2RvIGlzOlxuICAgIC8vIC0gYmV0dGVyIGRldGVjdCB3aGF0IGtpbmQgb2Ygc3RhcnQgaXMgbmVlZGVkXG4gICAgLy8gLSByZXR1cm4gYm90aCBmbGF2b3JzIG9mIHN0YXJ0aW5nIHBhdHRlcm5cbiAgICAvLyAtIGF0dGFjaCAkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4gd2hlbiBjcmVhdGluZyB0aGUgYWN0dWFsIFJlZ0V4cFxuICAgIC8vXG4gICAgLy8gQWgsIGJ1dCB3YWl0LCBubywgdGhhdCBhbGwgb25seSBhcHBsaWVzIHRvIHRoZSByb290IHdoZW4gdGhlIGZpcnN0IHBhdHRlcm5cbiAgICAvLyBpcyBub3QgYW4gZXh0Z2xvYi4gSWYgdGhlIGZpcnN0IHBhdHRlcm4gSVMgYW4gZXh0Z2xvYiwgdGhlbiB3ZSBuZWVkIGFsbFxuICAgIC8vIHRoYXQgZG90IHByZXZlbnRpb24gYml6IHRvIGxpdmUgaW4gdGhlIGV4dGdsb2IgcG9ydGlvbnMsIGJlY2F1c2UgZWdcbiAgICAvLyArKCp8LngqKSBjYW4gbWF0Y2ggLnh5IGJ1dCBub3QgLnl4LlxuICAgIC8vXG4gICAgLy8gU28sIHJldHVybiB0aGUgdHdvIGZsYXZvcnMgaWYgaXQncyAjcm9vdCBhbmQgdGhlIGZpcnN0IGNoaWxkIGlzIG5vdCBhblxuICAgIC8vIEFTVCwgb3RoZXJ3aXNlIGxlYXZlIGl0IHRvIHRoZSBjaGlsZCBBU1QgdG8gaGFuZGxlIGl0LCBhbmQgdGhlcmUsXG4gICAgLy8gdXNlIHRoZSAoPzpefC8pIHN0eWxlIG9mIHN0YXJ0IGJpbmRpbmcuXG4gICAgLy9cbiAgICAvLyBFdmVuIHNpbXBsaWZpZWQgZnVydGhlcjpcbiAgICAvLyAtIFNpbmNlIHRoZSBzdGFydCBmb3IgYSBqb2luIGlzIGVnIC8oPyFcXC4pIGFuZCB0aGUgc3RhcnQgZm9yIGEgcGFydFxuICAgIC8vIGlzIF4oPyFcXC4pLCB3ZSBjYW4ganVzdCBwcmVwZW5kICg/IVxcLikgdG8gdGhlIHBhdHRlcm4gKGVpdGhlciByb290XG4gICAgLy8gb3Igc3RhcnQgb3Igd2hhdGV2ZXIpIGFuZCBwcmVwZW5kIF4gb3IgLyBhdCB0aGUgUmVnZXhwIGNvbnN0cnVjdGlvbi5cbiAgICB0b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCkge1xuICAgICAgICBjb25zdCBkb3QgPSBhbGxvd0RvdCA/PyAhIXRoaXMuI29wdGlvbnMuZG90O1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuI2ZpbGxOZWdzKCk7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBub0VtcHR5ID0gdGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpO1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gdGhpcy4jcGFydHNcbiAgICAgICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZSwgXywgaGFzTWFnaWMsIHVmbGFnXSA9IHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IEFTVC4jcGFyc2VHbG9iKHAsIHRoaXMuI2hhc01hZ2ljLCBub0VtcHR5KVxuICAgICAgICAgICAgICAgICAgICA6IHAudG9SZWdFeHBTb3VyY2UoYWxsb3dEb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdGhpcy4jaGFzTWFnaWMgfHwgaGFzTWFnaWM7XG4gICAgICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiNwYXJ0c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc3RyaW5nIHRoYXQgd2lsbCBtYXRjaCB0aGUgc3RhcnQgb2YgdGhlIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGRvdHMgYW5kIHN1Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vICcuJyBhbmQgJy4uJyBjYW5ub3QgbWF0Y2ggdW5sZXNzIHRoZSBwYXR0ZXJuIGlzIHRoYXQgZXhhY3RseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCBzdGFydHMgd2l0aCAuIG9yIGRvdDp0cnVlIGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG90VHJhdkFsbG93ZWQgPSB0aGlzLiNwYXJ0cy5sZW5ndGggPT09IDEgJiYganVzdERvdHMuaGFzKHRoaXMuI3BhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb3RUcmF2QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBzID0gYWRkUGF0dGVyblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIHBvc3NpYmlsaXR5IG9mIG1hdGNoaW5nIC4gb3IgLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJldmVudCB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZE5vVHJhdiA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG90cyBhcmUgYWxsb3dlZCwgYW5kIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFxcLiwgYW5kIHRoZW4gWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyYy5zdGFydHNXaXRoKCdcXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgyKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuXFxcXC4nKSAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcHJldmVudCBkb3RzIGlmIGl0IGNhbid0IG1hdGNoIGEgZG90LCBvciBpZiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWItcGF0dGVybiB3aWxsIGJlIHByZXZlbnRpbmcgaXQgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZE5vRG90ID0gIWRvdCAmJiAhYWxsb3dEb3QgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmVlZE5vVHJhdiA/IHN0YXJ0Tm9UcmF2ZXJzYWwgOiBuZWVkTm9Eb3QgPyBzdGFydE5vRG90IDogJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhlIFwiZW5kIG9mIHBhdGggcG9ydGlvblwiIHBhdHRlcm4gdG8gbmVnYXRpb24gdGFpbHNcbiAgICAgICAgICAgIGxldCBlbmQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNyb290LiNmaWxsZWROZWdzICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAnKD86JHxcXFxcLyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmluYWwgPSBzdGFydCArIHNyYyArIGVuZDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICAgICAgdW5lc2NhcGUoc3JjKSxcbiAgICAgICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGJvZHkgKnR3aWNlKiBpZiBpdCdzIGEgcmVwZWF0IHBhdHRlcm5cbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0LCBvbmNlIGluIG5vZG90IG1vZGUsIHRoZW4gYWdhaW4gaW4gZG90IG1vZGUsIHNvIGFcbiAgICAgICAgLy8gcGF0dGVybiBsaWtlICooPykgY2FuIG1hdGNoICd4LnknXG4gICAgICAgIGNvbnN0IHJlcGVhdGVkID0gdGhpcy50eXBlID09PSAnKicgfHwgdGhpcy50eXBlID09PSAnKyc7XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50eXBlID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonO1xuICAgICAgICBsZXQgYm9keSA9IHRoaXMuI3BhcnRzVG9SZWdFeHAoZG90KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSAmJiAhYm9keSAmJiB0aGlzLnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBleHRnbG9iLCBoYXMgdG8gYXQgbGVhc3QgYmUgKnNvbWV0aGluZyogcHJlc2VudCwgaWYgaXQnc1xuICAgICAgICAgICAgLy8gdGhlIGVudGlyZSBwYXRoIHBvcnRpb24uXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy4jcGFydHMgPSBbc107XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gW3MsIHVuZXNjYXBlKHRoaXMudG9TdHJpbmcoKSksIGZhbHNlLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gWFhYIGFic3RyYWN0IG91dCB0aGlzIG1hcCBtZXRob2RcbiAgICAgICAgbGV0IGJvZHlEb3RBbGxvd2VkID0gIXJlcGVhdGVkIHx8IGFsbG93RG90IHx8IGRvdCB8fCAhc3RhcnROb0RvdFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiB0aGlzLiNwYXJ0c1RvUmVnRXhwKHRydWUpO1xuICAgICAgICBpZiAoYm9keURvdEFsbG93ZWQgPT09IGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHlEb3RBbGxvd2VkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBib2R5ID0gYCg/OiR7Ym9keX0pKD86JHtib2R5RG90QWxsb3dlZH0pKj9gO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIGVtcHR5ICEoKSBpcyBleGFjdGx5IGVxdWl2YWxlbnQgdG8gYSBzdGFyTm9FbXB0eVxuICAgICAgICBsZXQgZmluYWwgPSAnJztcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJyEnICYmIHRoaXMuI2VtcHR5RXh0KSB7XG4gICAgICAgICAgICBmaW5hbCA9ICh0aGlzLmlzU3RhcnQoKSAmJiAhZG90ID8gc3RhcnROb0RvdCA6ICcnKSArIHN0YXJOb0VtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xvc2UgPSB0aGlzLnR5cGUgPT09ICchJ1xuICAgICAgICAgICAgICAgID8gLy8gISgpIG11c3QgbWF0Y2ggc29tZXRoaW5nLGJ1dCAhKHgpIGNhbiBtYXRjaCAnJ1xuICAgICAgICAgICAgICAgICAgICAnKSknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmlzU3RhcnQoKSAmJiAhZG90ICYmICFhbGxvd0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhciArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJ0AnXG4gICAgICAgICAgICAgICAgICAgID8gJyknXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnPydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJyk/J1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICcrJyAmJiBib2R5RG90QWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICcqJyAmJiBib2R5RG90QWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGApP2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgKSR7dGhpcy50eXBlfWA7XG4gICAgICAgICAgICBmaW5hbCA9IHN0YXJ0ICsgYm9keSArIGNsb3NlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgIHVuZXNjYXBlKGJvZHkpLFxuICAgICAgICAgICAgKHRoaXMuI2hhc01hZ2ljID0gISF0aGlzLiNoYXNNYWdpYyksXG4gICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgI3BhcnRzVG9SZWdFeHAoZG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgLm1hcChwID0+IHtcbiAgICAgICAgICAgIC8vIGV4dGdsb2IgQVNUcyBzaG91bGQgb25seSBjb250YWluIHBhcmVudCBBU1RzXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0eXBlIGluIGV4dGdsb2IgYXN0Pz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAvLyBjYW4gaWdub3JlIGhhc01hZ2ljLCBiZWNhdXNlIGV4dGdsb2JzIGFyZSBhbHJlYWR5IGFsd2F5cyBtYWdpY1xuICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBfaGFzTWFnaWMsIHVmbGFnXSA9IHAudG9SZWdFeHBTb3VyY2UoZG90KTtcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnID0gdGhpcy4jdWZsYWcgfHwgdWZsYWc7XG4gICAgICAgICAgICByZXR1cm4gcmU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKHAgPT4gISh0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCkpIHx8ICEhcClcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgfVxuICAgIHN0YXRpYyAjcGFyc2VHbG9iKGdsb2IsIGhhc01hZ2ljLCBub0VtcHR5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZSA9ICcnO1xuICAgICAgICBsZXQgdWZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2xvYi5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlICs9IChyZVNwZWNpYWxzLmhhcyhjKSA/ICdcXFxcJyA6ICcnKSArIGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGdsb2IubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXFxcXFwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3JjLCBuZWVkVWZsYWcsIGNvbnN1bWVkLCBtYWdpY10gPSBwYXJzZUNsYXNzKGdsb2IsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgbmVlZFVmbGFnO1xuICAgICAgICAgICAgICAgICAgICBpICs9IGNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBtYWdpYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlmIChub0VtcHR5ICYmIGdsb2IgPT09ICcqJylcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3Rhck5vRW1wdHk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICByZSArPSBxbWFyaztcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZSArPSByZWdFeHBFc2NhcGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZSwgdW5lc2NhcGUoZ2xvYiksICEhaGFzTWFnaWMsIHVmbGFnXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIl0sIm5hbWVzIjpbInBhcnNlQ2xhc3MiLCJ1bmVzY2FwZSIsInR5cGVzIiwiU2V0IiwiaXNFeHRnbG9iVHlwZSIsImMiLCJoYXMiLCJzdGFydE5vVHJhdmVyc2FsIiwic3RhcnROb0RvdCIsImFkZFBhdHRlcm5TdGFydCIsImp1c3REb3RzIiwicmVTcGVjaWFscyIsInJlZ0V4cEVzY2FwZSIsInMiLCJyZXBsYWNlIiwicW1hcmsiLCJzdGFyIiwic3Rhck5vRW1wdHkiLCJBU1QiLCJyb290IiwiaGFzTWFnaWMiLCJ1ZmxhZyIsInBhcnRzIiwicGFyZW50IiwicGFyZW50SW5kZXgiLCJuZWdzIiwiZmlsbGVkTmVncyIsIm9wdGlvbnMiLCJ0b1N0cmluZyIsImVtcHR5RXh0IiwiY29uc3RydWN0b3IiLCJ0eXBlIiwicHVzaCIsImxlbmd0aCIsInVuZGVmaW5lZCIsInAiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiZmlsbE5lZ3MiLCJFcnJvciIsIm4iLCJwb3AiLCJwcCIsImkiLCJwYXJ0IiwiY29weUluIiwidG9KU09OIiwicmV0Iiwic2xpY2UiLCJpc1N0YXJ0IiwidW5zaGlmdCIsImlzRW5kIiwicGwiLCJjbG9uZSIsInBhcnNlQVNUIiwic3RyIiwiYXN0IiwicG9zIiwib3B0IiwiZXNjYXBpbmciLCJpbkJyYWNlIiwiYnJhY2VTdGFydCIsImJyYWNlTmVnIiwiYWNjIiwiY2hhckF0Iiwibm9leHQiLCJleHQiLCJzdWJzdHJpbmciLCJmcm9tR2xvYiIsInBhdHRlcm4iLCJ0b01NUGF0dGVybiIsImdsb2IiLCJyZSIsImJvZHkiLCJ0b1JlZ0V4cFNvdXJjZSIsImFueU1hZ2ljIiwibm9jYXNlIiwibm9jYXNlTWFnaWNPbmx5IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImZsYWdzIiwiT2JqZWN0IiwiYXNzaWduIiwiUmVnRXhwIiwiX3NyYyIsIl9nbG9iIiwiYWxsb3dEb3QiLCJkb3QiLCJub0VtcHR5Iiwic3JjIiwiXyIsInBhcnNlR2xvYiIsInN0YXJ0IiwiZG90VHJhdkFsbG93ZWQiLCJhcHMiLCJuZWVkTm9UcmF2Iiwic3RhcnRzV2l0aCIsIm5lZWROb0RvdCIsImVuZCIsImZpbmFsIiwicmVwZWF0ZWQiLCJwYXJ0c1RvUmVnRXhwIiwiYm9keURvdEFsbG93ZWQiLCJjbG9zZSIsIl9oYXNNYWdpYyIsImZpbHRlciIsIm5lZWRVZmxhZyIsImNvbnN1bWVkIiwibWFnaWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/ast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/brace-expressions.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/brace-expressions.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseClass: () => (/* binding */ parseClass)\n/* harmony export */ });\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    \"[:alnum:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\",\n        true\n    ],\n    \"[:alpha:]\": [\n        \"\\\\p{L}\\\\p{Nl}\",\n        true\n    ],\n    \"[:ascii:]\": [\n        \"\\\\x\" + \"00-\\\\x\" + \"7f\",\n        false\n    ],\n    \"[:blank:]\": [\n        \"\\\\p{Zs}\\\\t\",\n        true\n    ],\n    \"[:cntrl:]\": [\n        \"\\\\p{Cc}\",\n        true\n    ],\n    \"[:digit:]\": [\n        \"\\\\p{Nd}\",\n        true\n    ],\n    \"[:graph:]\": [\n        \"\\\\p{Z}\\\\p{C}\",\n        true,\n        true\n    ],\n    \"[:lower:]\": [\n        \"\\\\p{Ll}\",\n        true\n    ],\n    \"[:print:]\": [\n        \"\\\\p{C}\",\n        true\n    ],\n    \"[:punct:]\": [\n        \"\\\\p{P}\",\n        true\n    ],\n    \"[:space:]\": [\n        \"\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f\",\n        true\n    ],\n    \"[:upper:]\": [\n        \"\\\\p{Lu}\",\n        true\n    ],\n    \"[:word:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}\",\n        true\n    ],\n    \"[:xdigit:]\": [\n        \"A-Fa-f0-9\",\n        false\n    ]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s)=>s.replace(/[[\\]\\\\-]/g, \"\\\\$&\");\n// escape all regexp magic characters\nconst regexpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges)=>ranges.join(\"\");\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position)=>{\n    const pos = position;\n    /* c8 ignore start */ if (glob.charAt(pos) !== \"[\") {\n        throw new Error(\"not in a brace expression\");\n    }\n    /* c8 ignore stop */ const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = \"\";\n    WHILE: while(i < glob.length){\n        const c = glob.charAt(i);\n        if ((c === \"!\" || c === \"^\") && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === \"]\" && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === \"\\\\\") {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n        // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === \"[\" && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return [\n                            \"$.\",\n                            false,\n                            glob.length - pos,\n                            true\n                        ];\n                    }\n                    i += cls.length;\n                    if (neg) negs.push(unip);\n                    else ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + \"-\" + braceEscape(c));\n            } else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = \"\";\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith(\"-]\", i + 1)) {\n            ranges.push(braceEscape(c + \"-\"));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith(\"-\", i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return [\n            \"\",\n            false,\n            0,\n            false\n        ];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return [\n            \"$.\",\n            false,\n            glob.length - pos,\n            true\n        ];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [\n            regexpEscape(r),\n            false,\n            endPos - pos,\n            false\n        ];\n    }\n    const sranges = \"[\" + (negate ? \"^\" : \"\") + rangesToString(ranges) + \"]\";\n    const snegs = \"[\" + (negate ? \"\" : \"^\") + rangesToString(negs) + \"]\";\n    const comb = ranges.length && negs.length ? \"(\" + sranges + \"|\" + snegs + \")\" : ranges.length ? sranges : snegs;\n    return [\n        comb,\n        uflag,\n        endPos - pos,\n        true\n    ];\n}; //# sourceMappingURL=brace-expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvYnJhY2UtZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQUN4RSx3Q0FBd0M7QUFDeEMsOERBQThEO0FBQzlELE1BQU1BLGVBQWU7SUFDakIsYUFBYTtRQUFDO1FBQXdCO0tBQUs7SUFDM0MsYUFBYTtRQUFDO1FBQWlCO0tBQUs7SUFDcEMsYUFBYTtRQUFDLFFBQVEsV0FBVztRQUFNO0tBQU07SUFDN0MsYUFBYTtRQUFDO1FBQWM7S0FBSztJQUNqQyxhQUFhO1FBQUM7UUFBVztLQUFLO0lBQzlCLGFBQWE7UUFBQztRQUFXO0tBQUs7SUFDOUIsYUFBYTtRQUFDO1FBQWdCO1FBQU07S0FBSztJQUN6QyxhQUFhO1FBQUM7UUFBVztLQUFLO0lBQzlCLGFBQWE7UUFBQztRQUFVO0tBQUs7SUFDN0IsYUFBYTtRQUFDO1FBQVU7S0FBSztJQUM3QixhQUFhO1FBQUM7UUFBeUI7S0FBSztJQUM1QyxhQUFhO1FBQUM7UUFBVztLQUFLO0lBQzlCLFlBQVk7UUFBQztRQUErQjtLQUFLO0lBQ2pELGNBQWM7UUFBQztRQUFhO0tBQU07QUFDdEM7QUFDQSwrREFBK0Q7QUFDL0QsbUJBQW1CO0FBQ25CLE1BQU1DLGNBQWMsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLGFBQWE7QUFDbEQscUNBQXFDO0FBQ3JDLE1BQU1DLGVBQWUsQ0FBQ0YsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLDRCQUE0QjtBQUNsRSw0REFBNEQ7QUFDNUQsTUFBTUUsaUJBQWlCLENBQUNDLFNBQVdBLE9BQU9DLElBQUksQ0FBQztBQUMvQywrREFBK0Q7QUFDL0Qsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSx5Q0FBeUM7QUFDekMsaUVBQWlFO0FBQ2pFLDZCQUE2QjtBQUN0QixNQUFNQyxhQUFhLENBQUNDLE1BQU1DO0lBQzdCLE1BQU1DLE1BQU1EO0lBQ1osbUJBQW1CLEdBQ25CLElBQUlELEtBQUtHLE1BQU0sQ0FBQ0QsU0FBUyxLQUFLO1FBQzFCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUNBLGtCQUFrQixHQUNsQixNQUFNUCxTQUFTLEVBQUU7SUFDakIsTUFBTVEsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsSUFBSUosTUFBTTtJQUNkLElBQUlLLFdBQVc7SUFDZixJQUFJQyxRQUFRO0lBQ1osSUFBSUMsV0FBVztJQUNmLElBQUlDLFNBQVM7SUFDYixJQUFJQyxTQUFTVDtJQUNiLElBQUlVLGFBQWE7SUFDakJDLE9BQU8sTUFBT1AsSUFBSU4sS0FBS2MsTUFBTSxDQUFFO1FBQzNCLE1BQU1DLElBQUlmLEtBQUtHLE1BQU0sQ0FBQ0c7UUFDdEIsSUFBSSxDQUFDUyxNQUFNLE9BQU9BLE1BQU0sR0FBRSxLQUFNVCxNQUFNSixNQUFNLEdBQUc7WUFDM0NRLFNBQVM7WUFDVEo7WUFDQTtRQUNKO1FBQ0EsSUFBSVMsTUFBTSxPQUFPUixZQUFZLENBQUNFLFVBQVU7WUFDcENFLFNBQVNMLElBQUk7WUFDYjtRQUNKO1FBQ0FDLFdBQVc7UUFDWCxJQUFJUSxNQUFNLE1BQU07WUFDWixJQUFJLENBQUNOLFVBQVU7Z0JBQ1hBLFdBQVc7Z0JBQ1hIO2dCQUNBO1lBQ0o7UUFDQSwwREFBMEQ7UUFDOUQ7UUFDQSxJQUFJUyxNQUFNLE9BQU8sQ0FBQ04sVUFBVTtZQUN4Qiw0REFBNEQ7WUFDNUQsS0FBSyxNQUFNLENBQUNPLEtBQUssQ0FBQ0MsTUFBTUMsR0FBR0MsSUFBSSxDQUFDLElBQUlDLE9BQU9DLE9BQU8sQ0FBQzlCLGNBQWU7Z0JBQzlELElBQUlTLEtBQUtzQixVQUFVLENBQUNOLEtBQUtWLElBQUk7b0JBQ3pCLCtDQUErQztvQkFDL0MsSUFBSU0sWUFBWTt3QkFDWixPQUFPOzRCQUFDOzRCQUFNOzRCQUFPWixLQUFLYyxNQUFNLEdBQUdaOzRCQUFLO3lCQUFLO29CQUNqRDtvQkFDQUksS0FBS1UsSUFBSUYsTUFBTTtvQkFDZixJQUFJSyxLQUNBZCxLQUFLa0IsSUFBSSxDQUFDTjt5QkFFVnBCLE9BQU8wQixJQUFJLENBQUNOO29CQUNoQlQsUUFBUUEsU0FBU1U7b0JBQ2pCLFNBQVNMO2dCQUNiO1lBQ0o7UUFDSjtRQUNBLGdEQUFnRDtRQUNoREosV0FBVztRQUNYLElBQUlHLFlBQVk7WUFDWixzREFBc0Q7WUFDdEQsbUJBQW1CO1lBQ25CLElBQUlHLElBQUlILFlBQVk7Z0JBQ2hCZixPQUFPMEIsSUFBSSxDQUFDL0IsWUFBWW9CLGNBQWMsTUFBTXBCLFlBQVl1QjtZQUM1RCxPQUNLLElBQUlBLE1BQU1ILFlBQVk7Z0JBQ3ZCZixPQUFPMEIsSUFBSSxDQUFDL0IsWUFBWXVCO1lBQzVCO1lBQ0FILGFBQWE7WUFDYk47WUFDQTtRQUNKO1FBQ0EscUNBQXFDO1FBQ3JDLDhEQUE4RDtRQUM5RCxJQUFJTixLQUFLc0IsVUFBVSxDQUFDLE1BQU1oQixJQUFJLElBQUk7WUFDOUJULE9BQU8wQixJQUFJLENBQUMvQixZQUFZdUIsSUFBSTtZQUM1QlQsS0FBSztZQUNMO1FBQ0o7UUFDQSxJQUFJTixLQUFLc0IsVUFBVSxDQUFDLEtBQUtoQixJQUFJLElBQUk7WUFDN0JNLGFBQWFHO1lBQ2JULEtBQUs7WUFDTDtRQUNKO1FBQ0Esb0RBQW9EO1FBQ3BEVCxPQUFPMEIsSUFBSSxDQUFDL0IsWUFBWXVCO1FBQ3hCVDtJQUNKO0lBQ0EsSUFBSUssU0FBU0wsR0FBRztRQUNaLHNEQUFzRDtRQUN0RCwrQ0FBK0M7UUFDL0MsT0FBTztZQUFDO1lBQUk7WUFBTztZQUFHO1NBQU07SUFDaEM7SUFDQSxnRUFBZ0U7SUFDaEUsa0VBQWtFO0lBQ2xFLElBQUksQ0FBQ1QsT0FBT2lCLE1BQU0sSUFBSSxDQUFDVCxLQUFLUyxNQUFNLEVBQUU7UUFDaEMsT0FBTztZQUFDO1lBQU07WUFBT2QsS0FBS2MsTUFBTSxHQUFHWjtZQUFLO1NBQUs7SUFDakQ7SUFDQSx5RUFBeUU7SUFDekUsc0VBQXNFO0lBQ3RFLHlFQUF5RTtJQUN6RSxzRUFBc0U7SUFDdEUsSUFBSUcsS0FBS1MsTUFBTSxLQUFLLEtBQ2hCakIsT0FBT2lCLE1BQU0sS0FBSyxLQUNsQixTQUFTVSxJQUFJLENBQUMzQixNQUFNLENBQUMsRUFBRSxLQUN2QixDQUFDYSxRQUFRO1FBQ1QsTUFBTWUsSUFBSTVCLE1BQU0sQ0FBQyxFQUFFLENBQUNpQixNQUFNLEtBQUssSUFBSWpCLE1BQU0sQ0FBQyxFQUFFLENBQUM2QixLQUFLLENBQUMsQ0FBQyxLQUFLN0IsTUFBTSxDQUFDLEVBQUU7UUFDbEUsT0FBTztZQUFDRixhQUFhOEI7WUFBSTtZQUFPZCxTQUFTVDtZQUFLO1NBQU07SUFDeEQ7SUFDQSxNQUFNeUIsVUFBVSxNQUFPakIsQ0FBQUEsU0FBUyxNQUFNLEVBQUMsSUFBS2QsZUFBZUMsVUFBVTtJQUNyRSxNQUFNK0IsUUFBUSxNQUFPbEIsQ0FBQUEsU0FBUyxLQUFLLEdBQUUsSUFBS2QsZUFBZVMsUUFBUTtJQUNqRSxNQUFNd0IsT0FBT2hDLE9BQU9pQixNQUFNLElBQUlULEtBQUtTLE1BQU0sR0FDbkMsTUFBTWEsVUFBVSxNQUFNQyxRQUFRLE1BQzlCL0IsT0FBT2lCLE1BQU0sR0FDVGEsVUFDQUM7SUFDVixPQUFPO1FBQUNDO1FBQU1yQjtRQUFPRyxTQUFTVDtRQUFLO0tBQUs7QUFDNUMsRUFBRSxDQUNGLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvYnJhY2UtZXhwcmVzc2lvbnMuanM/NTM4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2xhdGUgdGhlIHZhcmlvdXMgcG9zaXggY2hhcmFjdGVyIGNsYXNzZXMgaW50byB1bmljb2RlIHByb3BlcnRpZXNcbi8vIHRoaXMgd29ya3MgYWNyb3NzIGFsbCB1bmljb2RlIGxvY2FsZXNcbi8vIHsgPHBvc2l4IGNsYXNzPjogWzx0cmFuc2xhdGlvbj4sIC91IGZsYWcgcmVxdWlyZWQsIG5lZ2F0ZWRdXG5jb25zdCBwb3NpeENsYXNzZXMgPSB7XG4gICAgJ1s6YWxudW06XSc6IFsnXFxcXHB7TH1cXFxccHtObH1cXFxccHtOZH0nLCB0cnVlXSxcbiAgICAnWzphbHBoYTpdJzogWydcXFxccHtMfVxcXFxwe05sfScsIHRydWVdLFxuICAgICdbOmFzY2lpOl0nOiBbJ1xcXFx4JyArICcwMC1cXFxceCcgKyAnN2YnLCBmYWxzZV0sXG4gICAgJ1s6Ymxhbms6XSc6IFsnXFxcXHB7WnN9XFxcXHQnLCB0cnVlXSxcbiAgICAnWzpjbnRybDpdJzogWydcXFxccHtDY30nLCB0cnVlXSxcbiAgICAnWzpkaWdpdDpdJzogWydcXFxccHtOZH0nLCB0cnVlXSxcbiAgICAnWzpncmFwaDpdJzogWydcXFxccHtafVxcXFxwe0N9JywgdHJ1ZSwgdHJ1ZV0sXG4gICAgJ1s6bG93ZXI6XSc6IFsnXFxcXHB7TGx9JywgdHJ1ZV0sXG4gICAgJ1s6cHJpbnQ6XSc6IFsnXFxcXHB7Q30nLCB0cnVlXSxcbiAgICAnWzpwdW5jdDpdJzogWydcXFxccHtQfScsIHRydWVdLFxuICAgICdbOnNwYWNlOl0nOiBbJ1xcXFxwe1p9XFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZicsIHRydWVdLFxuICAgICdbOnVwcGVyOl0nOiBbJ1xcXFxwe0x1fScsIHRydWVdLFxuICAgICdbOndvcmQ6XSc6IFsnXFxcXHB7TH1cXFxccHtObH1cXFxccHtOZH1cXFxccHtQY30nLCB0cnVlXSxcbiAgICAnWzp4ZGlnaXQ6XSc6IFsnQS1GYS1mMC05JywgZmFsc2VdLFxufTtcbi8vIG9ubHkgbmVlZCB0byBlc2NhcGUgYSBmZXcgdGhpbmdzIGluc2lkZSBvZiBicmFjZSBleHByZXNzaW9uc1xuLy8gZXNjYXBlczogWyBcXCBdIC1cbmNvbnN0IGJyYWNlRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvW1tcXF1cXFxcLV0vZywgJ1xcXFwkJicpO1xuLy8gZXNjYXBlIGFsbCByZWdleHAgbWFnaWMgY2hhcmFjdGVyc1xuY29uc3QgcmVnZXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGV2ZXJ5dGhpbmcgaGFzIGFscmVhZHkgYmVlbiBlc2NhcGVkLCB3ZSBqdXN0IGhhdmUgdG8gam9pblxuY29uc3QgcmFuZ2VzVG9TdHJpbmcgPSAocmFuZ2VzKSA9PiByYW5nZXMuam9pbignJyk7XG4vLyB0YWtlcyBhIGdsb2Igc3RyaW5nIGF0IGEgcG9zaXggYnJhY2UgZXhwcmVzc2lvbiwgYW5kIHJldHVybnNcbi8vIGFuIGVxdWl2YWxlbnQgcmVndWxhciBleHByZXNzaW9uIHNvdXJjZSwgYW5kIGJvb2xlYW4gaW5kaWNhdGluZ1xuLy8gd2hldGhlciB0aGUgL3UgZmxhZyBuZWVkcyB0byBiZSBhcHBsaWVkLCBhbmQgdGhlIG51bWJlciBvZiBjaGFyc1xuLy8gY29uc3VtZWQgdG8gcGFyc2UgdGhlIGNoYXJhY3RlciBjbGFzcy5cbi8vIFRoaXMgYWxzbyByZW1vdmVzIG91dCBvZiBvcmRlciByYW5nZXMsIGFuZCByZXR1cm5zICgkLikgaWYgdGhlXG4vLyBlbnRpcmUgY2xhc3MganVzdCBubyBnb29kLlxuZXhwb3J0IGNvbnN0IHBhcnNlQ2xhc3MgPSAoZ2xvYiwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbjtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoZ2xvYi5jaGFyQXQocG9zKSAhPT0gJ1snKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGluIGEgYnJhY2UgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IG5lZ3MgPSBbXTtcbiAgICBsZXQgaSA9IHBvcyArIDE7XG4gICAgbGV0IHNhd1N0YXJ0ID0gZmFsc2U7XG4gICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgIGxldCBlbmRQb3MgPSBwb3M7XG4gICAgbGV0IHJhbmdlU3RhcnQgPSAnJztcbiAgICBXSElMRTogd2hpbGUgKGkgPCBnbG9iLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gZ2xvYi5jaGFyQXQoaSk7XG4gICAgICAgIGlmICgoYyA9PT0gJyEnIHx8IGMgPT09ICdeJykgJiYgaSA9PT0gcG9zICsgMSkge1xuICAgICAgICAgICAgbmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnXScgJiYgc2F3U3RhcnQgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICBlbmRQb3MgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNhd1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKCFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVkIFxcIGNoYXIsIGZhbGwgdGhyb3VnaCBhbmQgdHJlYXQgbGlrZSBub3JtYWwgY2hhclxuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnWycgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYSBwb3NpeCBjbGFzcywgYSBjb2xsYXRpb24gZXF1aXZhbGVudCwgb3IganVzdCBhIFtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NscywgW3VuaXAsIHUsIG5lZ11dIG9mIE9iamVjdC5lbnRyaWVzKHBvc2l4Q2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKGNscywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCwgW2EtW10gaXMgZmluZSwgYnV0IG5vdCBbYS1bOmFscGhhXV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpICs9IGNscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdzLnB1c2godW5pcCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IHU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIFdISUxFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgaXQncyBqdXN0IGEgbm9ybWFsIGNoYXJhY3RlciwgZWZmZWN0aXZlbHlcbiAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHRoaXMgcmFuZ2UgYXdheSBpZiBpdCdzIG5vdCB2YWxpZCwgYnV0IG90aGVyc1xuICAgICAgICAgICAgLy8gY2FuIHN0aWxsIG1hdGNoLlxuICAgICAgICAgICAgaWYgKGMgPiByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUocmFuZ2VTdGFydCkgKyAnLScgKyBicmFjZUVzY2FwZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2VTdGFydCA9ICcnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IG1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIHJhbmdlLlxuICAgICAgICAvLyBjYW4gYmUgZWl0aGVyIGMtZCBvciBjLV0gb3IgYzxtb3JlLi4uPl0gb3IgY10gYXQgdGhpcyBwb2ludFxuICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKCctXScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYyArICctJykpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IGM7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgdGhlIHN0YXJ0IG9mIGEgcmFuZ2UsIGp1c3QgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoZW5kUG9zIDwgaSkge1xuICAgICAgICAvLyBkaWRuJ3Qgc2VlIHRoZSBlbmQgb2YgdGhlIGNsYXNzLCBub3QgYSB2YWxpZCBjbGFzcyxcbiAgICAgICAgLy8gYnV0IG1pZ2h0IHN0aWxsIGJlIHZhbGlkIGFzIGEgbGl0ZXJhbCBtYXRjaC5cbiAgICAgICAgcmV0dXJuIFsnJywgZmFsc2UsIDAsIGZhbHNlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG5vIHJhbmdlcyBhbmQgbm8gbmVnYXRlcywgdGhlbiB3ZSBoYXZlIGEgcmFuZ2UgdGhhdFxuICAgIC8vIGNhbm5vdCBwb3NzaWJseSBtYXRjaCBhbnl0aGluZywgYW5kIHRoYXQgcG9pc29ucyB0aGUgd2hvbGUgZ2xvYlxuICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiAhbmVncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsnJC4nLCBmYWxzZSwgZ2xvYi5sZW5ndGggLSBwb3MsIHRydWVdO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3Qgb25lIHBvc2l0aXZlIHJhbmdlLCBhbmQgaXQncyBhIHNpbmdsZSBjaGFyYWN0ZXIsIHRoZW4gdGhhdCdzXG4gICAgLy8gbm90IGFjdHVhbGx5IGEgbWFnaWMgcGF0dGVybiwgaXQncyBqdXN0IHRoYXQgb25lIGxpdGVyYWwgY2hhcmFjdGVyLlxuICAgIC8vIHdlIHNob3VsZCBub3QgdHJlYXQgdGhhdCBhcyBcIm1hZ2ljXCIsIHdlIHNob3VsZCBqdXN0IHJldHVybiB0aGUgbGl0ZXJhbFxuICAgIC8vIGNoYXJhY3Rlci4gW19dIGlzIGEgcGVyZmVjdGx5IHZhbGlkIHdheSB0byBlc2NhcGUgZ2xvYiBtYWdpYyBjaGFycy5cbiAgICBpZiAobmVncy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgcmFuZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAvXlxcXFw/LiQvLnRlc3QocmFuZ2VzWzBdKSAmJlxuICAgICAgICAhbmVnYXRlKSB7XG4gICAgICAgIGNvbnN0IHIgPSByYW5nZXNbMF0ubGVuZ3RoID09PSAyID8gcmFuZ2VzWzBdLnNsaWNlKC0xKSA6IHJhbmdlc1swXTtcbiAgICAgICAgcmV0dXJuIFtyZWdleHBFc2NhcGUociksIGZhbHNlLCBlbmRQb3MgLSBwb3MsIGZhbHNlXTtcbiAgICB9XG4gICAgY29uc3Qgc3JhbmdlcyA9ICdbJyArIChuZWdhdGUgPyAnXicgOiAnJykgKyByYW5nZXNUb1N0cmluZyhyYW5nZXMpICsgJ10nO1xuICAgIGNvbnN0IHNuZWdzID0gJ1snICsgKG5lZ2F0ZSA/ICcnIDogJ14nKSArIHJhbmdlc1RvU3RyaW5nKG5lZ3MpICsgJ10nO1xuICAgIGNvbnN0IGNvbWIgPSByYW5nZXMubGVuZ3RoICYmIG5lZ3MubGVuZ3RoXG4gICAgICAgID8gJygnICsgc3JhbmdlcyArICd8JyArIHNuZWdzICsgJyknXG4gICAgICAgIDogcmFuZ2VzLmxlbmd0aFxuICAgICAgICAgICAgPyBzcmFuZ2VzXG4gICAgICAgICAgICA6IHNuZWdzO1xuICAgIHJldHVybiBbY29tYiwgdWZsYWcsIGVuZFBvcyAtIHBvcywgdHJ1ZV07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJhY2UtZXhwcmVzc2lvbnMuanMubWFwIl0sIm5hbWVzIjpbInBvc2l4Q2xhc3NlcyIsImJyYWNlRXNjYXBlIiwicyIsInJlcGxhY2UiLCJyZWdleHBFc2NhcGUiLCJyYW5nZXNUb1N0cmluZyIsInJhbmdlcyIsImpvaW4iLCJwYXJzZUNsYXNzIiwiZ2xvYiIsInBvc2l0aW9uIiwicG9zIiwiY2hhckF0IiwiRXJyb3IiLCJuZWdzIiwiaSIsInNhd1N0YXJ0IiwidWZsYWciLCJlc2NhcGluZyIsIm5lZ2F0ZSIsImVuZFBvcyIsInJhbmdlU3RhcnQiLCJXSElMRSIsImxlbmd0aCIsImMiLCJjbHMiLCJ1bmlwIiwidSIsIm5lZyIsIk9iamVjdCIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwicHVzaCIsInRlc3QiLCJyIiwic2xpY2UiLCJzcmFuZ2VzIiwic25lZ3MiLCJjb21iIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/escape.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/escape.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escape: () => (/* binding */ escape)\n/* harmony export */ });\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */ const escape = (s, { windowsPathsNoEscape = false } = {})=>{\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape ? s.replace(/[?*()[\\]]/g, \"[$&]\") : s.replace(/[?*()[\\]\\\\]/g, \"\\\\$&\");\n}; //# sourceMappingURL=escape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1BLFNBQVMsQ0FBQ0MsR0FBRyxFQUFFQyx1QkFBdUIsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVELHdEQUF3RDtJQUN4RCw0REFBNEQ7SUFDNUQsc0RBQXNEO0lBQ3RELE9BQU9BLHVCQUNERCxFQUFFRSxPQUFPLENBQUMsY0FBYyxVQUN4QkYsRUFBRUUsT0FBTyxDQUFDLGdCQUFnQjtBQUNwQyxFQUFFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L21qcy9lc2NhcGUuanM/Mzk1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVzY2FwZSBhbGwgbWFnaWMgY2hhcmFjdGVycyBpbiBhIGdsb2IgcGF0dGVybi5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlIHwgR2xvYk9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGV9XG4gKiBvcHRpb24gaXMgdXNlZCwgdGhlbiBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIGluIGBbXWAsIGJlY2F1c2VcbiAqIGEgbWFnaWMgY2hhcmFjdGVyIHdyYXBwZWQgaW4gYSBjaGFyYWN0ZXIgY2xhc3MgY2FuIG9ubHkgYmUgc2F0aXNmaWVkIGJ5XG4gKiB0aGF0IGV4YWN0IGNoYXJhY3Rlci4gIEluIHRoaXMgbW9kZSwgYFxcYCBpcyBfbm90XyBlc2NhcGVkLCBiZWNhdXNlIGl0IGlzXG4gKiBub3QgaW50ZXJwcmV0ZWQgYXMgYSBtYWdpYyBjaGFyYWN0ZXIsIGJ1dCBpbnN0ZWFkIGFzIGEgcGF0aCBzZXBhcmF0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGUgPSAocywgeyB3aW5kb3dzUGF0aHNOb0VzY2FwZSA9IGZhbHNlLCB9ID0ge30pID0+IHtcbiAgICAvLyBkb24ndCBuZWVkIHRvIGVzY2FwZSArQCEgYmVjYXVzZSB3ZSBlc2NhcGUgdGhlIHBhcmVuc1xuICAgIC8vIHRoYXQgbWFrZSB0aG9zZSBtYWdpYywgYW5kIGVzY2FwaW5nICEgYXMgWyFdIGlzbid0IHZhbGlkLFxuICAgIC8vIGJlY2F1c2UgWyFdXSBpcyBhIHZhbGlkIGdsb2IgY2xhc3MgbWVhbmluZyBub3QgJ10nLlxuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvWz8qKClbXFxdXS9nLCAnWyQmXScpXG4gICAgICAgIDogcy5yZXBsYWNlKC9bPyooKVtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJlc2NhcGUiLCJzIiwid2luZG93c1BhdGhzTm9Fc2NhcGUiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/escape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* reexport safe */ _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST),\n/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),\n/* harmony export */   Minimatch: () => (/* binding */ Minimatch),\n/* harmony export */   braceExpand: () => (/* binding */ braceExpand),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   makeRe: () => (/* binding */ makeRe),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   minimatch: () => (/* binding */ minimatch),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape)\n/* harmony export */ });\n/* harmony import */ var brace_expansion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/bullmq/node_modules/brace-expansion/index.js\");\n/* harmony import */ var _assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/assert-valid-pattern.js\");\n/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/ast.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/escape.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/unescape.js\");\n\n\n\n\n\nconst minimatch = (p, pattern, options = {})=>{\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext)=>(f)=>!f.startsWith(\".\") && f.endsWith(ext);\nconst starDotExtTestDot = (ext)=>(f)=>f.endsWith(ext);\nconst starDotExtTestNocase = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>!f.startsWith(\".\") && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f)=>!f.startsWith(\".\") && f.includes(\".\");\nconst starDotStarTestDot = (f)=>f !== \".\" && f !== \"..\" && f.includes(\".\");\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f)=>f !== \".\" && f !== \"..\" && f.startsWith(\".\");\nconst starRE = /^\\*+$/;\nconst starTest = (f)=>f.length !== 0 && !f.startsWith(\".\");\nconst starTestDot = (f)=>f.length !== 0 && f !== \".\" && f !== \"..\";\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && !f.startsWith(\".\");\n};\nconst qmarksTestNoExtDot = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && f !== \".\" && f !== \"..\";\n};\n/* c8 ignore start */ const defaultPlatform = typeof process === \"object\" && process ? typeof process.env === \"object\" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : \"posix\";\nconst path = {\n    win32: {\n        sep: \"\\\\\"\n    },\n    posix: {\n        sep: \"/\"\n    }\n};\n/* c8 ignore stop */ const sep = defaultPlatform === \"win32\" ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nconst GLOBSTAR = Symbol(\"globstar **\");\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\nconst filter = (pattern, options = {})=>(p)=>minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {})=>Object.assign({}, a, b);\nconst defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}){\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */ constructor(type, parent, options = {}){\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */ static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),\n        escape: (s, options = {})=>orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),\n        defaults: (options)=>orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {})=>{\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return brace_expansion__WEBPACK_IMPORTED_MODULE_0__(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nconst match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options = {}){\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === \"win32\";\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set){\n            for (const part of pattern){\n                if (typeof part !== \"string\") return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [\n            ...new Set(this.braceExpand())\n        ];\n        if (options.debug) {\n            this.debug = (...args)=>console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __)=>{\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === \"\" && s[1] === \"\" && (s[2] === \"?\" || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [\n                        ...s.slice(0, 4),\n                        ...s.slice(4).map((ss)=>this.parse(ss))\n                    ];\n                } else if (isDrive) {\n                    return [\n                        s[0],\n                        ...s.slice(1).map((ss)=>this.parse(ss))\n                    ];\n                }\n            }\n            return s.map((ss)=>this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter((s)=>s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for(let i = 0; i < this.set.length; i++){\n                const p = this.set[i];\n                if (p[0] === \"\" && p[1] === \"\" && this.globParts[i][2] === \"?\" && typeof p[3] === \"string\" && /^[a-z]:$/i.test(p[3])) {\n                    p[2] = \"?\";\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for(let i = 0; i < globParts.length; i++){\n                for(let j = 0; j < globParts[i].length; j++){\n                    if (globParts[i][j] === \"**\") {\n                        globParts[i][j] = \"*\";\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        } else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        } else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map((parts)=>{\n            let gs = -1;\n            while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                let i = gs;\n                while(parts[i + 1] === \"**\"){\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map((parts)=>{\n            parts = parts.reduce((set, part)=>{\n                const prev = set[set.length - 1];\n                if (part === \"**\" && prev === \"**\") {\n                    return set;\n                }\n                if (part === \"..\") {\n                    if (prev && prev !== \"..\" && prev !== \".\" && prev !== \"**\") {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [\n                \"\"\n            ] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for(let i = 1; i < parts.length - 1; i++){\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                    if (p === \".\" || p === \"\") {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                const p = parts[dd - 1];\n                if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        }while (didSomething);\n        return parts.length === 0 ? [\n            \"\"\n        ] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts){\n                let gs = -1;\n                while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                    let gss = gs;\n                    while(parts[gss + 1] === \"**\"){\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== \"..\") continue;\n                    if (!p || p === \".\" || p === \"..\" || !p2 || p2 === \".\" || p2 === \"..\") {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = \"**\";\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for(let i = 1; i < parts.length - 1; i++){\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                        if (p === \".\" || p === \"\") {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                    const p = parts[dd - 1];\n                    if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === \"**\";\n                        const splin = needDot ? [\n                            \".\"\n                        ] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0) parts.push(\"\");\n                        dd -= 2;\n                    }\n                }\n            }\n        }while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for(let i = 0; i < globParts.length - 1; i++){\n            for(let j = i + 1; j < globParts.length; j++){\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched) continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter((gs)=>gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = \"\";\n        while(ai < a.length && bi < b.length){\n            if (a[ai] === b[bi]) {\n                result.push(which === \"b\" ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            } else if (emptyGSMatch && a[ai] === \"**\" && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            } else if (emptyGSMatch && b[bi] === \"**\" && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            } else if (a[ai] === \"*\" && b[bi] && (this.options.dot || !b[bi].startsWith(\".\")) && b[bi] !== \"**\") {\n                if (which === \"b\") return false;\n                which = \"a\";\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            } else if (b[bi] === \"*\" && a[ai] && (this.options.dot || !a[ai].startsWith(\".\")) && a[ai] !== \"**\") {\n                if (which === \"a\") return false;\n                which = \"b\";\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            } else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === \"string\" && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive && file[0] === \"\" && file[1] === \"\" && file[2] === \"?\" && /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === \"string\" && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive && pattern[0] === \"\" && pattern[1] === \"\" && pattern[2] === \"?\" && typeof pattern[3] === \"string\" && /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === \"number\" && typeof pdi === \"number\") {\n                const [fd, pd] = [\n                    file[fdi],\n                    pattern[pdi]\n                ];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    } else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug(\"matchOne\", this, {\n            file,\n            pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */ if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */ if (p === GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */ return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = p.test(f);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        /* c8 ignore start */ } else {\n            // should be unreachable.\n            throw new Error(\"wtf?\");\n        }\n    /* c8 ignore stop */ }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") return GLOBSTAR;\n        if (pattern === \"\") return \"\";\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if (m = pattern.match(starRE)) {\n            fastTest = options.dot ? starTestDot : starTest;\n        } else if (m = pattern.match(starDotExtRE)) {\n            fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n        } else if (m = pattern.match(qmarksRE)) {\n            fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n        } else if (m = pattern.match(starDotStarRE)) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        } else if (m = pattern.match(dotStarRE)) {\n            fastTest = dotStarTest;\n        }\n        const re = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST.fromGlob(pattern, this.options).toMMPattern();\n        return fastTest ? Object.assign(re, {\n            test: fastTest\n        }) : re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = new Set(options.nocase ? [\n            \"i\"\n        ] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            const pp = pattern.map((p)=>{\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(\"\"))flags.add(f);\n                }\n                return typeof p === \"string\" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;\n            });\n            pp.forEach((p, i)=>{\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + next;\n                    } else {\n                        pp[i] = twoStar;\n                    }\n                } else if (next === undefined) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\" + twoStar + \")?\";\n                } else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter((p)=>p !== GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? [\n            \"(?:\",\n            \")\"\n        ] : [\n            \"\",\n            \"\"\n        ];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^\" + open + re + close + \"$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").+$\";\n        try {\n            this.regexp = new RegExp(re, [\n                ...flags\n            ].join(\"\"));\n        /* c8 ignore start */ } catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */ return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split(\"/\");\n        } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return [\n                \"\",\n                ...p.split(/\\/+/)\n            ];\n        } else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === \"\";\n        }\n        if (f === \"/\" && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split(\"\\\\\").join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, \"split\", ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for(let i = ff.length - 2; !filename && i >= 0; i--){\n                filename = ff[i];\n            }\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */ \n\n\n/* c8 ignore stop */ minimatch.AST = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape;\nminimatch.unescape = _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDMEI7QUFDaEM7QUFDTTtBQUNJO0FBQ2xDLE1BQU1LLFlBQVksQ0FBQ0MsR0FBR0MsU0FBU0MsVUFBVSxDQUFDLENBQUM7SUFDOUNQLDRFQUFrQkEsQ0FBQ007SUFDbkIsb0NBQW9DO0lBQ3BDLElBQUksQ0FBQ0MsUUFBUUMsU0FBUyxJQUFJRixRQUFRRyxNQUFNLENBQUMsT0FBTyxLQUFLO1FBQ2pELE9BQU87SUFDWDtJQUNBLE9BQU8sSUFBSUMsVUFBVUosU0FBU0MsU0FBU0ksS0FBSyxDQUFDTjtBQUNqRCxFQUFFO0FBQ0Ysd0RBQXdEO0FBQ3hELE1BQU1PLGVBQWU7QUFDckIsTUFBTUMsaUJBQWlCLENBQUNDLE1BQVEsQ0FBQ0MsSUFBTSxDQUFDQSxFQUFFQyxVQUFVLENBQUMsUUFBUUQsRUFBRUUsUUFBUSxDQUFDSDtBQUN4RSxNQUFNSSxvQkFBb0IsQ0FBQ0osTUFBUSxDQUFDQyxJQUFNQSxFQUFFRSxRQUFRLENBQUNIO0FBQ3JELE1BQU1LLHVCQUF1QixDQUFDTDtJQUMxQkEsTUFBTUEsSUFBSU0sV0FBVztJQUNyQixPQUFPLENBQUNMLElBQU0sQ0FBQ0EsRUFBRUMsVUFBVSxDQUFDLFFBQVFELEVBQUVLLFdBQVcsR0FBR0gsUUFBUSxDQUFDSDtBQUNqRTtBQUNBLE1BQU1PLDBCQUEwQixDQUFDUDtJQUM3QkEsTUFBTUEsSUFBSU0sV0FBVztJQUNyQixPQUFPLENBQUNMLElBQU1BLEVBQUVLLFdBQVcsR0FBR0gsUUFBUSxDQUFDSDtBQUMzQztBQUNBLE1BQU1RLGdCQUFnQjtBQUN0QixNQUFNQyxrQkFBa0IsQ0FBQ1IsSUFBTSxDQUFDQSxFQUFFQyxVQUFVLENBQUMsUUFBUUQsRUFBRVMsUUFBUSxDQUFDO0FBQ2hFLE1BQU1DLHFCQUFxQixDQUFDVixJQUFN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QixTQUFTQyxHQUFHLEVBQUU7UUFDakIsT0FBTzNELFVBQVUwRCxRQUFRLENBQUNDLEtBQUtyRCxTQUFTO0lBQzVDO0FBQ0o7QUFDQSxtQkFBbUIsR0FDWTtBQUNNO0FBQ0k7QUFDekMsa0JBQWtCLEdBQ2xCTixVQUFVSCxHQUFHLEdBQUdBLHdDQUFHQTtBQUNuQkcsVUFBVU0sU0FBUyxHQUFHQTtBQUN0Qk4sVUFBVUYsTUFBTSxHQUFHQSw4Q0FBTUE7QUFDekJFLFVBQVVELFFBQVEsR0FBR0Esa0RBQVFBLEVBQzdCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvaW5kZXguanM/ZTExNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXhwYW5kIGZyb20gJ2JyYWNlLWV4cGFuc2lvbic7XG5pbXBvcnQgeyBhc3NlcnRWYWxpZFBhdHRlcm4gfSBmcm9tICcuL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzJztcbmltcG9ydCB7IEFTVCB9IGZyb20gJy4vYXN0LmpzJztcbmltcG9ydCB7IGVzY2FwZSB9IGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG5leHBvcnQgY29uc3QgbWluaW1hdGNoID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKTtcbn07XG4vLyBPcHRpbWl6ZWQgY2hlY2tpbmcgZm9yIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm5zLlxuY29uc3Qgc3RhckRvdEV4dFJFID0gL15cXCorKFteK0AhP1xcKlxcW1xcKF0qKSQvO1xuY29uc3Qgc3RhckRvdEV4dFRlc3QgPSAoZXh0KSA9PiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0RG90ID0gKGV4dCkgPT4gKGYpID0+IGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90ID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdFN0YXJSRSA9IC9eXFwqK1xcLlxcKiskLztcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdCA9IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0RG90ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IGRvdFN0YXJSRSA9IC9eXFwuXFwqKyQvO1xuY29uc3QgZG90U3RhclRlc3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyUkUgPSAvXlxcKiskLztcbmNvbnN0IHN0YXJUZXN0ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJUZXN0RG90ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xuY29uc3QgcW1hcmtzUkUgPSAvXlxcPysoW14rQCE/XFwqXFxbXFwoXSopPyQvO1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZSA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlRG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3REb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHREb3QgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG59O1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/ICh0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fXykgfHxcbiAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ3Bvc2l4Jyk7XG5jb25zdCBwYXRoID0ge1xuICAgIHdpbjMyOiB7IHNlcDogJ1xcXFwnIH0sXG4gICAgcG9zaXg6IHsgc2VwOiAnLycgfSxcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0IGNvbnN0IHNlcCA9IGRlZmF1bHRQbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHBhdGgud2luMzIuc2VwIDogcGF0aC5wb3NpeC5zZXA7XG5taW5pbWF0Y2guc2VwID0gc2VwO1xuZXhwb3J0IGNvbnN0IEdMT0JTVEFSID0gU3ltYm9sKCdnbG9ic3RhciAqKicpO1xubWluaW1hdGNoLkdMT0JTVEFSID0gR0xPQlNUQVI7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG5leHBvcnQgY29uc3QgZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gKHApID0+IG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IChkZWYpID0+IHtcbiAgICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IG1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQVNUOiBjbGFzcyBBU1QgZXh0ZW5kcyBvcmlnLkFTVCB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIodHlwZSwgcGFyZW50LCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLnVuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGZpbHRlcjogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBkZWZhdWx0czogKG9wdGlvbnMpID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYWtlUmU6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgYnJhY2VFeHBhbmQ6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYXRjaDogKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIHNlcDogb3JpZy5zZXAsXG4gICAgICAgIEdMT0JTVEFSOiBHTE9CU1RBUixcbiAgICB9KTtcbn07XG5taW5pbWF0Y2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xuZXhwb3J0IGNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAgIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gICAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pO1xufTtcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kO1xuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5leHBvcnQgY29uc3QgbWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYWtlUmUoKTtcbm1pbmltYXRjaC5tYWtlUmUgPSBtYWtlUmU7XG5leHBvcnQgY29uc3QgbWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmID0+IG1tLm1hdGNoKGYpKTtcbiAgICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QucHVzaChwYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xubWluaW1hdGNoLm1hdGNoID0gbWF0Y2g7XG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYk1hZ2ljID0gL1s/Kl18WytAIV1cXCguKj9cXCl8XFxbfFxcXS87XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuZXhwb3J0IGNsYXNzIE1pbmltYXRjaCB7XG4gICAgb3B0aW9ucztcbiAgICBzZXQ7XG4gICAgcGF0dGVybjtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICBub25lZ2F0ZTtcbiAgICBuZWdhdGU7XG4gICAgY29tbWVudDtcbiAgICBlbXB0eTtcbiAgICBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICBwYXJ0aWFsO1xuICAgIGdsb2JTZXQ7XG4gICAgZ2xvYlBhcnRzO1xuICAgIG5vY2FzZTtcbiAgICBpc1dpbmRvd3M7XG4gICAgcGxhdGZvcm07XG4gICAgd2luZG93c05vTWFnaWNSb290O1xuICAgIHJlZ2V4cDtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLmlzV2luZG93cyA9IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8IG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyA9ICEhb3B0aW9ucy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICAgICAgdGhpcy5yZWdleHAgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vbmVnYXRlID0gISFvcHRpb25zLm5vbmVnYXRlO1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbDtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSAhIXRoaXMub3B0aW9ucy5ub2Nhc2U7XG4gICAgICAgIHRoaXMud2luZG93c05vTWFnaWNSb290ID1cbiAgICAgICAgICAgIG9wdGlvbnMud2luZG93c05vTWFnaWNSb290ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMud2luZG93c05vTWFnaWNSb290XG4gICAgICAgICAgICAgICAgOiAhISh0aGlzLmlzV2luZG93cyAmJiB0aGlzLm5vY2FzZSk7XG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFtdO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNldCA9IFtdO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgICAgIHRoaXMubWFrZSgpO1xuICAgIH1cbiAgICBoYXNNYWdpYygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYWdpY2FsQnJhY2VzICYmIHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKC4uLl8pIHsgfVxuICAgIG1ha2UoKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgICAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgICAgICAgdGhpcy5wYXJzZU5lZ2F0ZSgpO1xuICAgICAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gWy4uLm5ldyBTZXQodGhpcy5icmFjZUV4cGFuZCgpKV07XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlNldCk7XG4gICAgICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZlxuICAgICAgICAvLyBwYXRoLXBvcnRpb24gbWF0Y2hpbmcgcGF0dGVybnMuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBwcmVwcm9jZXNzIHRvIG1ha2UgdGhlIGdsb2IgcGF0dGVybiBzZXRzIGEgYml0IHNpbXBsZXJcbiAgICAgICAgLy8gYW5kIGRlZHVwZWQuICBUaGVyZSBhcmUgc29tZSBwZXJmLWtpbGxpbmcgcGF0dGVybnMgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gcHJvYmxlbXMgd2l0aCBhIGdsb2Igd2FsaywgYnV0IHdlIGNhbiBzaW1wbGlmeSB0aGVtIGRvd24gYSBiaXQuXG4gICAgICAgIGNvbnN0IHJhd0dsb2JQYXJ0cyA9IHRoaXMuZ2xvYlNldC5tYXAocyA9PiB0aGlzLnNsYXNoU3BsaXQocykpO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IHRoaXMucHJlcHJvY2VzcyhyYXdHbG9iUGFydHMpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iUGFydHMpO1xuICAgICAgICAvLyBnbG9iIC0tPiByZWdleHBzXG4gICAgICAgIGxldCBzZXQgPSB0aGlzLmdsb2JQYXJ0cy5tYXAoKHMsIF8sIF9fKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIGEgZHJpdmUgb3IgdW5jIHBhdGguXG4gICAgICAgICAgICAgICAgY29uc3QgaXNVTkMgPSBzWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBzWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAoc1syXSA9PT0gJz8nIHx8ICFnbG9iTWFnaWMudGVzdChzWzJdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWdsb2JNYWdpYy50ZXN0KHNbM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJpdmUgPSAvXlthLXpdOi9pLnRlc3Qoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVU5DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucy5zbGljZSgwLCA0KSwgLi4ucy5zbGljZSg0KS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEcml2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NbMF0sIC4uLnMuc2xpY2UoMSkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHMubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5zZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpO1xuICAgICAgICAvLyBkbyBub3QgdHJlYXQgdGhlID8gaW4gVU5DIHBhdGhzIGFzIG1hZ2ljXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iUGFydHNbaV1bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gJz8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5zZXQpO1xuICAgIH1cbiAgICAvLyB2YXJpb3VzIHRyYW5zZm9ybXMgdG8gZXF1aXZhbGVudCBwYXR0ZXJuIHNldHMgdGhhdCBhcmVcbiAgICAvLyBmYXN0ZXIgdG8gcHJvY2VzcyBpbiBhIGZpbGVzeXN0ZW0gd2Fsay4gIFRoZSBnb2FsIGlzIHRvXG4gICAgLy8gZWxpbWluYXRlIHdoYXQgd2UgY2FuLCBhbmQgcHVzaCBhbGwgKiogcGF0dGVybnMgYXMgZmFyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGFzIHBvc3NpYmxlLCBldmVuIGlmIGl0IGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGF0dGVybnMgdGhhdCB3ZSBoYXZlIHRvIHByb2Nlc3MuXG4gICAgcHJlcHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGluIGdsb2JzdGFyIG1vZGUsIHRoZW4gdHVybiBhbGwgKiogaW50byAqXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdsb2JQYXJ0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYlBhcnRzW2ldW2pdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV1bal0gPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgb3B0aW1pemF0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBmcyB3YWxraW5nXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLnNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDEpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgYmFzaWMgb3B0aW1pemF0aW9ucyB0byByZW1vdmUgc29tZSAuLiBwYXJ0c1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5sZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBqdXN0IGdldCByaWQgb2YgYWRqYXNjZW50ICoqIHBvcnRpb25zXG4gICAgYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGdzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCBpIC0gZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgYWRqYXNjZW50ICoqIGFuZCByZXNvbHZlIC4uIHBvcnRpb25zXG4gICAgbGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5yZWR1Y2UoKHNldCwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionICYmIHByZXYgPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJy4uJyAmJiBwcmV2ICE9PSAnLicgJiYgcHJldiAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldmVsVHdvRmlsZU9wdGltaXplKHBhcnRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzID0gdGhpcy5zbGFzaFNwbGl0KHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgfVxuICAgIC8vIEZpcnN0IHBoYXNlOiBzaW5nbGUtcGF0dGVybiBwcm9jZXNzaW5nXG4gICAgLy8gPHByZT4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHJlc3Q+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxwPiBpcyBhbnkgcG9ydGlvbiBvdGhlciB0aGFuIC4sIC4uLCAnJywgb3IgKipcbiAgICAvLyA8ZT4gaXMgLiBvciAnJ1xuICAgIC8vXG4gICAgLy8gKiovLi4gaXMgKmJydXRhbCogZm9yIGZpbGVzeXN0ZW0gd2Fsa2luZyBwZXJmb3JtYW5jZSwgYmVjYXVzZVxuICAgIC8vIGl0IGVmZmVjdGl2ZWx5IHJlc2V0cyB0aGUgcmVjdXJzaXZlIHdhbGsgZWFjaCB0aW1lIGl0IG9jY3VycyxcbiAgICAvLyBhbmQgKiogY2Fubm90IGJlIHJlZHVjZWQgb3V0IGJ5IGEgLi4gcGF0dGVybiBwYXJ0IGxpa2UgYSByZWdleHBcbiAgICAvLyBvciBtb3N0IHN0cmluZ3MgKG90aGVyIHRoYW4gLi4sIC4sIGFuZCAnJykgY2FuIGJlLlxuICAgIC8vXG4gICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyAqKi8qKi88cmVzdD4gLT4gKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyAqKi8qLzxyZXN0PiAtPiAqLyoqLzxyZXN0PiA8PT0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lc24ndCBmb2xsb3dcbiAgICAvLyB0aGlzIFdPVUxEIGJlIGFsbG93ZWQgaWYgKiogZGlkIGZvbGxvdyBzeW1saW5rcywgb3IgKiBkaWRuJ3RcbiAgICBmaXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnRzIG9mIGdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3NzID0gZ3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tnc3MgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPHByZT4vKiovKiovPHJlc3Q+IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3NzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWcsIGlmIGdzIGlzIDIgYW5kIGdzcyBpcyA0LCB0aGF0IG1lYW5zIHdlIGhhdmUgMyAqKlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0cywgYW5kIGNhbiByZW1vdmUgMiBvZiB0aGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3NzID4gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncyArIDEsIGdzcyAtIGdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRzW2dzICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tncyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRzW2dzICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlZGl0IHBhcnRzIGluIHBsYWNlLCBhbmQgcHVzaCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltnc10gPSAnKionO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGdzLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRG90ID0gZGQgPT09IDEgJiYgcGFydHNbZGQgKyAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGluID0gbmVlZERvdCA/IFsnLiddIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyLCAuLi5zcGxpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8gc2Vjb25kIHBoYXNlOiBtdWx0aS1wYXR0ZXJuIGRlZHVwZXNcbiAgICAvLyB7PHByZT4vKi88cmVzdD4sPHByZT4vPHA+LzxyZXN0Pn0gLT4gPHByZT4vKi88cmVzdD5cbiAgICAvLyB7PHByZT4vPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi8qKi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvLyBeLS0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lbnMndCBmb2xsb3cgc3ltbGlua3NcbiAgICBzZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMucGFydHNNYXRjaChnbG9iUGFydHNbaV0sIGdsb2JQYXJ0c1tqXSwgIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2ldID0gbWF0Y2hlZDtcbiAgICAgICAgICAgICAgICBnbG9iUGFydHNbal0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLmZpbHRlcihncyA9PiBncy5sZW5ndGgpO1xuICAgIH1cbiAgICBwYXJ0c01hdGNoKGEsIGIsIGVtcHR5R1NNYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBhaSA9IDA7XG4gICAgICAgIGxldCBiaSA9IDA7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHdoaWNoID0gJyc7XG4gICAgICAgIHdoaWxlIChhaSA8IGEubGVuZ3RoICYmIGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChhW2FpXSA9PT0gYltiaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aGljaCA9PT0gJ2InID8gYltiaV0gOiBhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlHU01hdGNoICYmIGFbYWldID09PSAnKionICYmIGJbYmldID09PSBhW2FpICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBiW2JpXSA9PT0gJyoqJyAmJiBhW2FpXSA9PT0gYltiaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhW2FpXSA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgYltiaV0gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmRvdCB8fCAhYltiaV0uc3RhcnRzV2l0aCgnLicpKSAmJlxuICAgICAgICAgICAgICAgIGJbYmldICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaWNoID09PSAnYicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGljaCA9ICdhJztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYltiaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGFbYWldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWFbYWldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2EnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYic7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBmYWxsIG91dCBvZiB0aGUgbG9vcCwgaXQgbWVhbnMgdGhleSB0d28gYXJlIGlkZW50aWNhbFxuICAgICAgICAvLyBhcyBsb25nIGFzIHRoZWlyIGxlbmd0aHMgbWF0Y2hcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlTmVnYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25lZ2F0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmVnYXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnOyBpKyspIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9ICFuZWdhdGU7XG4gICAgICAgICAgICBuZWdhdGVPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVnYXRlT2Zmc2V0KVxuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zbGljZShuZWdhdGVPZmZzZXQpO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbiAgICAvLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbiAgICAvLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4gICAgLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4gICAgLy8gdGhlIHBhcnRzIG1hdGNoLlxuICAgIG1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBVTkMgcGF0aHMgbGlrZSAvLz8vWDovLi4uIGNhbiBtYXRjaCBYOi8uLi4gYW5kIHZpY2UgdmVyc2FcbiAgICAgICAgLy8gRHJpdmUgbGV0dGVycyBpbiBhYnNvbHV0ZSBkcml2ZSBvciB1bmMgcGF0aHMgYXJlIGFsd2F5cyBjb21wYXJlZFxuICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgY29uc3QgZmlsZURyaXZlID0gdHlwZW9mIGZpbGVbMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QoZmlsZVswXSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlVU5DID0gIWZpbGVEcml2ZSAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KGZpbGVbM10pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybkRyaXZlID0gdHlwZW9mIHBhdHRlcm5bMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QocGF0dGVyblswXSk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuVU5DID0gIXBhdHRlcm5Ecml2ZSAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGF0dGVyblszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bM10pO1xuICAgICAgICAgICAgY29uc3QgZmRpID0gZmlsZVVOQyA/IDMgOiBmaWxlRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcGRpID0gcGF0dGVyblVOQyA/IDMgOiBwYXR0ZXJuRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZGkgPT09ICdudW1iZXInICYmIHR5cGVvZiBwZGkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZkLCBwZF0gPSBbZmlsZVtmZGldLCBwYXR0ZXJuW3BkaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmZC50b0xvd2VyQ2FzZSgpID09PSBwZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5bcGRpXSA9IGZkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGRpID4gZmRpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZShwZGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZkaSA+IHBkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuc2xpY2UoZmRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvbHZlIGFuZCByZWR1Y2UgLiBhbmQgLi4gcG9ydGlvbnMgaW4gdGhlIGZpbGUgYXMgd2VsbC5cbiAgICAgICAgLy8gZG9udCcgbmVlZCB0byBkbyB0aGUgc2Vjb25kIHBoYXNlLCBiZWNhdXNlIGl0J3Mgb25seSBvbmUgc3RyaW5nW11cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmxldmVsVHdvRmlsZU9wdGltaXplKGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgdGhpcywgeyBmaWxlLCBwYXR0ZXJuIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGZpID0gMCwgcGkgPSAwLCBmbCA9IGZpbGUubGVuZ3RoLCBwbCA9IHBhdHRlcm4ubGVuZ3RoOyBmaSA8IGZsICYmIHBpIDwgcGw7IGZpKyssIHBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKTtcbiAgICAgICAgICAgIHZhciBwID0gcGF0dGVybltwaV07XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVbZmldO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgICAgICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAocCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pO1xuICAgICAgICAgICAgICAgIC8vIFwiKipcIlxuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL2NcbiAgICAgICAgICAgICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAgICAgICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgICAgICAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgICAgICAgICAgICB2YXIgZnIgPSBmaTtcbiAgICAgICAgICAgICAgICB2YXIgcHIgPSBwaSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyID09PSBmbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiAqKlxuICAgICAgICAgICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgICAgICAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgICAgICAgICAgbGV0IGhpdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBmID09PSBwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBwLnRlc3QoZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhpdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAgICAgICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgICAgICAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgICAgICAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcbiAgICAgICAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICAgICAgICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgICAgICAgICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAgICAgICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgICAgICAgICAgcmV0dXJuIGZpID09PSBmbCAtIDEgJiYgZmlsZVtmaV0gPT09ICcnO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICBicmFjZUV4cGFuZCgpIHtcbiAgICAgICAgcmV0dXJuIGJyYWNlRXhwYW5kKHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgcGFyc2UocGF0dGVybikge1xuICAgICAgICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybik7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHNob3J0Y3V0c1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyoqJylcbiAgICAgICAgICAgIHJldHVybiBHTE9CU1RBUjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcnKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAvLyBmYXIgYW5kIGF3YXksIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm4gcGFydHMgYXJlXG4gICAgICAgIC8vICosICouKiwgYW5kICouPGV4dD4gIEFkZCBhIGZhc3QgY2hlY2sgbWV0aG9kIGZvciB0aG9zZS5cbiAgICAgICAgbGV0IG07XG4gICAgICAgIGxldCBmYXN0VGVzdCA9IG51bGw7XG4gICAgICAgIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyVGVzdERvdCA6IHN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90RXh0UkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdE5vY2FzZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFyRG90RXh0VGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJEb3RFeHRUZXN0KShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2gocW1hcmtzUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdE5vY2FzZURvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3QpKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90U3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyRG90U3RhclRlc3REb3QgOiBzdGFyRG90U3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKGRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IGRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlID0gQVNULmZyb21HbG9iKHBhdHRlcm4sIHRoaXMub3B0aW9ucykudG9NTVBhdHRlcm4oKTtcbiAgICAgICAgcmV0dXJuIGZhc3RUZXN0ID8gT2JqZWN0LmFzc2lnbihyZSwgeyB0ZXN0OiBmYXN0VGVzdCB9KSA6IHJlO1xuICAgIH1cbiAgICBtYWtlUmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAgICAgICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgICAgICAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gICAgICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICghc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyXG4gICAgICAgICAgICA/IHN0YXJcbiAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICA/IHR3b1N0YXJEb3RcbiAgICAgICAgICAgICAgICA6IHR3b1N0YXJOb0RvdDtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBuZXcgU2V0KG9wdGlvbnMubm9jYXNlID8gWydpJ10gOiBbXSk7XG4gICAgICAgIC8vIHJlZ2V4cGlmeSBub24tZ2xvYnN0YXIgcGF0dGVybnNcbiAgICAgICAgLy8gaWYgKiogaXMgb25seSBpdGVtLCB0aGVuIHdlIGp1c3QgZG8gb25lIHR3b1N0YXJcbiAgICAgICAgLy8gaWYgKiogaXMgZmlyc3QsIGFuZCB0aGVyZSBhcmUgbW9yZSwgcHJlcGVuZCAoXFwvfHR3b1N0YXJcXC8pPyB0byBuZXh0XG4gICAgICAgIC8vIGlmICoqIGlzIGxhc3QsIGFwcGVuZCAoXFwvdHdvU3RhcnwpIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIGlmICoqIGlzIGluIHRoZSBtaWRkbGUsIGFwcGVuZCAoXFwvfFxcL3R3b1N0YXJcXC8pIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIHRoZW4gZmlsdGVyIG91dCBHTE9CU1RBUiBzeW1ib2xzXG4gICAgICAgIGxldCByZSA9IHNldFxuICAgICAgICAgICAgLm1hcChwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBwID0gcGF0dGVybi5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHAuZmxhZ3Muc3BsaXQoJycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWRkKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICAgICAgICAgICAgICAgIDogcCA9PT0gR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC5fc3JjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcC5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBwW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHBbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwICE9PSBHTE9CU1RBUiB8fCBwcmV2ID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiBuZXh0ICE9PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHBbaSArIDFdID0gJyg/OlxcXFwvfCcgKyB0d29TdGFyICsgJ1xcXFwvKT8nICsgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2ldID0gdHdvU3RhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSAtIDFdID0gcHJldiArICcoPzpcXFxcL3wnICsgdHdvU3RhciArICcpPyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgIT09IEdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98XFxcXC8nICsgdHdvU3RhciArICdcXFxcLyknICsgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSArIDFdID0gR0xPQlNUQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHAuZmlsdGVyKHAgPT4gcCAhPT0gR0xPQlNUQVIpLmpvaW4oJy8nKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgIC8vIG5lZWQgdG8gd3JhcCBpbiBwYXJlbnMgaWYgd2UgaGFkIG1vcmUgdGhhbiBvbmUgdGhpbmcgd2l0aCB8LFxuICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBhbmNob3JlZCB0byBeIGFuZCB0aGUgbGFzdCB0byAkXG4gICAgICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBzZXQubGVuZ3RoID4gMSA/IFsnKD86JywgJyknXSA6IFsnJywgJyddO1xuICAgICAgICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gICAgICAgIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICAgICAgICByZSA9ICdeJyArIG9wZW4gKyByZSArIGNsb3NlICsgJyQnO1xuICAgICAgICAvLyBjYW4gbWF0Y2ggYW55dGhpbmcsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhpcy5cbiAgICAgICAgaWYgKHRoaXMubmVnYXRlKVxuICAgICAgICAgICAgcmUgPSAnXig/IScgKyByZSArICcpLiskJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgWy4uLmZsYWdzXS5qb2luKCcnKSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlXG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICB9XG4gICAgc2xhc2hTcGxpdChwKSB7XG4gICAgICAgIC8vIGlmIHAgc3RhcnRzIHdpdGggLy8gb24gd2luZG93cywgd2UgcHJlc2VydmUgdGhhdFxuICAgICAgICAvLyBzbyB0aGF0IFVOQyBwYXRocyBhcmVuJ3QgYnJva2VuLiAgT3RoZXJ3aXNlLCBhbnkgbnVtYmVyIG9mXG4gICAgICAgIC8vIC8gY2hhcmFjdGVycyBhcmUgY29hbGVzY2VkIGludG8gb25lLCB1bmxlc3NcbiAgICAgICAgLy8gcHJlc2VydmVNdWx0aXBsZVNsYXNoZXMgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgIGlmICh0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5zcGxpdCgnLycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNXaW5kb3dzICYmIC9eXFwvXFwvW15cXC9dKy8udGVzdChwKSkge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGV4dHJhICcnIGZvciB0aGUgb25lIHdlIGxvc2VcbiAgICAgICAgICAgIHJldHVybiBbJycsIC4uLnAuc3BsaXQoL1xcLysvKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcC5zcGxpdCgvXFwvKy8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGYsIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pO1xuICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gICAgICAgIC8vIGNvbW1lbnRzLCBldGMuXG4gICAgICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGYgPT09ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZiA9IGYuc3BsaXQoJ1xcXFwnKS5qb2luKCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJlYXQgdGhlIHRlc3QgcGF0aCBhcyBhIHNldCBvZiBwYXRocGFydHMuXG4gICAgICAgIGNvbnN0IGZmID0gdGhpcy5zbGFzaFNwbGl0KGYpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZmYpO1xuICAgICAgICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gICAgICAgIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gICAgICAgIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuICAgICAgICBjb25zdCBzZXQgPSB0aGlzLnNldDtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpO1xuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICAgICAgICBsZXQgZmlsZW5hbWUgPSBmZltmZi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZmLmxlbmd0aCAtIDI7ICFmaWxlbmFtZSAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmZbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzZXRbaV07XG4gICAgICAgICAgICBsZXQgZmlsZSA9IGZmO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IFtmaWxlbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpO1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5uZWdhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgICAgICAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gICAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGU7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0cyhkZWYpIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaDtcbiAgICB9XG59XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCB7IEFTVCB9IGZyb20gJy4vYXN0LmpzJztcbmV4cG9ydCB7IGVzY2FwZSB9IGZyb20gJy4vZXNjYXBlLmpzJztcbmV4cG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xubWluaW1hdGNoLkFTVCA9IEFTVDtcbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2g7XG5taW5pbWF0Y2guZXNjYXBlID0gZXNjYXBlO1xubWluaW1hdGNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiZXhwYW5kIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwiQVNUIiwiZXNjYXBlIiwidW5lc2NhcGUiLCJtaW5pbWF0Y2giLCJwIiwicGF0dGVybiIsIm9wdGlvbnMiLCJub2NvbW1lbnQiLCJjaGFyQXQiLCJNaW5pbWF0Y2giLCJtYXRjaCIsInN0YXJEb3RFeHRSRSIsInN0YXJEb3RFeHRUZXN0IiwiZXh0IiwiZiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInN0YXJEb3RFeHRUZXN0RG90Iiwic3RhckRvdEV4dFRlc3ROb2Nhc2UiLCJ0b0xvd2VyQ2FzZSIsInN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90Iiwic3RhckRvdFN0YXJSRSIsInN0YXJEb3RTdGFyVGVzdCIsImluY2x1ZGVzIiwic3RhckRvdFN0YXJUZXN0RG90IiwiZG90U3RhclJFIiwiZG90U3RhclRlc3QiLCJzdGFyUkUiLCJzdGFyVGVzdCIsImxlbmd0aCIsInN0YXJUZXN0RG90IiwicW1hcmtzUkUiLCJxbWFya3NUZXN0Tm9jYXNlIiwiJDAiLCJub2V4dCIsInFtYXJrc1Rlc3ROb0V4dCIsInFtYXJrc1Rlc3ROb2Nhc2VEb3QiLCJxbWFya3NUZXN0Tm9FeHREb3QiLCJxbWFya3NUZXN0RG90IiwicW1hcmtzVGVzdCIsImxlbiIsImRlZmF1bHRQbGF0Zm9ybSIsInByb2Nlc3MiLCJlbnYiLCJfX01JTklNQVRDSF9URVNUSU5HX1BMQVRGT1JNX18iLCJwbGF0Zm9ybSIsInBhdGgiLCJ3aW4zMiIsInNlcCIsInBvc2l4IiwiR0xPQlNUQVIiLCJTeW1ib2wiLCJxbWFyayIsInN0YXIiLCJ0d29TdGFyRG90IiwidHdvU3Rhck5vRG90IiwiZmlsdGVyIiwiYSIsImIiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0cyIsImRlZiIsImtleXMiLCJvcmlnIiwibSIsImNvbnN0cnVjdG9yIiwidHlwZSIsInBhcmVudCIsImZyb21HbG9iIiwicyIsIm1ha2VSZSIsImJyYWNlRXhwYW5kIiwibGlzdCIsIm5vYnJhY2UiLCJ0ZXN0IiwibW0iLCJub251bGwiLCJwdXNoIiwiZ2xvYk1hZ2ljIiwicmVnRXhwRXNjYXBlIiwicmVwbGFjZSIsImlzV2luZG93cyIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwiYWxsb3dXaW5kb3dzRXNjYXBlIiwicHJlc2VydmVNdWx0aXBsZVNsYXNoZXMiLCJyZWdleHAiLCJuZWdhdGUiLCJub25lZ2F0ZSIsImNvbW1lbnQiLCJlbXB0eSIsInBhcnRpYWwiLCJub2Nhc2UiLCJ3aW5kb3dzTm9NYWdpY1Jvb3QiLCJ1bmRlZmluZWQiLCJnbG9iU2V0IiwiZ2xvYlBhcnRzIiwic2V0IiwibWFrZSIsImhhc01hZ2ljIiwibWFnaWNhbEJyYWNlcyIsInBhcnQiLCJkZWJ1ZyIsIl8iLCJwYXJzZU5lZ2F0ZSIsIlNldCIsImFyZ3MiLCJjb25zb2xlIiwiZXJyb3IiLCJyYXdHbG9iUGFydHMiLCJtYXAiLCJzbGFzaFNwbGl0IiwicHJlcHJvY2VzcyIsIl9fIiwiaXNVTkMiLCJpc0RyaXZlIiwic2xpY2UiLCJzcyIsInBhcnNlIiwiaW5kZXhPZiIsImkiLCJub2dsb2JzdGFyIiwiaiIsIm9wdGltaXphdGlvbkxldmVsIiwiZmlyc3RQaGFzZVByZVByb2Nlc3MiLCJzZWNvbmRQaGFzZVByZVByb2Nlc3MiLCJsZXZlbE9uZU9wdGltaXplIiwiYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZSIsInBhcnRzIiwiZ3MiLCJzcGxpY2UiLCJyZWR1Y2UiLCJwcmV2IiwicG9wIiwibGV2ZWxUd29GaWxlT3B0aW1pemUiLCJBcnJheSIsImlzQXJyYXkiLCJkaWRTb21ldGhpbmciLCJkZCIsImdzcyIsIm5leHQiLCJwMiIsIm90aGVyIiwibmVlZERvdCIsInNwbGluIiwibWF0Y2hlZCIsInBhcnRzTWF0Y2giLCJlbXB0eUdTTWF0Y2giLCJhaSIsImJpIiwicmVzdWx0Iiwid2hpY2giLCJkb3QiLCJuZWdhdGVPZmZzZXQiLCJtYXRjaE9uZSIsImZpbGUiLCJmaWxlRHJpdmUiLCJmaWxlVU5DIiwicGF0dGVybkRyaXZlIiwicGF0dGVyblVOQyIsImZkaSIsInBkaSIsImZkIiwicGQiLCJmaSIsInBpIiwiZmwiLCJwbCIsImZyIiwicHIiLCJzd2FsbG93ZWUiLCJoaXQiLCJFcnJvciIsImZhc3RUZXN0IiwicmUiLCJ0b01NUGF0dGVybiIsInR3b1N0YXIiLCJmbGFncyIsInBwIiwiUmVnRXhwIiwic3BsaXQiLCJhZGQiLCJfc3JjIiwiZm9yRWFjaCIsImpvaW4iLCJvcGVuIiwiY2xvc2UiLCJleCIsImZmIiwiZmlsZW5hbWUiLCJtYXRjaEJhc2UiLCJmbGlwTmVnYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/unescape.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/node_modules/minimatch/dist/mjs/unescape.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: () => (/* binding */ unescape)\n/* harmony export */ });\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */ const unescape = (s, { windowsPathsNoEscape = false } = {})=>{\n    return windowsPathsNoEscape ? s.replace(/\\[([^\\/\\\\])\\]/g, \"$1\") : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, \"$1$2\").replace(/\\\\([^\\/])/g, \"$1\");\n}; //# sourceMappingURL=unescape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvdW5lc2NhcGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNQSxXQUFXLENBQUNDLEdBQUcsRUFBRUMsdUJBQXVCLEtBQUssRUFBRyxHQUFHLENBQUMsQ0FBQztJQUM5RCxPQUFPQSx1QkFDREQsRUFBRUUsT0FBTyxDQUFDLGtCQUFrQixRQUM1QkYsRUFBRUUsT0FBTyxDQUFDLDZCQUE2QixRQUFRQSxPQUFPLENBQUMsY0FBYztBQUMvRSxFQUFFLENBQ0Ysb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhdmVsX3BsYW5lci8uL25vZGVfbW9kdWxlcy9idWxsbXEvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L21qcy91bmVzY2FwZS5qcz81NTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW4tZXNjYXBlIGEgc3RyaW5nIHRoYXQgaGFzIGJlZW4gZXNjYXBlZCB3aXRoIHtAbGluayBlc2NhcGV9LlxuICpcbiAqIElmIHRoZSB7QGxpbmsgd2luZG93c1BhdGhzTm9Fc2NhcGV9IG9wdGlvbiBpcyB1c2VkLCB0aGVuIHNxdWFyZS1icmFjZVxuICogZXNjYXBlcyBhcmUgcmVtb3ZlZCwgYnV0IG5vdCBiYWNrc2xhc2ggZXNjYXBlcy4gIEZvciBleGFtcGxlLCBpdCB3aWxsIHR1cm5cbiAqIHRoZSBzdHJpbmcgYCdbKl0nYCBpbnRvIGAqYCwgYnV0IGl0IHdpbGwgbm90IHR1cm4gYCdcXFxcKidgIGludG8gYCcqJ2AsXG4gKiBiZWN1YXNlIGBcXGAgaXMgYSBwYXRoIHNlcGFyYXRvciBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUuXG4gKlxuICogV2hlbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIGlzIG5vdCBzZXQsIHRoZW4gYm90aCBicmFjZSBlc2NhcGVzIGFuZFxuICogYmFja3NsYXNoIGVzY2FwZXMgYXJlIHJlbW92ZWQuXG4gKlxuICogU2xhc2hlcyAoYW5kIGJhY2tzbGFzaGVzIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZSkgY2Fubm90IGJlIGVzY2FwZWRcbiAqIG9yIHVuZXNjYXBlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvd3NQYXRoc05vRXNjYXBlXG4gICAgICAgID8gcy5yZXBsYWNlKC9cXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJylcbiAgICAgICAgOiBzLnJlcGxhY2UoLygoPyFcXFxcKS58XilcXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJDInKS5yZXBsYWNlKC9cXFxcKFteXFwvXSkvZywgJyQxJyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5lc2NhcGUuanMubWFwIl0sIm5hbWVzIjpbInVuZXNjYXBlIiwicyIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/node_modules/minimatch/dist/mjs/unescape.js\n");

/***/ })

};
;