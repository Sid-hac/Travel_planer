"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-pro-sidebar";
exports.ids = ["vendor-chunks/react-pro-sidebar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-pro-sidebar/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pro-sidebar/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LevelContext: () => (/* binding */ LevelContext),\n/* harmony export */   Menu: () => (/* binding */ Menu),\n/* harmony export */   MenuContext: () => (/* binding */ MenuContext),\n/* harmony export */   MenuItem: () => (/* binding */ MenuItem),\n/* harmony export */   MenuItemFR: () => (/* binding */ MenuItemFR),\n/* harmony export */   ProSidebarProvider: () => (/* binding */ ProSidebarProvider),\n/* harmony export */   Sidebar: () => (/* binding */ Sidebar),\n/* harmony export */   SidebarContext: () => (/* binding */ SidebarContext),\n/* harmony export */   SubMenu: () => (/* binding */ SubMenu),\n/* harmony export */   SubMenuFR: () => (/* binding */ SubMenuFR),\n/* harmony export */   menuClasses: () => (/* binding */ menuClasses),\n/* harmony export */   sidebarClasses: () => (/* binding */ sidebarClasses),\n/* harmony export */   useProSidebar: () => (/* binding */ useProSidebar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction memoize(fn) {\n    var cache = Object.create(null);\n    return function(arg) {\n        if (cache[arg] === undefined) cache[arg] = fn(arg);\n        return cache[arg];\n    };\n}\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\nvar isPropValid = /* #__PURE__ */ memoize(function(prop) {\n    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n});\n/*\n\nBased off glamor's StyleSheet, thanks Sunil ❤️\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n\n// usage\n\nimport { StyleSheet } from '@emotion/sheet'\n\nlet styleSheet = new StyleSheet({ key: '', container: document.head })\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/ // $FlowFixMe\nfunction sheetForTag(tag) {\n    if (tag.sheet) {\n        // $FlowFixMe\n        return tag.sheet;\n    } // this weirdness brought to you by firefox\n    /* istanbul ignore next */ for(var i = 0; i < document.styleSheets.length; i++){\n        if (document.styleSheets[i].ownerNode === tag) {\n            // $FlowFixMe\n            return document.styleSheets[i];\n        }\n    }\n}\nfunction createStyleElement(options) {\n    var tag = document.createElement(\"style\");\n    tag.setAttribute(\"data-emotion\", options.key);\n    if (options.nonce !== undefined) {\n        tag.setAttribute(\"nonce\", options.nonce);\n    }\n    tag.appendChild(document.createTextNode(\"\"));\n    tag.setAttribute(\"data-s\", \"\");\n    return tag;\n}\nvar StyleSheet = /*#__PURE__*/ function() {\n    // Using Node instead of HTMLElement since container may be a ShadowRoot\n    function StyleSheet(options) {\n        var _this = this;\n        this._insertTag = function(tag) {\n            var before;\n            if (_this.tags.length === 0) {\n                if (_this.insertionPoint) {\n                    before = _this.insertionPoint.nextSibling;\n                } else if (_this.prepend) {\n                    before = _this.container.firstChild;\n                } else {\n                    before = _this.before;\n                }\n            } else {\n                before = _this.tags[_this.tags.length - 1].nextSibling;\n            }\n            _this.container.insertBefore(tag, before);\n            _this.tags.push(tag);\n        };\n        this.isSpeedy = options.speedy === undefined ? \"development\" === \"production\" : options.speedy;\n        this.tags = [];\n        this.ctr = 0;\n        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets\n        this.key = options.key;\n        this.container = options.container;\n        this.prepend = options.prepend;\n        this.insertionPoint = options.insertionPoint;\n        this.before = null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.hydrate = function hydrate(nodes) {\n        nodes.forEach(this._insertTag);\n    };\n    _proto.insert = function insert(rule) {\n        // the max length is how many rules we have per style tag, it's 65000 in speedy mode\n        // it's 1 in dev because we insert source maps that map a single rule to a location\n        // and you can only have one source map per style tag\n        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {\n            this._insertTag(createStyleElement(this));\n        }\n        var tag = this.tags[this.tags.length - 1];\n        if (true) {\n            var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;\n            if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {\n                // this would only cause problem in speedy mode\n                // but we don't want enabling speedy to affect the observable behavior\n                // so we report this error at all times\n                console.error(\"You're attempting to insert the following rule:\\n\" + rule + \"\\n\\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.\");\n            }\n            this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;\n        }\n        if (this.isSpeedy) {\n            var sheet = sheetForTag(tag);\n            try {\n                // this is the ultrafast version, works across browsers\n                // the big drawback is that the css won't be editable in devtools\n                sheet.insertRule(rule, sheet.cssRules.length);\n            } catch (e) {\n                if ( true && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {\n                    console.error('There was a problem inserting the following rule: \"' + rule + '\"', e);\n                }\n            }\n        } else {\n            tag.appendChild(document.createTextNode(rule));\n        }\n        this.ctr++;\n    };\n    _proto.flush = function flush() {\n        // $FlowFixMe\n        this.tags.forEach(function(tag) {\n            return tag.parentNode && tag.parentNode.removeChild(tag);\n        });\n        this.tags = [];\n        this.ctr = 0;\n        if (true) {\n            this._alreadyInsertedOrderInsensitiveRule = false;\n        }\n    };\n    return StyleSheet;\n}();\nvar MS = \"-ms-\";\nvar MOZ = \"-moz-\";\nvar WEBKIT = \"-webkit-\";\nvar COMMENT = \"comm\";\nvar RULESET = \"rule\";\nvar DECLARATION = \"decl\";\nvar IMPORT = \"@import\";\nvar KEYFRAMES = \"@keyframes\";\n/**\n * @param {number}\n * @return {number}\n */ var abs = Math.abs;\n/**\n * @param {number}\n * @return {string}\n */ var from = String.fromCharCode;\n/**\n * @param {object}\n * @return {object}\n */ var assign = Object.assign;\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */ function hash$2(value, length) {\n    return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;\n}\n/**\n * @param {string} value\n * @return {string}\n */ function trim(value) {\n    return value.trim();\n}\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */ function match(value, pattern) {\n    return (value = pattern.exec(value)) ? value[0] : value;\n}\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */ function replace(value, pattern, replacement) {\n    return value.replace(pattern, replacement);\n}\n/**\n * @param {string} value\n * @param {string} search\n * @return {number}\n */ function indexof(value, search) {\n    return value.indexOf(search);\n}\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */ function charat(value, index) {\n    return value.charCodeAt(index) | 0;\n}\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function substr(value, begin, end) {\n    return value.slice(begin, end);\n}\n/**\n * @param {string} value\n * @return {number}\n */ function strlen(value) {\n    return value.length;\n}\n/**\n * @param {any[]} value\n * @return {number}\n */ function sizeof(value) {\n    return value.length;\n}\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */ function append(value, array) {\n    return array.push(value), value;\n}\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */ function combine(array, callback) {\n    return array.map(callback).join(\"\");\n}\nvar line = 1;\nvar column = 1;\nvar length = 0;\nvar position = 0;\nvar character = 0;\nvar characters = \"\";\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {number} length\n */ function node(value, root, parent, type, props, children, length) {\n    return {\n        value: value,\n        root: root,\n        parent: parent,\n        type: type,\n        props: props,\n        children: children,\n        line: line,\n        column: column,\n        length: length,\n        return: \"\"\n    };\n}\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */ function copy(root, props) {\n    return assign(node(\"\", null, null, \"\", null, null, 0), root, {\n        length: -root.length\n    }, props);\n}\n/**\n * @return {number}\n */ function char() {\n    return character;\n}\n/**\n * @return {number}\n */ function prev() {\n    character = position > 0 ? charat(characters, --position) : 0;\n    if (column--, character === 10) column = 1, line--;\n    return character;\n}\n/**\n * @return {number}\n */ function next() {\n    character = position < length ? charat(characters, position++) : 0;\n    if (column++, character === 10) column = 1, line++;\n    return character;\n}\n/**\n * @return {number}\n */ function peek() {\n    return charat(characters, position);\n}\n/**\n * @return {number}\n */ function caret() {\n    return position;\n}\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function slice(begin, end) {\n    return substr(characters, begin, end);\n}\n/**\n * @param {number} type\n * @return {number}\n */ function token(type) {\n    switch(type){\n        // \\0 \\t \\n \\r \\s whitespace token\n        case 0:\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            return 5;\n        // ! + , / > @ ~ isolate token\n        case 33:\n        case 43:\n        case 44:\n        case 47:\n        case 62:\n        case 64:\n        case 126:\n        // ; { } breakpoint token\n        case 59:\n        case 123:\n        case 125:\n            return 4;\n        // : accompanied token\n        case 58:\n            return 3;\n        // \" ' ( [ opening delimit token\n        case 34:\n        case 39:\n        case 40:\n        case 91:\n            return 2;\n        // ) ] closing delimit token\n        case 41:\n        case 93:\n            return 1;\n    }\n    return 0;\n}\n/**\n * @param {string} value\n * @return {any[]}\n */ function alloc(value) {\n    return line = column = 1, length = strlen(characters = value), position = 0, [];\n}\n/**\n * @param {any} value\n * @return {any}\n */ function dealloc(value) {\n    return characters = \"\", value;\n}\n/**\n * @param {number} type\n * @return {string}\n */ function delimit(type) {\n    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));\n}\n/**\n * @param {number} type\n * @return {string}\n */ function whitespace(type) {\n    while(character = peek())if (character < 33) next();\n    else break;\n    return token(type) > 2 || token(character) > 3 ? \"\" : \" \";\n}\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */ function escaping(index, count) {\n    while(--count && next())// not 0-9 A-F a-f\n    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;\n    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));\n}\n/**\n * @param {number} type\n * @return {number}\n */ function delimiter(type) {\n    while(next())switch(character){\n        // ] ) \" '\n        case type:\n            return position;\n        // \" '\n        case 34:\n        case 39:\n            if (type !== 34 && type !== 39) delimiter(character);\n            break;\n        // (\n        case 40:\n            if (type === 41) delimiter(type);\n            break;\n        // \\\n        case 92:\n            next();\n            break;\n    }\n    return position;\n}\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */ function commenter(type, index) {\n    while(next())// //\n    if (type + character === 47 + 10) break;\n    else if (type + character === 42 + 42 && peek() === 47) break;\n    return \"/*\" + slice(index, position - 1) + \"*\" + from(type === 47 ? type : next());\n}\n/**\n * @param {number} index\n * @return {string}\n */ function identifier(index) {\n    while(!token(peek()))next();\n    return slice(index, position);\n}\n/**\n * @param {string} value\n * @return {object[]}\n */ function compile(value) {\n    return dealloc(parse(\"\", null, null, null, [\n        \"\"\n    ], value = alloc(value), 0, [\n        0\n    ], value));\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */ function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n    var index = 0;\n    var offset = 0;\n    var length = pseudo;\n    var atrule = 0;\n    var property = 0;\n    var previous = 0;\n    var variable = 1;\n    var scanning = 1;\n    var ampersand = 1;\n    var character = 0;\n    var type = \"\";\n    var props = rules;\n    var children = rulesets;\n    var reference = rule;\n    var characters = type;\n    while(scanning)switch(previous = character, character = next()){\n        // (\n        case 40:\n            if (previous != 108 && charat(characters, length - 1) == 58) {\n                if (indexof(characters += replace(delimit(character), \"&\", \"&\\f\"), \"&\\f\") != -1) ampersand = -1;\n                break;\n            }\n        // \" ' [\n        case 34:\n        case 39:\n        case 91:\n            characters += delimit(character);\n            break;\n        // \\t \\n \\r \\s\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            characters += whitespace(previous);\n            break;\n        // \\\n        case 92:\n            characters += escaping(caret() - 1, 7);\n            continue;\n        // /\n        case 47:\n            switch(peek()){\n                case 42:\n                case 47:\n                    append(comment(commenter(next(), caret()), root, parent), declarations);\n                    break;\n                default:\n                    characters += \"/\";\n            }\n            break;\n        // {\n        case 123 * variable:\n            points[index++] = strlen(characters) * ampersand;\n        // } ; \\0\n        case 125 * variable:\n        case 59:\n        case 0:\n            switch(character){\n                // \\0 }\n                case 0:\n                case 125:\n                    scanning = 0;\n                // ;\n                case 59 + offset:\n                    if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + \";\", rule, parent, length - 1) : declaration(replace(characters, \" \", \"\") + \";\", rule, parent, length - 2), declarations);\n                    break;\n                // @ ;\n                case 59:\n                    characters += \";\";\n                // { rule/at-rule\n                default:\n                    append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);\n                    if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);\n                    else switch(atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule){\n                        // d m s\n                        case 100:\n                        case 109:\n                        case 115:\n                            parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);\n                            break;\n                        default:\n                            parse(characters, reference, reference, reference, [\n                                \"\"\n                            ], children, 0, points, children);\n                    }\n            }\n            index = offset = property = 0, variable = ampersand = 1, type = characters = \"\", length = pseudo;\n            break;\n        // :\n        case 58:\n            length = 1 + strlen(characters), property = previous;\n        default:\n            if (variable < 1) {\n                if (character == 123) --variable;\n                else if (character == 125 && variable++ == 0 && prev() == 125) continue;\n            }\n            switch(characters += from(character), character * variable){\n                // &\n                case 38:\n                    ampersand = offset > 0 ? 1 : (characters += \"\\f\", -1);\n                    break;\n                // ,\n                case 44:\n                    points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;\n                    break;\n                // @\n                case 64:\n                    // -\n                    if (peek() === 45) characters += delimit(next());\n                    atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;\n                    break;\n                // -\n                case 45:\n                    if (previous === 45 && strlen(characters) == 2) variable = 0;\n            }\n    }\n    return rulesets;\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @return {object}\n */ function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {\n    var post = offset - 1;\n    var rule = offset === 0 ? rules : [\n        \"\"\n    ];\n    var size = sizeof(rule);\n    for(var i = 0, j = 0, k = 0; i < index; ++i)for(var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)if (z = trim(j > 0 ? rule[x] + \" \" + y : replace(y, /&\\f/g, rule[x]))) props[k++] = z;\n    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);\n}\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @return {object}\n */ function comment(value, root, parent) {\n    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @return {object}\n */ function declaration(value, root, parent, length) {\n    return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);\n}\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function serialize(children, callback) {\n    var output = \"\";\n    var length = sizeof(children);\n    for(var i = 0; i < length; i++)output += callback(children[i], i, children, callback) || \"\";\n    return output;\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function stringify(element, index, children, callback) {\n    switch(element.type){\n        case IMPORT:\n        case DECLARATION:\n            return element.return = element.return || element.value;\n        case COMMENT:\n            return \"\";\n        case KEYFRAMES:\n            return element.return = element.value + \"{\" + serialize(element.children, callback) + \"}\";\n        case RULESET:\n            element.value = element.props.join(\",\");\n    }\n    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + \"{\" + children + \"}\" : \"\";\n}\n/**\n * @param {function[]} collection\n * @return {function}\n */ function middleware(collection) {\n    var length = sizeof(collection);\n    return function(element, index, children, callback) {\n        var output = \"\";\n        for(var i = 0; i < length; i++)output += collection[i](element, index, children, callback) || \"\";\n        return output;\n    };\n}\n/**\n * @param {function} callback\n * @return {function}\n */ function rulesheet(callback) {\n    return function(element) {\n        if (!element.root) {\n            if (element = element.return) callback(element);\n        }\n    };\n}\nvar weakMemoize = function weakMemoize(func) {\n    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps\n    var cache = new WeakMap();\n    return function(arg) {\n        if (cache.has(arg)) {\n            // $FlowFixMe\n            return cache.get(arg);\n        }\n        var ret = func(arg);\n        cache.set(arg, ret);\n        return ret;\n    };\n};\nvar identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {\n    var previous = 0;\n    var character = 0;\n    while(true){\n        previous = character;\n        character = peek(); // &\\f\n        if (previous === 38 && character === 12) {\n            points[index] = 1;\n        }\n        if (token(character)) {\n            break;\n        }\n        next();\n    }\n    return slice(begin, position);\n};\nvar toRules = function toRules(parsed, points) {\n    // pretend we've started with a comma\n    var index = -1;\n    var character = 44;\n    do {\n        switch(token(character)){\n            case 0:\n                // &\\f\n                if (character === 38 && peek() === 12) {\n                    // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings\n                    // stylis inserts \\f after & to know when & where it should replace this sequence with the context selector\n                    // and when it should just concatenate the outer and inner selectors\n                    // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here\n                    points[index] = 1;\n                }\n                parsed[index] += identifierWithPointTracking(position - 1, points, index);\n                break;\n            case 2:\n                parsed[index] += delimit(character);\n                break;\n            case 4:\n                // comma\n                if (character === 44) {\n                    // colon\n                    parsed[++index] = peek() === 58 ? \"&\\f\" : \"\";\n                    points[index] = parsed[index].length;\n                    break;\n                }\n            // fallthrough\n            default:\n                parsed[index] += from(character);\n        }\n    }while (character = next());\n    return parsed;\n};\nvar getRules = function getRules(value, points) {\n    return dealloc(toRules(alloc(value), points));\n}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11\nvar fixedElements = /* #__PURE__ */ new WeakMap();\nvar compat = function compat(element) {\n    if (element.type !== \"rule\" || !element.parent || // positive .length indicates that this rule contains pseudo\n    // negative .length indicates that this rule has been already prefixed\n    element.length < 1) {\n        return;\n    }\n    var value = element.value, parent = element.parent;\n    var isImplicitRule = element.column === parent.column && element.line === parent.line;\n    while(parent.type !== \"rule\"){\n        parent = parent.parent;\n        if (!parent) return;\n    } // short-circuit for the simplest case\n    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {\n        return;\n    } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)\n    // then the props has already been manipulated beforehand as they that array is shared between it and its \"rule parent\"\n    if (isImplicitRule) {\n        return;\n    }\n    fixedElements.set(element, true);\n    var points = [];\n    var rules = getRules(value, points);\n    var parentRules = parent.props;\n    for(var i = 0, k = 0; i < rules.length; i++){\n        for(var j = 0; j < parentRules.length; j++, k++){\n            element.props[k] = points[i] ? rules[i].replace(/&\\f/g, parentRules[j]) : parentRules[j] + \" \" + rules[i];\n        }\n    }\n};\nvar removeLabel = function removeLabel(element) {\n    if (element.type === \"decl\") {\n        var value = element.value;\n        if (value.charCodeAt(0) === 108 && // charcode for b\n        value.charCodeAt(2) === 98) {\n            // this ignores label\n            element[\"return\"] = \"\";\n            element.value = \"\";\n        }\n    }\n};\nvar ignoreFlag = \"emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason\";\nvar isIgnoringComment = function isIgnoringComment(element) {\n    return element.type === \"comm\" && element.children.indexOf(ignoreFlag) > -1;\n};\nvar createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {\n    return function(element, index, children) {\n        if (element.type !== \"rule\" || cache.compat) return;\n        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);\n        if (unsafePseudoClasses) {\n            var isNested = element.parent === children[0]; // in nested rules comments become children of the \"auto-inserted\" rule\n            //\n            // considering this input:\n            // .a {\n            //   .b /* comm */ {}\n            //   color: hotpink;\n            // }\n            // we get output corresponding to this:\n            // .a {\n            //   & {\n            //     /* comm */\n            //     color: hotpink;\n            //   }\n            //   .b {}\n            // }\n            var commentContainer = isNested ? children[0].children : children;\n            for(var i = commentContainer.length - 1; i >= 0; i--){\n                var node = commentContainer[i];\n                if (node.line < element.line) {\n                    break;\n                } // it is quite weird but comments are *usually* put at `column: element.column - 1`\n                // so we seek *from the end* for the node that is earlier than the rule's `element` and check that\n                // this will also match inputs like this:\n                // .a {\n                //   /* comm */\n                //   .b {}\n                // }\n                //\n                // but that is fine\n                //\n                // it would be the easiest to change the placement of the comment to be the first child of the rule:\n                // .a {\n                //   .b { /* comm */ }\n                // }\n                // with such inputs we wouldn't have to search for the comment at all\n                // TODO: consider changing this comment placement in the next major version\n                if (node.column < element.column) {\n                    if (isIgnoringComment(node)) {\n                        return;\n                    }\n                    break;\n                }\n            }\n            unsafePseudoClasses.forEach(function(unsafePseudoClass) {\n                console.error('The pseudo class \"' + unsafePseudoClass + '\" is potentially unsafe when doing server-side rendering. Try changing it to \"' + unsafePseudoClass.split(\"-child\")[0] + '-of-type\".');\n            });\n        }\n    };\n};\nvar isImportRule = function isImportRule(element) {\n    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;\n};\nvar isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {\n    for(var i = index - 1; i >= 0; i--){\n        if (!isImportRule(children[i])) {\n            return true;\n        }\n    }\n    return false;\n}; // use this to remove incorrect elements from further processing\n// so they don't get handed to the `sheet` (or anything else)\n// as that could potentially lead to additional logs which in turn could be overhelming to the user\nvar nullifyElement = function nullifyElement(element) {\n    element.type = \"\";\n    element.value = \"\";\n    element[\"return\"] = \"\";\n    element.children = \"\";\n    element.props = \"\";\n};\nvar incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {\n    if (!isImportRule(element)) {\n        return;\n    }\n    if (element.parent) {\n        console.error(\"`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.\");\n        nullifyElement(element);\n    } else if (isPrependedWithRegularRules(index, children)) {\n        console.error(\"`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.\");\n        nullifyElement(element);\n    }\n};\n/* eslint-disable no-fallthrough */ function prefix(value, length) {\n    switch(hash$2(value, length)){\n        // color-adjust\n        case 5103:\n            return WEBKIT + \"print-\" + value + value;\n        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n        case 5737:\n        case 4201:\n        case 3177:\n        case 3433:\n        case 1641:\n        case 4457:\n        case 2921:\n        case 5572:\n        case 6356:\n        case 5844:\n        case 3191:\n        case 6645:\n        case 3005:\n        case 6391:\n        case 5879:\n        case 5623:\n        case 6135:\n        case 4599:\n        case 4855:\n        case 4215:\n        case 6389:\n        case 5109:\n        case 5365:\n        case 5621:\n        case 3829:\n            return WEBKIT + value + value;\n        // appearance, user-select, transform, hyphens, text-size-adjust\n        case 5349:\n        case 4246:\n        case 4810:\n        case 6968:\n        case 2756:\n            return WEBKIT + value + MOZ + value + MS + value + value;\n        // flex, flex-direction\n        case 6828:\n        case 4268:\n            return WEBKIT + value + MS + value + value;\n        // order\n        case 6165:\n            return WEBKIT + value + MS + \"flex-\" + value + value;\n        // align-items\n        case 5187:\n            return WEBKIT + value + replace(value, /(\\w+).+(:[^]+)/, WEBKIT + \"box-$1$2\" + MS + \"flex-$1$2\") + value;\n        // align-self\n        case 5443:\n            return WEBKIT + value + MS + \"flex-item-\" + replace(value, /flex-|-self/, \"\") + value;\n        // align-content\n        case 4675:\n            return WEBKIT + value + MS + \"flex-line-pack\" + replace(value, /align-content|flex-|-self/, \"\") + value;\n        // flex-shrink\n        case 5548:\n            return WEBKIT + value + MS + replace(value, \"shrink\", \"negative\") + value;\n        // flex-basis\n        case 5292:\n            return WEBKIT + value + MS + replace(value, \"basis\", \"preferred-size\") + value;\n        // flex-grow\n        case 6060:\n            return WEBKIT + \"box-\" + replace(value, \"-grow\", \"\") + WEBKIT + value + MS + replace(value, \"grow\", \"positive\") + value;\n        // transition\n        case 4554:\n            return WEBKIT + replace(value, /([^-])(transform)/g, \"$1\" + WEBKIT + \"$2\") + value;\n        // cursor\n        case 6187:\n            return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + \"$1\"), /(image-set)/, WEBKIT + \"$1\"), value, \"\") + value;\n        // background, background-image\n        case 5495:\n        case 3959:\n            return replace(value, /(image-set\\([^]*)/, WEBKIT + \"$1\" + \"$`$1\");\n        // justify-content\n        case 4968:\n            return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + \"box-pack:$3\" + MS + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + WEBKIT + value + value;\n        // (margin|padding)-inline-(start|end)\n        case 4095:\n        case 3583:\n        case 4068:\n        case 2532:\n            return replace(value, /(.+)-inline(.+)/, WEBKIT + \"$1$2\") + value;\n        // (min|max)?(width|height|inline-size|block-size)\n        case 8116:\n        case 7059:\n        case 5753:\n        case 5535:\n        case 5445:\n        case 5701:\n        case 4933:\n        case 4677:\n        case 5533:\n        case 5789:\n        case 5021:\n        case 4765:\n            // stretch, max-content, min-content, fill-available\n            if (strlen(value) - 1 - length > 6) switch(charat(value, length + 1)){\n                // (m)ax-content, (m)in-content\n                case 109:\n                    // -\n                    if (charat(value, length + 4) !== 45) break;\n                // (f)ill-available, (f)it-content\n                case 102:\n                    return replace(value, /(.+:)(.+)-([^]+)/, \"$1\" + WEBKIT + \"$2-$3\" + \"$1\" + MOZ + (charat(value, length + 3) == 108 ? \"$3\" : \"$2-$3\")) + value;\n                // (s)tretch\n                case 115:\n                    return ~indexof(value, \"stretch\") ? prefix(replace(value, \"stretch\", \"fill-available\"), length) + value : value;\n            }\n            break;\n        // position: sticky\n        case 4949:\n            // (s)ticky?\n            if (charat(value, length + 1) !== 115) break;\n        // display: (flex|inline-flex)\n        case 6444:\n            switch(charat(value, strlen(value) - 3 - (~indexof(value, \"!important\") && 10))){\n                // stic(k)y\n                case 107:\n                    return replace(value, \":\", \":\" + WEBKIT) + value;\n                // (inline-)?fl(e)x\n                case 101:\n                    return replace(value, /(.+:)([^;!]+)(;|!.+)?/, \"$1\" + WEBKIT + (charat(value, 14) === 45 ? \"inline-\" : \"\") + \"box$3\" + \"$1\" + WEBKIT + \"$2$3\" + \"$1\" + MS + \"$2box$3\") + value;\n            }\n            break;\n        // writing-mode\n        case 5936:\n            switch(charat(value, length + 11)){\n                // vertical-l(r)\n                case 114:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb\") + value;\n                // vertical-r(l)\n                case 108:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + value;\n                // horizontal(-)tb\n                case 45:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"lr\") + value;\n            }\n            return WEBKIT + value + MS + value + value;\n    }\n    return value;\n}\nvar prefixer = function prefixer(element, index, children, callback) {\n    if (element.length > -1) {\n        if (!element[\"return\"]) switch(element.type){\n            case DECLARATION:\n                element[\"return\"] = prefix(element.value, element.length);\n                break;\n            case KEYFRAMES:\n                return serialize([\n                    copy(element, {\n                        value: replace(element.value, \"@\", \"@\" + WEBKIT)\n                    })\n                ], callback);\n            case RULESET:\n                if (element.length) return combine(element.props, function(value) {\n                    switch(match(value, /(::plac\\w+|:read-\\w+)/)){\n                        // :read-(only|write)\n                        case \":read-only\":\n                        case \":read-write\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(read-\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                })\n                            ], callback);\n                        // :placeholder\n                        case \"::placeholder\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + WEBKIT + \"input-$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, MS + \"input-$1\")\n                                    ]\n                                })\n                            ], callback);\n                    }\n                    return \"\";\n                });\n        }\n    }\n};\nvar isBrowser$5 = typeof document !== \"undefined\";\nvar getServerStylisCache = isBrowser$5 ? undefined : weakMemoize(function() {\n    return memoize(function() {\n        var cache = {};\n        return function(name) {\n            return cache[name];\n        };\n    });\n});\nvar defaultStylisPlugins = [\n    prefixer\n];\nvar createCache = function createCache(options) {\n    var key = options.key;\n    if ( true && !key) {\n        throw new Error(\"You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\\n\" + 'If multiple caches share the same key they might \"fight\" for each other\\'s style elements.');\n    }\n    if (isBrowser$5 && key === \"css\") {\n        var ssrStyles = document.querySelectorAll(\"style[data-emotion]:not([data-s])\"); // get SSRed styles out of the way of React's hydration\n        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)\n        // note this very very intentionally targets all style elements regardless of the key to ensure\n        // that creating a cache works inside of render of a React component\n        Array.prototype.forEach.call(ssrStyles, function(node) {\n            // we want to only move elements which have a space in the data-emotion attribute value\n            // because that indicates that it is an Emotion 11 server-side rendered style elements\n            // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector\n            // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)\n            // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles\n            // will not result in the Emotion 10 styles being destroyed\n            var dataEmotionAttribute = node.getAttribute(\"data-emotion\");\n            if (dataEmotionAttribute.indexOf(\" \") === -1) {\n                return;\n            }\n            document.head.appendChild(node);\n            node.setAttribute(\"data-s\", \"\");\n        });\n    }\n    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;\n    if (true) {\n        // $FlowFixMe\n        if (/[^a-z-]/.test(key)) {\n            throw new Error('Emotion key must only contain lower case alphabetical characters and - but \"' + key + '\" was passed');\n        }\n    }\n    var inserted = {};\n    var container;\n    var nodesToHydrate = [];\n    if (isBrowser$5) {\n        container = options.container || document.head;\n        Array.prototype.forEach.call(// means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n        document.querySelectorAll('style[data-emotion^=\"' + key + ' \"]'), function(node) {\n            var attrib = node.getAttribute(\"data-emotion\").split(\" \"); // $FlowFixMe\n            for(var i = 1; i < attrib.length; i++){\n                inserted[attrib[i]] = true;\n            }\n            nodesToHydrate.push(node);\n        });\n    }\n    var _insert;\n    var omnipresentPlugins = [\n        compat,\n        removeLabel\n    ];\n    if (true) {\n        omnipresentPlugins.push(createUnsafeSelectorsAlarm({\n            get compat () {\n                return cache.compat;\n            }\n        }), incorrectImportAlarm);\n    }\n    if (isBrowser$5) {\n        var currentSheet;\n        var finalizingPlugins = [\n            stringify,\n             true ? function(element) {\n                if (!element.root) {\n                    if (element[\"return\"]) {\n                        currentSheet.insert(element[\"return\"]);\n                    } else if (element.value && element.type !== COMMENT) {\n                        // insert empty rule in non-production environments\n                        // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet\n                        currentSheet.insert(element.value + \"{}\");\n                    }\n                }\n            } : 0\n        ];\n        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));\n        var stylis = function stylis(styles) {\n            return serialize(compile(styles), serializer);\n        };\n        _insert = function insert(selector, serialized, sheet, shouldCache) {\n            currentSheet = sheet;\n            if ( true && serialized.map !== undefined) {\n                currentSheet = {\n                    insert: function insert(rule) {\n                        sheet.insert(rule + serialized.map);\n                    }\n                };\n            }\n            stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            if (shouldCache) {\n                cache.inserted[serialized.name] = true;\n            }\n        };\n    } else {\n        var _finalizingPlugins = [\n            stringify\n        ];\n        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));\n        var _stylis = function _stylis(styles) {\n            return serialize(compile(styles), _serializer);\n        }; // $FlowFixMe\n        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);\n        var getRules = function getRules(selector, serialized) {\n            var name = serialized.name;\n            if (serverStylisCache[name] === undefined) {\n                serverStylisCache[name] = _stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            }\n            return serverStylisCache[name];\n        };\n        _insert = function _insert(selector, serialized, sheet, shouldCache) {\n            var name = serialized.name;\n            var rules = getRules(selector, serialized);\n            if (cache.compat === undefined) {\n                // in regular mode, we don't set the styles on the inserted cache\n                // since we don't need to and that would be wasting memory\n                // we return them so that they are rendered in a style tag\n                if (shouldCache) {\n                    cache.inserted[name] = true;\n                }\n                if (// because if people do ssr in tests, the source maps showing up would be annoying\n                 true && serialized.map !== undefined) {\n                    return rules + serialized.map;\n                }\n                return rules;\n            } else {\n                // in compat mode, we put the styles on the inserted cache so\n                // that emotion-server can pull out the styles\n                // except when we don't want to cache it which was in Global but now\n                // is nowhere but we don't want to do a major right now\n                // and just in case we're going to leave the case here\n                // it's also not affecting client side bundle size\n                // so it's really not a big deal\n                if (shouldCache) {\n                    cache.inserted[name] = rules;\n                } else {\n                    return rules;\n                }\n            }\n        };\n    }\n    var cache = {\n        key: key,\n        sheet: new StyleSheet({\n            key: key,\n            container: container,\n            nonce: options.nonce,\n            speedy: options.speedy,\n            prepend: options.prepend,\n            insertionPoint: options.insertionPoint\n        }),\n        nonce: options.nonce,\n        inserted: inserted,\n        registered: {},\n        insert: _insert\n    };\n    cache.sheet.hydrate(nodesToHydrate);\n    return cache;\n};\nvar isBrowser$4 = typeof document !== \"undefined\";\nfunction getRegisteredStyles$1(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles$1 = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$4 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles$1 = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles$1(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$4 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$4 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2$1(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys$1 = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$2 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR$1 = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex$1 = /[A-Z]|^ms/g;\nvar animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty$1 = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue$1 = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName$1 = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, \"-$&\").toLowerCase();\n});\nvar processStyleValue$1 = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex$1, function(match, p1, p2) {\n                        cursor$1 = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor$1\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys$1[key] !== 1 && !isCustomProperty$1(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern$1 = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues$1 = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue$1 = processStyleValue$1;\n    var msPattern$1 = /^-ms-/;\n    var hyphenPattern$1 = /-(.)/g;\n    var hyphenatedCache$1 = {};\n    processStyleValue$1 = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues$1.indexOf(value) === -1 && !contentValuePattern$1.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue$1(key, value);\n        if (processed !== \"\" && !isCustomProperty$1(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache$1[key] === undefined) {\n            hyphenatedCache$1[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern$1, \"ms-\").replace(hyphenPattern$1, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage$1 = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation$1(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage$1);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor$1 = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor$1\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor$1 = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor$1\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject$1(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor$1;\n                    var result = interpolation(mergedProps);\n                    cursor$1 = previousCursor;\n                    return handleInterpolation$1(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex$1, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject$1(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation$1(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue$1(value)) {\n                    string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage$1);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue$1(value[_i])) {\n                            string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation$1(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName$1(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR$1);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern$1 = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern$1;\nif (true) {\n    sourceMapPattern$1 = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor$1;\nvar serializeStyles$1 = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor$1 = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation$1(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation$1(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern$1, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern$1.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern$1.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2$1(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor$1,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor$1\n    };\n};\nvar isBrowser$3 = typeof document !== \"undefined\";\nvar syncFallback = function syncFallback(create) {\n    return create();\n};\nvar useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] ? react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] : false;\nvar useInsertionEffectAlwaysWithSyncFallback = !isBrowser$3 ? syncFallback : useInsertionEffect || syncFallback;\nvar isBrowser$2 = typeof document !== \"undefined\";\nvar hasOwnProperty = {}.hasOwnProperty;\nvar EmotionCacheContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(// because this module is primarily intended for the browser and node\n// but it's also required in react native and similar environments sometimes\n// and we could have a special build just for that\n// but this is much easier and the native packages\n// might use a different theme context in the future anyway\ntypeof HTMLElement !== \"undefined\" ? /* #__PURE__ */ createCache({\n    key: \"css\"\n}) : null);\nif (true) {\n    EmotionCacheContext.displayName = \"EmotionCacheContext\";\n}\nEmotionCacheContext.Provider;\nvar withEmotionCache = function withEmotionCache(func) {\n    // $FlowFixMe\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(props, ref) {\n        // the cache will never be null in the browser\n        var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n        return func(props, cache, ref);\n    });\n};\nif (!isBrowser$2) {\n    withEmotionCache = function withEmotionCache(func) {\n        return function(props) {\n            var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n            if (cache === null) {\n                // yes, we're potentially creating this on every render\n                // it doesn't actually matter though since it's only on the server\n                // so there will only every be a single render\n                // that could change in the future because of suspense and etc. but for now,\n                // this works and i don't want to optimise for a future thing that we aren't sure about\n                cache = createCache({\n                    key: \"css\"\n                });\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmotionCacheContext.Provider, {\n                    value: cache\n                }, func(props, cache));\n            } else {\n                return func(props, cache);\n            }\n        };\n    };\n}\nvar ThemeContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nif (true) {\n    ThemeContext.displayName = \"EmotionThemeContext\";\n}\nvar typePropName = \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\";\nvar labelPropName = \"__EMOTION_LABEL_PLEASE_DO_NOT_USE__\";\nvar Insertion$1 = function Insertion(_ref) {\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles$1(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles$1(cache, serialized, isStringTag);\n    });\n    if (!isBrowser$2 && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\nvar Emotion = /* #__PURE__ */ withEmotionCache(function(props, cache, ref) {\n    var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works\n    // not passing the registered cache to serializeStyles because it would\n    // make certain babel optimisations not possible\n    if (typeof cssProp === \"string\" && cache.registered[cssProp] !== undefined) {\n        cssProp = cache.registered[cssProp];\n    }\n    var WrappedComponent = props[typePropName];\n    var registeredStyles = [\n        cssProp\n    ];\n    var className = \"\";\n    if (typeof props.className === \"string\") {\n        className = getRegisteredStyles$1(cache.registered, registeredStyles, props.className);\n    } else if (props.className != null) {\n        className = props.className + \" \";\n    }\n    var serialized = serializeStyles$1(registeredStyles, undefined, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext));\n    if ( true && serialized.name.indexOf(\"-\") === -1) {\n        var labelFromStack = props[labelPropName];\n        if (labelFromStack) {\n            serialized = serializeStyles$1([\n                serialized,\n                \"label:\" + labelFromStack + \";\"\n            ]);\n        }\n    }\n    className += cache.key + \"-\" + serialized.name;\n    var newProps = {};\n    for(var key in props){\n        if (hasOwnProperty.call(props, key) && key !== \"css\" && key !== typePropName && ( false || key !== labelPropName)) {\n            newProps[key] = props[key];\n        }\n    }\n    newProps.ref = ref;\n    newProps.className = className;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion$1, {\n        cache: cache,\n        serialized: serialized,\n        isStringTag: typeof WrappedComponent === \"string\"\n    }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, newProps));\n});\nif (true) {\n    Emotion.displayName = \"EmotionCssPropInternal\";\n}\nvar isBrowser$1 = typeof document !== \"undefined\";\nfunction getRegisteredStyles(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$1 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$1 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$1 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex = /[A-Z]|^ms/g;\nvar animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, \"-$&\").toLowerCase();\n});\nvar processStyleValue = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex, function(match, p1, p2) {\n                        cursor = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue = processStyleValue;\n    var msPattern = /^-ms-/;\n    var hyphenPattern = /-(.)/g;\n    var hyphenatedCache = {};\n    processStyleValue = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue(key, value);\n        if (processed !== \"\" && !isCustomProperty(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache[key] === undefined) {\n            hyphenatedCache[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern, \"ms-\").replace(hyphenPattern, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor;\n                    var result = interpolation(mergedProps);\n                    cursor = previousCursor;\n                    return handleInterpolation(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue(value)) {\n                    string += processStyleName(_key) + \":\" + processStyleValue(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue(value[_i])) {\n                            string += processStyleName(_key) + \":\" + processStyleValue(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern;\nif (true) {\n    sourceMapPattern = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor;\nvar serializeStyles = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor\n    };\n};\nvar testOmitPropsOnStringTag = isPropValid;\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n    return key !== \"theme\";\n};\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n    return typeof tag === \"string\" && // 96 is one less than the char code\n    // for \"a\" so this is checking that\n    // it's a lowercase character\n    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n    var shouldForwardProp;\n    if (options) {\n        var optionsShouldForwardProp = options.shouldForwardProp;\n        shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {\n            return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n        } : optionsShouldForwardProp;\n    }\n    if (typeof shouldForwardProp !== \"function\" && isReal) {\n        shouldForwardProp = tag.__emotion_forwardProp;\n    }\n    return shouldForwardProp;\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar isBrowser = typeof document !== \"undefined\";\nvar Insertion = function Insertion(_ref) {\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles(cache, serialized, isStringTag);\n    });\n    if (!isBrowser && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\nvar createStyled = function createStyled(tag, options) {\n    if (true) {\n        if (tag === undefined) {\n            throw new Error(\"You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.\");\n        }\n    }\n    var isReal = tag.__emotion_real === tag;\n    var baseTag = isReal && tag.__emotion_base || tag;\n    var identifierName;\n    var targetClassName;\n    if (options !== undefined) {\n        identifierName = options.label;\n        targetClassName = options.target;\n    }\n    var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n    var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n    var shouldUseAs = !defaultShouldForwardProp(\"as\");\n    return function() {\n        var args = arguments;\n        var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n        if (identifierName !== undefined) {\n            styles.push(\"label:\" + identifierName + \";\");\n        }\n        if (args[0] == null || args[0].raw === undefined) {\n            styles.push.apply(styles, args);\n        } else {\n            if ( true && args[0][0] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n            }\n            styles.push(args[0][0]);\n            var len = args.length;\n            var i = 1;\n            for(; i < len; i++){\n                if ( true && args[0][i] === undefined) {\n                    console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n                }\n                styles.push(args[i], args[0][i]);\n            }\n        } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n        var Styled = withEmotionCache(function(props, cache, ref) {\n            var FinalTag = shouldUseAs && props.as || baseTag;\n            var className = \"\";\n            var classInterpolations = [];\n            var mergedProps = props;\n            if (props.theme == null) {\n                mergedProps = {};\n                for(var key in props){\n                    mergedProps[key] = props[key];\n                }\n                mergedProps.theme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);\n            }\n            if (typeof props.className === \"string\") {\n                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n            } else if (props.className != null) {\n                className = props.className + \" \";\n            }\n            var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n            className += cache.key + \"-\" + serialized.name;\n            if (targetClassName !== undefined) {\n                className += \" \" + targetClassName;\n            }\n            var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;\n            var newProps = {};\n            for(var _key in props){\n                if (shouldUseAs && _key === \"as\") continue;\n                if (finalShouldForwardProp(_key)) {\n                    newProps[_key] = props[_key];\n                }\n            }\n            newProps.className = className;\n            newProps.ref = ref;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion, {\n                cache: cache,\n                serialized: serialized,\n                isStringTag: typeof FinalTag === \"string\"\n            }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FinalTag, newProps));\n        });\n        Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === \"string\" ? baseTag : baseTag.displayName || baseTag.name || \"Component\") + \")\";\n        Styled.defaultProps = tag.defaultProps;\n        Styled.__emotion_real = Styled;\n        Styled.__emotion_base = baseTag;\n        Styled.__emotion_styles = styles;\n        Styled.__emotion_forwardProp = shouldForwardProp;\n        Object.defineProperty(Styled, \"toString\", {\n            value: function value() {\n                if (targetClassName === undefined && \"development\" !== \"production\") {\n                    return \"NO_COMPONENT_SELECTOR\";\n                } // $FlowFixMe: coerce undefined to string\n                return \".\" + targetClassName;\n            }\n        });\n        Styled.withComponent = function(nextTag, nextOptions) {\n            return createStyled(nextTag, _extends({}, options, nextOptions, {\n                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n            })).apply(void 0, styles);\n        };\n        return Styled;\n    };\n};\nvar tags = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n];\nvar newStyled = createStyled.bind();\ntags.forEach(function(tagName) {\n    // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n    newStyled[tagName] = newStyled(tagName);\n});\nvar classnames$1 = {\n    exports: {}\n};\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/ (function(module) {\n    /* global define */ (function() {\n        var hasOwn = {}.hasOwnProperty;\n        function classNames() {\n            var classes = [];\n            for(var i = 0; i < arguments.length; i++){\n                var arg = arguments[i];\n                if (!arg) continue;\n                var argType = typeof arg;\n                if (argType === \"string\" || argType === \"number\") {\n                    classes.push(arg);\n                } else if (Array.isArray(arg)) {\n                    if (arg.length) {\n                        var inner = classNames.apply(null, arg);\n                        if (inner) {\n                            classes.push(inner);\n                        }\n                    }\n                } else if (argType === \"object\") {\n                    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n                        classes.push(arg.toString());\n                        continue;\n                    }\n                    for(var key in arg){\n                        if (hasOwn.call(arg, key) && arg[key]) {\n                            classes.push(key);\n                        }\n                    }\n                }\n            }\n            return classes.join(\" \");\n        }\n        if (module.exports) {\n            classNames.default = classNames;\n            module.exports = classNames;\n        } else {\n            window.classNames = classNames;\n        }\n    })();\n})(classnames$1);\nvar classnames = classnames$1.exports;\nvar LegacySidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar SidebarProvider = function(_a) {\n    var children = _a.children;\n    var _b = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n        collapsed: false,\n        toggled: false,\n        broken: false,\n        rtl: false,\n        transitionDuration: 300\n    }), sidebarState = _b[0], setSidebarState = _b[1];\n    var updateSidebarState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(values) {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), values);\n        });\n    }, []);\n    var updateCollapseState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                collapsed: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.collapsed)\n            });\n        });\n    }, []);\n    var updateToggleState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                toggled: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.toggled)\n            });\n        });\n    }, []);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return __assign(__assign({}, sidebarState), {\n            updateSidebarState: updateSidebarState,\n            updateCollapseState: updateCollapseState,\n            updateToggleState: updateToggleState\n        });\n    }, [\n        sidebarState,\n        updateCollapseState,\n        updateSidebarState,\n        updateToggleState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LegacySidebarContext.Provider, {\n        value: providerValue\n    }, children);\n};\nvar useLegacySidebar = function() {\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LegacySidebarContext);\n    return context;\n};\nvar useMediaQuery = function(breakpoint) {\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!breakpoint && \"undefined\" !== \"undefined\" && 0), matches = _a[0], setMatches = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (breakpoint) {\n            var media_1 = window.matchMedia(breakpoint);\n            var handleMatch_1 = function() {\n                if (media_1.matches !== matches) {\n                    setMatches(media_1.matches);\n                }\n            };\n            handleMatch_1();\n            media_1.addEventListener(\"change\", handleMatch_1);\n            return function() {\n                return media_1.removeEventListener(\"change\", handleMatch_1);\n            };\n        }\n    }, [\n        matches,\n        breakpoint\n    ]);\n    return matches;\n};\nvar sidebarClasses = {\n    root: \"ps-sidebar-root\",\n    container: \"ps-sidebar-container\",\n    image: \"ps-sidebar-image\",\n    backdrop: \"ps-sidebar-backdrop\",\n    collapsed: \"ps-collapsed\",\n    toggled: \"ps-toggled\",\n    rtl: \"ps-rtl\",\n    broken: \"ps-broken\"\n};\nvar menuClasses = {\n    root: \"ps-menu-root\",\n    menuItemRoot: \"ps-menuitem-root\",\n    subMenuRoot: \"ps-submenu-root\",\n    button: \"ps-menu-button\",\n    prefix: \"ps-menu-prefix\",\n    suffix: \"ps-menu-suffix\",\n    label: \"ps-menu-label\",\n    icon: \"ps-menu-icon\",\n    subMenuContent: \"ps-submenu-content\",\n    SubMenuExpandIcon: \"ps-submenu-expand-icon\",\n    disabled: \"ps-disabled\",\n    active: \"ps-active\",\n    open: \"ps-open\"\n};\nvar StyledBackdrop = newStyled.div(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n], [\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n])));\nvar templateObject_1$b;\nvar BREAK_POINTS = {\n    xs: \"480px\",\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n    xxl: \"1600px\",\n    always: \"always\",\n    all: \"all\"\n};\nvar StyledSidebar = newStyled.aside(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return \"width, left, right, \".concat(transitionDuration, \"ms\");\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.rtl, sidebarClasses.broken, function(_a) {\n    var rtl = _a.rtl, width = _a.width;\n    return !rtl ? \"left: -\".concat(width, \";\") : \"\";\n}, sidebarClasses.collapsed, function(_a) {\n    var rtl = _a.rtl, collapsedWidth = _a.collapsedWidth;\n    return !rtl ? \"left: -\".concat(collapsedWidth, \"; \") : \"\";\n}, sidebarClasses.toggled, function(_a) {\n    var rtl = _a.rtl;\n    return !rtl ? \"left: 0;\" : \"\";\n}, sidebarClasses.rtl, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.toggled, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar StyledSidebarContainer = newStyled.div(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var backgroundColor = _a.backgroundColor;\n    return backgroundColor ? \"background-color:\".concat(backgroundColor, \";\") : \"\";\n});\nvar StyledSidebarImage = newStyled.img(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n])), sidebarClasses.image);\nvar SidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    collapsed: false,\n    toggled: false,\n    rtl: false,\n    transitionDuration: 300\n});\nvar Sidebar = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function(_a, ref) {\n    var _b;\n    var collapsed = _a.collapsed, toggled = _a.toggled, onBackdropClick = _a.onBackdropClick, onBreakPoint = _a.onBreakPoint, _c = _a.width, width = _c === void 0 ? \"250px\" : _c, _d = _a.collapsedWidth, collapsedWidth = _d === void 0 ? \"80px\" : _d, defaultCollapsed = _a.defaultCollapsed, className = _a.className, children = _a.children, breakPoint = _a.breakPoint, customBreakPoint = _a.customBreakPoint, _e = _a.backgroundColor, backgroundColor = _e === void 0 ? \"rgb(249, 249, 249, 0.7)\" : _e, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, image = _a.image, rtl = _a.rtl, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"collapsed\",\n        \"toggled\",\n        \"onBackdropClick\",\n        \"onBreakPoint\",\n        \"width\",\n        \"collapsedWidth\",\n        \"defaultCollapsed\",\n        \"className\",\n        \"children\",\n        \"breakPoint\",\n        \"customBreakPoint\",\n        \"backgroundColor\",\n        \"transitionDuration\",\n        \"image\",\n        \"rtl\",\n        \"rootStyles\"\n    ]);\n    var getBreakpointValue = function() {\n        if (customBreakPoint) {\n            return \"(max-width: \".concat(customBreakPoint, \")\");\n        }\n        if (breakPoint) {\n            if ([\n                \"xs\",\n                \"sm\",\n                \"md\",\n                \"lg\",\n                \"xl\",\n                \"xxl\"\n            ].includes(breakPoint)) {\n                return \"(max-width: \".concat(BREAK_POINTS[breakPoint], \")\");\n            }\n            if (breakPoint === \"always\" || breakPoint === \"all\") {\n                if (breakPoint === \"always\") {\n                    console.warn('The \"always\" breakPoint is deprecated and will be removed in future release. ' + 'Please use the \"all\" breakPoint instead.');\n                }\n                return \"screen\";\n            }\n            return \"(max-width: \".concat(breakPoint, \")\");\n        }\n    };\n    var breakpointCallbackFnRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    breakpointCallbackFnRef.current = function(broken) {\n        onBreakPoint === null || onBreakPoint === void 0 ? void 0 : onBreakPoint(broken);\n    };\n    var broken = useMediaQuery(getBreakpointValue());\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _g[0], setMounted = _g[1];\n    var legacySidebarContext = useLegacySidebar();\n    var collapsedValue = collapsed !== null && collapsed !== void 0 ? collapsed : !mounted && defaultCollapsed ? true : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.collapsed;\n    var toggledValue = toggled !== null && toggled !== void 0 ? toggled : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.toggled;\n    var handleBackdropClick = function() {\n        onBackdropClick === null || onBackdropClick === void 0 ? void 0 : onBackdropClick();\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            toggled: false\n        });\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var _a;\n        (_a = breakpointCallbackFnRef.current) === null || _a === void 0 ? void 0 : _a.call(breakpointCallbackFnRef, broken);\n    }, [\n        broken\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            broken: broken,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        broken,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState,\n        rtl,\n        transitionDuration\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!mounted) {\n            legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n                collapsed: defaultCollapsed\n            });\n            setMounted(true);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        defaultCollapsed,\n        mounted,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarContext.Provider, {\n        value: {\n            collapsed: collapsedValue,\n            toggled: toggledValue,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebar, __assign({\n        ref: ref,\n        \"data-testid\": \"\".concat(sidebarClasses.root, \"-test-id\"),\n        rtl: rtl,\n        rootStyles: rootStyles,\n        width: width,\n        collapsedWidth: collapsedWidth,\n        transitionDuration: transitionDuration,\n        className: classnames(sidebarClasses.root, (_b = {}, _b[sidebarClasses.collapsed] = collapsedValue, _b[sidebarClasses.toggled] = toggledValue, _b[sidebarClasses.broken] = broken, _b[sidebarClasses.rtl] = rtl, _b), className)\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarContainer, {\n        \"data-testid\": \"\".concat(sidebarClasses.container, \"-test-id\"),\n        className: sidebarClasses.container,\n        backgroundColor: backgroundColor\n    }, children), image && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarImage, {\n        \"data-testid\": \"\".concat(sidebarClasses.image, \"-test-id\"),\n        src: image,\n        alt: \"sidebar background\",\n        className: sidebarClasses.image\n    }), broken && toggledValue && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledBackdrop, {\n        \"data-testid\": \"\".concat(sidebarClasses.backdrop, \"-test-id\"),\n        role: \"button\",\n        tabIndex: 0,\n        \"aria-label\": \"backdrop\",\n        onClick: handleBackdropClick,\n        onKeyPress: handleBackdropClick,\n        className: sidebarClasses.backdrop\n    })));\n});\nvar templateObject_1$a, templateObject_2$1, templateObject_3$1;\nvar StyledUl = newStyled.ul(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n], [\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n])));\nvar templateObject_1$9;\nvar StyledMenu = newStyled.nav(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n])), menuClasses.root, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar MenuContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar LevelContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(0);\nvar MenuFR = function(_a, ref) {\n    var children = _a.children, className = _a.className, _b = _a.transitionDuration, transitionDuration = _b === void 0 ? 300 : _b, _c = _a.closeOnClick, closeOnClick = _c === void 0 ? false : _c, rootStyles = _a.rootStyles, menuItemStyles = _a.menuItemStyles, renderExpandIcon = _a.renderExpandIcon, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"transitionDuration\",\n        \"closeOnClick\",\n        \"rootStyles\",\n        \"menuItemStyles\",\n        \"renderExpandIcon\"\n    ]);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return {\n            transitionDuration: transitionDuration,\n            closeOnClick: closeOnClick,\n            menuItemStyles: menuItemStyles,\n            renderExpandIcon: renderExpandIcon\n        };\n    }, [\n        transitionDuration,\n        closeOnClick,\n        menuItemStyles,\n        renderExpandIcon\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuContext.Provider, {\n        value: providerValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenu, __assign({\n        ref: ref,\n        className: classnames(menuClasses.root, className),\n        rootStyles: rootStyles\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children))));\n};\nvar Menu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuFR);\nvar templateObject_1$8;\nvar useMenu = function() {\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(MenuContext);\n    if (context === undefined) {\n        //TODO: set better error message\n        throw new Error(\"Menu Component is required!\");\n    }\n    return context;\n};\nvar StyledSubMenuContent = newStyled.div(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\n    \"\\n  height: 0px;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  height: 0px;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed && \"\\n     background-color: white;\\n     box-shadow: 0 3px 6px -4px #0000001f, 0 6px 16px #00000014, 0 9px 28px 8px #0000000d;\\n     \";\n}, function(_a) {\n    var defaultOpen = _a.defaultOpen;\n    return defaultOpen && \"height: auto;display: block;\";\n}, function(_a) {\n    var collapsed = _a.collapsed, firstLevel = _a.firstLevel, openWhenCollapsed = _a.openWhenCollapsed;\n    return collapsed && firstLevel ? \"\\n      position: fixed;\\n      padding-left: 0px;\\n      width: 200px;\\n      border-radius: 4px;\\n      height: auto!important;\\n      display: block!important;     \\n      transition: none!important;     \\n      visibility: \".concat(openWhenCollapsed ? \"visible\" : \"hidden\", \";\\n     \") : \"\\n      position: static!important;\\n      transform: none!important;\\n      \";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar SubMenuContentFR = function(_a, ref) {\n    var children = _a.children, open = _a.open, openWhenCollapsed = _a.openWhenCollapsed, firstLevel = _a.firstLevel, collapsed = _a.collapsed, defaultOpen = _a.defaultOpen, rest = __rest(_a, [\n        \"children\",\n        \"open\",\n        \"openWhenCollapsed\",\n        \"firstLevel\",\n        \"collapsed\",\n        \"defaultOpen\"\n    ]);\n    var transitionDuration = useMenu().transitionDuration;\n    var defaultOpenState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(defaultOpen)[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenuContent, __assign({\n        \"data-testid\": \"\".concat(menuClasses.subMenuContent, \"-test-id\"),\n        ref: ref,\n        firstLevel: firstLevel,\n        collapsed: collapsed,\n        open: open,\n        openWhenCollapsed: openWhenCollapsed,\n        transitionDuration: transitionDuration,\n        defaultOpen: defaultOpenState\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children));\n};\nvar SubMenuContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuContentFR);\nvar templateObject_1$7;\nvar StyledMenuLabel = newStyled.span(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$6;\nvar StyledMenuIcon = newStyled.span(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 10px;\" : \"margin-right: 10px;\";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$5;\nvar StyledMenuPrefix = newStyled.span(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 5px;\" : \"margin-right: 5px;\";\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$4;\nvar StyledMenuSuffix = newStyled.span(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$3;\nvar StyledExpandIconWrapper = newStyled.span(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var collapsed = _a.collapsed, level = _a.level, rtl = _a.rtl;\n    return collapsed && level === 0 && \"\\n    position: absolute;\\n    \".concat(rtl ? \"left: 10px;\" : \"right: 10px;\", \"\\n    top: 50%;\\n    transform: translateY(-50%);\\n    \\n    \");\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar StyledExpandIcon = newStyled.span(templateObject_2 || (templateObject_2 = __makeTemplateObject([\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n], [\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"\\n          border-left: 2px solid currentcolor;\\n          border-top: 2px solid currentcolor;\\n        \" : \" border-right: 2px solid currentcolor;\\n          border-bottom: 2px solid currentcolor;\\n        \";\n}, function(_a) {\n    var open = _a.open, rtl = _a.rtl;\n    return open ? rtl ? \"-135deg\" : \"45deg\" : \"-45deg\";\n});\nvar StyledExpandIconCollapsed = newStyled.span(templateObject_3 || (templateObject_3 = __makeTemplateObject([\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n], [\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n])));\nvar templateObject_1$2, templateObject_2, templateObject_3;\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [\n    top,\n    bottom,\n    right,\n    left\n];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n    return acc.concat([\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []);\nvar placements = /*#__PURE__*/ [].concat(basePlacements, [\n    auto\n]).reduce(function(acc, placement) {\n    return acc.concat([\n        placement,\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []); // modifiers that need to read the DOM\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\"; // pure-logic modifiers\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [\n    beforeRead,\n    read,\n    afterRead,\n    beforeMain,\n    main,\n    afterMain,\n    beforeWrite,\n    write,\n    afterWrite\n];\nfunction getNodeName(element) {\n    return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (node.toString() !== \"[object Window]\") {\n        var ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n// and applies them to the HTMLElements such as popper and arrow\nfunction applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function(name) {\n        var style = state.styles[name] || {};\n        var attributes = state.attributes[name] || {};\n        var element = state.elements[name]; // arrow is optional + virtual elements\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n            return;\n        } // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe[cannot-write]\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function(name) {\n            var value = attributes[name];\n            if (value === false) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value === true ? \"\" : value);\n            }\n        });\n    });\n}\nfunction effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n        popper: {\n            position: state.options.strategy,\n            left: \"0\",\n            top: \"0\",\n            margin: \"0\"\n        },\n        arrow: {\n            position: \"absolute\"\n        },\n        reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function() {\n        Object.keys(state.elements).forEach(function(name) {\n            var element = state.elements[name];\n            var attributes = state.attributes[name] || {};\n            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n            var style = styleProperties.reduce(function(style, property) {\n                style[property] = \"\";\n                return style;\n            }, {}); // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            }\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(attribute) {\n                element.removeAttribute(attribute);\n            });\n        });\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar applyStyles$1 = {\n    name: \"applyStyles\",\n    enabled: true,\n    phase: \"write\",\n    fn: applyStyles,\n    effect: effect$2,\n    requires: [\n        \"computeStyles\"\n    ]\n};\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n        return uaData.brands.map(function(item) {\n            return item.brand + \"/\" + item.version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n        width: width,\n        height: height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x: x,\n        y: y\n    };\n}\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n        width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n        height = clientRect.height;\n    }\n    return {\n        x: element.offsetLeft,\n        y: element.offsetTop,\n        width: width,\n        height: height\n    };\n}\nfunction contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        var next = child;\n        do {\n            if (next && parent.isSameNode(next)) {\n                return true;\n            } // $FlowFixMe[prop-missing]: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    } // Give up, the result is false\n    return false;\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].indexOf(getNodeName(element)) >= 0;\n}\nfunction getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getParentNode(element) {\n    if (getNodeName(element) === \"html\") {\n        return element;\n    }\n    return(// $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n    );\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\nfunction getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n        var elementCss = getComputedStyle(element);\n        if (elementCss.position === \"fixed\") {\n            return null;\n        }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && [\n        \"html\",\n        \"body\"\n    ].indexOf(getNodeName(currentNode)) < 0){\n        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n        // create a containing block.\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n        if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n            \"transform\",\n            \"perspective\"\n        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    var window1 = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n}\nfunction getFreshSideObject() {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n}\nfunction mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n    return keys.reduce(function(hashMap, key) {\n        hashMap[key] = value;\n        return hashMap;\n    }, {});\n}\nvar toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state, name = _ref.name, options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0;\n    var len = isVertical ? \"height\" : \"width\";\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === \"y\" ? top : left;\n    var maxProp = axis === \"y\" ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n    var state = _ref2.state, options = _ref2.options;\n    var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n    if (arrowElement == null) {\n        return;\n    } // CSS selector\n    if (typeof arrowElement === \"string\") {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (true) {\n        if (!isHTMLElement(arrowElement)) {\n            console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\",\n                \"the arrow.\"\n            ].join(\" \"));\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        if (true) {\n            console.error([\n                'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n                \"element.\"\n            ].join(\" \"));\n        }\n        return;\n    }\n    state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\nvar arrow$1 = {\n    name: \"arrow\",\n    enabled: true,\n    phase: \"main\",\n    fn: arrow,\n    effect: effect$1,\n    requires: [\n        \"popperOffsets\"\n    ],\n    requiresIfExists: [\n        \"preventOverflow\"\n    ]\n};\nfunction getVariation(placement) {\n    return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsetsByDPR(_ref) {\n    var x = _ref.x, y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n        x: round(x * dpr) / dpr || 0,\n        y: round(y * dpr) / dpr || 0\n    };\n}\nfunction mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty(\"x\");\n    var hasY = offsets.hasOwnProperty(\"y\");\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n        var offsetParent = getOffsetParent(popper);\n        var heightProp = \"clientHeight\";\n        var widthProp = \"clientWidth\";\n        if (offsetParent === getWindow(popper)) {\n            offsetParent = getDocumentElement(popper);\n            if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n                heightProp = \"scrollHeight\";\n                widthProp = \"scrollWidth\";\n            }\n        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n        offsetParent = offsetParent;\n        if (placement === top || (placement === left || placement === right) && variation === end) {\n            sideY = bottom;\n            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n            y -= offsetY - popperRect.height;\n            y *= gpuAcceleration ? 1 : -1;\n        }\n        if (placement === left || (placement === top || placement === bottom) && variation === end) {\n            sideX = right;\n            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n            x -= offsetX - popperRect.width;\n            x *= gpuAcceleration ? 1 : -1;\n        }\n    }\n    var commonStyles = Object.assign({\n        position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n        var _Object$assign;\n        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n    var state = _ref5.state, options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    if (true) {\n        var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || \"\";\n        if (adaptive && [\n            \"transform\",\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ].some(function(property) {\n            return transitionProperty.indexOf(property) >= 0;\n        })) {\n            console.warn([\n                \"Popper: Detected CSS transitions on at least one of the following\",\n                'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n                \"\\n\\n\",\n                'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n                \"for smooth transitions, or remove these properties from the CSS\",\n                \"transition declaration on the popper element if only transitioning\",\n                \"opacity or background-color for example.\",\n                \"\\n\\n\",\n                \"We recommend using the popper element as a wrapper around an inner\",\n                \"element that can have any CSS property transitioned for animations.\"\n            ].join(\" \"));\n        }\n    }\n    var commonStyles = {\n        placement: getBasePlacement(state.placement),\n        variation: getVariation(state.placement),\n        popper: state.elements.popper,\n        popperRect: state.rects.popper,\n        gpuAcceleration: gpuAcceleration,\n        isFixed: state.options.strategy === \"fixed\"\n    };\n    if (state.modifiersData.popperOffsets != null) {\n        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.popperOffsets,\n            position: state.options.strategy,\n            adaptive: adaptive,\n            roundOffsets: roundOffsets\n        })));\n    }\n    if (state.modifiersData.arrow != null) {\n        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.arrow,\n            position: \"absolute\",\n            adaptive: false,\n            roundOffsets: roundOffsets\n        })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-placement\": state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar computeStyles$1 = {\n    name: \"computeStyles\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    fn: computeStyles,\n    data: {}\n};\nvar passive = {\n    passive: true\n};\nfunction effect(_ref) {\n    var state = _ref.state, instance = _ref.instance, options = _ref.options;\n    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n    var window1 = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n        scrollParents.forEach(function(scrollParent) {\n            scrollParent.addEventListener(\"scroll\", instance.update, passive);\n        });\n    }\n    if (resize) {\n        window1.addEventListener(\"resize\", instance.update, passive);\n    }\n    return function() {\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.removeEventListener(\"resize\", instance.update, passive);\n        }\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar eventListeners = {\n    name: \"eventListeners\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n};\nvar hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function(matched) {\n        return hash$1[matched];\n    });\n}\nvar hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function(matched) {\n        return hash[matched];\n    });\n}\nfunction getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n    };\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        var layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n        x: x + getWindowScrollBarX(element),\n        y: y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].indexOf(getNodeName(node)) >= 0) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n        return node;\n    }\n    return getScrollParent(getParentNode(node));\n}\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/ function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n        list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n        left: rect.x,\n        top: rect.y,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    });\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(function(clippingParent) {\n        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n    });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [\n        rootBoundary\n    ]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n        var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\nfunction computeOffsets(_ref) {\n    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch(basePlacement){\n        case top:\n            offsets = {\n                x: commonX,\n                y: reference.y - element.height\n            };\n            break;\n        case bottom:\n            offsets = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case right:\n            offsets = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case left:\n            offsets = {\n                x: reference.x - element.width,\n                y: commonY\n            };\n            break;\n        default:\n            offsets = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        switch(variation){\n            case start:\n                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                break;\n            case end:\n                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                break;\n        }\n    }\n    return offsets;\n}\nfunction detectOverflow(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: \"absolute\",\n        placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    var overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        var offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(function(key) {\n            var multiply = [\n                right,\n                bottom\n            ].indexOf(key) >= 0 ? 1 : -1;\n            var axis = [\n                top,\n                bottom\n            ].indexOf(key) >= 0 ? \"y\" : \"x\";\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n        return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function(placement) {\n        return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n        allowedPlacements = placements$1;\n        if (true) {\n            console.error([\n                \"Popper: The `allowedAutoPlacements` option did not allow any\",\n                \"placements. Ensure the `placement` option matches the variation\",\n                \"of the allowed placements.\",\n                'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n                'Use \"auto-start\" instead.'\n            ].join(\" \"));\n        }\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n    var overflows = allowedPlacements.reduce(function(acc, placement) {\n        acc[placement] = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding\n        })[getBasePlacement(placement)];\n        return acc;\n    }, {});\n    return Object.keys(overflows).sort(function(a, b) {\n        return overflows[a] - overflows[b];\n    });\n}\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\nfunction flip(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n        getOppositePlacement(preferredPlacement)\n    ] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [\n        preferredPlacement\n    ].concat(fallbackPlacements).reduce(function(acc, placement) {\n        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            flipVariations: flipVariations,\n            allowedAutoPlacements: allowedAutoPlacements\n        }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for(var i = 0; i < placements.length; i++){\n        var placement = placements[i];\n        var _basePlacement = getBasePlacement(placement);\n        var isStartVariation = getVariation(placement) === start;\n        var isVertical = [\n            top,\n            bottom\n        ].indexOf(_basePlacement) >= 0;\n        var len = isVertical ? \"width\" : \"height\";\n        var overflow = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            altBoundary: altBoundary,\n            padding: padding\n        });\n        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        var altVariationSide = getOppositePlacement(mainVariationSide);\n        var checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[_basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(function(check) {\n            return check;\n        })) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        var numberOfChecks = flipVariations ? 3 : 1;\n        var _loop = function _loop(_i) {\n            var fittingPlacement = placements.find(function(placement) {\n                var checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, _i).every(function(check) {\n                        return check;\n                    });\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                return \"break\";\n            }\n        };\n        for(var _i = numberOfChecks; _i > 0; _i--){\n            var _ret = _loop(_i);\n            if (_ret === \"break\") break;\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n} // eslint-disable-next-line import/no-unused-modules\nvar flip$1 = {\n    name: \"flip\",\n    enabled: true,\n    phase: \"main\",\n    fn: flip,\n    requiresIfExists: [\n        \"offset\"\n    ],\n    data: {\n        _skip: false\n    }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n        preventedOffsets = {\n            x: 0,\n            y: 0\n        };\n    }\n    return {\n        top: overflow.top - rect.height - preventedOffsets.y,\n        right: overflow.right - rect.width + preventedOffsets.x,\n        bottom: overflow.bottom - rect.height + preventedOffsets.y,\n        left: overflow.left - rect.width - preventedOffsets.x\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return [\n        top,\n        right,\n        bottom,\n        left\n    ].some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\nfunction hide(_ref) {\n    var state = _ref.state, name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n        elementContext: \"reference\"\n    });\n    var popperAltOverflow = detectOverflow(state, {\n        altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n        referenceClippingOffsets: referenceClippingOffsets,\n        popperEscapeOffsets: popperEscapeOffsets,\n        isReferenceHidden: isReferenceHidden,\n        hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-reference-hidden\": isReferenceHidden,\n        \"data-popper-escaped\": hasPopperEscaped\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar hide$1 = {\n    name: \"hide\",\n    enabled: true,\n    phase: \"main\",\n    requiresIfExists: [\n        \"preventOverflow\"\n    ],\n    fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [\n        left,\n        top\n    ].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n        placement: placement\n    })) : offset, skidding = _ref[0], distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0 ? {\n        x: distance,\n        y: skidding\n    } : {\n        x: skidding,\n        y: distance\n    };\n}\nfunction offset(_ref2) {\n    var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n    var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n        0,\n        0\n    ] : _options$offset;\n    var data = placements.reduce(function(acc, placement) {\n        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n        return acc;\n    }, {});\n    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n        state.modifiersData.popperOffsets.x += x;\n        state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar offset$1 = {\n    name: \"offset\",\n    enabled: true,\n    phase: \"main\",\n    requires: [\n        \"popperOffsets\"\n    ],\n    fn: offset\n};\nfunction popperOffsets(_ref) {\n    var state = _ref.state, name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n        reference: state.rects.reference,\n        element: state.rects.popper,\n        strategy: \"absolute\",\n        placement: state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar popperOffsets$1 = {\n    name: \"popperOffsets\",\n    enabled: true,\n    phase: \"read\",\n    fn: popperOffsets,\n    data: {}\n};\nfunction getAltAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n        mainAxis: tetherOffsetValue,\n        altAxis: tetherOffsetValue\n    } : Object.assign({\n        mainAxis: 0,\n        altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n        x: 0,\n        y: 0\n    };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        var _offsetModifierState$;\n        var mainSide = mainAxis === \"y\" ? top : left;\n        var altSide = mainAxis === \"y\" ? bottom : right;\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var offset = popperOffsets[mainAxis];\n        var min$1 = offset + overflow[mainSide];\n        var max$1 = offset - overflow[altSide];\n        var additive = tether ? -popperRect[len] / 2 : 0;\n        var minLen = variation === start ? referenceRect[len] : popperRect[len];\n        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        var arrowElement = state.elements.arrow;\n        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n            width: 0,\n            height: 0\n        };\n        var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n        var arrowPaddingMin = arrowPaddingObject[mainSide];\n        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n        var tetherMax = offset + maxOffset - offsetModifierValue;\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        var _offsetModifierState$2;\n        var _mainSide = mainAxis === \"x\" ? top : left;\n        var _altSide = mainAxis === \"x\" ? bottom : right;\n        var _offset = popperOffsets[altAxis];\n        var _len = altAxis === \"y\" ? \"height\" : \"width\";\n        var _min = _offset + overflow[_mainSide];\n        var _max = _offset - overflow[_altSide];\n        var isOriginSide = [\n            top,\n            left\n        ].indexOf(basePlacement) !== -1;\n        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar preventOverflow$1 = {\n    name: \"preventOverflow\",\n    enabled: true,\n    phase: \"main\",\n    fn: preventOverflow,\n    requiresIfExists: [\n        \"offset\"\n    ]\n};\nfunction getHTMLElementScroll(element) {\n    return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n    };\n}\nfunction getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n        return getWindowScroll(node);\n    } else {\n        return getHTMLElementScroll(node);\n    }\n}\nfunction isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    var offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n        isScrollParent(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            offsets = getBoundingClientRect(offsetParent, true);\n            offsets.x += offsetParent.clientLeft;\n            offsets.y += offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function(modifier) {\n        map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n    function sort(modifier) {\n        visited.add(modifier.name);\n        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n        requires.forEach(function(dep) {\n            if (!visited.has(dep)) {\n                var depModifier = map.get(dep);\n                if (depModifier) {\n                    sort(depModifier);\n                }\n            }\n        });\n        result.push(modifier);\n    }\n    modifiers.forEach(function(modifier) {\n        if (!visited.has(modifier.name)) {\n            // check for visited object\n            sort(modifier);\n        }\n    });\n    return result;\n}\nfunction orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n    return modifierPhases.reduce(function(acc, phase) {\n        return acc.concat(orderedModifiers.filter(function(modifier) {\n            return modifier.phase === phase;\n        }));\n    }, []);\n}\nfunction debounce(fn) {\n    var pending;\n    return function() {\n        if (!pending) {\n            pending = new Promise(function(resolve) {\n                Promise.resolve().then(function() {\n                    pending = undefined;\n                    resolve(fn());\n                });\n            });\n        }\n        return pending;\n    };\n}\nfunction format(str) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    return [].concat(args).reduce(function(p, c) {\n        return p.replace(/%s/, c);\n    }, str);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = [\n    \"name\",\n    \"enabled\",\n    \"phase\",\n    \"fn\",\n    \"effect\",\n    \"requires\",\n    \"options\"\n];\nfunction validateModifiers(modifiers) {\n    modifiers.forEach(function(modifier) {\n        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`\n        .filter(function(value, index, self) {\n            return self.indexOf(value) === index;\n        }).forEach(function(key) {\n            switch(key){\n                case \"name\":\n                    if (typeof modifier.name !== \"string\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', '\"' + String(modifier.name) + '\"'));\n                    }\n                    break;\n                case \"enabled\":\n                    if (typeof modifier.enabled !== \"boolean\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', '\"' + String(modifier.enabled) + '\"'));\n                    }\n                    break;\n                case \"phase\":\n                    if (modifierPhases.indexOf(modifier.phase) < 0) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(modifier.phase) + '\"'));\n                    }\n                    break;\n                case \"fn\":\n                    if (typeof modifier.fn !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"effect\":\n                    if (modifier.effect != null && typeof modifier.effect !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"requires\":\n                    if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', '\"' + String(modifier.requires) + '\"'));\n                    }\n                    break;\n                case \"requiresIfExists\":\n                    if (!Array.isArray(modifier.requiresIfExists)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(modifier.requiresIfExists) + '\"'));\n                    }\n                    break;\n                case \"options\":\n                case \"data\":\n                    break;\n                default:\n                    console.error('PopperJS: an invalid property has been provided to the \"' + modifier.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {\n                        return '\"' + s + '\"';\n                    }).join(\", \") + '; but \"' + key + '\" was provided.');\n            }\n            modifier.requires && modifier.requires.forEach(function(requirement) {\n                if (modifiers.find(function(mod) {\n                    return mod.name === requirement;\n                }) == null) {\n                    console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n                }\n            });\n        });\n    });\n}\nfunction uniqueBy(arr, fn) {\n    var identifiers = new Set();\n    return arr.filter(function(item) {\n        var identifier = fn(item);\n        if (!identifiers.has(identifier)) {\n            identifiers.add(identifier);\n            return true;\n        }\n    });\n}\nfunction mergeByName(modifiers) {\n    var merged = modifiers.reduce(function(merged, current) {\n        var existing = merged[current.name];\n        merged[current.name] = existing ? Object.assign({}, existing, current, {\n            options: Object.assign({}, existing.options, current.options),\n            data: Object.assign({}, existing.data, current.data)\n        }) : current;\n        return merged;\n    }, {}); // IE11 does not support Object.values\n    return Object.keys(merged).map(function(key) {\n        return merged[key];\n    });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\";\nvar INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\";\nvar DEFAULT_OPTIONS = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n};\nfunction areValidElements() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return !args.some(function(element) {\n        return !(element && typeof element.getBoundingClientRect === \"function\");\n    });\n}\nfunction popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n        generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n        if (options === void 0) {\n            options = defaultOptions;\n        }\n        var state = {\n            placement: \"bottom\",\n            orderedModifiers: [],\n            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n            modifiersData: {},\n            elements: {\n                reference: reference,\n                popper: popper\n            },\n            attributes: {},\n            styles: {}\n        };\n        var effectCleanupFns = [];\n        var isDestroyed = false;\n        var instance = {\n            state: state,\n            setOptions: function setOptions(setOptionsAction) {\n                var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                cleanupModifierEffects();\n                state.options = Object.assign({}, defaultOptions, state.options, options);\n                state.scrollParents = {\n                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                    popper: listScrollParents(popper)\n                }; // Orders the modifiers based on their dependencies and `phase`\n                // properties\n                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                state.orderedModifiers = orderedModifiers.filter(function(m) {\n                    return m.enabled;\n                }); // Validate the provided modifiers so that the consumer will get warned\n                // if one of the modifiers is invalid for any reason\n                if (true) {\n                    var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {\n                        var name = _ref.name;\n                        return name;\n                    });\n                    validateModifiers(modifiers);\n                    if (getBasePlacement(state.options.placement) === auto) {\n                        var flipModifier = state.orderedModifiers.find(function(_ref2) {\n                            var name = _ref2.name;\n                            return name === \"flip\";\n                        });\n                        if (!flipModifier) {\n                            console.error([\n                                'Popper: \"auto\" placements require the \"flip\" modifier be',\n                                \"present and enabled to work.\"\n                            ].join(\" \"));\n                        }\n                    }\n                    var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n                    // cause bugs with positioning, so we'll warn the consumer\n                    if ([\n                        marginTop,\n                        marginRight,\n                        marginBottom,\n                        marginLeft\n                    ].some(function(margin) {\n                        return parseFloat(margin);\n                    })) {\n                        console.warn([\n                            'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                            \"between the popper and its reference element or boundary.\",\n                            \"To replicate margin, use the `offset` modifier, as well as\",\n                            \"the `padding` option in the `preventOverflow` and `flip`\",\n                            \"modifiers.\"\n                        ].join(\" \"));\n                    }\n                }\n                runModifierEffects();\n                return instance.update();\n            },\n            // Sync update – it will always be executed, even if not necessary. This\n            // is useful for low frequency updates where sync behavior simplifies the\n            // logic.\n            // For high frequency updates (e.g. `resize` and `scroll` events), always\n            // prefer the async Popper#update method\n            forceUpdate: function forceUpdate() {\n                if (isDestroyed) {\n                    return;\n                }\n                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                // anymore\n                if (!areValidElements(reference, popper)) {\n                    if (true) {\n                        console.error(INVALID_ELEMENT_ERROR);\n                    }\n                    return;\n                } // Store the reference and popper rects to be read by modifiers\n                state.rects = {\n                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                    popper: getLayoutRect(popper)\n                }; // Modifiers have the ability to reset the current update cycle. The\n                // most common use case for this is the `flip` modifier changing the\n                // placement, which then needs to re-run all the modifiers, because the\n                // logic was previously ran for the previous placement and is therefore\n                // stale/incorrect\n                state.reset = false;\n                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                // is filled with the initial data specified by the modifier. This means\n                // it doesn't persist and is fresh on each update.\n                // To ensure persistent data, use `${name}#persistent`\n                state.orderedModifiers.forEach(function(modifier) {\n                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                });\n                var __debug_loops__ = 0;\n                for(var index = 0; index < state.orderedModifiers.length; index++){\n                    if (true) {\n                        __debug_loops__ += 1;\n                        if (__debug_loops__ > 100) {\n                            console.error(INFINITE_LOOP_ERROR);\n                            break;\n                        }\n                    }\n                    if (state.reset === true) {\n                        state.reset = false;\n                        index = -1;\n                        continue;\n                    }\n                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                    if (typeof fn === \"function\") {\n                        state = fn({\n                            state: state,\n                            options: _options,\n                            name: name,\n                            instance: instance\n                        }) || state;\n                    }\n                }\n            },\n            // Async and optimistically optimized update – it will not be executed if\n            // not necessary (debounced to run at most once-per-tick)\n            update: debounce(function() {\n                return new Promise(function(resolve) {\n                    instance.forceUpdate();\n                    resolve(state);\n                });\n            }),\n            destroy: function destroy() {\n                cleanupModifierEffects();\n                isDestroyed = true;\n            }\n        };\n        if (!areValidElements(reference, popper)) {\n            if (true) {\n                console.error(INVALID_ELEMENT_ERROR);\n            }\n            return instance;\n        }\n        instance.setOptions(options).then(function(state) {\n            if (!isDestroyed && options.onFirstUpdate) {\n                options.onFirstUpdate(state);\n            }\n        }); // Modifiers have the ability to execute arbitrary code before the first\n        // update cycle runs. They will be executed in the same order as the update\n        // cycle. This is useful when a modifier adds some persistent data that\n        // other modifiers need to use, but the modifier is run after the dependent\n        // one.\n        function runModifierEffects() {\n            state.orderedModifiers.forEach(function(_ref3) {\n                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;\n                if (typeof effect === \"function\") {\n                    var cleanupFn = effect({\n                        state: state,\n                        name: name,\n                        instance: instance,\n                        options: options\n                    });\n                    var noopFn = function noopFn() {};\n                    effectCleanupFns.push(cleanupFn || noopFn);\n                }\n            });\n        }\n        function cleanupModifierEffects() {\n            effectCleanupFns.forEach(function(fn) {\n                return fn();\n            });\n            effectCleanupFns = [];\n        }\n        return instance;\n    };\n}\nvar defaultModifiers = [\n    eventListeners,\n    popperOffsets$1,\n    computeStyles$1,\n    applyStyles$1,\n    offset$1,\n    flip$1,\n    preventOverflow$1,\n    arrow$1,\n    hide$1\n];\nvar createPopper = /*#__PURE__*/ popperGenerator({\n    defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\nvar usePopper = function(options) {\n    var level = options.level, buttonRef = options.buttonRef, contentRef = options.contentRef;\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _a.collapsed, toggled = _a.toggled, transitionDuration = _a.transitionDuration;\n    var popperInstanceRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    /**\r\n     * create popper instance only on first level submenu components and when sidebar is collapsed\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (level === 0 && collapsed && contentRef.current && buttonRef.current) {\n            popperInstanceRef.current = createPopper(buttonRef.current, contentRef.current, {\n                placement: \"right\",\n                strategy: \"fixed\",\n                modifiers: [\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: [\n                                0,\n                                5\n                            ]\n                        }\n                    }\n                ]\n            });\n        }\n        return function() {\n            var _a;\n            return (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        };\n    }, [\n        level,\n        collapsed,\n        contentRef,\n        buttonRef\n    ]);\n    /**\r\n     * update popper instance (position) when buttonRef or contentRef changes\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (contentRef.current && buttonRef.current) {\n            var ro = new ResizeObserver(function() {\n                var _a;\n                (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n            });\n            ro.observe(contentRef.current);\n            ro.observe(buttonRef.current);\n        }\n        setTimeout(function() {\n            var _a;\n            (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n        }, transitionDuration);\n    }, [\n        transitionDuration,\n        toggled,\n        contentRef,\n        buttonRef\n    ]);\n    return {\n        popperInstance: popperInstanceRef.current\n    };\n};\nvar menuButtonStyles = function(props) {\n    var rtl = props.rtl, level = props.level, collapsed = props.collapsed, disabled = props.disabled, active = props.active;\n    return \"\\n    display: flex;\\n    align-items: center;\\n    height: 50px;\\n    text-decoration: none;\\n    color: inherit;\\n    box-sizing: border-box;\\n    cursor: pointer;\\n\\n    \".concat(rtl ? \"padding-left: 20px;\\n           padding-right: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n            \") : \"padding-right: 20px;\\n           padding-left: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n           \"), \"\\n\\n    &:hover {\\n      background-color: #f3f3f3;\\n    }\\n\\n    \").concat(disabled && \" \\n      pointer-events: none;\\n      cursor: default;\\n      color:#adadad;\\n        \", \"\\n\\n    \").concat(active && \"background-color: #e2eef9;\", \"\\n  \\n  \");\n};\nvar MenuButtonRef = function(_a, ref) {\n    var className = _a.className, component = _a.component, children = _a.children, rest = __rest(_a, [\n        \"className\",\n        \"component\",\n        \"children\"\n    ]);\n    if (component) {\n        if (typeof component === \"string\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(component, __assign(__assign({\n                className: classnames(className)\n            }, rest), {\n                ref: ref\n            }), children);\n        } else {\n            var _b = component.props, classNameProp = _b.className, props = __rest(_b, [\n                \"className\"\n            ]);\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(component, __assign(__assign(__assign({\n                className: classnames(className, classNameProp)\n            }, rest), props), {\n                ref: ref\n            }), children);\n        }\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", __assign({\n            ref: ref,\n            className: classnames(className)\n        }, rest), children);\n    }\n};\nvar MenuButton = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuButtonRef);\nvar StyledSubMenu = newStyled.li(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\nvar SubMenuFR = function(_a, ref) {\n    var _b;\n    var children = _a.children, className = _a.className, label = _a.label, icon = _a.icon, title = _a.title, prefix = _a.prefix, suffix = _a.suffix, openControlled = _a.open, defaultOpen = _a.defaultOpen, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, rootStyles = _a.rootStyles, component = _a.component, onOpenChange = _a.onOpenChange, onClick = _a.onClick, onKeyUp = _a.onKeyUp, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"label\",\n        \"icon\",\n        \"title\",\n        \"prefix\",\n        \"suffix\",\n        \"open\",\n        \"defaultOpen\",\n        \"active\",\n        \"disabled\",\n        \"rootStyles\",\n        \"component\",\n        \"onOpenChange\",\n        \"onClick\",\n        \"onKeyUp\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, sidebarTransitionDuration = _e.transitionDuration;\n    var _f = useMenu(), renderExpandIcon = _f.renderExpandIcon, closeOnClick = _f.closeOnClick, menuItemStyles = _f.menuItemStyles, transitionDuration = _f.transitionDuration;\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!defaultOpen), open = _g[0], setOpen = _g[1];\n    var _h = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), openWhenCollapsed = _h[0], setOpenWhenCollapsed = _h[1];\n    var _j = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _j[0], setMounted = _j[1];\n    var buttonRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var contentRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var timer = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    var popperInstance = usePopper({\n        level: level,\n        buttonRef: buttonRef,\n        contentRef: contentRef\n    }).popperInstance;\n    var expandContent = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        var _a;\n        var target = contentRef.current;\n        if (target) {\n            var height = (_a = target === null || target === void 0 ? void 0 : target.querySelector(\".\".concat(menuClasses.subMenuContent, \" > ul\"))) === null || _a === void 0 ? void 0 : _a.clientHeight;\n            target.style.overflow = \"hidden\";\n            target.style.height = \"\".concat(height, \"px\");\n            timer.current = setTimeout(function() {\n                target.style.overflow = \"auto\";\n                target.style.height = \"auto\";\n            }, transitionDuration);\n        }\n    }, [\n        transitionDuration\n    ]);\n    var collapseContent = function() {\n        var _a;\n        var target = contentRef.current;\n        if (target) {\n            var height = (_a = target === null || target === void 0 ? void 0 : target.querySelector(\".\".concat(menuClasses.subMenuContent, \" > ul\"))) === null || _a === void 0 ? void 0 : _a.clientHeight;\n            target.style.overflow = \"hidden\";\n            target.style.height = \"\".concat(height, \"px\");\n            target.offsetHeight;\n            target.style.height = \"0px\";\n        }\n    };\n    var handleSlideToggle = function() {\n        if (!(level === 0 && collapsed)) {\n            if (typeof openControlled === \"undefined\") {\n                clearTimeout(Number(timer.current));\n                open ? collapseContent() : expandContent();\n                onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!open);\n                setOpen(!open);\n            } else {\n                onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!openControlled);\n            }\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!(level === 0 && collapsed) && typeof openControlled !== \"undefined\" && mounted) {\n            clearTimeout(Number(timer.current));\n            !openControlled ? collapseContent() : expandContent();\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        collapsed,\n        expandContent,\n        label,\n        level,\n        onOpenChange,\n        openControlled\n    ]);\n    var handleOnClick = function(event) {\n        onClick === null || onClick === void 0 ? void 0 : onClick(event);\n        handleSlideToggle();\n    };\n    var handleOnKeyUp = function(event) {\n        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n        if (event.key === \"Enter\") {\n            handleSlideToggle();\n        }\n    };\n    var getSubMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: true,\n                open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix, subMenuContentElStyles = menuItemStyles.subMenuContent, SubMenuExpandIconElStyles = menuItemStyles.SubMenuExpandIcon;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                case \"SubMenuExpandIcon\":\n                    return typeof SubMenuExpandIconElStyles === \"function\" ? SubMenuExpandIconElStyles(params) : SubMenuExpandIconElStyles;\n                case \"subMenuContent\":\n                    return typeof subMenuContentElStyles === \"function\" ? subMenuContentElStyles(params) : subMenuContentElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setTimeout(function() {\n            return popperInstance === null || popperInstance === void 0 ? void 0 : popperInstance.update();\n        }, sidebarTransitionDuration);\n        if (collapsed && level === 0) {\n            setOpenWhenCollapsed(false);\n        // ? if its useful to close first level submenus on collapse sidebar uncomment the code below\n        // setOpen(false);\n        }\n    }, [\n        collapsed,\n        level,\n        rtl,\n        sidebarTransitionDuration,\n        popperInstance\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var handleTogglePopper = function(target) {\n            var _a, _b, _c;\n            if (!openWhenCollapsed && ((_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.contains(target))) setOpenWhenCollapsed(true);\n            else if (closeOnClick && !((_b = target.closest(\".\".concat(menuClasses.menuItemRoot))) === null || _b === void 0 ? void 0 : _b.classList.contains(menuClasses.subMenuRoot)) || !((_c = contentRef.current) === null || _c === void 0 ? void 0 : _c.contains(target)) && openWhenCollapsed) {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var handleDocumentClick = function(event) {\n            handleTogglePopper(event.target);\n        };\n        var handleDocumentKeyUp = function(event) {\n            if (event.key === \"Enter\") {\n                handleTogglePopper(event.target);\n            } else if (event.key === \"Escape\") {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var removeEventListeners = function() {\n            document.removeEventListener(\"click\", handleDocumentClick);\n            document.removeEventListener(\"keyup\", handleDocumentKeyUp);\n        };\n        removeEventListeners();\n        if (collapsed && level === 0) {\n            document.addEventListener(\"click\", handleDocumentClick, false);\n            document.addEventListener(\"keyup\", handleDocumentKeyUp, false);\n        }\n        return function() {\n            removeEventListeners();\n        };\n    }, [\n        collapsed,\n        level,\n        closeOnClick,\n        openWhenCollapsed\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setMounted(true);\n    }, []);\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b[menuClasses.open] = openControlled !== null && openControlled !== void 0 ? openControlled : open, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenu, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, menuClasses.subMenuRoot, sharedClasses, className),\n        menuItemStyles: getSubMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getSubMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        ref: buttonRef,\n        title: title,\n        className: classnames(menuClasses.button, sharedClasses),\n        onClick: handleOnClick,\n        onKeyUp: handleOnKeyUp,\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getSubMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"label\")\n    }, label), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"suffix\")\n    }, suffix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconWrapper, {\n        rtl: rtl,\n        className: classnames(menuClasses.SubMenuExpandIcon, sharedClasses),\n        collapsed: collapsed,\n        level: level,\n        rootStyles: getSubMenuItemStyles(\"SubMenuExpandIcon\")\n    }, renderExpandIcon ? renderExpandIcon({\n        level: level,\n        disabled: disabled,\n        active: active,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }) : collapsed && level === 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconCollapsed, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIcon, {\n        rtl: rtl,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SubMenuContent, {\n        ref: contentRef,\n        openWhenCollapsed: openWhenCollapsed,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open,\n        firstLevel: level === 0,\n        collapsed: collapsed,\n        defaultOpen: openControlled && !mounted || defaultOpen,\n        className: classnames(menuClasses.subMenuContent, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"subMenuContent\")\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: level + 1\n    }, children)));\n};\nvar SubMenu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuFR);\nvar templateObject_1$1;\nvar StyledMenuItem = newStyled.li(templateObject_1 || (templateObject_1 = __makeTemplateObject([\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\nvar MenuItemFR = function(_a, ref) {\n    var _b;\n    var children = _a.children, icon = _a.icon, className = _a.className, prefix = _a.prefix, suffix = _a.suffix, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, component = _a.component, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"children\",\n        \"icon\",\n        \"className\",\n        \"prefix\",\n        \"suffix\",\n        \"active\",\n        \"disabled\",\n        \"component\",\n        \"rootStyles\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, transitionDuration = _e.transitionDuration;\n    var menuItemStyles = useMenu().menuItemStyles;\n    var getMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: false\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuItem, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, sharedClasses, className),\n        menuItemStyles: getMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        className: classnames(menuClasses.button, sharedClasses),\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getMenuItemStyles(\"label\")\n    }, children), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getMenuItemStyles(\"suffix\")\n    }, suffix)));\n};\nvar MenuItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuItemFR);\nvar templateObject_1;\n/**\r\n * @deprecated\r\n * `ProSidebarProvider` is deprecated and will be removed in the next major release.\r\n */ var ProSidebarProvider = function(_a) {\n    var children = _a.children;\n    console.warn(\"ProSidebarProvider is deprecated and will be removed in the next major release.\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarProvider, null, children);\n};\n/**\r\n * @deprecated\r\n * `useProSidebar` is deprecated and will be removed in the next major release.\r\n *  please use Sidebar props instead.\r\n */ var useProSidebar = function() {\n    var legacySidebarContext = useLegacySidebar();\n    if (legacySidebarContext === undefined) {\n        throw new Error(\"useProSidebar must be used within a ProSidebarProvider. Please wrap your component with a ProSidebarProvider to use this hook.\");\n    }\n    var collapseSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateCollapseState();\n        else legacySidebarContext.updateSidebarState({\n            collapsed: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateCollapseState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    var toggleSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateToggleState();\n        else legacySidebarContext.updateSidebarState({\n            toggled: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateToggleState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        console.warn(\"useProSidebar is deprecated and will be removed in the next major release. Please use Sidebar props instead.\");\n    }, []);\n    return {\n        collapseSidebar: collapseSidebar,\n        toggleSidebar: toggleSidebar,\n        collapsed: !!legacySidebarContext.collapsed,\n        broken: !!legacySidebarContext.broken,\n        toggled: !!legacySidebarContext.toggled,\n        rtl: !!legacySidebarContext.rtl\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJvLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDd0U7QUFFdkc7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLElBQUlPLFdBQVc7SUFDWEEsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVNGLFNBQVNHLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSUksS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQ2hGO1FBQ0EsT0FBT047SUFDWDtJQUNBLE9BQU9ILFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQ2hDO0FBRUEsU0FBU08sT0FBT1YsQ0FBQyxFQUFFVyxDQUFDO0lBQ2hCLElBQUlaLElBQUksQ0FBQztJQUNULElBQUssSUFBSU0sS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxNQUFNTSxFQUFFQyxPQUFPLENBQUNQLEtBQUssR0FDOUVOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFDZixJQUFJTCxLQUFLLFFBQVEsT0FBT0gsT0FBT2dCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSVosSUFBSSxHQUFHSSxJQUFJUixPQUFPZ0IscUJBQXFCLENBQUNiLElBQUlDLElBQUlJLEVBQUVELE1BQU0sRUFBRUgsSUFBSztRQUNwRSxJQUFJVSxFQUFFQyxPQUFPLENBQUNQLENBQUMsQ0FBQ0osRUFBRSxJQUFJLEtBQUtKLE9BQU9T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QUNqQkMsZUFBZUE7UUFDZjduQixXQUFXLENBQUMsQ0FBQ3FGLHFCQUFxQnJGLFNBQVM7UUFDM0NFLFFBQVEsQ0FBQyxDQUFDbUYscUJBQXFCbkYsTUFBTTtRQUNyQ0QsU0FBUyxDQUFDLENBQUNvRixxQkFBcUJwRixPQUFPO1FBQ3ZDRSxLQUFLLENBQUMsQ0FBQ2tGLHFCQUFxQmxGLEdBQUc7SUFDbkM7QUFDSjtBQUU4SyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbF9wbGFuZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJvLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcz83MzgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyBmb3J3YXJkUmVmLCB1c2VDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuXG52YXIgcmVhY3RQcm9wc1JlZ2V4ID0gL14oKGNoaWxkcmVufGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfGtleXxyZWZ8YXV0b0ZvY3VzfGRlZmF1bHRWYWx1ZXxkZWZhdWx0Q2hlY2tlZHxpbm5lckhUTUx8c3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nfHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ3x2YWx1ZUxpbmt8YWJicnxhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxlbnRlcktleUhpbnR8Zm9ybXxmb3JtQWN0aW9ufGZvcm1FbmNUeXBlfGZvcm1NZXRob2R8Zm9ybU5vVmFsaWRhdGV8Zm9ybVRhcmdldHxmcmFtZUJvcmRlcnxoZWFkZXJzfGhlaWdodHxoaWRkZW58aGlnaHxocmVmfGhyZWZMYW5nfGh0bWxGb3J8aHR0cEVxdWl2fGlkfGlucHV0TW9kZXxpbnRlZ3JpdHl8aXN8a2V5UGFyYW1zfGtleVR5cGV8a2luZHxsYWJlbHxsYW5nfGxpc3R8bG9hZGluZ3xsb29wfGxvd3xtYXJnaW5IZWlnaHR8bWFyZ2luV2lkdGh8bWF4fG1heExlbmd0aHxtZWRpYXxtZWRpYUdyb3VwfG1ldGhvZHxtaW58bWluTGVuZ3RofG11bHRpcGxlfG11dGVkfG5hbWV8bm9uY2V8bm9WYWxpZGF0ZXxvcGVufG9wdGltdW18cGF0dGVybnxwbGFjZWhvbGRlcnxwbGF5c0lubGluZXxwb3N0ZXJ8cHJlbG9hZHxwcm9maWxlfHJhZGlvR3JvdXB8cmVhZE9ubHl8cmVmZXJyZXJQb2xpY3l8cmVsfHJlcXVpcmVkfHJldmVyc2VkfHJvbGV8cm93c3xyb3dTcGFufHNhbmRib3h8c2NvcGV8c2NvcGVkfHNjcm9sbGluZ3xzZWFtbGVzc3xzZWxlY3RlZHxzaGFwZXxzaXplfHNpemVzfHNsb3R8c3BhbnxzcGVsbENoZWNrfHNyY3xzcmNEb2N8c3JjTGFuZ3xzcmNTZXR8c3RhcnR8c3RlcHxzdHlsZXxzdW1tYXJ5fHRhYkluZGV4fHRhcmdldHx0aXRsZXx0cmFuc2xhdGV8dHlwZXx1c2VNYXB8dmFsdWV8d2lkdGh8d21vZGV8d3JhcHxhYm91dHxkYXRhdHlwZXxpbmxpc3R8cHJlZml4fHByb3BlcnR5fHJlc291cmNlfHR5cGVvZnx2b2NhYnxhdXRvQ2FwaXRhbGl6ZXxhdXRvQ29ycmVjdHxhdXRvU2F2ZXxjb2xvcnxpbmNyZW1lbnRhbHxmYWxsYmFja3xpbmVydHxpdGVtUHJvcHxpdGVtU2NvcGV8aXRlbVR5cGV8aXRlbUlEfGl0ZW1SZWZ8b258b3B0aW9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLzsgLy8gaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81YmZlZTY4YTRjZDdlNjAwOWVmNjFkMjNcblxudmFyIGlzUHJvcFZhbGlkID0gLyogI19fUFVSRV9fICovbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTFcbiAgLyogbyAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMFxuICAvKiBuICovXG4gICYmIHByb3AuY2hhckNvZGVBdCgyKSA8IDkxO1xufVxuLyogWisxICovXG4pO1xuXG4vKlxuXG5CYXNlZCBvZmYgZ2xhbW9yJ3MgU3R5bGVTaGVldCwgdGhhbmtzIFN1bmlsIOKdpO+4j1xuXG5oaWdoIHBlcmZvcm1hbmNlIFN0eWxlU2hlZXQgZm9yIGNzcy1pbi1qcyBzeXN0ZW1zXG5cbi0gdXNlcyBtdWx0aXBsZSBzdHlsZSB0YWdzIGJlaGluZCB0aGUgc2NlbmVzIGZvciBtaWxsaW9ucyBvZiBydWxlc1xuLSB1c2VzIGBpbnNlcnRSdWxlYCBmb3IgYXBwZW5kaW5nIGluIHByb2R1Y3Rpb24gZm9yICptdWNoKiBmYXN0ZXIgcGVyZm9ybWFuY2VcblxuLy8gdXNhZ2VcblxuaW1wb3J0IHsgU3R5bGVTaGVldCB9IGZyb20gJ0BlbW90aW9uL3NoZWV0J1xuXG5sZXQgc3R5bGVTaGVldCA9IG5ldyBTdHlsZVNoZWV0KHsga2V5OiAnJywgY29udGFpbmVyOiBkb2N1bWVudC5oZWFkIH0pXG5cbnN0eWxlU2hlZXQuaW5zZXJ0KCcjYm94IHsgYm9yZGVyOiAxcHggc29saWQgcmVkOyB9Jylcbi0gYXBwZW5kcyBhIGNzcyBydWxlIGludG8gdGhlIHN0eWxlc2hlZXRcblxuc3R5bGVTaGVldC5mbHVzaCgpXG4tIGVtcHRpZXMgdGhlIHN0eWxlc2hlZXQgb2YgYWxsIGl0cyBjb250ZW50c1xuXG4qL1xuLy8gJEZsb3dGaXhNZVxuZnVuY3Rpb24gc2hlZXRGb3JUYWcodGFnKSB7XG4gIGlmICh0YWcuc2hlZXQpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIHRhZy5zaGVldDtcbiAgfSAvLyB0aGlzIHdlaXJkbmVzcyBicm91Z2h0IHRvIHlvdSBieSBmaXJlZm94XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZG9jdW1lbnQuc3R5bGVTaGVldHNbaV0ub3duZXJOb2RlID09PSB0YWcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHJldHVybiBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZW1vdGlvbicsIG9wdGlvbnMua2V5KTtcblxuICBpZiAob3B0aW9ucy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBvcHRpb25zLm5vbmNlKTtcbiAgfVxuXG4gIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICB0YWcuc2V0QXR0cmlidXRlKCdkYXRhLXMnLCAnJyk7XG4gIHJldHVybiB0YWc7XG59XG5cbnZhciBTdHlsZVNoZWV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gVXNpbmcgTm9kZSBpbnN0ZWFkIG9mIEhUTUxFbGVtZW50IHNpbmNlIGNvbnRhaW5lciBtYXkgYmUgYSBTaGFkb3dSb290XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9pbnNlcnRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICB2YXIgYmVmb3JlO1xuXG4gICAgICBpZiAoX3RoaXMudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKF90aGlzLmluc2VydGlvblBvaW50KSB7XG4gICAgICAgICAgYmVmb3JlID0gX3RoaXMuaW5zZXJ0aW9uUG9pbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucHJlcGVuZCkge1xuICAgICAgICAgIGJlZm9yZSA9IF90aGlzLmNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IF90aGlzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVmb3JlID0gX3RoaXMudGFnc1tfdGhpcy50YWdzLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRhZywgYmVmb3JlKTtcblxuICAgICAgX3RoaXMudGFncy5wdXNoKHRhZyk7XG4gICAgfTtcblxuICAgIHRoaXMuaXNTcGVlZHkgPSBvcHRpb25zLnNwZWVkeSA9PT0gdW5kZWZpbmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA6IG9wdGlvbnMuc3BlZWR5O1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgICB0aGlzLm5vbmNlID0gb3B0aW9ucy5ub25jZTsgLy8ga2V5IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YS1lbW90aW9uIGF0dHJpYnV0ZSwgaXQncyB1c2VkIHRvIGlkZW50aWZ5IGRpZmZlcmVudCBzaGVldHNcblxuICAgIHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdGhpcy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnByZXBlbmQgPSBvcHRpb25zLnByZXBlbmQ7XG4gICAgdGhpcy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdGhpcy5iZWZvcmUgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oeWRyYXRlID0gZnVuY3Rpb24gaHlkcmF0ZShub2Rlcykge1xuICAgIG5vZGVzLmZvckVhY2godGhpcy5faW5zZXJ0VGFnKTtcbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAvLyB0aGUgbWF4IGxlbmd0aCBpcyBob3cgbWFueSBydWxlcyB3ZSBoYXZlIHBlciBzdHlsZSB0YWcsIGl0J3MgNjUwMDAgaW4gc3BlZWR5IG1vZGVcbiAgICAvLyBpdCdzIDEgaW4gZGV2IGJlY2F1c2Ugd2UgaW5zZXJ0IHNvdXJjZSBtYXBzIHRoYXQgbWFwIGEgc2luZ2xlIHJ1bGUgdG8gYSBsb2NhdGlvblxuICAgIC8vIGFuZCB5b3UgY2FuIG9ubHkgaGF2ZSBvbmUgc291cmNlIG1hcCBwZXIgc3R5bGUgdGFnXG4gICAgaWYgKHRoaXMuY3RyICUgKHRoaXMuaXNTcGVlZHkgPyA2NTAwMCA6IDEpID09PSAwKSB7XG4gICAgICB0aGlzLl9pbnNlcnRUYWcoY3JlYXRlU3R5bGVFbGVtZW50KHRoaXMpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy50YWdzW3RoaXMudGFncy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaXNJbXBvcnRSdWxlID0gcnVsZS5jaGFyQ29kZUF0KDApID09PSA2NCAmJiBydWxlLmNoYXJDb2RlQXQoMSkgPT09IDEwNTtcblxuICAgICAgaWYgKGlzSW1wb3J0UnVsZSAmJiB0aGlzLl9hbHJlYWR5SW5zZXJ0ZWRPcmRlckluc2Vuc2l0aXZlUnVsZSkge1xuICAgICAgICAvLyB0aGlzIHdvdWxkIG9ubHkgY2F1c2UgcHJvYmxlbSBpbiBzcGVlZHkgbW9kZVxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCBlbmFibGluZyBzcGVlZHkgdG8gYWZmZWN0IHRoZSBvYnNlcnZhYmxlIGJlaGF2aW9yXG4gICAgICAgIC8vIHNvIHdlIHJlcG9ydCB0aGlzIGVycm9yIGF0IGFsbCB0aW1lc1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5zZXJ0IHRoZSBmb2xsb3dpbmcgcnVsZTpcXG5cIiArIHJ1bGUgKyAnXFxuXFxuYEBpbXBvcnRgIHJ1bGVzIG11c3QgYmUgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBydWxlcyBpbiBhIHN0eWxlc2hlZXQgYnV0IG90aGVyIHJ1bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluc2VydGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgYEBpbXBvcnRgIHJ1bGVzIGFyZSBiZWZvcmUgYWxsIG90aGVyIHJ1bGVzLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUgPSB0aGlzLl9hbHJlYWR5SW5zZXJ0ZWRPcmRlckluc2Vuc2l0aXZlUnVsZSB8fCAhaXNJbXBvcnRSdWxlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3BlZWR5KSB7XG4gICAgICB2YXIgc2hlZXQgPSBzaGVldEZvclRhZyh0YWcpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSB1bHRyYWZhc3QgdmVyc2lvbiwgd29ya3MgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIHRoZSBiaWcgZHJhd2JhY2sgaXMgdGhhdCB0aGUgY3NzIHdvbid0IGJlIGVkaXRhYmxlIGluIGRldnRvb2xzXG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIS86KC1tb3otcGxhY2Vob2xkZXJ8LW1vei1mb2N1cy1pbm5lcnwtbW96LWZvY3VzcmluZ3wtbXMtaW5wdXQtcGxhY2Vob2xkZXJ8LW1vei1yZWFkLXdyaXRlfC1tb3otcmVhZC1vbmx5fC1tcy1jbGVhcnwtbXMtZXhwYW5kfC1tcy1yZXZlYWwpey8udGVzdChydWxlKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGluc2VydGluZyB0aGUgZm9sbG93aW5nIHJ1bGU6IFxcXCJcIiArIHJ1bGUgKyBcIlxcXCJcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGUpKTtcbiAgICB9XG5cbiAgICB0aGlzLmN0cisrO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICB0aGlzLnRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICByZXR1cm4gdGFnLnBhcmVudE5vZGUgJiYgdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnKTtcbiAgICB9KTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLmN0ciA9IDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBNUyA9ICctbXMtJztcbnZhciBNT1ogPSAnLW1vei0nO1xudmFyIFdFQktJVCA9ICctd2Via2l0LSc7XG5cbnZhciBDT01NRU5UID0gJ2NvbW0nO1xudmFyIFJVTEVTRVQgPSAncnVsZSc7XG52YXIgREVDTEFSQVRJT04gPSAnZGVjbCc7XG52YXIgSU1QT1JUID0gJ0BpbXBvcnQnO1xudmFyIEtFWUZSQU1FUyA9ICdAa2V5ZnJhbWVzJztcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG52YXIgZnJvbSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBoYXNoJDIgKHZhbHVlLCBsZW5ndGgpIHtcblx0cmV0dXJuIGNoYXJhdCh2YWx1ZSwgMCkgXiA0NSA/ICgoKCgoKChsZW5ndGggPDwgMikgXiBjaGFyYXQodmFsdWUsIDApKSA8PCAyKSBeIGNoYXJhdCh2YWx1ZSwgMSkpIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAyKSkgPDwgMikgXiBjaGFyYXQodmFsdWUsIDMpIDogMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmltICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUudHJpbSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuICogQHJldHVybiB7c3RyaW5nP31cbiAqL1xuZnVuY3Rpb24gbWF0Y2ggKHZhbHVlLCBwYXR0ZXJuKSB7XG5cdHJldHVybiAodmFsdWUgPSBwYXR0ZXJuLmV4ZWModmFsdWUpKSA/IHZhbHVlWzBdIDogdmFsdWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7KHN0cmluZ3xSZWdFeHApfSBwYXR0ZXJuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZSAodmFsdWUsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cdHJldHVybiB2YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBpbmRleG9mICh2YWx1ZSwgc2VhcmNoKSB7XG5cdHJldHVybiB2YWx1ZS5pbmRleE9mKHNlYXJjaClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjaGFyYXQgKHZhbHVlLCBpbmRleCkge1xuXHRyZXR1cm4gdmFsdWUuY2hhckNvZGVBdChpbmRleCkgfCAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3Vic3RyICh2YWx1ZSwgYmVnaW4sIGVuZCkge1xuXHRyZXR1cm4gdmFsdWUuc2xpY2UoYmVnaW4sIGVuZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3RybGVuICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUubGVuZ3RoXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2l6ZW9mICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUubGVuZ3RoXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJheVxuICogQHJldHVybiB7YW55fVxuICovXG5mdW5jdGlvbiBhcHBlbmQgKHZhbHVlLCBhcnJheSkge1xuXHRyZXR1cm4gYXJyYXkucHVzaCh2YWx1ZSksIHZhbHVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmUgKGFycmF5LCBjYWxsYmFjaykge1xuXHRyZXR1cm4gYXJyYXkubWFwKGNhbGxiYWNrKS5qb2luKCcnKVxufVxuXG52YXIgbGluZSA9IDE7XG52YXIgY29sdW1uID0gMTtcbnZhciBsZW5ndGggPSAwO1xudmFyIHBvc2l0aW9uID0gMDtcbnZhciBjaGFyYWN0ZXIgPSAwO1xudmFyIGNoYXJhY3RlcnMgPSAnJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgc3RyaW5nfSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3RbXSB8IHN0cmluZ30gY2hpbGRyZW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gbm9kZSAodmFsdWUsIHJvb3QsIHBhcmVudCwgdHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBsZW5ndGgpIHtcblx0cmV0dXJuIHt2YWx1ZTogdmFsdWUsIHJvb3Q6IHJvb3QsIHBhcmVudDogcGFyZW50LCB0eXBlOiB0eXBlLCBwcm9wczogcHJvcHMsIGNoaWxkcmVuOiBjaGlsZHJlbiwgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4sIGxlbmd0aDogbGVuZ3RoLCByZXR1cm46ICcnfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29weSAocm9vdCwgcHJvcHMpIHtcblx0cmV0dXJuIGFzc2lnbihub2RlKCcnLCBudWxsLCBudWxsLCAnJywgbnVsbCwgbnVsbCwgMCksIHJvb3QsIHtsZW5ndGg6IC1yb290Lmxlbmd0aH0sIHByb3BzKVxufVxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2hhciAoKSB7XG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHByZXYgKCkge1xuXHRjaGFyYWN0ZXIgPSBwb3NpdGlvbiA+IDAgPyBjaGFyYXQoY2hhcmFjdGVycywgLS1wb3NpdGlvbikgOiAwO1xuXG5cdGlmIChjb2x1bW4tLSwgY2hhcmFjdGVyID09PSAxMClcblx0XHRjb2x1bW4gPSAxLCBsaW5lLS07XG5cblx0cmV0dXJuIGNoYXJhY3RlclxufVxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gbmV4dCAoKSB7XG5cdGNoYXJhY3RlciA9IHBvc2l0aW9uIDwgbGVuZ3RoID8gY2hhcmF0KGNoYXJhY3RlcnMsIHBvc2l0aW9uKyspIDogMDtcblxuXHRpZiAoY29sdW1uKyssIGNoYXJhY3RlciA9PT0gMTApXG5cdFx0Y29sdW1uID0gMSwgbGluZSsrO1xuXG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBlZWsgKCkge1xuXHRyZXR1cm4gY2hhcmF0KGNoYXJhY3RlcnMsIHBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2FyZXQgKCkge1xuXHRyZXR1cm4gcG9zaXRpb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIHN1YnN0cihjaGFyYWN0ZXJzLCBiZWdpbiwgZW5kKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuICh0eXBlKSB7XG5cdHN3aXRjaCAodHlwZSkge1xuXHRcdC8vIFxcMCBcXHQgXFxuIFxcciBcXHMgd2hpdGVzcGFjZSB0b2tlblxuXHRcdGNhc2UgMDogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuXHRcdFx0cmV0dXJuIDVcblx0XHQvLyAhICsgLCAvID4gQCB+IGlzb2xhdGUgdG9rZW5cblx0XHRjYXNlIDMzOiBjYXNlIDQzOiBjYXNlIDQ0OiBjYXNlIDQ3OiBjYXNlIDYyOiBjYXNlIDY0OiBjYXNlIDEyNjpcblx0XHQvLyA7IHsgfSBicmVha3BvaW50IHRva2VuXG5cdFx0Y2FzZSA1OTogY2FzZSAxMjM6IGNhc2UgMTI1OlxuXHRcdFx0cmV0dXJuIDRcblx0XHQvLyA6IGFjY29tcGFuaWVkIHRva2VuXG5cdFx0Y2FzZSA1ODpcblx0XHRcdHJldHVybiAzXG5cdFx0Ly8gXCIgJyAoIFsgb3BlbmluZyBkZWxpbWl0IHRva2VuXG5cdFx0Y2FzZSAzNDogY2FzZSAzOTogY2FzZSA0MDogY2FzZSA5MTpcblx0XHRcdHJldHVybiAyXG5cdFx0Ly8gKSBdIGNsb3NpbmcgZGVsaW1pdCB0b2tlblxuXHRcdGNhc2UgNDE6IGNhc2UgOTM6XG5cdFx0XHRyZXR1cm4gMVxuXHR9XG5cblx0cmV0dXJuIDBcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge2FueVtdfVxuICovXG5mdW5jdGlvbiBhbGxvYyAodmFsdWUpIHtcblx0cmV0dXJuIGxpbmUgPSBjb2x1bW4gPSAxLCBsZW5ndGggPSBzdHJsZW4oY2hhcmFjdGVycyA9IHZhbHVlKSwgcG9zaXRpb24gPSAwLCBbXVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7YW55fVxuICovXG5mdW5jdGlvbiBkZWFsbG9jICh2YWx1ZSkge1xuXHRyZXR1cm4gY2hhcmFjdGVycyA9ICcnLCB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlbGltaXQgKHR5cGUpIHtcblx0cmV0dXJuIHRyaW0oc2xpY2UocG9zaXRpb24gLSAxLCBkZWxpbWl0ZXIodHlwZSA9PT0gOTEgPyB0eXBlICsgMiA6IHR5cGUgPT09IDQwID8gdHlwZSArIDEgOiB0eXBlKSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gd2hpdGVzcGFjZSAodHlwZSkge1xuXHR3aGlsZSAoY2hhcmFjdGVyID0gcGVlaygpKVxuXHRcdGlmIChjaGFyYWN0ZXIgPCAzMylcblx0XHRcdG5leHQoKTtcblx0XHRlbHNlXG5cdFx0XHRicmVha1xuXG5cdHJldHVybiB0b2tlbih0eXBlKSA+IDIgfHwgdG9rZW4oY2hhcmFjdGVyKSA+IDMgPyAnJyA6ICcgJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwaW5nIChpbmRleCwgY291bnQpIHtcblx0d2hpbGUgKC0tY291bnQgJiYgbmV4dCgpKVxuXHRcdC8vIG5vdCAwLTkgQS1GIGEtZlxuXHRcdGlmIChjaGFyYWN0ZXIgPCA0OCB8fCBjaGFyYWN0ZXIgPiAxMDIgfHwgKGNoYXJhY3RlciA+IDU3ICYmIGNoYXJhY3RlciA8IDY1KSB8fCAoY2hhcmFjdGVyID4gNzAgJiYgY2hhcmFjdGVyIDwgOTcpKVxuXHRcdFx0YnJlYWtcblxuXHRyZXR1cm4gc2xpY2UoaW5kZXgsIGNhcmV0KCkgKyAoY291bnQgPCA2ICYmIHBlZWsoKSA9PSAzMiAmJiBuZXh0KCkgPT0gMzIpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlbGltaXRlciAodHlwZSkge1xuXHR3aGlsZSAobmV4dCgpKVxuXHRcdHN3aXRjaCAoY2hhcmFjdGVyKSB7XG5cdFx0XHQvLyBdICkgXCIgJ1xuXHRcdFx0Y2FzZSB0eXBlOlxuXHRcdFx0XHRyZXR1cm4gcG9zaXRpb25cblx0XHRcdC8vIFwiICdcblx0XHRcdGNhc2UgMzQ6IGNhc2UgMzk6XG5cdFx0XHRcdGlmICh0eXBlICE9PSAzNCAmJiB0eXBlICE9PSAzOSlcblx0XHRcdFx0XHRkZWxpbWl0ZXIoY2hhcmFjdGVyKTtcblx0XHRcdFx0YnJlYWtcblx0XHRcdC8vIChcblx0XHRcdGNhc2UgNDA6XG5cdFx0XHRcdGlmICh0eXBlID09PSA0MSlcblx0XHRcdFx0XHRkZWxpbWl0ZXIodHlwZSk7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXFxuXHRcdFx0Y2FzZSA5Mjpcblx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRyZXR1cm4gcG9zaXRpb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvbW1lbnRlciAodHlwZSwgaW5kZXgpIHtcblx0d2hpbGUgKG5leHQoKSlcblx0XHQvLyAvL1xuXHRcdGlmICh0eXBlICsgY2hhcmFjdGVyID09PSA0NyArIDEwKVxuXHRcdFx0YnJlYWtcblx0XHQvLyAvKlxuXHRcdGVsc2UgaWYgKHR5cGUgKyBjaGFyYWN0ZXIgPT09IDQyICsgNDIgJiYgcGVlaygpID09PSA0Nylcblx0XHRcdGJyZWFrXG5cblx0cmV0dXJuICcvKicgKyBzbGljZShpbmRleCwgcG9zaXRpb24gLSAxKSArICcqJyArIGZyb20odHlwZSA9PT0gNDcgPyB0eXBlIDogbmV4dCgpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyIChpbmRleCkge1xuXHR3aGlsZSAoIXRva2VuKHBlZWsoKSkpXG5cdFx0bmV4dCgpO1xuXG5cdHJldHVybiBzbGljZShpbmRleCwgcG9zaXRpb24pXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAodmFsdWUpIHtcblx0cmV0dXJuIGRlYWxsb2MocGFyc2UoJycsIG51bGwsIG51bGwsIG51bGwsIFsnJ10sIHZhbHVlID0gYWxsb2ModmFsdWUpLCAwLCBbMF0sIHZhbHVlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcnVsZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcnVsZXNcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVzZXRzXG4gKiBAcGFyYW0ge251bWJlcltdfSBwc2V1ZG9cbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZGVjbGFyYXRpb25zXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlICh2YWx1ZSwgcm9vdCwgcGFyZW50LCBydWxlLCBydWxlcywgcnVsZXNldHMsIHBzZXVkbywgcG9pbnRzLCBkZWNsYXJhdGlvbnMpIHtcblx0dmFyIGluZGV4ID0gMDtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHZhciBsZW5ndGggPSBwc2V1ZG87XG5cdHZhciBhdHJ1bGUgPSAwO1xuXHR2YXIgcHJvcGVydHkgPSAwO1xuXHR2YXIgcHJldmlvdXMgPSAwO1xuXHR2YXIgdmFyaWFibGUgPSAxO1xuXHR2YXIgc2Nhbm5pbmcgPSAxO1xuXHR2YXIgYW1wZXJzYW5kID0gMTtcblx0dmFyIGNoYXJhY3RlciA9IDA7XG5cdHZhciB0eXBlID0gJyc7XG5cdHZhciBwcm9wcyA9IHJ1bGVzO1xuXHR2YXIgY2hpbGRyZW4gPSBydWxlc2V0cztcblx0dmFyIHJlZmVyZW5jZSA9IHJ1bGU7XG5cdHZhciBjaGFyYWN0ZXJzID0gdHlwZTtcblxuXHR3aGlsZSAoc2Nhbm5pbmcpXG5cdFx0c3dpdGNoIChwcmV2aW91cyA9IGNoYXJhY3RlciwgY2hhcmFjdGVyID0gbmV4dCgpKSB7XG5cdFx0XHQvLyAoXG5cdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRpZiAocHJldmlvdXMgIT0gMTA4ICYmIGNoYXJhdChjaGFyYWN0ZXJzLCBsZW5ndGggLSAxKSA9PSA1OCkge1xuXHRcdFx0XHRcdGlmIChpbmRleG9mKGNoYXJhY3RlcnMgKz0gcmVwbGFjZShkZWxpbWl0KGNoYXJhY3RlciksICcmJywgJyZcXGYnKSwgJyZcXGYnKSAhPSAtMSlcblx0XHRcdFx0XHRcdGFtcGVyc2FuZCA9IC0xO1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdC8vIFwiICcgW1xuXHRcdFx0Y2FzZSAzNDogY2FzZSAzOTogY2FzZSA5MTpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSBkZWxpbWl0KGNoYXJhY3Rlcik7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXHQgXFxuIFxcciBcXHNcblx0XHRcdGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSB3aGl0ZXNwYWNlKHByZXZpb3VzKTtcblx0XHRcdFx0YnJlYWtcblx0XHRcdC8vIFxcXG5cdFx0XHRjYXNlIDkyOlxuXHRcdFx0XHRjaGFyYWN0ZXJzICs9IGVzY2FwaW5nKGNhcmV0KCkgLSAxLCA3KTtcblx0XHRcdFx0Y29udGludWVcblx0XHRcdC8vIC9cblx0XHRcdGNhc2UgNDc6XG5cdFx0XHRcdHN3aXRjaCAocGVlaygpKSB7XG5cdFx0XHRcdFx0Y2FzZSA0MjogY2FzZSA0Nzpcblx0XHRcdFx0XHRcdGFwcGVuZChjb21tZW50KGNvbW1lbnRlcihuZXh0KCksIGNhcmV0KCkpLCByb290LCBwYXJlbnQpLCBkZWNsYXJhdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hhcmFjdGVycyArPSAnLyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWtcblx0XHRcdC8vIHtcblx0XHRcdGNhc2UgMTIzICogdmFyaWFibGU6XG5cdFx0XHRcdHBvaW50c1tpbmRleCsrXSA9IHN0cmxlbihjaGFyYWN0ZXJzKSAqIGFtcGVyc2FuZDtcblx0XHRcdC8vIH0gOyBcXDBcblx0XHRcdGNhc2UgMTI1ICogdmFyaWFibGU6IGNhc2UgNTk6IGNhc2UgMDpcblx0XHRcdFx0c3dpdGNoIChjaGFyYWN0ZXIpIHtcblx0XHRcdFx0XHQvLyBcXDAgfVxuXHRcdFx0XHRcdGNhc2UgMDogY2FzZSAxMjU6IHNjYW5uaW5nID0gMDtcblx0XHRcdFx0XHQvLyA7XG5cdFx0XHRcdFx0Y2FzZSA1OSArIG9mZnNldDpcblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA+IDAgJiYgKHN0cmxlbihjaGFyYWN0ZXJzKSAtIGxlbmd0aCkpXG5cdFx0XHRcdFx0XHRcdGFwcGVuZChwcm9wZXJ0eSA+IDMyID8gZGVjbGFyYXRpb24oY2hhcmFjdGVycyArICc7JywgcnVsZSwgcGFyZW50LCBsZW5ndGggLSAxKSA6IGRlY2xhcmF0aW9uKHJlcGxhY2UoY2hhcmFjdGVycywgJyAnLCAnJykgKyAnOycsIHJ1bGUsIHBhcmVudCwgbGVuZ3RoIC0gMiksIGRlY2xhcmF0aW9ucyk7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vIEAgO1xuXHRcdFx0XHRcdGNhc2UgNTk6IGNoYXJhY3RlcnMgKz0gJzsnO1xuXHRcdFx0XHRcdC8vIHsgcnVsZS9hdC1ydWxlXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGFwcGVuZChyZWZlcmVuY2UgPSBydWxlc2V0KGNoYXJhY3RlcnMsIHJvb3QsIHBhcmVudCwgaW5kZXgsIG9mZnNldCwgcnVsZXMsIHBvaW50cywgdHlwZSwgcHJvcHMgPSBbXSwgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoKSwgcnVsZXNldHMpO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2hhcmFjdGVyID09PSAxMjMpXG5cdFx0XHRcdFx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2UoY2hhcmFjdGVycywgcm9vdCwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIHByb3BzLCBydWxlc2V0cywgbGVuZ3RoLCBwb2ludHMsIGNoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoYXRydWxlID09PSA5OSAmJiBjaGFyYXQoY2hhcmFjdGVycywgMykgPT09IDExMCA/IDEwMCA6IGF0cnVsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZCBtIHNcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMTAwOiBjYXNlIDEwOTogY2FzZSAxMTU6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlKHZhbHVlLCByZWZlcmVuY2UsIHJlZmVyZW5jZSwgcnVsZSAmJiBhcHBlbmQocnVsZXNldCh2YWx1ZSwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIDAsIDAsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHJ1bGVzLCBwcm9wcyA9IFtdLCBsZW5ndGgpLCBjaGlsZHJlbiksIHJ1bGVzLCBjaGlsZHJlbiwgbGVuZ3RoLCBwb2ludHMsIHJ1bGUgPyBwcm9wcyA6IGNoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlKGNoYXJhY3RlcnMsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIFsnJ10sIGNoaWxkcmVuLCAwLCBwb2ludHMsIGNoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCA9IG9mZnNldCA9IHByb3BlcnR5ID0gMCwgdmFyaWFibGUgPSBhbXBlcnNhbmQgPSAxLCB0eXBlID0gY2hhcmFjdGVycyA9ICcnLCBsZW5ndGggPSBwc2V1ZG87XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyA6XG5cdFx0XHRjYXNlIDU4OlxuXHRcdFx0XHRsZW5ndGggPSAxICsgc3RybGVuKGNoYXJhY3RlcnMpLCBwcm9wZXJ0eSA9IHByZXZpb3VzO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aWYgKHZhcmlhYmxlIDwgMSlcblx0XHRcdFx0XHRpZiAoY2hhcmFjdGVyID09IDEyMylcblx0XHRcdFx0XHRcdC0tdmFyaWFibGU7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY2hhcmFjdGVyID09IDEyNSAmJiB2YXJpYWJsZSsrID09IDAgJiYgcHJldigpID09IDEyNSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdFx0c3dpdGNoIChjaGFyYWN0ZXJzICs9IGZyb20oY2hhcmFjdGVyKSwgY2hhcmFjdGVyICogdmFyaWFibGUpIHtcblx0XHRcdFx0XHQvLyAmXG5cdFx0XHRcdFx0Y2FzZSAzODpcblx0XHRcdFx0XHRcdGFtcGVyc2FuZCA9IG9mZnNldCA+IDAgPyAxIDogKGNoYXJhY3RlcnMgKz0gJ1xcZicsIC0xKTtcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Ly8gLFxuXHRcdFx0XHRcdGNhc2UgNDQ6XG5cdFx0XHRcdFx0XHRwb2ludHNbaW5kZXgrK10gPSAoc3RybGVuKGNoYXJhY3RlcnMpIC0gMSkgKiBhbXBlcnNhbmQsIGFtcGVyc2FuZCA9IDE7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vIEBcblx0XHRcdFx0XHRjYXNlIDY0OlxuXHRcdFx0XHRcdFx0Ly8gLVxuXHRcdFx0XHRcdFx0aWYgKHBlZWsoKSA9PT0gNDUpXG5cdFx0XHRcdFx0XHRcdGNoYXJhY3RlcnMgKz0gZGVsaW1pdChuZXh0KCkpO1xuXG5cdFx0XHRcdFx0XHRhdHJ1bGUgPSBwZWVrKCksIG9mZnNldCA9IGxlbmd0aCA9IHN0cmxlbih0eXBlID0gY2hhcmFjdGVycyArPSBpZGVudGlmaWVyKGNhcmV0KCkpKSwgY2hhcmFjdGVyKys7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vIC1cblx0XHRcdFx0XHRjYXNlIDQ1OlxuXHRcdFx0XHRcdFx0aWYgKHByZXZpb3VzID09PSA0NSAmJiBzdHJsZW4oY2hhcmFjdGVycykgPT0gMilcblx0XHRcdFx0XHRcdFx0dmFyaWFibGUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdHJldHVybiBydWxlc2V0c1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0P30gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVzXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gY2hpbGRyZW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVsZXNldCAodmFsdWUsIHJvb3QsIHBhcmVudCwgaW5kZXgsIG9mZnNldCwgcnVsZXMsIHBvaW50cywgdHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBsZW5ndGgpIHtcblx0dmFyIHBvc3QgPSBvZmZzZXQgLSAxO1xuXHR2YXIgcnVsZSA9IG9mZnNldCA9PT0gMCA/IHJ1bGVzIDogWycnXTtcblx0dmFyIHNpemUgPSBzaXplb2YocnVsZSk7XG5cblx0Zm9yICh2YXIgaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IGluZGV4OyArK2kpXG5cdFx0Zm9yICh2YXIgeCA9IDAsIHkgPSBzdWJzdHIodmFsdWUsIHBvc3QgKyAxLCBwb3N0ID0gYWJzKGogPSBwb2ludHNbaV0pKSwgeiA9IHZhbHVlOyB4IDwgc2l6ZTsgKyt4KVxuXHRcdFx0aWYgKHogPSB0cmltKGogPiAwID8gcnVsZVt4XSArICcgJyArIHkgOiByZXBsYWNlKHksIC8mXFxmL2csIHJ1bGVbeF0pKSlcblx0XHRcdFx0cHJvcHNbaysrXSA9IHo7XG5cblx0cmV0dXJuIG5vZGUodmFsdWUsIHJvb3QsIHBhcmVudCwgb2Zmc2V0ID09PSAwID8gUlVMRVNFVCA6IHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0P30gcGFyZW50XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbW1lbnQgKHZhbHVlLCByb290LCBwYXJlbnQpIHtcblx0cmV0dXJuIG5vZGUodmFsdWUsIHJvb3QsIHBhcmVudCwgQ09NTUVOVCwgZnJvbShjaGFyKCkpLCBzdWJzdHIodmFsdWUsIDIsIC0yKSwgMClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWNsYXJhdGlvbiAodmFsdWUsIHJvb3QsIHBhcmVudCwgbGVuZ3RoKSB7XG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIERFQ0xBUkFUSU9OLCBzdWJzdHIodmFsdWUsIDAsIGxlbmd0aCksIHN1YnN0cih2YWx1ZSwgbGVuZ3RoICsgMSwgLTEpLCBsZW5ndGgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3RbXX0gY2hpbGRyZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG5cdHZhciBvdXRwdXQgPSAnJztcblx0dmFyIGxlbmd0aCA9IHNpemVvZihjaGlsZHJlbik7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRvdXRwdXQgKz0gY2FsbGJhY2soY2hpbGRyZW5baV0sIGksIGNoaWxkcmVuLCBjYWxsYmFjaykgfHwgJyc7XG5cblx0cmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcblx0c3dpdGNoIChlbGVtZW50LnR5cGUpIHtcblx0XHRjYXNlIElNUE9SVDogY2FzZSBERUNMQVJBVElPTjogcmV0dXJuIGVsZW1lbnQucmV0dXJuID0gZWxlbWVudC5yZXR1cm4gfHwgZWxlbWVudC52YWx1ZVxuXHRcdGNhc2UgQ09NTUVOVDogcmV0dXJuICcnXG5cdFx0Y2FzZSBLRVlGUkFNRVM6IHJldHVybiBlbGVtZW50LnJldHVybiA9IGVsZW1lbnQudmFsdWUgKyAneycgKyBzZXJpYWxpemUoZWxlbWVudC5jaGlsZHJlbiwgY2FsbGJhY2spICsgJ30nXG5cdFx0Y2FzZSBSVUxFU0VUOiBlbGVtZW50LnZhbHVlID0gZWxlbWVudC5wcm9wcy5qb2luKCcsJyk7XG5cdH1cblxuXHRyZXR1cm4gc3RybGVuKGNoaWxkcmVuID0gc2VyaWFsaXplKGVsZW1lbnQuY2hpbGRyZW4sIGNhbGxiYWNrKSkgPyBlbGVtZW50LnJldHVybiA9IGVsZW1lbnQudmFsdWUgKyAneycgKyBjaGlsZHJlbiArICd9JyA6ICcnXG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbltdfSBjb2xsZWN0aW9uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWlkZGxld2FyZSAoY29sbGVjdGlvbikge1xuXHR2YXIgbGVuZ3RoID0gc2l6ZW9mKGNvbGxlY3Rpb24pO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRvdXRwdXQgKz0gY29sbGVjdGlvbltpXShlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB8fCAnJztcblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gcnVsZXNoZWV0IChjYWxsYmFjaykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoIWVsZW1lbnQucm9vdClcblx0XHRcdGlmIChlbGVtZW50ID0gZWxlbWVudC5yZXR1cm4pXG5cdFx0XHRcdGNhbGxiYWNrKGVsZW1lbnQpO1xuXHR9XG59XG5cbnZhciB3ZWFrTWVtb2l6ZSA9IGZ1bmN0aW9uIHdlYWtNZW1vaXplKGZ1bmMpIHtcbiAgLy8gJEZsb3dGaXhNZSBmbG93IGRvZXNuJ3QgaW5jbHVkZSBhbGwgbm9uLXByaW1pdGl2ZSB0eXBlcyBhcyBhbGxvd2VkIGZvciB3ZWFrbWFwc1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZS5oYXMoYXJnKSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcmV0dXJuIGNhY2hlLmdldChhcmcpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBmdW5jKGFyZyk7XG4gICAgY2FjaGUuc2V0KGFyZywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xufTtcblxudmFyIGlkZW50aWZpZXJXaXRoUG9pbnRUcmFja2luZyA9IGZ1bmN0aW9uIGlkZW50aWZpZXJXaXRoUG9pbnRUcmFja2luZyhiZWdpbiwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgcHJldmlvdXMgPSAwO1xuICB2YXIgY2hhcmFjdGVyID0gMDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHByZXZpb3VzID0gY2hhcmFjdGVyO1xuICAgIGNoYXJhY3RlciA9IHBlZWsoKTsgLy8gJlxcZlxuXG4gICAgaWYgKHByZXZpb3VzID09PSAzOCAmJiBjaGFyYWN0ZXIgPT09IDEyKSB7XG4gICAgICBwb2ludHNbaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4oY2hhcmFjdGVyKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIHNsaWNlKGJlZ2luLCBwb3NpdGlvbik7XG59O1xuXG52YXIgdG9SdWxlcyA9IGZ1bmN0aW9uIHRvUnVsZXMocGFyc2VkLCBwb2ludHMpIHtcbiAgLy8gcHJldGVuZCB3ZSd2ZSBzdGFydGVkIHdpdGggYSBjb21tYVxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGNoYXJhY3RlciA9IDQ0O1xuXG4gIGRvIHtcbiAgICBzd2l0Y2ggKHRva2VuKGNoYXJhY3RlcikpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gJlxcZlxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSAzOCAmJiBwZWVrKCkgPT09IDEyKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBub3QgMTAwJSBjb3JyZWN0LCB3ZSBkb24ndCBhY2NvdW50IGZvciBsaXRlcmFsIHNlcXVlbmNlcyBoZXJlIC0gbGlrZSBmb3IgZXhhbXBsZSBxdW90ZWQgc3RyaW5nc1xuICAgICAgICAgIC8vIHN0eWxpcyBpbnNlcnRzIFxcZiBhZnRlciAmIHRvIGtub3cgd2hlbiAmIHdoZXJlIGl0IHNob3VsZCByZXBsYWNlIHRoaXMgc2VxdWVuY2Ugd2l0aCB0aGUgY29udGV4dCBzZWxlY3RvclxuICAgICAgICAgIC8vIGFuZCB3aGVuIGl0IHNob3VsZCBqdXN0IGNvbmNhdGVuYXRlIHRoZSBvdXRlciBhbmQgaW5uZXIgc2VsZWN0b3JzXG4gICAgICAgICAgLy8gaXQncyB2ZXJ5IHVubGlrZWx5IGZvciB0aGlzIHNlcXVlbmNlIHRvIGFjdHVhbGx5IGFwcGVhciBpbiBhIGRpZmZlcmVudCBjb250ZXh0LCBzbyB3ZSBqdXN0IGxldmVyYWdlIHRoaXMgZmFjdCBoZXJlXG4gICAgICAgICAgcG9pbnRzW2luZGV4XSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWRbaW5kZXhdICs9IGlkZW50aWZpZXJXaXRoUG9pbnRUcmFja2luZyhwb3NpdGlvbiAtIDEsIHBvaW50cywgaW5kZXgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBwYXJzZWRbaW5kZXhdICs9IGRlbGltaXQoY2hhcmFjdGVyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgLy8gY29tbWFcbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gNDQpIHtcbiAgICAgICAgICAvLyBjb2xvblxuICAgICAgICAgIHBhcnNlZFsrK2luZGV4XSA9IHBlZWsoKSA9PT0gNTggPyAnJlxcZicgOiAnJztcbiAgICAgICAgICBwb2ludHNbaW5kZXhdID0gcGFyc2VkW2luZGV4XS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFyc2VkW2luZGV4XSArPSBmcm9tKGNoYXJhY3Rlcik7XG4gICAgfVxuICB9IHdoaWxlIChjaGFyYWN0ZXIgPSBuZXh0KCkpO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG52YXIgZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcyh2YWx1ZSwgcG9pbnRzKSB7XG4gIHJldHVybiBkZWFsbG9jKHRvUnVsZXMoYWxsb2ModmFsdWUpLCBwb2ludHMpKTtcbn07IC8vIFdlYWtTZXQgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZSwgYnV0IG9ubHkgV2Vha01hcCBpcyBzdXBwb3J0ZWQgaW4gSUUxMVxuXG5cbnZhciBmaXhlZEVsZW1lbnRzID0gLyogI19fUFVSRV9fICovbmV3IFdlYWtNYXAoKTtcbnZhciBjb21wYXQgPSBmdW5jdGlvbiBjb21wYXQoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC50eXBlICE9PSAncnVsZScgfHwgIWVsZW1lbnQucGFyZW50IHx8IC8vIHBvc2l0aXZlIC5sZW5ndGggaW5kaWNhdGVzIHRoYXQgdGhpcyBydWxlIGNvbnRhaW5zIHBzZXVkb1xuICAvLyBuZWdhdGl2ZSAubGVuZ3RoIGluZGljYXRlcyB0aGF0IHRoaXMgcnVsZSBoYXMgYmVlbiBhbHJlYWR5IHByZWZpeGVkXG4gIGVsZW1lbnQubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IGVsZW1lbnQudmFsdWUsXG4gICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgdmFyIGlzSW1wbGljaXRSdWxlID0gZWxlbWVudC5jb2x1bW4gPT09IHBhcmVudC5jb2x1bW4gJiYgZWxlbWVudC5saW5lID09PSBwYXJlbnQubGluZTtcblxuICB3aGlsZSAocGFyZW50LnR5cGUgIT09ICdydWxlJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgfSAvLyBzaG9ydC1jaXJjdWl0IGZvciB0aGUgc2ltcGxlc3QgY2FzZVxuXG5cbiAgaWYgKGVsZW1lbnQucHJvcHMubGVuZ3RoID09PSAxICYmIHZhbHVlLmNoYXJDb2RlQXQoMCkgIT09IDU4XG4gIC8qIGNvbG9uICovXG4gICYmICFmaXhlZEVsZW1lbnRzLmdldChwYXJlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlmIHRoaXMgaXMgYW4gaW1wbGljaXRseSBpbnNlcnRlZCBydWxlICh0aGUgb25lIGVhZ2VybHkgaW5zZXJ0ZWQgYXQgdGhlIGVhY2ggbmV3IG5lc3RlZCBsZXZlbClcbiAgLy8gdGhlbiB0aGUgcHJvcHMgaGFzIGFscmVhZHkgYmVlbiBtYW5pcHVsYXRlZCBiZWZvcmVoYW5kIGFzIHRoZXkgdGhhdCBhcnJheSBpcyBzaGFyZWQgYmV0d2VlbiBpdCBhbmQgaXRzIFwicnVsZSBwYXJlbnRcIlxuXG5cbiAgaWYgKGlzSW1wbGljaXRSdWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZml4ZWRFbGVtZW50cy5zZXQoZWxlbWVudCwgdHJ1ZSk7XG4gIHZhciBwb2ludHMgPSBbXTtcbiAgdmFyIHJ1bGVzID0gZ2V0UnVsZXModmFsdWUsIHBvaW50cyk7XG4gIHZhciBwYXJlbnRSdWxlcyA9IHBhcmVudC5wcm9wcztcblxuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50UnVsZXMubGVuZ3RoOyBqKyssIGsrKykge1xuICAgICAgZWxlbWVudC5wcm9wc1trXSA9IHBvaW50c1tpXSA/IHJ1bGVzW2ldLnJlcGxhY2UoLyZcXGYvZywgcGFyZW50UnVsZXNbal0pIDogcGFyZW50UnVsZXNbal0gKyBcIiBcIiArIHJ1bGVzW2ldO1xuICAgIH1cbiAgfVxufTtcbnZhciByZW1vdmVMYWJlbCA9IGZ1bmN0aW9uIHJlbW92ZUxhYmVsKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC52YWx1ZTtcblxuICAgIGlmICggLy8gY2hhcmNvZGUgZm9yIGxcbiAgICB2YWx1ZS5jaGFyQ29kZUF0KDApID09PSAxMDggJiYgLy8gY2hhcmNvZGUgZm9yIGJcbiAgICB2YWx1ZS5jaGFyQ29kZUF0KDIpID09PSA5OCkge1xuICAgICAgLy8gdGhpcyBpZ25vcmVzIGxhYmVsXG4gICAgICBlbGVtZW50W1wicmV0dXJuXCJdID0gJyc7XG4gICAgICBlbGVtZW50LnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG59O1xudmFyIGlnbm9yZUZsYWcgPSAnZW1vdGlvbi1kaXNhYmxlLXNlcnZlci1yZW5kZXJpbmctdW5zYWZlLXNlbGVjdG9yLXdhcm5pbmctcGxlYXNlLWRvLW5vdC11c2UtdGhpcy10aGUtd2FybmluZy1leGlzdHMtZm9yLWEtcmVhc29uJztcblxudmFyIGlzSWdub3JpbmdDb21tZW50ID0gZnVuY3Rpb24gaXNJZ25vcmluZ0NvbW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50eXBlID09PSAnY29tbScgJiYgZWxlbWVudC5jaGlsZHJlbi5pbmRleE9mKGlnbm9yZUZsYWcpID4gLTE7XG59O1xuXG52YXIgY3JlYXRlVW5zYWZlU2VsZWN0b3JzQWxhcm0gPSBmdW5jdGlvbiBjcmVhdGVVbnNhZmVTZWxlY3RvcnNBbGFybShjYWNoZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbikge1xuICAgIGlmIChlbGVtZW50LnR5cGUgIT09ICdydWxlJyB8fCBjYWNoZS5jb21wYXQpIHJldHVybjtcbiAgICB2YXIgdW5zYWZlUHNldWRvQ2xhc3NlcyA9IGVsZW1lbnQudmFsdWUubWF0Y2goLyg6Zmlyc3R8Om50aHw6bnRoLWxhc3QpLWNoaWxkL2cpO1xuXG4gICAgaWYgKHVuc2FmZVBzZXVkb0NsYXNzZXMpIHtcbiAgICAgIHZhciBpc05lc3RlZCA9IGVsZW1lbnQucGFyZW50ID09PSBjaGlsZHJlblswXTsgLy8gaW4gbmVzdGVkIHJ1bGVzIGNvbW1lbnRzIGJlY29tZSBjaGlsZHJlbiBvZiB0aGUgXCJhdXRvLWluc2VydGVkXCIgcnVsZVxuICAgICAgLy9cbiAgICAgIC8vIGNvbnNpZGVyaW5nIHRoaXMgaW5wdXQ6XG4gICAgICAvLyAuYSB7XG4gICAgICAvLyAgIC5iIC8qIGNvbW0gKi8ge31cbiAgICAgIC8vICAgY29sb3I6IGhvdHBpbms7XG4gICAgICAvLyB9XG4gICAgICAvLyB3ZSBnZXQgb3V0cHV0IGNvcnJlc3BvbmRpbmcgdG8gdGhpczpcbiAgICAgIC8vIC5hIHtcbiAgICAgIC8vICAgJiB7XG4gICAgICAvLyAgICAgLyogY29tbSAqL1xuICAgICAgLy8gICAgIGNvbG9yOiBob3RwaW5rO1xuICAgICAgLy8gICB9XG4gICAgICAvLyAgIC5iIHt9XG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBjb21tZW50Q29udGFpbmVyID0gaXNOZXN0ZWQgPyBjaGlsZHJlblswXS5jaGlsZHJlbiA6IC8vIGdsb2JhbCBydWxlIGF0IHRoZSByb290IGxldmVsXG4gICAgICBjaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IGNvbW1lbnRDb250YWluZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21tZW50Q29udGFpbmVyW2ldO1xuXG4gICAgICAgIGlmIChub2RlLmxpbmUgPCBlbGVtZW50LmxpbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBpdCBpcyBxdWl0ZSB3ZWlyZCBidXQgY29tbWVudHMgYXJlICp1c3VhbGx5KiBwdXQgYXQgYGNvbHVtbjogZWxlbWVudC5jb2x1bW4gLSAxYFxuICAgICAgICAvLyBzbyB3ZSBzZWVrICpmcm9tIHRoZSBlbmQqIGZvciB0aGUgbm9kZSB0aGF0IGlzIGVhcmxpZXIgdGhhbiB0aGUgcnVsZSdzIGBlbGVtZW50YCBhbmQgY2hlY2sgdGhhdFxuICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyBtYXRjaCBpbnB1dHMgbGlrZSB0aGlzOlxuICAgICAgICAvLyAuYSB7XG4gICAgICAgIC8vICAgLyogY29tbSAqL1xuICAgICAgICAvLyAgIC5iIHt9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYnV0IHRoYXQgaXMgZmluZVxuICAgICAgICAvL1xuICAgICAgICAvLyBpdCB3b3VsZCBiZSB0aGUgZWFzaWVzdCB0byBjaGFuZ2UgdGhlIHBsYWNlbWVudCBvZiB0aGUgY29tbWVudCB0byBiZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHJ1bGU6XG4gICAgICAgIC8vIC5hIHtcbiAgICAgICAgLy8gICAuYiB7IC8qIGNvbW0gKi8gfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHdpdGggc3VjaCBpbnB1dHMgd2Ugd291bGRuJ3QgaGF2ZSB0byBzZWFyY2ggZm9yIHRoZSBjb21tZW50IGF0IGFsbFxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBjaGFuZ2luZyB0aGlzIGNvbW1lbnQgcGxhY2VtZW50IGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cblxuXG4gICAgICAgIGlmIChub2RlLmNvbHVtbiA8IGVsZW1lbnQuY29sdW1uKSB7XG4gICAgICAgICAgaWYgKGlzSWdub3JpbmdDb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdW5zYWZlUHNldWRvQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uICh1bnNhZmVQc2V1ZG9DbGFzcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHBzZXVkbyBjbGFzcyBcXFwiXCIgKyB1bnNhZmVQc2V1ZG9DbGFzcyArIFwiXFxcIiBpcyBwb3RlbnRpYWxseSB1bnNhZmUgd2hlbiBkb2luZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuIFRyeSBjaGFuZ2luZyBpdCB0byBcXFwiXCIgKyB1bnNhZmVQc2V1ZG9DbGFzcy5zcGxpdCgnLWNoaWxkJylbMF0gKyBcIi1vZi10eXBlXFxcIi5cIik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgaXNJbXBvcnRSdWxlID0gZnVuY3Rpb24gaXNJbXBvcnRSdWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZS5jaGFyQ29kZUF0KDEpID09PSAxMDUgJiYgZWxlbWVudC50eXBlLmNoYXJDb2RlQXQoMCkgPT09IDY0O1xufTtcblxudmFyIGlzUHJlcGVuZGVkV2l0aFJlZ3VsYXJSdWxlcyA9IGZ1bmN0aW9uIGlzUHJlcGVuZGVkV2l0aFJlZ3VsYXJSdWxlcyhpbmRleCwgY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoIWlzSW1wb3J0UnVsZShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IC8vIHVzZSB0aGlzIHRvIHJlbW92ZSBpbmNvcnJlY3QgZWxlbWVudHMgZnJvbSBmdXJ0aGVyIHByb2Nlc3Npbmdcbi8vIHNvIHRoZXkgZG9uJ3QgZ2V0IGhhbmRlZCB0byB0aGUgYHNoZWV0YCAob3IgYW55dGhpbmcgZWxzZSlcbi8vIGFzIHRoYXQgY291bGQgcG90ZW50aWFsbHkgbGVhZCB0byBhZGRpdGlvbmFsIGxvZ3Mgd2hpY2ggaW4gdHVybiBjb3VsZCBiZSBvdmVyaGVsbWluZyB0byB0aGUgdXNlclxuXG5cbnZhciBudWxsaWZ5RWxlbWVudCA9IGZ1bmN0aW9uIG51bGxpZnlFbGVtZW50KGVsZW1lbnQpIHtcbiAgZWxlbWVudC50eXBlID0gJyc7XG4gIGVsZW1lbnQudmFsdWUgPSAnJztcbiAgZWxlbWVudFtcInJldHVyblwiXSA9ICcnO1xuICBlbGVtZW50LmNoaWxkcmVuID0gJyc7XG4gIGVsZW1lbnQucHJvcHMgPSAnJztcbn07XG5cbnZhciBpbmNvcnJlY3RJbXBvcnRBbGFybSA9IGZ1bmN0aW9uIGluY29ycmVjdEltcG9ydEFsYXJtKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbikge1xuICBpZiAoIWlzSW1wb3J0UnVsZShlbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGVtZW50LnBhcmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJgQGltcG9ydGAgcnVsZXMgY2FuJ3QgYmUgbmVzdGVkIGluc2lkZSBvdGhlciBydWxlcy4gUGxlYXNlIG1vdmUgaXQgdG8gdGhlIHRvcCBsZXZlbCBhbmQgcHV0IGl0IGJlZm9yZSByZWd1bGFyIHJ1bGVzLiBLZWVwIGluIG1pbmQgdGhhdCB0aGV5IGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIGdsb2JhbCBzdHlsZXMuXCIpO1xuICAgIG51bGxpZnlFbGVtZW50KGVsZW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzUHJlcGVuZGVkV2l0aFJlZ3VsYXJSdWxlcyhpbmRleCwgY2hpbGRyZW4pKSB7XG4gICAgY29uc29sZS5lcnJvcihcImBAaW1wb3J0YCBydWxlcyBjYW4ndCBiZSBhZnRlciBvdGhlciBydWxlcy4gUGxlYXNlIHB1dCB5b3VyIGBAaW1wb3J0YCBydWxlcyBiZWZvcmUgeW91ciBvdGhlciBydWxlcy5cIik7XG4gICAgbnVsbGlmeUVsZW1lbnQoZWxlbWVudCk7XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG5cbmZ1bmN0aW9uIHByZWZpeCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHN3aXRjaCAoaGFzaCQyKHZhbHVlLCBsZW5ndGgpKSB7XG4gICAgLy8gY29sb3ItYWRqdXN0XG4gICAgY2FzZSA1MTAzOlxuICAgICAgcmV0dXJuIFdFQktJVCArICdwcmludC0nICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBhbmltYXRpb24sIGFuaW1hdGlvbi0oZGVsYXl8ZGlyZWN0aW9ufGR1cmF0aW9ufGZpbGwtbW9kZXxpdGVyYXRpb24tY291bnR8bmFtZXxwbGF5LXN0YXRlfHRpbWluZy1mdW5jdGlvbilcblxuICAgIGNhc2UgNTczNzpcbiAgICBjYXNlIDQyMDE6XG4gICAgY2FzZSAzMTc3OlxuICAgIGNhc2UgMzQzMzpcbiAgICBjYXNlIDE2NDE6XG4gICAgY2FzZSA0NDU3OlxuICAgIGNhc2UgMjkyMTogLy8gdGV4dC1kZWNvcmF0aW9uLCBmaWx0ZXIsIGNsaXAtcGF0aCwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgY29sdW1uLCBib3gtZGVjb3JhdGlvbi1icmVha1xuXG4gICAgY2FzZSA1NTcyOlxuICAgIGNhc2UgNjM1NjpcbiAgICBjYXNlIDU4NDQ6XG4gICAgY2FzZSAzMTkxOlxuICAgIGNhc2UgNjY0NTpcbiAgICBjYXNlIDMwMDU6IC8vIG1hc2ssIG1hc2staW1hZ2UsIG1hc2stKG1vZGV8Y2xpcHxzaXplKSwgbWFzay0ocmVwZWF0fG9yaWdpbiksIG1hc2stcG9zaXRpb24sIG1hc2stY29tcG9zaXRlLFxuXG4gICAgY2FzZSA2MzkxOlxuICAgIGNhc2UgNTg3OTpcbiAgICBjYXNlIDU2MjM6XG4gICAgY2FzZSA2MTM1OlxuICAgIGNhc2UgNDU5OTpcbiAgICBjYXNlIDQ4NTU6IC8vIGJhY2tncm91bmQtY2xpcCwgY29sdW1ucywgY29sdW1uLShjb3VudHxmaWxsfGdhcHxydWxlfHJ1bGUtY29sb3J8cnVsZS1zdHlsZXxydWxlLXdpZHRofHNwYW58d2lkdGgpXG5cbiAgICBjYXNlIDQyMTU6XG4gICAgY2FzZSA2Mzg5OlxuICAgIGNhc2UgNTEwOTpcbiAgICBjYXNlIDUzNjU6XG4gICAgY2FzZSA1NjIxOlxuICAgIGNhc2UgMzgyOTpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIHZhbHVlO1xuICAgIC8vIGFwcGVhcmFuY2UsIHVzZXItc2VsZWN0LCB0cmFuc2Zvcm0sIGh5cGhlbnMsIHRleHQtc2l6ZS1hZGp1c3RcblxuICAgIGNhc2UgNTM0OTpcbiAgICBjYXNlIDQyNDY6XG4gICAgY2FzZSA0ODEwOlxuICAgIGNhc2UgNjk2ODpcbiAgICBjYXNlIDI3NTY6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNT1ogKyB2YWx1ZSArIE1TICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBmbGV4LCBmbGV4LWRpcmVjdGlvblxuXG4gICAgY2FzZSA2ODI4OlxuICAgIGNhc2UgNDI2ODpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBvcmRlclxuXG4gICAgY2FzZSA2MTY1OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyAnZmxleC0nICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBhbGlnbi1pdGVtc1xuXG4gICAgY2FzZSA1MTg3OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgcmVwbGFjZSh2YWx1ZSwgLyhcXHcrKS4rKDpbXl0rKS8sIFdFQktJVCArICdib3gtJDEkMicgKyBNUyArICdmbGV4LSQxJDInKSArIHZhbHVlO1xuICAgIC8vIGFsaWduLXNlbGZcblxuICAgIGNhc2UgNTQ0MzpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtaXRlbS0nICsgcmVwbGFjZSh2YWx1ZSwgL2ZsZXgtfC1zZWxmLywgJycpICsgdmFsdWU7XG4gICAgLy8gYWxpZ24tY29udGVudFxuXG4gICAgY2FzZSA0Njc1OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyAnZmxleC1saW5lLXBhY2snICsgcmVwbGFjZSh2YWx1ZSwgL2FsaWduLWNvbnRlbnR8ZmxleC18LXNlbGYvLCAnJykgKyB2YWx1ZTtcbiAgICAvLyBmbGV4LXNocmlua1xuXG4gICAgY2FzZSA1NTQ4OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyB2YWx1ZTtcbiAgICAvLyBmbGV4LWJhc2lzXG5cbiAgICBjYXNlIDUyOTI6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsICdiYXNpcycsICdwcmVmZXJyZWQtc2l6ZScpICsgdmFsdWU7XG4gICAgLy8gZmxleC1ncm93XG5cbiAgICBjYXNlIDYwNjA6XG4gICAgICByZXR1cm4gV0VCS0lUICsgJ2JveC0nICsgcmVwbGFjZSh2YWx1ZSwgJy1ncm93JywgJycpICsgV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsICdncm93JywgJ3Bvc2l0aXZlJykgKyB2YWx1ZTtcbiAgICAvLyB0cmFuc2l0aW9uXG5cbiAgICBjYXNlIDQ1NTQ6XG4gICAgICByZXR1cm4gV0VCS0lUICsgcmVwbGFjZSh2YWx1ZSwgLyhbXi1dKSh0cmFuc2Zvcm0pL2csICckMScgKyBXRUJLSVQgKyAnJDInKSArIHZhbHVlO1xuICAgIC8vIGN1cnNvclxuXG4gICAgY2FzZSA2MTg3OlxuICAgICAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZShyZXBsYWNlKHZhbHVlLCAvKHpvb20tfGdyYWIpLywgV0VCS0lUICsgJyQxJyksIC8oaW1hZ2Utc2V0KS8sIFdFQktJVCArICckMScpLCB2YWx1ZSwgJycpICsgdmFsdWU7XG4gICAgLy8gYmFja2dyb3VuZCwgYmFja2dyb3VuZC1pbWFnZVxuXG4gICAgY2FzZSA1NDk1OlxuICAgIGNhc2UgMzk1OTpcbiAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKGltYWdlLXNldFxcKFteXSopLywgV0VCS0lUICsgJyQxJyArICckYCQxJyk7XG4gICAgLy8ganVzdGlmeS1jb250ZW50XG5cbiAgICBjYXNlIDQ5Njg6XG4gICAgICByZXR1cm4gcmVwbGFjZShyZXBsYWNlKHZhbHVlLCAvKC4rOikoZmxleC0pPyguKikvLCBXRUJLSVQgKyAnYm94LXBhY2s6JDMnICsgTVMgKyAnZmxleC1wYWNrOiQzJyksIC9zListYlteO10rLywgJ2p1c3RpZnknKSArIFdFQktJVCArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gKG1hcmdpbnxwYWRkaW5nKS1pbmxpbmUtKHN0YXJ0fGVuZClcblxuICAgIGNhc2UgNDA5NTpcbiAgICBjYXNlIDM1ODM6XG4gICAgY2FzZSA0MDY4OlxuICAgIGNhc2UgMjUzMjpcbiAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rKS1pbmxpbmUoLispLywgV0VCS0lUICsgJyQxJDInKSArIHZhbHVlO1xuICAgIC8vIChtaW58bWF4KT8od2lkdGh8aGVpZ2h0fGlubGluZS1zaXplfGJsb2NrLXNpemUpXG5cbiAgICBjYXNlIDgxMTY6XG4gICAgY2FzZSA3MDU5OlxuICAgIGNhc2UgNTc1MzpcbiAgICBjYXNlIDU1MzU6XG4gICAgY2FzZSA1NDQ1OlxuICAgIGNhc2UgNTcwMTpcbiAgICBjYXNlIDQ5MzM6XG4gICAgY2FzZSA0Njc3OlxuICAgIGNhc2UgNTUzMzpcbiAgICBjYXNlIDU3ODk6XG4gICAgY2FzZSA1MDIxOlxuICAgIGNhc2UgNDc2NTpcbiAgICAgIC8vIHN0cmV0Y2gsIG1heC1jb250ZW50LCBtaW4tY29udGVudCwgZmlsbC1hdmFpbGFibGVcbiAgICAgIGlmIChzdHJsZW4odmFsdWUpIC0gMSAtIGxlbmd0aCA+IDYpIHN3aXRjaCAoY2hhcmF0KHZhbHVlLCBsZW5ndGggKyAxKSkge1xuICAgICAgICAvLyAobSlheC1jb250ZW50LCAobSlpbi1jb250ZW50XG4gICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgIC8vIC1cbiAgICAgICAgICBpZiAoY2hhcmF0KHZhbHVlLCBsZW5ndGggKyA0KSAhPT0gNDUpIGJyZWFrO1xuICAgICAgICAvLyAoZilpbGwtYXZhaWxhYmxlLCAoZilpdC1jb250ZW50XG5cbiAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2UodmFsdWUsIC8oLis6KSguKyktKFteXSspLywgJyQxJyArIFdFQktJVCArICckMi0kMycgKyAnJDEnICsgTU9aICsgKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgMykgPT0gMTA4ID8gJyQzJyA6ICckMi0kMycpKSArIHZhbHVlO1xuICAgICAgICAvLyAocyl0cmV0Y2hcblxuICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICByZXR1cm4gfmluZGV4b2YodmFsdWUsICdzdHJldGNoJykgPyBwcmVmaXgocmVwbGFjZSh2YWx1ZSwgJ3N0cmV0Y2gnLCAnZmlsbC1hdmFpbGFibGUnKSwgbGVuZ3RoKSArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBwb3NpdGlvbjogc3RpY2t5XG5cbiAgICBjYXNlIDQ5NDk6XG4gICAgICAvLyAocyl0aWNreT9cbiAgICAgIGlmIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDEpICE9PSAxMTUpIGJyZWFrO1xuICAgIC8vIGRpc3BsYXk6IChmbGV4fGlubGluZS1mbGV4KVxuXG4gICAgY2FzZSA2NDQ0OlxuICAgICAgc3dpdGNoIChjaGFyYXQodmFsdWUsIHN0cmxlbih2YWx1ZSkgLSAzIC0gKH5pbmRleG9mKHZhbHVlLCAnIWltcG9ydGFudCcpICYmIDEwKSkpIHtcbiAgICAgICAgLy8gc3RpYyhrKXlcbiAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2UodmFsdWUsICc6JywgJzonICsgV0VCS0lUKSArIHZhbHVlO1xuICAgICAgICAvLyAoaW5saW5lLSk/ZmwoZSl4XG5cbiAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2UodmFsdWUsIC8oLis6KShbXjshXSspKDt8IS4rKT8vLCAnJDEnICsgV0VCS0lUICsgKGNoYXJhdCh2YWx1ZSwgMTQpID09PSA0NSA/ICdpbmxpbmUtJyA6ICcnKSArICdib3gkMycgKyAnJDEnICsgV0VCS0lUICsgJyQyJDMnICsgJyQxJyArIE1TICsgJyQyYm94JDMnKSArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICAvLyB3cml0aW5nLW1vZGVcblxuICAgIGNhc2UgNTkzNjpcbiAgICAgIHN3aXRjaCAoY2hhcmF0KHZhbHVlLCBsZW5ndGggKyAxMSkpIHtcbiAgICAgICAgLy8gdmVydGljYWwtbChyKVxuICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgJ3RiJykgKyB2YWx1ZTtcbiAgICAgICAgLy8gdmVydGljYWwtcihsKVxuXG4gICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgcmVwbGFjZSh2YWx1ZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCAndGItcmwnKSArIHZhbHVlO1xuICAgICAgICAvLyBob3Jpem9udGFsKC0pdGJcblxuICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgcmVwbGFjZSh2YWx1ZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCAnbHInKSArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHZhbHVlICsgdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBwcmVmaXhlciA9IGZ1bmN0aW9uIHByZWZpeGVyKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgaWYgKGVsZW1lbnQubGVuZ3RoID4gLTEpIGlmICghZWxlbWVudFtcInJldHVyblwiXSkgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICBjYXNlIERFQ0xBUkFUSU9OOlxuICAgICAgZWxlbWVudFtcInJldHVyblwiXSA9IHByZWZpeChlbGVtZW50LnZhbHVlLCBlbGVtZW50Lmxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgS0VZRlJBTUVTOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbY29weShlbGVtZW50LCB7XG4gICAgICAgIHZhbHVlOiByZXBsYWNlKGVsZW1lbnQudmFsdWUsICdAJywgJ0AnICsgV0VCS0lUKVxuICAgICAgfSldLCBjYWxsYmFjayk7XG5cbiAgICBjYXNlIFJVTEVTRVQ6XG4gICAgICBpZiAoZWxlbWVudC5sZW5ndGgpIHJldHVybiBjb21iaW5lKGVsZW1lbnQucHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKG1hdGNoKHZhbHVlLCAvKDo6cGxhY1xcdyt8OnJlYWQtXFx3KykvKSkge1xuICAgICAgICAgIC8vIDpyZWFkLShvbmx5fHdyaXRlKVxuICAgICAgICAgIGNhc2UgJzpyZWFkLW9ubHknOlxuICAgICAgICAgIGNhc2UgJzpyZWFkLXdyaXRlJzpcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoW2NvcHkoZWxlbWVudCwge1xuICAgICAgICAgICAgICBwcm9wczogW3JlcGxhY2UodmFsdWUsIC86KHJlYWQtXFx3KykvLCAnOicgKyBNT1ogKyAnJDEnKV1cbiAgICAgICAgICAgIH0pXSwgY2FsbGJhY2spO1xuICAgICAgICAgIC8vIDpwbGFjZWhvbGRlclxuXG4gICAgICAgICAgY2FzZSAnOjpwbGFjZWhvbGRlcic6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtjb3B5KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtyZXBsYWNlKHZhbHVlLCAvOihwbGFjXFx3KykvLCAnOicgKyBXRUJLSVQgKyAnaW5wdXQtJDEnKV1cbiAgICAgICAgICAgIH0pLCBjb3B5KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtyZXBsYWNlKHZhbHVlLCAvOihwbGFjXFx3KykvLCAnOicgKyBNT1ogKyAnJDEnKV1cbiAgICAgICAgICAgIH0pLCBjb3B5KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtyZXBsYWNlKHZhbHVlLCAvOihwbGFjXFx3KykvLCBNUyArICdpbnB1dC0kMScpXVxuICAgICAgICAgICAgfSldLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgfVxufTtcblxudmFyIGlzQnJvd3NlciQ1ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBnZXRTZXJ2ZXJTdHlsaXNDYWNoZSA9IGlzQnJvd3NlciQ1ID8gdW5kZWZpbmVkIDogd2Vha01lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhY2hlID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gY2FjaGVbbmFtZV07XG4gICAgfTtcbiAgfSk7XG59KTtcbnZhciBkZWZhdWx0U3R5bGlzUGx1Z2lucyA9IFtwcmVmaXhlcl07XG5cbnZhciBjcmVhdGVDYWNoZSA9IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgaGF2ZSB0byBjb25maWd1cmUgYGtleWAgZm9yIHlvdXIgY2FjaGUuIFBsZWFzZSBtYWtlIHN1cmUgaXQncyB1bmlxdWUgKGFuZCBub3QgZXF1YWwgdG8gJ2NzcycpIGFzIGl0J3MgdXNlZCBmb3IgbGlua2luZyBzdHlsZXMgdG8geW91ciBjYWNoZS5cXG5cIiArIFwiSWYgbXVsdGlwbGUgY2FjaGVzIHNoYXJlIHRoZSBzYW1lIGtleSB0aGV5IG1pZ2h0IFxcXCJmaWdodFxcXCIgZm9yIGVhY2ggb3RoZXIncyBzdHlsZSBlbGVtZW50cy5cIik7XG4gIH1cblxuICBpZiAoaXNCcm93c2VyJDUgJiYga2V5ID09PSAnY3NzJykge1xuICAgIHZhciBzc3JTdHlsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbZGF0YS1lbW90aW9uXTpub3QoW2RhdGEtc10pXCIpOyAvLyBnZXQgU1NSZWQgc3R5bGVzIG91dCBvZiB0aGUgd2F5IG9mIFJlYWN0J3MgaHlkcmF0aW9uXG4gICAgLy8gZG9jdW1lbnQuaGVhZCBpcyBhIHNhZmUgcGxhY2UgdG8gbW92ZSB0aGVtIHRvKHRob3VnaCBub3RlIGRvY3VtZW50LmhlYWQgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBsYXN0IHBsYWNlIHRoZXkgd2lsbCBiZSlcbiAgICAvLyBub3RlIHRoaXMgdmVyeSB2ZXJ5IGludGVudGlvbmFsbHkgdGFyZ2V0cyBhbGwgc3R5bGUgZWxlbWVudHMgcmVnYXJkbGVzcyBvZiB0aGUga2V5IHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgY3JlYXRpbmcgYSBjYWNoZSB3b3JrcyBpbnNpZGUgb2YgcmVuZGVyIG9mIGEgUmVhY3QgY29tcG9uZW50XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNzclN0eWxlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIHdlIHdhbnQgdG8gb25seSBtb3ZlIGVsZW1lbnRzIHdoaWNoIGhhdmUgYSBzcGFjZSBpbiB0aGUgZGF0YS1lbW90aW9uIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgLy8gYmVjYXVzZSB0aGF0IGluZGljYXRlcyB0aGF0IGl0IGlzIGFuIEVtb3Rpb24gMTEgc2VydmVyLXNpZGUgcmVuZGVyZWQgc3R5bGUgZWxlbWVudHNcbiAgICAgIC8vIHdoaWxlIHdlIHdpbGwgYWxyZWFkeSBpZ25vcmUgRW1vdGlvbiAxMSBjbGllbnQtc2lkZSBpbnNlcnRlZCBzdHlsZXMgYmVjYXVzZSBvZiB0aGUgOm5vdChbZGF0YS1zXSkgcGFydCBpbiB0aGUgc2VsZWN0b3JcbiAgICAgIC8vIEVtb3Rpb24gMTAgY2xpZW50LXNpZGUgaW5zZXJ0ZWQgc3R5bGVzIGRpZCBub3QgaGF2ZSBkYXRhLXMgKGJ1dCBpbXBvcnRhbnRseSBkaWQgbm90IGhhdmUgYSBzcGFjZSBpbiB0aGVpciBkYXRhLWVtb3Rpb24gYXR0cmlidXRlcylcbiAgICAgIC8vIHNvIGNoZWNraW5nIGZvciB0aGUgc3BhY2UgZW5zdXJlcyB0aGF0IGxvYWRpbmcgRW1vdGlvbiAxMSBhZnRlciBFbW90aW9uIDEwIGhhcyBpbnNlcnRlZCBzb21lIHN0eWxlc1xuICAgICAgLy8gd2lsbCBub3QgcmVzdWx0IGluIHRoZSBFbW90aW9uIDEwIHN0eWxlcyBiZWluZyBkZXN0cm95ZWRcbiAgICAgIHZhciBkYXRhRW1vdGlvbkF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWVtb3Rpb24nKTtcblxuICAgICAgaWYgKGRhdGFFbW90aW9uQXR0cmlidXRlLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXMnLCAnJyk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3R5bGlzUGx1Z2lucyA9IG9wdGlvbnMuc3R5bGlzUGx1Z2lucyB8fCBkZWZhdWx0U3R5bGlzUGx1Z2lucztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBpZiAoL1teYS16LV0vLnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1vdGlvbiBrZXkgbXVzdCBvbmx5IGNvbnRhaW4gbG93ZXIgY2FzZSBhbHBoYWJldGljYWwgY2hhcmFjdGVycyBhbmQgLSBidXQgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBwYXNzZWRcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc2VydGVkID0ge307XG4gIHZhciBjb250YWluZXI7XG4gIHZhciBub2Rlc1RvSHlkcmF0ZSA9IFtdO1xuXG4gIGlmIChpc0Jyb3dzZXIkNSkge1xuICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IGRvY3VtZW50LmhlYWQ7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCggLy8gdGhpcyBtZWFucyB3ZSB3aWxsIGlnbm9yZSBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGEgc3BhY2UgaW4gdGhlbSB3aGljaFxuICAgIC8vIG1lYW5zIHRoYXQgdGhlIHN0eWxlIGVsZW1lbnRzIHdlJ3JlIGxvb2tpbmcgYXQgYXJlIG9ubHkgRW1vdGlvbiAxMSBzZXJ2ZXItcmVuZGVyZWQgc3R5bGUgZWxlbWVudHNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbZGF0YS1lbW90aW9uXj1cXFwiXCIgKyBrZXkgKyBcIiBcXFwiXVwiKSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBhdHRyaWIgPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZW1vdGlvblwiKS5zcGxpdCgnICcpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXR0cmliLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc2VydGVkW2F0dHJpYltpXV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2Rlc1RvSHlkcmF0ZS5wdXNoKG5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIF9pbnNlcnQ7XG5cbiAgdmFyIG9tbmlwcmVzZW50UGx1Z2lucyA9IFtjb21wYXQsIHJlbW92ZUxhYmVsXTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIG9tbmlwcmVzZW50UGx1Z2lucy5wdXNoKGNyZWF0ZVVuc2FmZVNlbGVjdG9yc0FsYXJtKHtcbiAgICAgIGdldCBjb21wYXQoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5jb21wYXQ7XG4gICAgICB9XG5cbiAgICB9KSwgaW5jb3JyZWN0SW1wb3J0QWxhcm0pO1xuICB9XG5cbiAgaWYgKGlzQnJvd3NlciQ1KSB7XG4gICAgdmFyIGN1cnJlbnRTaGVldDtcbiAgICB2YXIgZmluYWxpemluZ1BsdWdpbnMgPSBbc3RyaW5naWZ5LCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghZWxlbWVudC5yb290KSB7XG4gICAgICAgIGlmIChlbGVtZW50W1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgY3VycmVudFNoZWV0Lmluc2VydChlbGVtZW50W1wicmV0dXJuXCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnZhbHVlICYmIGVsZW1lbnQudHlwZSAhPT0gQ09NTUVOVCkge1xuICAgICAgICAgIC8vIGluc2VydCBlbXB0eSBydWxlIGluIG5vbi1wcm9kdWN0aW9uIGVudmlyb25tZW50c1xuICAgICAgICAgIC8vIHNvIEBlbW90aW9uL2plc3QgY2FuIGdyYWIgYGtleWAgZnJvbSB0aGUgKEpTKURPTSBmb3IgY2FjaGVzIHdpdGhvdXQgYW55IHJ1bGVzIGluc2VydGVkIHlldFxuICAgICAgICAgIGN1cnJlbnRTaGVldC5pbnNlcnQoZWxlbWVudC52YWx1ZSArIFwie31cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IDogcnVsZXNoZWV0KGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBjdXJyZW50U2hlZXQuaW5zZXJ0KHJ1bGUpO1xuICAgIH0pXTtcbiAgICB2YXIgc2VyaWFsaXplciA9IG1pZGRsZXdhcmUob21uaXByZXNlbnRQbHVnaW5zLmNvbmNhdChzdHlsaXNQbHVnaW5zLCBmaW5hbGl6aW5nUGx1Z2lucykpO1xuXG4gICAgdmFyIHN0eWxpcyA9IGZ1bmN0aW9uIHN0eWxpcyhzdHlsZXMpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemUoY29tcGlsZShzdHlsZXMpLCBzZXJpYWxpemVyKTtcbiAgICB9O1xuXG4gICAgX2luc2VydCA9IGZ1bmN0aW9uIGluc2VydChzZWxlY3Rvciwgc2VyaWFsaXplZCwgc2hlZXQsIHNob3VsZENhY2hlKSB7XG4gICAgICBjdXJyZW50U2hlZXQgPSBzaGVldDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2VyaWFsaXplZC5tYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdXJyZW50U2hlZXQgPSB7XG4gICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0KHJ1bGUgKyBzZXJpYWxpemVkLm1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzdHlsaXMoc2VsZWN0b3IgPyBzZWxlY3RvciArIFwie1wiICsgc2VyaWFsaXplZC5zdHlsZXMgKyBcIn1cIiA6IHNlcmlhbGl6ZWQuc3R5bGVzKTtcblxuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIGNhY2hlLmluc2VydGVkW3NlcmlhbGl6ZWQubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9maW5hbGl6aW5nUGx1Z2lucyA9IFtzdHJpbmdpZnldO1xuXG4gICAgdmFyIF9zZXJpYWxpemVyID0gbWlkZGxld2FyZShvbW5pcHJlc2VudFBsdWdpbnMuY29uY2F0KHN0eWxpc1BsdWdpbnMsIF9maW5hbGl6aW5nUGx1Z2lucykpO1xuXG4gICAgdmFyIF9zdHlsaXMgPSBmdW5jdGlvbiBfc3R5bGlzKHN0eWxlcykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShjb21waWxlKHN0eWxlcyksIF9zZXJpYWxpemVyKTtcbiAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIHZhciBzZXJ2ZXJTdHlsaXNDYWNoZSA9IGdldFNlcnZlclN0eWxpc0NhY2hlKHN0eWxpc1BsdWdpbnMpKGtleSk7XG5cbiAgICB2YXIgZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcyhzZWxlY3Rvciwgc2VyaWFsaXplZCkge1xuICAgICAgdmFyIG5hbWUgPSBzZXJpYWxpemVkLm5hbWU7XG5cbiAgICAgIGlmIChzZXJ2ZXJTdHlsaXNDYWNoZVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcnZlclN0eWxpc0NhY2hlW25hbWVdID0gX3N0eWxpcyhzZWxlY3RvciA/IHNlbGVjdG9yICsgXCJ7XCIgKyBzZXJpYWxpemVkLnN0eWxlcyArIFwifVwiIDogc2VyaWFsaXplZC5zdHlsZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VydmVyU3R5bGlzQ2FjaGVbbmFtZV07XG4gICAgfTtcblxuICAgIF9pbnNlcnQgPSBmdW5jdGlvbiBfaW5zZXJ0KHNlbGVjdG9yLCBzZXJpYWxpemVkLCBzaGVldCwgc2hvdWxkQ2FjaGUpIHtcbiAgICAgIHZhciBuYW1lID0gc2VyaWFsaXplZC5uYW1lO1xuICAgICAgdmFyIHJ1bGVzID0gZ2V0UnVsZXMoc2VsZWN0b3IsIHNlcmlhbGl6ZWQpO1xuXG4gICAgICBpZiAoY2FjaGUuY29tcGF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaW4gcmVndWxhciBtb2RlLCB3ZSBkb24ndCBzZXQgdGhlIHN0eWxlcyBvbiB0aGUgaW5zZXJ0ZWQgY2FjaGVcbiAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBhbmQgdGhhdCB3b3VsZCBiZSB3YXN0aW5nIG1lbW9yeVxuICAgICAgICAvLyB3ZSByZXR1cm4gdGhlbSBzbyB0aGF0IHRoZXkgYXJlIHJlbmRlcmVkIGluIGEgc3R5bGUgdGFnXG4gICAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAgIGNhY2hlLmluc2VydGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggLy8gdXNpbmcgPT09IGRldmVsb3BtZW50IGluc3RlYWQgb2YgIT09IHByb2R1Y3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSBpZiBwZW9wbGUgZG8gc3NyIGluIHRlc3RzLCB0aGUgc291cmNlIG1hcHMgc2hvd2luZyB1cCB3b3VsZCBiZSBhbm5veWluZ1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBzZXJpYWxpemVkLm1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bGVzICsgc2VyaWFsaXplZC5tYXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbiBjb21wYXQgbW9kZSwgd2UgcHV0IHRoZSBzdHlsZXMgb24gdGhlIGluc2VydGVkIGNhY2hlIHNvXG4gICAgICAgIC8vIHRoYXQgZW1vdGlvbi1zZXJ2ZXIgY2FuIHB1bGwgb3V0IHRoZSBzdHlsZXNcbiAgICAgICAgLy8gZXhjZXB0IHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSBpdCB3aGljaCB3YXMgaW4gR2xvYmFsIGJ1dCBub3dcbiAgICAgICAgLy8gaXMgbm93aGVyZSBidXQgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIG1ham9yIHJpZ2h0IG5vd1xuICAgICAgICAvLyBhbmQganVzdCBpbiBjYXNlIHdlJ3JlIGdvaW5nIHRvIGxlYXZlIHRoZSBjYXNlIGhlcmVcbiAgICAgICAgLy8gaXQncyBhbHNvIG5vdCBhZmZlY3RpbmcgY2xpZW50IHNpZGUgYnVuZGxlIHNpemVcbiAgICAgICAgLy8gc28gaXQncyByZWFsbHkgbm90IGEgYmlnIGRlYWxcbiAgICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgICAgY2FjaGUuaW5zZXJ0ZWRbbmFtZV0gPSBydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0ge1xuICAgIGtleToga2V5LFxuICAgIHNoZWV0OiBuZXcgU3R5bGVTaGVldCh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgICBzcGVlZHk6IG9wdGlvbnMuc3BlZWR5LFxuICAgICAgcHJlcGVuZDogb3B0aW9ucy5wcmVwZW5kLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnRcbiAgICB9KSxcbiAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICBpbnNlcnRlZDogaW5zZXJ0ZWQsXG4gICAgcmVnaXN0ZXJlZDoge30sXG4gICAgaW5zZXJ0OiBfaW5zZXJ0XG4gIH07XG4gIGNhY2hlLnNoZWV0Lmh5ZHJhdGUobm9kZXNUb0h5ZHJhdGUpO1xuICByZXR1cm4gY2FjaGU7XG59O1xuXG52YXIgaXNCcm93c2VyJDQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFN0eWxlcyQxKHJlZ2lzdGVyZWQsIHJlZ2lzdGVyZWRTdHlsZXMsIGNsYXNzTmFtZXMpIHtcbiAgdmFyIHJhd0NsYXNzTmFtZSA9ICcnO1xuICBjbGFzc05hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgaWYgKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWdpc3RlcmVkU3R5bGVzLnB1c2gocmVnaXN0ZXJlZFtjbGFzc05hbWVdICsgXCI7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXdDbGFzc05hbWUgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJhd0NsYXNzTmFtZTtcbn1cbnZhciByZWdpc3RlclN0eWxlcyQxID0gZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKSB7XG4gIHZhciBjbGFzc05hbWUgPSBjYWNoZS5rZXkgKyBcIi1cIiArIHNlcmlhbGl6ZWQubmFtZTtcblxuICBpZiAoIC8vIHdlIG9ubHkgbmVlZCB0byBhZGQgdGhlIHN0eWxlcyB0byB0aGUgcmVnaXN0ZXJlZCBjYWNoZSBpZiB0aGVcbiAgLy8gY2xhc3MgbmFtZSBjb3VsZCBiZSB1c2VkIGZ1cnRoZXIgZG93blxuICAvLyB0aGUgdHJlZSBidXQgaWYgaXQncyBhIHN0cmluZyB0YWcsIHdlIGtub3cgaXQgd29uJ3RcbiAgLy8gc28gd2UgZG9uJ3QgaGF2ZSB0byBhZGQgaXQgdG8gcmVnaXN0ZXJlZCBjYWNoZS5cbiAgLy8gdGhpcyBpbXByb3ZlcyBtZW1vcnkgdXNhZ2Ugc2luY2Ugd2UgY2FuIGF2b2lkIHN0b3JpbmcgdGhlIHdob2xlIHN0eWxlIHN0cmluZ1xuICAoaXNTdHJpbmdUYWcgPT09IGZhbHNlIHx8IC8vIHdlIG5lZWQgdG8gYWx3YXlzIHN0b3JlIGl0IGlmIHdlJ3JlIGluIGNvbXBhdCBtb2RlIGFuZFxuICAvLyBpbiBub2RlIHNpbmNlIGVtb3Rpb24tc2VydmVyIHJlbGllcyBvbiB3aGV0aGVyIGEgc3R5bGUgaXMgaW5cbiAgLy8gdGhlIHJlZ2lzdGVyZWQgY2FjaGUgdG8ga25vdyB3aGV0aGVyIGEgc3R5bGUgaXMgZ2xvYmFsIG9yIG5vdFxuICAvLyBhbHNvLCBub3RlIHRoYXQgdGhpcyBjaGVjayB3aWxsIGJlIGRlYWQgY29kZSBlbGltaW5hdGVkIGluIHRoZSBicm93c2VyXG4gIGlzQnJvd3NlciQ0ID09PSBmYWxzZSAmJiBjYWNoZS5jb21wYXQgIT09IHVuZGVmaW5lZCkgJiYgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZS5yZWdpc3RlcmVkW2NsYXNzTmFtZV0gPSBzZXJpYWxpemVkLnN0eWxlcztcbiAgfVxufTtcbnZhciBpbnNlcnRTdHlsZXMkMSA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgcmVnaXN0ZXJTdHlsZXMkMShjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB2YXIgY2xhc3NOYW1lID0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgaWYgKGNhY2hlLmluc2VydGVkW3NlcmlhbGl6ZWQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzdHlsZXNGb3JTU1IgPSAnJztcbiAgICB2YXIgY3VycmVudCA9IHNlcmlhbGl6ZWQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgbWF5YmVTdHlsZXMgPSBjYWNoZS5pbnNlcnQoc2VyaWFsaXplZCA9PT0gY3VycmVudCA/IFwiLlwiICsgY2xhc3NOYW1lIDogJycsIGN1cnJlbnQsIGNhY2hlLnNoZWV0LCB0cnVlKTtcblxuICAgICAgaWYgKCFpc0Jyb3dzZXIkNCAmJiBtYXliZVN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlc0ZvclNTUiArPSBtYXliZVN0eWxlcztcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICB9IHdoaWxlIChjdXJyZW50ICE9PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKCFpc0Jyb3dzZXIkNCAmJiBzdHlsZXNGb3JTU1IubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGVzRm9yU1NSO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvbXVybXVyaGFzaC1qc1xuLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FhcHBsZWJ5L3NtaGFzaGVyL2Jsb2IvNjFhMDUzMGYyODI3N2YyZTg1MGJmYzM5NjAwY2U2MWQwMmI1MThkZS9zcmMvTXVybXVySGFzaDIuY3BwI0wzNy1MODZcbmZ1bmN0aW9uIG11cm11cjIkMShzdHIpIHtcbiAgLy8gJ20nIGFuZCAncicgYXJlIG1peGluZyBjb25zdGFudHMgZ2VuZXJhdGVkIG9mZmxpbmUuXG4gIC8vIFRoZXkncmUgbm90IHJlYWxseSAnbWFnaWMnLCB0aGV5IGp1c3QgaGFwcGVuIHRvIHdvcmsgd2VsbC5cbiAgLy8gY29uc3QgbSA9IDB4NWJkMWU5OTU7XG4gIC8vIGNvbnN0IHIgPSAyNDtcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgaGFzaFxuICB2YXIgaCA9IDA7IC8vIE1peCA0IGJ5dGVzIGF0IGEgdGltZSBpbnRvIHRoZSBoYXNoXG5cbiAgdmFyIGssXG4gICAgICBpID0gMCxcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yICg7IGxlbiA+PSA0OyArK2ksIGxlbiAtPSA0KSB7XG4gICAgayA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZiB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgOCB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDI0O1xuICAgIGsgPVxuICAgIC8qIE1hdGguaW11bChrLCBtKTogKi9cbiAgICAoayAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChrID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICAgIGsgXj1cbiAgICAvKiBrID4+PiByOiAqL1xuICAgIGsgPj4+IDI0O1xuICAgIGggPVxuICAgIC8qIE1hdGguaW11bChrLCBtKTogKi9cbiAgICAoayAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChrID4+PiAxNikgKiAweGU5OTUgPDwgMTYpIF5cbiAgICAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gICAgKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoaCA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgfSAvLyBIYW5kbGUgdGhlIGxhc3QgZmV3IGJ5dGVzIG9mIHRoZSBpbnB1dCBhcnJheVxuXG5cbiAgc3dpdGNoIChsZW4pIHtcbiAgICBjYXNlIDM6XG4gICAgICBoIF49IChzdHIuY2hhckNvZGVBdChpICsgMikgJiAweGZmKSA8PCAxNjtcblxuICAgIGNhc2UgMjpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmYpIDw8IDg7XG5cbiAgICBjYXNlIDE6XG4gICAgICBoIF49IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgICAgIGggPVxuICAgICAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAgICAgKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoaCA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgfSAvLyBEbyBhIGZldyBmaW5hbCBtaXhlcyBvZiB0aGUgaGFzaCB0byBlbnN1cmUgdGhlIGxhc3QgZmV3XG4gIC8vIGJ5dGVzIGFyZSB3ZWxsLWluY29ycG9yYXRlZC5cblxuXG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPVxuICAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIHJldHVybiAoKGggXiBoID4+PiAxNSkgPj4+IDApLnRvU3RyaW5nKDM2KTtcbn1cblxudmFyIHVuaXRsZXNzS2V5cyQxID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgdGFiU2l6ZTogMSxcbiAgd2lkb3dzOiAxLFxuICB6SW5kZXg6IDEsXG4gIHpvb206IDEsXG4gIFdlYmtpdExpbmVDbGFtcDogMSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogMSxcbiAgZmxvb2RPcGFjaXR5OiAxLFxuICBzdG9wT3BhY2l0eTogMSxcbiAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuICBzdHJva2VEYXNob2Zmc2V0OiAxLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VPcGFjaXR5OiAxLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxudmFyIElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDIgPSBcIllvdSBoYXZlIGlsbGVnYWwgZXNjYXBlIHNlcXVlbmNlIGluIHlvdXIgdGVtcGxhdGUgbGl0ZXJhbCwgbW9zdCBsaWtlbHkgaW5zaWRlIGNvbnRlbnQncyBwcm9wZXJ0eSB2YWx1ZS5cXG5CZWNhdXNlIHlvdSB3cml0ZSB5b3VyIENTUyBpbnNpZGUgYSBKYXZhU2NyaXB0IHN0cmluZyB5b3UgYWN0dWFsbHkgaGF2ZSB0byBkbyBkb3VibGUgZXNjYXBpbmcsIHNvIGZvciBleGFtcGxlIFxcXCJjb250ZW50OiAnXFxcXDAwZDcnO1xcXCIgc2hvdWxkIGJlY29tZSBcXFwiY29udGVudDogJ1xcXFxcXFxcMDBkNyc7XFxcIi5cXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6XFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvVGVtcGxhdGVfbGl0ZXJhbHMjRVMyMDE4X3JldmlzaW9uX29mX2lsbGVnYWxfZXNjYXBlX3NlcXVlbmNlc1wiO1xudmFyIFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SJDEgPSBcIllvdSBoYXZlIHBhc3NlZCBpbiBmYWxzeSB2YWx1ZSBhcyBzdHlsZSBvYmplY3QncyBrZXkgKGNhbiBoYXBwZW4gd2hlbiBpbiBleGFtcGxlIHlvdSBwYXNzIHVuZXhwb3J0ZWQgY29tcG9uZW50IGFzIGNvbXB1dGVkIGtleSkuXCI7XG52YXIgaHlwaGVuYXRlUmVnZXgkMSA9IC9bQS1aXXxebXMvZztcbnZhciBhbmltYXRpb25SZWdleCQxID0gL19FTU9fKFteX10rPylfKFteXSo/KV9FTU9fL2c7XG5cbnZhciBpc0N1c3RvbVByb3BlcnR5JDEgPSBmdW5jdGlvbiBpc0N1c3RvbVByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBwcm9wZXJ0eS5jaGFyQ29kZUF0KDEpID09PSA0NTtcbn07XG5cbnZhciBpc1Byb2Nlc3NhYmxlVmFsdWUkMSA9IGZ1bmN0aW9uIGlzUHJvY2Vzc2FibGVWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJztcbn07XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lJDEgPSAvKiAjX19QVVJFX18gKi9tZW1vaXplKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGlzQ3VzdG9tUHJvcGVydHkkMShzdHlsZU5hbWUpID8gc3R5bGVOYW1lIDogc3R5bGVOYW1lLnJlcGxhY2UoaHlwaGVuYXRlUmVnZXgkMSwgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG59KTtcblxudmFyIHByb2Nlc3NTdHlsZVZhbHVlJDEgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICBjYXNlICdhbmltYXRpb25OYW1lJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShhbmltYXRpb25SZWdleCQxLCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMikge1xuICAgICAgICAgICAgY3Vyc29yJDEgPSB7XG4gICAgICAgICAgICAgIG5hbWU6IHAxLFxuICAgICAgICAgICAgICBzdHlsZXM6IHAyLFxuICAgICAgICAgICAgICBuZXh0OiBjdXJzb3IkMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgaWYgKHVuaXRsZXNzS2V5cyQxW2tleV0gIT09IDEgJiYgIWlzQ3VzdG9tUHJvcGVydHkkMShrZXkpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNvbnRlbnRWYWx1ZVBhdHRlcm4kMSA9IC8odmFyfGF0dHJ8Y291bnRlcnM/fHVybHxlbGVtZW50fCgoKHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsKSl8Y29uaWMpLWdyYWRpZW50KVxcKHwobm8tKT8ob3BlbnxjbG9zZSktcXVvdGUvO1xuICB2YXIgY29udGVudFZhbHVlcyQxID0gWydub3JtYWwnLCAnbm9uZScsICdpbml0aWFsJywgJ2luaGVyaXQnLCAndW5zZXQnXTtcbiAgdmFyIG9sZFByb2Nlc3NTdHlsZVZhbHVlJDEgPSBwcm9jZXNzU3R5bGVWYWx1ZSQxO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiQxID0gLy0oLikvZztcbiAgdmFyIGh5cGhlbmF0ZWRDYWNoZSQxID0ge307XG5cbiAgcHJvY2Vzc1N0eWxlVmFsdWUkMSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IGNvbnRlbnRWYWx1ZXMkMS5pbmRleE9mKHZhbHVlKSA9PT0gLTEgJiYgIWNvbnRlbnRWYWx1ZVBhdHRlcm4kMS50ZXN0KHZhbHVlKSAmJiAodmFsdWUuY2hhckF0KDApICE9PSB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkgfHwgdmFsdWUuY2hhckF0KDApICE9PSAnXCInICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gXCInXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGJlIHVzaW5nIGEgdmFsdWUgZm9yICdjb250ZW50JyB3aXRob3V0IHF1b3RlcywgdHJ5IHJlcGxhY2luZyBpdCB3aXRoIGBjb250ZW50OiAnXFxcIlwiICsgdmFsdWUgKyBcIlxcXCInYFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvY2Vzc2VkID0gb2xkUHJvY2Vzc1N0eWxlVmFsdWUkMShrZXksIHZhbHVlKTtcblxuICAgIGlmIChwcm9jZXNzZWQgIT09ICcnICYmICFpc0N1c3RvbVByb3BlcnR5JDEoa2V5KSAmJiBrZXkuaW5kZXhPZignLScpICE9PSAtMSAmJiBoeXBoZW5hdGVkQ2FjaGUkMVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGh5cGhlbmF0ZWRDYWNoZSQxW2tleV0gPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihcIlVzaW5nIGtlYmFiLWNhc2UgZm9yIGNzcyBwcm9wZXJ0aWVzIGluIG9iamVjdHMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIFwiICsga2V5LnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKS5yZXBsYWNlKGh5cGhlblBhdHRlcm4kMSwgZnVuY3Rpb24gKHN0ciwgX2NoYXIpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KSArIFwiP1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICB9O1xufVxuXG52YXIgbm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UkMSA9ICdDb21wb25lbnQgc2VsZWN0b3JzIGNhbiBvbmx5IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCAnICsgJ0BlbW90aW9uL2JhYmVsLXBsdWdpbiwgdGhlIHN3YyBFbW90aW9uIHBsdWdpbiwgb3IgYW5vdGhlciBFbW90aW9uLWF3YXJlICcgKyAnY29tcGlsZXIgdHJhbnNmb3JtLic7XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgaW50ZXJwb2xhdGlvbikge1xuICBpZiAoaW50ZXJwb2xhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGludGVycG9sYXRpb24uX19lbW90aW9uX3N0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW50ZXJwb2xhdGlvbi50b1N0cmluZygpID09PSAnTk9fQ09NUE9ORU5UX1NFTEVDVE9SJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG5vQ29tcG9uZW50U2VsZWN0b3JNZXNzYWdlJDEpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5hbmltID09PSAxKSB7XG4gICAgICAgICAgY3Vyc29yJDEgPSB7XG4gICAgICAgICAgICBuYW1lOiBpbnRlcnBvbGF0aW9uLm5hbWUsXG4gICAgICAgICAgICBzdHlsZXM6IGludGVycG9sYXRpb24uc3R5bGVzLFxuICAgICAgICAgICAgbmV4dDogY3Vyc29yJDFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0aW9uLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW50ZXJwb2xhdGlvbi5uZXh0O1xuXG4gICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm90IHRoZSBtb3N0IGVmZmljaWVudCB0aGluZyBldmVyIGJ1dCB0aGlzIGlzIGEgcHJldHR5IHJhcmUgY2FzZVxuICAgICAgICAgICAgLy8gYW5kIHRoZXJlIHdpbGwgYmUgdmVyeSBmZXcgaXRlcmF0aW9ucyBvZiB0aGlzIGdlbmVyYWxseVxuICAgICAgICAgICAgd2hpbGUgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjdXJzb3IkMSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuZXh0Lm5hbWUsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBuZXh0LnN0eWxlcyxcbiAgICAgICAgICAgICAgICBuZXh0OiBjdXJzb3IkMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdHlsZXMgPSBpbnRlcnBvbGF0aW9uLnN0eWxlcyArIFwiO1wiO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW50ZXJwb2xhdGlvbi5tYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVzICs9IGludGVycG9sYXRpb24ubWFwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nRnJvbU9iamVjdCQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBpbnRlcnBvbGF0aW9uKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKG1lcmdlZFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNDdXJzb3IgPSBjdXJzb3IkMTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcyk7XG4gICAgICAgICAgY3Vyc29yJDEgPSBwcmV2aW91c0N1cnNvcjtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJwb2xhdGlvbiQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGdW5jdGlvbnMgdGhhdCBhcmUgaW50ZXJwb2xhdGVkIGluIGNzcyBjYWxscyB3aWxsIGJlIHN0cmluZ2lmaWVkLlxcbicgKyAnSWYgeW91IHdhbnQgdG8gaGF2ZSBhIGNzcyBjYWxsIGJhc2VkIG9uIHByb3BzLCBjcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBjc3MgY2FsbCBsaWtlIHRoaXNcXG4nICsgJ2xldCBkeW5hbWljU3R5bGUgPSAocHJvcHMpID0+IGNzc2Bjb2xvcjogJHtwcm9wcy5jb2xvcn1gXFxuJyArICdJdCBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5IHdpdGggcHJvcHMgb3IgaW50ZXJwb2xhdGVkIGluIGEgc3R5bGVkIGNhbGwgbGlrZSB0aGlzXFxuJyArIFwibGV0IFNvbWVDb21wb25lbnQgPSBzdHlsZWQoJ2RpdicpYCR7ZHluYW1pY1N0eWxlfWBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSBpbnRlcnBvbGF0aW9uLnJlcGxhY2UoYW5pbWF0aW9uUmVnZXgkMSwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICB2YXIgZmFrZVZhck5hbWUgPSBcImFuaW1hdGlvblwiICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKFwiY29uc3QgXCIgKyBmYWtlVmFyTmFtZSArIFwiID0ga2V5ZnJhbWVzYFwiICsgcDIucmVwbGFjZSgvXkBrZXlmcmFtZXMgYW5pbWF0aW9uLVxcdysvLCAnJykgKyBcImBcIik7XG4gICAgICAgICAgcmV0dXJuIFwiJHtcIiArIGZha2VWYXJOYW1lICsgXCJ9XCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2BrZXlmcmFtZXNgIG91dHB1dCBnb3QgaW50ZXJwb2xhdGVkIGludG8gcGxhaW4gc3RyaW5nLCBwbGVhc2Ugd3JhcCBpdCB3aXRoIGBjc3NgLlxcblxcbicgKyAnSW5zdGVhZCBvZiBkb2luZyB0aGlzOlxcblxcbicgKyBbXS5jb25jYXQobWF0Y2hlZCwgW1wiYFwiICsgcmVwbGFjZWQgKyBcImBcIl0pLmpvaW4oJ1xcbicpICsgJ1xcblxcbllvdSBzaG91bGQgd3JhcCBpdCB3aXRoIGBjc3NgIGxpa2UgdGhpczpcXG5cXG4nICsgKFwiY3NzYFwiICsgcmVwbGFjZWQgKyBcImBcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIGZpbmFsaXplIHN0cmluZyB2YWx1ZXMgKHJlZ3VsYXIgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGludGVycG9sYXRlZCBpbnRvIGNzcyBjYWxscylcblxuXG4gIGlmIChyZWdpc3RlcmVkID09IG51bGwpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHZhciBjYWNoZWQgPSByZWdpc3RlcmVkW2ludGVycG9sYXRpb25dO1xuICByZXR1cm4gY2FjaGVkICE9PSB1bmRlZmluZWQgPyBjYWNoZWQgOiBpbnRlcnBvbGF0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdGcm9tT2JqZWN0JDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIG9iaikge1xuICB2YXIgc3RyaW5nID0gJyc7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHJpbmcgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbiQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmpbaV0pICsgXCI7XCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbX2tleV07XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkICE9IG51bGwgJiYgcmVnaXN0ZXJlZFt2YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cmluZyArPSBfa2V5ICsgXCJ7XCIgKyByZWdpc3RlcmVkW3ZhbHVlXSArIFwifVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvY2Vzc2FibGVWYWx1ZSQxKHZhbHVlKSkge1xuICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lJDEoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlJDEoX2tleSwgdmFsdWUpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfa2V5ID09PSAnTk9fQ09NUE9ORU5UX1NFTEVDVE9SJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5vQ29tcG9uZW50U2VsZWN0b3JNZXNzYWdlJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycgJiYgKHJlZ2lzdGVyZWQgPT0gbnVsbCB8fCByZWdpc3RlcmVkW3ZhbHVlWzBdXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB2YWx1ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUkMSh2YWx1ZVtfaV0pKSB7XG4gICAgICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lJDEoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlJDEoX2tleSwgdmFsdWVbX2ldKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkID0gaGFuZGxlSW50ZXJwb2xhdGlvbiQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCB2YWx1ZSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKF9rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb25OYW1lJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lJDEoX2tleSkgKyBcIjpcIiArIGludGVycG9sYXRlZCArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfa2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiQxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgaW50ZXJwb2xhdGVkICsgXCJ9XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgbGFiZWxQYXR0ZXJuJDEgPSAvbGFiZWw6XFxzKihbXlxccztcXG57XSspXFxzKig7fCQpL2c7XG52YXIgc291cmNlTWFwUGF0dGVybiQxO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzb3VyY2VNYXBQYXR0ZXJuJDEgPSAvXFwvXFwqI1xcc3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvblxcL2pzb247XFxTK1xccytcXCpcXC8vZztcbn0gLy8gdGhpcyBpcyB0aGUgY3Vyc29yIGZvciBrZXlmcmFtZXNcbi8vIGtleWZyYW1lcyBhcmUgc3RvcmVkIG9uIHRoZSBTZXJpYWxpemVkU3R5bGVzIG9iamVjdCBhcyBhIGxpbmtlZCBsaXN0XG5cblxudmFyIGN1cnNvciQxO1xudmFyIHNlcmlhbGl6ZVN0eWxlcyQxID0gZnVuY3Rpb24gc2VyaWFsaXplU3R5bGVzKGFyZ3MsIHJlZ2lzdGVyZWQsIG1lcmdlZFByb3BzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgYXJnc1swXSAhPT0gbnVsbCAmJiBhcmdzWzBdLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH1cblxuICB2YXIgc3RyaW5nTW9kZSA9IHRydWU7XG4gIHZhciBzdHlsZXMgPSAnJztcbiAgY3Vyc29yJDEgPSB1bmRlZmluZWQ7XG4gIHZhciBzdHJpbmdzID0gYXJnc1swXTtcblxuICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpbmdNb2RlID0gZmFsc2U7XG4gICAgc3R5bGVzICs9IGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgc3RyaW5ncyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDIpO1xuICAgIH1cblxuICAgIHN0eWxlcyArPSBzdHJpbmdzWzBdO1xuICB9IC8vIHdlIHN0YXJ0IGF0IDEgc2luY2Ugd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBmaXJzdCBhcmdcblxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHN0eWxlcyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uJDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGFyZ3NbaV0pO1xuXG4gICAgaWYgKHN0cmluZ01vZGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0cmluZ3NbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDIpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXMgKz0gc3RyaW5nc1tpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgc291cmNlTWFwO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgc3R5bGVzID0gc3R5bGVzLnJlcGxhY2Uoc291cmNlTWFwUGF0dGVybiQxLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHNvdXJjZU1hcCA9IG1hdGNoO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9IC8vIHVzaW5nIGEgZ2xvYmFsIHJlZ2V4IHdpdGggLmV4ZWMgaXMgc3RhdGVmdWwgc28gbGFzdEluZGV4IGhhcyB0byBiZSByZXNldCBlYWNoIHRpbWVcblxuXG4gIGxhYmVsUGF0dGVybiQxLmxhc3RJbmRleCA9IDA7XG4gIHZhciBpZGVudGlmaWVyTmFtZSA9ICcnO1xuICB2YXIgbWF0Y2g7IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWI4MDljMmNmMjk0OTgwMGEwZjYxZmI1XG5cbiAgd2hpbGUgKChtYXRjaCA9IGxhYmVsUGF0dGVybiQxLmV4ZWMoc3R5bGVzKSkgIT09IG51bGwpIHtcbiAgICBpZGVudGlmaWVyTmFtZSArPSAnLScgKyAvLyAkRmxvd0ZpeE1lIHdlIGtub3cgaXQncyBub3QgbnVsbFxuICAgIG1hdGNoWzFdO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBtdXJtdXIyJDEoc3R5bGVzKSArIGlkZW50aWZpZXJOYW1lO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZSBTZXJpYWxpemVkU3R5bGVzIHR5cGUgZG9lc24ndCBoYXZlIHRvU3RyaW5nIHByb3BlcnR5IChhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaXQpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgIG1hcDogc291cmNlTWFwLFxuICAgICAgbmV4dDogY3Vyc29yJDEsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIllvdSBoYXZlIHRyaWVkIHRvIHN0cmluZ2lmeSBvYmplY3QgcmV0dXJuZWQgZnJvbSBgY3NzYCBmdW5jdGlvbi4gSXQgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBkaXJlY3RseSAoZS5nLiBhcyB2YWx1ZSBvZiB0aGUgYGNsYXNzTmFtZWAgcHJvcCksIGJ1dCByYXRoZXIgaGFuZGVkIHRvIGVtb3Rpb24gc28gaXQgY2FuIGhhbmRsZSBpdCAoZS5nLiBhcyB2YWx1ZSBvZiBgY3NzYCBwcm9wKS5cIjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHN0eWxlczogc3R5bGVzLFxuICAgIG5leHQ6IGN1cnNvciQxXG4gIH07XG59O1xuXG52YXIgaXNCcm93c2VyJDMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgc3luY0ZhbGxiYWNrID0gZnVuY3Rpb24gc3luY0ZhbGxiYWNrKGNyZWF0ZSkge1xuICByZXR1cm4gY3JlYXRlKCk7XG59O1xuXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RbJ3VzZUluc2VydGlvbicgKyAnRWZmZWN0J10gPyBSZWFjdFsndXNlSW5zZXJ0aW9uJyArICdFZmZlY3QnXSA6IGZhbHNlO1xudmFyIHVzZUluc2VydGlvbkVmZmVjdEFsd2F5c1dpdGhTeW5jRmFsbGJhY2sgPSAhaXNCcm93c2VyJDMgPyBzeW5jRmFsbGJhY2sgOiB1c2VJbnNlcnRpb25FZmZlY3QgfHwgc3luY0ZhbGxiYWNrO1xuXG52YXIgaXNCcm93c2VyJDIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbnZhciBFbW90aW9uQ2FjaGVDb250ZXh0ID0gLyogI19fUFVSRV9fICovY3JlYXRlQ29udGV4dCggLy8gd2UncmUgZG9pbmcgdGhpcyB0byBhdm9pZCBwcmVjb25zdHJ1Y3QncyBkZWFkIGNvZGUgZWxpbWluYXRpb24gaW4gdGhpcyBvbmUgY2FzZVxuLy8gYmVjYXVzZSB0aGlzIG1vZHVsZSBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIHRoZSBicm93c2VyIGFuZCBub2RlXG4vLyBidXQgaXQncyBhbHNvIHJlcXVpcmVkIGluIHJlYWN0IG5hdGl2ZSBhbmQgc2ltaWxhciBlbnZpcm9ubWVudHMgc29tZXRpbWVzXG4vLyBhbmQgd2UgY291bGQgaGF2ZSBhIHNwZWNpYWwgYnVpbGQganVzdCBmb3IgdGhhdFxuLy8gYnV0IHRoaXMgaXMgbXVjaCBlYXNpZXIgYW5kIHRoZSBuYXRpdmUgcGFja2FnZXNcbi8vIG1pZ2h0IHVzZSBhIGRpZmZlcmVudCB0aGVtZSBjb250ZXh0IGluIHRoZSBmdXR1cmUgYW55d2F5XG50eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gLyogI19fUFVSRV9fICovY3JlYXRlQ2FjaGUoe1xuICBrZXk6ICdjc3MnXG59KSA6IG51bGwpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBFbW90aW9uQ2FjaGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0Vtb3Rpb25DYWNoZUNvbnRleHQnO1xufVxuXG5FbW90aW9uQ2FjaGVDb250ZXh0LlByb3ZpZGVyO1xuXG52YXIgd2l0aEVtb3Rpb25DYWNoZSA9IGZ1bmN0aW9uIHdpdGhFbW90aW9uQ2FjaGUoZnVuYykge1xuICAvLyAkRmxvd0ZpeE1lXG4gIHJldHVybiAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIC8vIHRoZSBjYWNoZSB3aWxsIG5ldmVyIGJlIG51bGwgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgY2FjaGUgPSB1c2VDb250ZXh0KEVtb3Rpb25DYWNoZUNvbnRleHQpO1xuICAgIHJldHVybiBmdW5jKHByb3BzLCBjYWNoZSwgcmVmKTtcbiAgfSk7XG59O1xuXG5pZiAoIWlzQnJvd3NlciQyKSB7XG4gIHdpdGhFbW90aW9uQ2FjaGUgPSBmdW5jdGlvbiB3aXRoRW1vdGlvbkNhY2hlKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgY2FjaGUgPSB1c2VDb250ZXh0KEVtb3Rpb25DYWNoZUNvbnRleHQpO1xuXG4gICAgICBpZiAoY2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8geWVzLCB3ZSdyZSBwb3RlbnRpYWxseSBjcmVhdGluZyB0aGlzIG9uIGV2ZXJ5IHJlbmRlclxuICAgICAgICAvLyBpdCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciB0aG91Z2ggc2luY2UgaXQncyBvbmx5IG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gc28gdGhlcmUgd2lsbCBvbmx5IGV2ZXJ5IGJlIGEgc2luZ2xlIHJlbmRlclxuICAgICAgICAvLyB0aGF0IGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlIGJlY2F1c2Ugb2Ygc3VzcGVuc2UgYW5kIGV0Yy4gYnV0IGZvciBub3csXG4gICAgICAgIC8vIHRoaXMgd29ya3MgYW5kIGkgZG9uJ3Qgd2FudCB0byBvcHRpbWlzZSBmb3IgYSBmdXR1cmUgdGhpbmcgdGhhdCB3ZSBhcmVuJ3Qgc3VyZSBhYm91dFxuICAgICAgICBjYWNoZSA9IGNyZWF0ZUNhY2hlKHtcbiAgICAgICAgICBrZXk6ICdjc3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoRW1vdGlvbkNhY2hlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBjYWNoZVxuICAgICAgICB9LCBmdW5jKHByb3BzLCBjYWNoZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMocHJvcHMsIGNhY2hlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG52YXIgVGhlbWVDb250ZXh0ID0gLyogI19fUFVSRV9fICovY3JlYXRlQ29udGV4dCh7fSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRoZW1lQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbW90aW9uVGhlbWVDb250ZXh0Jztcbn1cblxudmFyIHR5cGVQcm9wTmFtZSA9ICdfX0VNT1RJT05fVFlQRV9QTEVBU0VfRE9fTk9UX1VTRV9fJztcbnZhciBsYWJlbFByb3BOYW1lID0gJ19fRU1PVElPTl9MQUJFTF9QTEVBU0VfRE9fTk9UX1VTRV9fJztcblxudmFyIEluc2VydGlvbiQxID0gZnVuY3Rpb24gSW5zZXJ0aW9uKF9yZWYpIHtcbiAgdmFyIGNhY2hlID0gX3JlZi5jYWNoZSxcbiAgICAgIHNlcmlhbGl6ZWQgPSBfcmVmLnNlcmlhbGl6ZWQsXG4gICAgICBpc1N0cmluZ1RhZyA9IF9yZWYuaXNTdHJpbmdUYWc7XG4gIHJlZ2lzdGVyU3R5bGVzJDEoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIHJ1bGVzID0gdXNlSW5zZXJ0aW9uRWZmZWN0QWx3YXlzV2l0aFN5bmNGYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc2VydFN0eWxlcyQxKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZyk7XG4gIH0pO1xuXG4gIGlmICghaXNCcm93c2VyJDIgJiYgcnVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHZhciBzZXJpYWxpemVkTmFtZXMgPSBzZXJpYWxpemVkLm5hbWU7XG4gICAgdmFyIG5leHQgPSBzZXJpYWxpemVkLm5leHQ7XG5cbiAgICB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXJpYWxpemVkTmFtZXMgKz0gJyAnICsgbmV4dC5uYW1lO1xuICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCAoX3JlZjIgPSB7fSwgX3JlZjJbXCJkYXRhLWVtb3Rpb25cIl0gPSBjYWNoZS5rZXkgKyBcIiBcIiArIHNlcmlhbGl6ZWROYW1lcywgX3JlZjIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICBfX2h0bWw6IHJ1bGVzXG4gICAgfSwgX3JlZjIubm9uY2UgPSBjYWNoZS5zaGVldC5ub25jZSwgX3JlZjIpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIEVtb3Rpb24gPSAvKiAjX19QVVJFX18gKi93aXRoRW1vdGlvbkNhY2hlKGZ1bmN0aW9uIChwcm9wcywgY2FjaGUsIHJlZikge1xuICB2YXIgY3NzUHJvcCA9IHByb3BzLmNzczsgLy8gc28gdGhhdCB1c2luZyBgY3NzYCBmcm9tIGBlbW90aW9uYCBhbmQgcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBjc3MgcHJvcCB3b3Jrc1xuICAvLyBub3QgcGFzc2luZyB0aGUgcmVnaXN0ZXJlZCBjYWNoZSB0byBzZXJpYWxpemVTdHlsZXMgYmVjYXVzZSBpdCB3b3VsZFxuICAvLyBtYWtlIGNlcnRhaW4gYmFiZWwgb3B0aW1pc2F0aW9ucyBub3QgcG9zc2libGVcblxuICBpZiAodHlwZW9mIGNzc1Byb3AgPT09ICdzdHJpbmcnICYmIGNhY2hlLnJlZ2lzdGVyZWRbY3NzUHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIGNzc1Byb3AgPSBjYWNoZS5yZWdpc3RlcmVkW2Nzc1Byb3BdO1xuICB9XG5cbiAgdmFyIFdyYXBwZWRDb21wb25lbnQgPSBwcm9wc1t0eXBlUHJvcE5hbWVdO1xuICB2YXIgcmVnaXN0ZXJlZFN0eWxlcyA9IFtjc3NQcm9wXTtcbiAgdmFyIGNsYXNzTmFtZSA9ICcnO1xuXG4gIGlmICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGNsYXNzTmFtZSA9IGdldFJlZ2lzdGVyZWRTdHlsZXMkMShjYWNoZS5yZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBwcm9wcy5jbGFzc05hbWUpO1xuICB9IGVsc2UgaWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgXCIgXCI7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyQxKHJlZ2lzdGVyZWRTdHlsZXMsIHVuZGVmaW5lZCwgdXNlQ29udGV4dChUaGVtZUNvbnRleHQpKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzZXJpYWxpemVkLm5hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHZhciBsYWJlbEZyb21TdGFjayA9IHByb3BzW2xhYmVsUHJvcE5hbWVdO1xuXG4gICAgaWYgKGxhYmVsRnJvbVN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzJDEoW3NlcmlhbGl6ZWQsICdsYWJlbDonICsgbGFiZWxGcm9tU3RhY2sgKyAnOyddKTtcbiAgICB9XG4gIH1cblxuICBjbGFzc05hbWUgKz0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG4gIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpICYmIGtleSAhPT0gJ2NzcycgJiYga2V5ICE9PSB0eXBlUHJvcE5hbWUgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgfHwga2V5ICE9PSBsYWJlbFByb3BOYW1lKSkge1xuICAgICAgbmV3UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG5cbiAgbmV3UHJvcHMucmVmID0gcmVmO1xuICBuZXdQcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoSW5zZXJ0aW9uJDEsIHtcbiAgICBjYWNoZTogY2FjaGUsXG4gICAgc2VyaWFsaXplZDogc2VyaWFsaXplZCxcbiAgICBpc1N0cmluZ1RhZzogdHlwZW9mIFdyYXBwZWRDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gIH0pLCAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBuZXdQcm9wcykpO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEVtb3Rpb24uZGlzcGxheU5hbWUgPSAnRW1vdGlvbkNzc1Byb3BJbnRlcm5hbCc7XG59XG5cbnZhciBpc0Jyb3dzZXIkMSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkU3R5bGVzKHJlZ2lzdGVyZWQsIHJlZ2lzdGVyZWRTdHlsZXMsIGNsYXNzTmFtZXMpIHtcbiAgdmFyIHJhd0NsYXNzTmFtZSA9ICcnO1xuICBjbGFzc05hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgaWYgKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWdpc3RlcmVkU3R5bGVzLnB1c2gocmVnaXN0ZXJlZFtjbGFzc05hbWVdICsgXCI7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXdDbGFzc05hbWUgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJhd0NsYXNzTmFtZTtcbn1cbnZhciByZWdpc3RlclN0eWxlcyA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZykge1xuICB2YXIgY2xhc3NOYW1lID0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgaWYgKCAvLyB3ZSBvbmx5IG5lZWQgdG8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIHJlZ2lzdGVyZWQgY2FjaGUgaWYgdGhlXG4gIC8vIGNsYXNzIG5hbWUgY291bGQgYmUgdXNlZCBmdXJ0aGVyIGRvd25cbiAgLy8gdGhlIHRyZWUgYnV0IGlmIGl0J3MgYSBzdHJpbmcgdGFnLCB3ZSBrbm93IGl0IHdvbid0XG4gIC8vIHNvIHdlIGRvbid0IGhhdmUgdG8gYWRkIGl0IHRvIHJlZ2lzdGVyZWQgY2FjaGUuXG4gIC8vIHRoaXMgaW1wcm92ZXMgbWVtb3J5IHVzYWdlIHNpbmNlIHdlIGNhbiBhdm9pZCBzdG9yaW5nIHRoZSB3aG9sZSBzdHlsZSBzdHJpbmdcbiAgKGlzU3RyaW5nVGFnID09PSBmYWxzZSB8fCAvLyB3ZSBuZWVkIHRvIGFsd2F5cyBzdG9yZSBpdCBpZiB3ZSdyZSBpbiBjb21wYXQgbW9kZSBhbmRcbiAgLy8gaW4gbm9kZSBzaW5jZSBlbW90aW9uLXNlcnZlciByZWxpZXMgb24gd2hldGhlciBhIHN0eWxlIGlzIGluXG4gIC8vIHRoZSByZWdpc3RlcmVkIGNhY2hlIHRvIGtub3cgd2hldGhlciBhIHN0eWxlIGlzIGdsb2JhbCBvciBub3RcbiAgLy8gYWxzbywgbm90ZSB0aGF0IHRoaXMgY2hlY2sgd2lsbCBiZSBkZWFkIGNvZGUgZWxpbWluYXRlZCBpbiB0aGUgYnJvd3NlclxuICBpc0Jyb3dzZXIkMSA9PT0gZmFsc2UgJiYgY2FjaGUuY29tcGF0ICE9PSB1bmRlZmluZWQpICYmIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID0gc2VyaWFsaXplZC5zdHlsZXM7XG4gIH1cbn07XG52YXIgaW5zZXJ0U3R5bGVzID0gZnVuY3Rpb24gaW5zZXJ0U3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZykge1xuICByZWdpc3RlclN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB2YXIgY2xhc3NOYW1lID0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgaWYgKGNhY2hlLmluc2VydGVkW3NlcmlhbGl6ZWQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzdHlsZXNGb3JTU1IgPSAnJztcbiAgICB2YXIgY3VycmVudCA9IHNlcmlhbGl6ZWQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgbWF5YmVTdHlsZXMgPSBjYWNoZS5pbnNlcnQoc2VyaWFsaXplZCA9PT0gY3VycmVudCA/IFwiLlwiICsgY2xhc3NOYW1lIDogJycsIGN1cnJlbnQsIGNhY2hlLnNoZWV0LCB0cnVlKTtcblxuICAgICAgaWYgKCFpc0Jyb3dzZXIkMSAmJiBtYXliZVN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlc0ZvclNTUiArPSBtYXliZVN0eWxlcztcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICB9IHdoaWxlIChjdXJyZW50ICE9PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKCFpc0Jyb3dzZXIkMSAmJiBzdHlsZXNGb3JTU1IubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGVzRm9yU1NSO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvbXVybXVyaGFzaC1qc1xuLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FhcHBsZWJ5L3NtaGFzaGVyL2Jsb2IvNjFhMDUzMGYyODI3N2YyZTg1MGJmYzM5NjAwY2U2MWQwMmI1MThkZS9zcmMvTXVybXVySGFzaDIuY3BwI0wzNy1MODZcbmZ1bmN0aW9uIG11cm11cjIoc3RyKSB7XG4gIC8vICdtJyBhbmQgJ3InIGFyZSBtaXhpbmcgY29uc3RhbnRzIGdlbmVyYXRlZCBvZmZsaW5lLlxuICAvLyBUaGV5J3JlIG5vdCByZWFsbHkgJ21hZ2ljJywgdGhleSBqdXN0IGhhcHBlbiB0byB3b3JrIHdlbGwuXG4gIC8vIGNvbnN0IG0gPSAweDViZDFlOTk1O1xuICAvLyBjb25zdCByID0gMjQ7XG4gIC8vIEluaXRpYWxpemUgdGhlIGhhc2hcbiAgdmFyIGggPSAwOyAvLyBNaXggNCBieXRlcyBhdCBhIHRpbWUgaW50byB0aGUgaGFzaFxuXG4gIHZhciBrLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAoOyBsZW4gPj0gNDsgKytpLCBsZW4gLT0gNCkge1xuICAgIGsgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDggfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNDtcbiAgICBrID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgICBrIF49XG4gICAgLyogayA+Pj4gcjogKi9cbiAgICBrID4+PiAyNDtcbiAgICBoID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KSBeXG4gICAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gSGFuZGxlIHRoZSBsYXN0IGZldyBieXRlcyBvZiB0aGUgaW5wdXQgYXJyYXlcblxuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAzOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICBjYXNlIDI6XG4gICAgICBoIF49IChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuXG4gICAgY2FzZSAxOlxuICAgICAgaCBePSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBoID1cbiAgICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gRG8gYSBmZXcgZmluYWwgbWl4ZXMgb2YgdGhlIGhhc2ggdG8gZW5zdXJlIHRoZSBsYXN0IGZld1xuICAvLyBieXRlcyBhcmUgd2VsbC1pbmNvcnBvcmF0ZWQuXG5cblxuICBoIF49IGggPj4+IDEzO1xuICBoID1cbiAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICByZXR1cm4gKChoIF4gaCA+Pj4gMTUpID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbnZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG52YXIgSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IkMSA9IFwiWW91IGhhdmUgaWxsZWdhbCBlc2NhcGUgc2VxdWVuY2UgaW4geW91ciB0ZW1wbGF0ZSBsaXRlcmFsLCBtb3N0IGxpa2VseSBpbnNpZGUgY29udGVudCdzIHByb3BlcnR5IHZhbHVlLlxcbkJlY2F1c2UgeW91IHdyaXRlIHlvdXIgQ1NTIGluc2lkZSBhIEphdmFTY3JpcHQgc3RyaW5nIHlvdSBhY3R1YWxseSBoYXZlIHRvIGRvIGRvdWJsZSBlc2NhcGluZywgc28gZm9yIGV4YW1wbGUgXFxcImNvbnRlbnQ6ICdcXFxcMDBkNyc7XFxcIiBzaG91bGQgYmVjb21lIFxcXCJjb250ZW50OiAnXFxcXFxcXFwwMGQ3JztcXFwiLlxcbllvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoaXMgaGVyZTpcXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9UZW1wbGF0ZV9saXRlcmFscyNFUzIwMThfcmV2aXNpb25fb2ZfaWxsZWdhbF9lc2NhcGVfc2VxdWVuY2VzXCI7XG52YXIgVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IgPSBcIllvdSBoYXZlIHBhc3NlZCBpbiBmYWxzeSB2YWx1ZSBhcyBzdHlsZSBvYmplY3QncyBrZXkgKGNhbiBoYXBwZW4gd2hlbiBpbiBleGFtcGxlIHlvdSBwYXNzIHVuZXhwb3J0ZWQgY29tcG9uZW50IGFzIGNvbXB1dGVkIGtleSkuXCI7XG52YXIgaHlwaGVuYXRlUmVnZXggPSAvW0EtWl18Xm1zL2c7XG52YXIgYW5pbWF0aW9uUmVnZXggPSAvX0VNT18oW15fXSs/KV8oW15dKj8pX0VNT18vZztcblxudmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBmdW5jdGlvbiBpc0N1c3RvbVByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBwcm9wZXJ0eS5jaGFyQ29kZUF0KDEpID09PSA0NTtcbn07XG5cbnZhciBpc1Byb2Nlc3NhYmxlVmFsdWUgPSBmdW5jdGlvbiBpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbic7XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaXNDdXN0b21Qcm9wZXJ0eShzdHlsZU5hbWUpID8gc3R5bGVOYW1lIDogc3R5bGVOYW1lLnJlcGxhY2UoaHlwaGVuYXRlUmVnZXgsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbnZhciBwcm9jZXNzU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICdhbmltYXRpb24nOlxuICAgIGNhc2UgJ2FuaW1hdGlvbk5hbWUnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMikge1xuICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwMSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBwMixcbiAgICAgICAgICAgICAgbmV4dDogY3Vyc29yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBpZiAodW5pdGxlc3NLZXlzW2tleV0gIT09IDEgJiYgIWlzQ3VzdG9tUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjb250ZW50VmFsdWVQYXR0ZXJuID0gLyh2YXJ8YXR0cnxjb3VudGVycz98dXJsfGVsZW1lbnR8KCgocmVwZWF0aW5nLSk/KGxpbmVhcnxyYWRpYWwpKXxjb25pYyktZ3JhZGllbnQpXFwofChuby0pPyhvcGVufGNsb3NlKS1xdW90ZS87XG4gIHZhciBjb250ZW50VmFsdWVzID0gWydub3JtYWwnLCAnbm9uZScsICdpbml0aWFsJywgJ2luaGVyaXQnLCAndW5zZXQnXTtcbiAgdmFyIG9sZFByb2Nlc3NTdHlsZVZhbHVlID0gcHJvY2Vzc1N0eWxlVmFsdWU7XG4gIHZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG4gIHZhciBoeXBoZW5hdGVkQ2FjaGUgPSB7fTtcblxuICBwcm9jZXNzU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IGNvbnRlbnRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmICFjb250ZW50VmFsdWVQYXR0ZXJuLnRlc3QodmFsdWUpICYmICh2YWx1ZS5jaGFyQXQoMCkgIT09IHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSB8fCB2YWx1ZS5jaGFyQXQoMCkgIT09ICdcIicgJiYgdmFsdWUuY2hhckF0KDApICE9PSBcIidcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IHNlZW0gdG8gYmUgdXNpbmcgYSB2YWx1ZSBmb3IgJ2NvbnRlbnQnIHdpdGhvdXQgcXVvdGVzLCB0cnkgcmVwbGFjaW5nIGl0IHdpdGggYGNvbnRlbnQ6ICdcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIidgXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9jZXNzZWQgPSBvbGRQcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKTtcblxuICAgIGlmIChwcm9jZXNzZWQgIT09ICcnICYmICFpc0N1c3RvbVByb3BlcnR5KGtleSkgJiYga2V5LmluZGV4T2YoJy0nKSAhPT0gLTEgJiYgaHlwaGVuYXRlZENhY2hlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaHlwaGVuYXRlZENhY2hlW2tleV0gPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihcIlVzaW5nIGtlYmFiLWNhc2UgZm9yIGNzcyBwcm9wZXJ0aWVzIGluIG9iamVjdHMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIFwiICsga2V5LnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoc3RyLCBfY2hhcikge1xuICAgICAgICByZXR1cm4gX2NoYXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pICsgXCI/XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH07XG59XG5cbnZhciBub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSA9ICdDb21wb25lbnQgc2VsZWN0b3JzIGNhbiBvbmx5IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCAnICsgJ0BlbW90aW9uL2JhYmVsLXBsdWdpbiwgdGhlIHN3YyBFbW90aW9uIHBsdWdpbiwgb3IgYW5vdGhlciBFbW90aW9uLWF3YXJlICcgKyAnY29tcGlsZXIgdHJhbnNmb3JtLic7XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pIHtcbiAgaWYgKGludGVycG9sYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpbnRlcnBvbGF0aW9uLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24udG9TdHJpbmcoKSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRpb247XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiBpbnRlcnBvbGF0aW9uKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLmFuaW0gPT09IDEpIHtcbiAgICAgICAgICBjdXJzb3IgPSB7XG4gICAgICAgICAgICBuYW1lOiBpbnRlcnBvbGF0aW9uLm5hbWUsXG4gICAgICAgICAgICBzdHlsZXM6IGludGVycG9sYXRpb24uc3R5bGVzLFxuICAgICAgICAgICAgbmV4dDogY3Vyc29yXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGlvbi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGludGVycG9sYXRpb24ubmV4dDtcblxuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbW9zdCBlZmZpY2llbnQgdGhpbmcgZXZlciBidXQgdGhpcyBpcyBhIHByZXR0eSByYXJlIGNhc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB3aWxsIGJlIHZlcnkgZmV3IGl0ZXJhdGlvbnMgb2YgdGhpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5leHQubmFtZSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IG5leHQuc3R5bGVzLFxuICAgICAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdHlsZXMgPSBpbnRlcnBvbGF0aW9uLnN0eWxlcyArIFwiO1wiO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW50ZXJwb2xhdGlvbi5tYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVzICs9IGludGVycG9sYXRpb24ubWFwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nRnJvbU9iamVjdChtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgaW50ZXJwb2xhdGlvbik7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIGlmIChtZXJnZWRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ3Vyc29yID0gY3Vyc29yO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBpbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzKTtcbiAgICAgICAgICBjdXJzb3IgPSBwcmV2aW91c0N1cnNvcjtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRnVuY3Rpb25zIHRoYXQgYXJlIGludGVycG9sYXRlZCBpbiBjc3MgY2FsbHMgd2lsbCBiZSBzdHJpbmdpZmllZC5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIGhhdmUgYSBjc3MgY2FsbCBiYXNlZCBvbiBwcm9wcywgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY3NzIGNhbGwgbGlrZSB0aGlzXFxuJyArICdsZXQgZHluYW1pY1N0eWxlID0gKHByb3BzKSA9PiBjc3NgY29sb3I6ICR7cHJvcHMuY29sb3J9YFxcbicgKyAnSXQgY2FuIGJlIGNhbGxlZCBkaXJlY3RseSB3aXRoIHByb3BzIG9yIGludGVycG9sYXRlZCBpbiBhIHN0eWxlZCBjYWxsIGxpa2UgdGhpc1xcbicgKyBcImxldCBTb21lQ29tcG9uZW50ID0gc3R5bGVkKCdkaXYnKWAke2R5bmFtaWNTdHlsZX1gXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gaW50ZXJwb2xhdGlvbi5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMikge1xuICAgICAgICAgIHZhciBmYWtlVmFyTmFtZSA9IFwiYW5pbWF0aW9uXCIgKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICBtYXRjaGVkLnB1c2goXCJjb25zdCBcIiArIGZha2VWYXJOYW1lICsgXCIgPSBrZXlmcmFtZXNgXCIgKyBwMi5yZXBsYWNlKC9eQGtleWZyYW1lcyBhbmltYXRpb24tXFx3Ky8sICcnKSArIFwiYFwiKTtcbiAgICAgICAgICByZXR1cm4gXCIke1wiICsgZmFrZVZhck5hbWUgKyBcIn1cIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignYGtleWZyYW1lc2Agb3V0cHV0IGdvdCBpbnRlcnBvbGF0ZWQgaW50byBwbGFpbiBzdHJpbmcsIHBsZWFzZSB3cmFwIGl0IHdpdGggYGNzc2AuXFxuXFxuJyArICdJbnN0ZWFkIG9mIGRvaW5nIHRoaXM6XFxuXFxuJyArIFtdLmNvbmNhdChtYXRjaGVkLCBbXCJgXCIgKyByZXBsYWNlZCArIFwiYFwiXSkuam9pbignXFxuJykgKyAnXFxuXFxuWW91IHNob3VsZCB3cmFwIGl0IHdpdGggYGNzc2AgbGlrZSB0aGlzOlxcblxcbicgKyAoXCJjc3NgXCIgKyByZXBsYWNlZCArIFwiYFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH0gLy8gZmluYWxpemUgc3RyaW5nIHZhbHVlcyAocmVndWxhciBzdHJpbmdzIGFuZCBmdW5jdGlvbnMgaW50ZXJwb2xhdGVkIGludG8gY3NzIGNhbGxzKVxuXG5cbiAgaWYgKHJlZ2lzdGVyZWQgPT0gbnVsbCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgdmFyIGNhY2hlZCA9IHJlZ2lzdGVyZWRbaW50ZXJwb2xhdGlvbl07XG4gIHJldHVybiBjYWNoZWQgIT09IHVuZGVmaW5lZCA/IGNhY2hlZCA6IGludGVycG9sYXRpb247XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIG9iaikge1xuICB2YXIgc3RyaW5nID0gJyc7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHJpbmcgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgb2JqW2ldKSArIFwiO1wiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW19rZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZCAhPSBudWxsICYmIHJlZ2lzdGVyZWRbdmFsdWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgcmVnaXN0ZXJlZFt2YWx1ZV0gKyBcIn1cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHByb2Nlc3NTdHlsZU5hbWUoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlKF9rZXksIHZhbHVlKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2tleSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJyAmJiAocmVnaXN0ZXJlZCA9PSBudWxsIHx8IHJlZ2lzdGVyZWRbdmFsdWVbMF1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHZhbHVlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2FibGVWYWx1ZSh2YWx1ZVtfaV0pKSB7XG4gICAgICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZShfa2V5LCB2YWx1ZVtfaV0pICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZWQgPSBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCB2YWx1ZSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKF9rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb25OYW1lJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lKF9rZXkpICsgXCI6XCIgKyBpbnRlcnBvbGF0ZWQgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2tleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0cmluZyArPSBfa2V5ICsgXCJ7XCIgKyBpbnRlcnBvbGF0ZWQgKyBcIn1cIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbnZhciBsYWJlbFBhdHRlcm4gPSAvbGFiZWw6XFxzKihbXlxccztcXG57XSspXFxzKig7fCQpL2c7XG52YXIgc291cmNlTWFwUGF0dGVybjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc291cmNlTWFwUGF0dGVybiA9IC9cXC9cXCojXFxzc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtcXFMrXFxzK1xcKlxcLy9nO1xufSAvLyB0aGlzIGlzIHRoZSBjdXJzb3IgZm9yIGtleWZyYW1lc1xuLy8ga2V5ZnJhbWVzIGFyZSBzdG9yZWQgb24gdGhlIFNlcmlhbGl6ZWRTdHlsZXMgb2JqZWN0IGFzIGEgbGlua2VkIGxpc3RcblxuXG52YXIgY3Vyc29yO1xudmFyIHNlcmlhbGl6ZVN0eWxlcyA9IGZ1bmN0aW9uIHNlcmlhbGl6ZVN0eWxlcyhhcmdzLCByZWdpc3RlcmVkLCBtZXJnZWRQcm9wcykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmIGFyZ3NbMF0gIT09IG51bGwgJiYgYXJnc1swXS5zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgdmFyIHN0cmluZ01vZGUgPSB0cnVlO1xuICB2YXIgc3R5bGVzID0gJyc7XG4gIGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgdmFyIHN0cmluZ3MgPSBhcmdzWzBdO1xuXG4gIGlmIChzdHJpbmdzID09IG51bGwgfHwgc3RyaW5ncy5yYXcgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmluZ01vZGUgPSBmYWxzZTtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgc3RyaW5ncyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDEpO1xuICAgIH1cblxuICAgIHN0eWxlcyArPSBzdHJpbmdzWzBdO1xuICB9IC8vIHdlIHN0YXJ0IGF0IDEgc2luY2Ugd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBmaXJzdCBhcmdcblxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHN0eWxlcyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBhcmdzW2ldKTtcblxuICAgIGlmIChzdHJpbmdNb2RlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdHJpbmdzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQxKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzICs9IHN0cmluZ3NbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvdXJjZU1hcDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHN0eWxlcyA9IHN0eWxlcy5yZXBsYWNlKHNvdXJjZU1hcFBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgc291cmNlTWFwID0gbWF0Y2g7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH0gLy8gdXNpbmcgYSBnbG9iYWwgcmVnZXggd2l0aCAuZXhlYyBpcyBzdGF0ZWZ1bCBzbyBsYXN0SW5kZXggaGFzIHRvIGJlIHJlc2V0IGVhY2ggdGltZVxuXG5cbiAgbGFiZWxQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBpZGVudGlmaWVyTmFtZSA9ICcnO1xuICB2YXIgbWF0Y2g7IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWI4MDljMmNmMjk0OTgwMGEwZjYxZmI1XG5cbiAgd2hpbGUgKChtYXRjaCA9IGxhYmVsUGF0dGVybi5leGVjKHN0eWxlcykpICE9PSBudWxsKSB7XG4gICAgaWRlbnRpZmllck5hbWUgKz0gJy0nICsgLy8gJEZsb3dGaXhNZSB3ZSBrbm93IGl0J3Mgbm90IG51bGxcbiAgICBtYXRjaFsxXTtcbiAgfVxuXG4gIHZhciBuYW1lID0gbXVybXVyMihzdHlsZXMpICsgaWRlbnRpZmllck5hbWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFNlcmlhbGl6ZWRTdHlsZXMgdHlwZSBkb2Vzbid0IGhhdmUgdG9TdHJpbmcgcHJvcGVydHkgKGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCBpdClcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgbWFwOiBzb3VyY2VNYXAsXG4gICAgICBuZXh0OiBjdXJzb3IsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIllvdSBoYXZlIHRyaWVkIHRvIHN0cmluZ2lmeSBvYmplY3QgcmV0dXJuZWQgZnJvbSBgY3NzYCBmdW5jdGlvbi4gSXQgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBkaXJlY3RseSAoZS5nLiBhcyB2YWx1ZSBvZiB0aGUgYGNsYXNzTmFtZWAgcHJvcCksIGJ1dCByYXRoZXIgaGFuZGVkIHRvIGVtb3Rpb24gc28gaXQgY2FuIGhhbmRsZSBpdCAoZS5nLiBhcyB2YWx1ZSBvZiBgY3NzYCBwcm9wKS5cIjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHN0eWxlczogc3R5bGVzLFxuICAgIG5leHQ6IGN1cnNvclxuICB9O1xufTtcblxudmFyIHRlc3RPbWl0UHJvcHNPblN0cmluZ1RhZyA9IGlzUHJvcFZhbGlkO1xuXG52YXIgdGVzdE9taXRQcm9wc09uQ29tcG9uZW50ID0gZnVuY3Rpb24gdGVzdE9taXRQcm9wc09uQ29tcG9uZW50KGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAndGhlbWUnO1xufTtcblxudmFyIGdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcCA9IGZ1bmN0aW9uIGdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcCh0YWcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnICYmIC8vIDk2IGlzIG9uZSBsZXNzIHRoYW4gdGhlIGNoYXIgY29kZVxuICAvLyBmb3IgXCJhXCIgc28gdGhpcyBpcyBjaGVja2luZyB0aGF0XG4gIC8vIGl0J3MgYSBsb3dlcmNhc2UgY2hhcmFjdGVyXG4gIHRhZy5jaGFyQ29kZUF0KDApID4gOTYgPyB0ZXN0T21pdFByb3BzT25TdHJpbmdUYWcgOiB0ZXN0T21pdFByb3BzT25Db21wb25lbnQ7XG59O1xudmFyIGNvbXBvc2VTaG91bGRGb3J3YXJkUHJvcHMgPSBmdW5jdGlvbiBjb21wb3NlU2hvdWxkRm9yd2FyZFByb3BzKHRhZywgb3B0aW9ucywgaXNSZWFsKSB7XG4gIHZhciBzaG91bGRGb3J3YXJkUHJvcDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zU2hvdWxkRm9yd2FyZFByb3AgPSBvcHRpb25zLnNob3VsZEZvcndhcmRQcm9wO1xuICAgIHNob3VsZEZvcndhcmRQcm9wID0gdGFnLl9fZW1vdGlvbl9mb3J3YXJkUHJvcCAmJiBvcHRpb25zU2hvdWxkRm9yd2FyZFByb3AgPyBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgIHJldHVybiB0YWcuX19lbW90aW9uX2ZvcndhcmRQcm9wKHByb3BOYW1lKSAmJiBvcHRpb25zU2hvdWxkRm9yd2FyZFByb3AocHJvcE5hbWUpO1xuICAgIH0gOiBvcHRpb25zU2hvdWxkRm9yd2FyZFByb3A7XG4gIH1cblxuICBpZiAodHlwZW9mIHNob3VsZEZvcndhcmRQcm9wICE9PSAnZnVuY3Rpb24nICYmIGlzUmVhbCkge1xuICAgIHNob3VsZEZvcndhcmRQcm9wID0gdGFnLl9fZW1vdGlvbl9mb3J3YXJkUHJvcDtcbiAgfVxuXG4gIHJldHVybiBzaG91bGRGb3J3YXJkUHJvcDtcbn07XG5cbnZhciBJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiA9IFwiWW91IGhhdmUgaWxsZWdhbCBlc2NhcGUgc2VxdWVuY2UgaW4geW91ciB0ZW1wbGF0ZSBsaXRlcmFsLCBtb3N0IGxpa2VseSBpbnNpZGUgY29udGVudCdzIHByb3BlcnR5IHZhbHVlLlxcbkJlY2F1c2UgeW91IHdyaXRlIHlvdXIgQ1NTIGluc2lkZSBhIEphdmFTY3JpcHQgc3RyaW5nIHlvdSBhY3R1YWxseSBoYXZlIHRvIGRvIGRvdWJsZSBlc2NhcGluZywgc28gZm9yIGV4YW1wbGUgXFxcImNvbnRlbnQ6ICdcXFxcMDBkNyc7XFxcIiBzaG91bGQgYmVjb21lIFxcXCJjb250ZW50OiAnXFxcXFxcXFwwMGQ3JztcXFwiLlxcbllvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoaXMgaGVyZTpcXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9UZW1wbGF0ZV9saXRlcmFscyNFUzIwMThfcmV2aXNpb25fb2ZfaWxsZWdhbF9lc2NhcGVfc2VxdWVuY2VzXCI7XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIEluc2VydGlvbiA9IGZ1bmN0aW9uIEluc2VydGlvbihfcmVmKSB7XG4gIHZhciBjYWNoZSA9IF9yZWYuY2FjaGUsXG4gICAgICBzZXJpYWxpemVkID0gX3JlZi5zZXJpYWxpemVkLFxuICAgICAgaXNTdHJpbmdUYWcgPSBfcmVmLmlzU3RyaW5nVGFnO1xuICByZWdpc3RlclN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB2YXIgcnVsZXMgPSB1c2VJbnNlcnRpb25FZmZlY3RBbHdheXNXaXRoU3luY0ZhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5zZXJ0U3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZyk7XG4gIH0pO1xuXG4gIGlmICghaXNCcm93c2VyICYmIHJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICB2YXIgc2VyaWFsaXplZE5hbWVzID0gc2VyaWFsaXplZC5uYW1lO1xuICAgIHZhciBuZXh0ID0gc2VyaWFsaXplZC5uZXh0O1xuXG4gICAgd2hpbGUgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZE5hbWVzICs9ICcgJyArIG5leHQubmFtZTtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgKF9yZWYyID0ge30sIF9yZWYyW1wiZGF0YS1lbW90aW9uXCJdID0gY2FjaGUua2V5ICsgXCIgXCIgKyBzZXJpYWxpemVkTmFtZXMsIF9yZWYyLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgX19odG1sOiBydWxlc1xuICAgIH0sIF9yZWYyLm5vbmNlID0gY2FjaGUuc2hlZXQubm9uY2UsIF9yZWYyKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBjcmVhdGVTdHlsZWQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZWQodGFnLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyZWF0ZSBhIHN0eWxlZCBlbGVtZW50IHdpdGggYW4gdW5kZWZpbmVkIGNvbXBvbmVudC5cXG5Zb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGltcG9ydCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNSZWFsID0gdGFnLl9fZW1vdGlvbl9yZWFsID09PSB0YWc7XG4gIHZhciBiYXNlVGFnID0gaXNSZWFsICYmIHRhZy5fX2Vtb3Rpb25fYmFzZSB8fCB0YWc7XG4gIHZhciBpZGVudGlmaWVyTmFtZTtcbiAgdmFyIHRhcmdldENsYXNzTmFtZTtcblxuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWRlbnRpZmllck5hbWUgPSBvcHRpb25zLmxhYmVsO1xuICAgIHRhcmdldENsYXNzTmFtZSA9IG9wdGlvbnMudGFyZ2V0O1xuICB9XG5cbiAgdmFyIHNob3VsZEZvcndhcmRQcm9wID0gY29tcG9zZVNob3VsZEZvcndhcmRQcm9wcyh0YWcsIG9wdGlvbnMsIGlzUmVhbCk7XG4gIHZhciBkZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AgPSBzaG91bGRGb3J3YXJkUHJvcCB8fCBnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AoYmFzZVRhZyk7XG4gIHZhciBzaG91bGRVc2VBcyA9ICFkZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AoJ2FzJyk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0eWxlcyA9IGlzUmVhbCAmJiB0YWcuX19lbW90aW9uX3N0eWxlcyAhPT0gdW5kZWZpbmVkID8gdGFnLl9fZW1vdGlvbl9zdHlsZXMuc2xpY2UoMCkgOiBbXTtcblxuICAgIGlmIChpZGVudGlmaWVyTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZXMucHVzaChcImxhYmVsOlwiICsgaWRlbnRpZmllck5hbWUgKyBcIjtcIik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3NbMF0gPT0gbnVsbCB8fCBhcmdzWzBdLnJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZXMucHVzaC5hcHBseShzdHlsZXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhcmdzWzBdWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlcy5wdXNoKGFyZ3NbMF1bMF0pO1xuICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFyZ3NbMF1baV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVzLnB1c2goYXJnc1tpXSwgYXJnc1swXVtpXSk7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lOiB3ZSBuZWVkIHRvIGNhc3QgU3RhdGVsZXNzRnVuY3Rpb25hbENvbXBvbmVudCB0byBvdXIgUHJpdmF0ZVN0eWxlZENvbXBvbmVudCBjbGFzc1xuXG5cbiAgICB2YXIgU3R5bGVkID0gd2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNhY2hlLCByZWYpIHtcbiAgICAgIHZhciBGaW5hbFRhZyA9IHNob3VsZFVzZUFzICYmIHByb3BzLmFzIHx8IGJhc2VUYWc7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gJyc7XG4gICAgICB2YXIgY2xhc3NJbnRlcnBvbGF0aW9ucyA9IFtdO1xuICAgICAgdmFyIG1lcmdlZFByb3BzID0gcHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy50aGVtZSA9PSBudWxsKSB7XG4gICAgICAgIG1lcmdlZFByb3BzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgbWVyZ2VkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBtZXJnZWRQcm9wcy50aGVtZSA9IHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGdldFJlZ2lzdGVyZWRTdHlsZXMoY2FjaGUucmVnaXN0ZXJlZCwgY2xhc3NJbnRlcnBvbGF0aW9ucywgcHJvcHMuY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKHN0eWxlcy5jb25jYXQoY2xhc3NJbnRlcnBvbGF0aW9ucyksIGNhY2hlLnJlZ2lzdGVyZWQsIG1lcmdlZFByb3BzKTtcbiAgICAgIGNsYXNzTmFtZSArPSBjYWNoZS5rZXkgKyBcIi1cIiArIHNlcmlhbGl6ZWQubmFtZTtcblxuICAgICAgaWYgKHRhcmdldENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIHRhcmdldENsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmFsU2hvdWxkRm9yd2FyZFByb3AgPSBzaG91bGRVc2VBcyAmJiBzaG91bGRGb3J3YXJkUHJvcCA9PT0gdW5kZWZpbmVkID8gZ2V0RGVmYXVsdFNob3VsZEZvcndhcmRQcm9wKEZpbmFsVGFnKSA6IGRlZmF1bHRTaG91bGRGb3J3YXJkUHJvcDtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBfa2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChzaG91bGRVc2VBcyAmJiBfa2V5ID09PSAnYXMnKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIC8vICRGbG93Rml4TWVcbiAgICAgICAgZmluYWxTaG91bGRGb3J3YXJkUHJvcChfa2V5KSkge1xuICAgICAgICAgIG5ld1Byb3BzW19rZXldID0gcHJvcHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3UHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgbmV3UHJvcHMucmVmID0gcmVmO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChJbnNlcnRpb24sIHtcbiAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICBzZXJpYWxpemVkOiBzZXJpYWxpemVkLFxuICAgICAgICBpc1N0cmluZ1RhZzogdHlwZW9mIEZpbmFsVGFnID09PSAnc3RyaW5nJ1xuICAgICAgfSksIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEZpbmFsVGFnLCBuZXdQcm9wcykpO1xuICAgIH0pO1xuICAgIFN0eWxlZC5kaXNwbGF5TmFtZSA9IGlkZW50aWZpZXJOYW1lICE9PSB1bmRlZmluZWQgPyBpZGVudGlmaWVyTmFtZSA6IFwiU3R5bGVkKFwiICsgKHR5cGVvZiBiYXNlVGFnID09PSAnc3RyaW5nJyA/IGJhc2VUYWcgOiBiYXNlVGFnLmRpc3BsYXlOYW1lIHx8IGJhc2VUYWcubmFtZSB8fCAnQ29tcG9uZW50JykgKyBcIilcIjtcbiAgICBTdHlsZWQuZGVmYXVsdFByb3BzID0gdGFnLmRlZmF1bHRQcm9wcztcbiAgICBTdHlsZWQuX19lbW90aW9uX3JlYWwgPSBTdHlsZWQ7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9iYXNlID0gYmFzZVRhZztcbiAgICBTdHlsZWQuX19lbW90aW9uX3N0eWxlcyA9IHN0eWxlcztcbiAgICBTdHlsZWQuX19lbW90aW9uX2ZvcndhcmRQcm9wID0gc2hvdWxkRm9yd2FyZFByb3A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxlZCwgJ3RvU3RyaW5nJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICBpZiAodGFyZ2V0Q2xhc3NOYW1lID09PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiAnTk9fQ09NUE9ORU5UX1NFTEVDVE9SJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lOiBjb2VyY2UgdW5kZWZpbmVkIHRvIHN0cmluZ1xuXG5cbiAgICAgICAgcmV0dXJuIFwiLlwiICsgdGFyZ2V0Q2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgU3R5bGVkLndpdGhDb21wb25lbnQgPSBmdW5jdGlvbiAobmV4dFRhZywgbmV4dE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTdHlsZWQobmV4dFRhZywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIG5leHRPcHRpb25zLCB7XG4gICAgICAgIHNob3VsZEZvcndhcmRQcm9wOiBjb21wb3NlU2hvdWxkRm9yd2FyZFByb3BzKFN0eWxlZCwgbmV4dE9wdGlvbnMsIHRydWUpXG4gICAgICB9KSkuYXBwbHkodm9pZCAwLCBzdHlsZXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3R5bGVkO1xuICB9O1xufTtcblxudmFyIHRhZ3MgPSBbJ2EnLCAnYWJicicsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2Jhc2UnLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW0nLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdsaW5rJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbWV0ZXInLCAnbmF2JywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGFyYW0nLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYW4nLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3dicicsIC8vIFNWR1xuJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3ZnJywgJ3RleHQnLCAndHNwYW4nXTtcblxudmFyIG5ld1N0eWxlZCA9IGNyZWF0ZVN0eWxlZC5iaW5kKCk7XG50YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgLy8gJEZsb3dGaXhNZTogd2UgY2FuIGlnbm9yZSB0aGlzIGJlY2F1c2UgaXRzIGV4cG9zZWQgdHlwZSBpcyBkZWZpbmVkIGJ5IHRoZSBDcmVhdGVTdHlsZWQgdHlwZVxuICBuZXdTdHlsZWRbdGFnTmFtZV0gPSBuZXdTdHlsZWQodGFnTmFtZSk7XG59KTtcblxudmFyIGNsYXNzbmFtZXMkMSA9IHtleHBvcnRzOiB7fX07XG5cbi8qIVxuXHRDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cblx0TGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcblx0aHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcygpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0aWYgKGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoYXJnLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmICFhcmcudG9TdHJpbmcudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZy50b1N0cmluZygpKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAobW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG59KGNsYXNzbmFtZXMkMSkpO1xuXG52YXIgY2xhc3NuYW1lcyA9IGNsYXNzbmFtZXMkMS5leHBvcnRzO1xuXG52YXIgTGVnYWN5U2lkZWJhckNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcbnZhciBTaWRlYmFyUHJvdmlkZXIgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgdmFyIF9iID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoe1xyXG4gICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXHJcbiAgICAgICAgdG9nZ2xlZDogZmFsc2UsXHJcbiAgICAgICAgYnJva2VuOiBmYWxzZSxcclxuICAgICAgICBydGw6IGZhbHNlLFxyXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxyXG4gICAgfSksIHNpZGViYXJTdGF0ZSA9IF9iWzBdLCBzZXRTaWRlYmFyU3RhdGUgPSBfYlsxXTtcclxuICAgIHZhciB1cGRhdGVTaWRlYmFyU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgc2V0U2lkZWJhclN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0YXRlKSwgdmFsdWVzKSk7IH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIHVwZGF0ZUNvbGxhcHNlU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0U2lkZWJhclN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0YXRlKSwgeyBjb2xsYXBzZWQ6ICFCb29sZWFuKHByZXZTdGF0ZSA9PT0gbnVsbCB8fCBwcmV2U3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZTdGF0ZS5jb2xsYXBzZWQpIH0pKTsgfSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICB2YXIgdXBkYXRlVG9nZ2xlU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0U2lkZWJhclN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0YXRlKSwgeyB0b2dnbGVkOiAhQm9vbGVhbihwcmV2U3RhdGUgPT09IG51bGwgfHwgcHJldlN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2U3RhdGUudG9nZ2xlZCkgfSkpOyB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBwcm92aWRlclZhbHVlID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHNpZGViYXJTdGF0ZSksIHsgdXBkYXRlU2lkZWJhclN0YXRlOiB1cGRhdGVTaWRlYmFyU3RhdGUsIHVwZGF0ZUNvbGxhcHNlU3RhdGU6IHVwZGF0ZUNvbGxhcHNlU3RhdGUsIHVwZGF0ZVRvZ2dsZVN0YXRlOiB1cGRhdGVUb2dnbGVTdGF0ZSB9KSk7IH0sIFtzaWRlYmFyU3RhdGUsIHVwZGF0ZUNvbGxhcHNlU3RhdGUsIHVwZGF0ZVNpZGViYXJTdGF0ZSwgdXBkYXRlVG9nZ2xlU3RhdGVdKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMZWdhY3lTaWRlYmFyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvdmlkZXJWYWx1ZSB9LCBjaGlsZHJlbikpO1xyXG59O1xuXG52YXIgdXNlTGVnYWN5U2lkZWJhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChMZWdhY3lTaWRlYmFyQ29udGV4dCk7XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufTtcblxudmFyIHVzZU1lZGlhUXVlcnkgPSBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xyXG4gICAgdmFyIF9hID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoISFicmVha3BvaW50ICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tYXRjaE1lZGlhKGJyZWFrcG9pbnQpLm1hdGNoZXMpLCBtYXRjaGVzID0gX2FbMF0sIHNldE1hdGNoZXMgPSBfYVsxXTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrcG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIG1lZGlhXzEgPSB3aW5kb3cubWF0Y2hNZWRpYShicmVha3BvaW50KTtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZU1hdGNoXzEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFfMS5tYXRjaGVzICE9PSBtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcyhtZWRpYV8xLm1hdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoYW5kbGVNYXRjaF8xKCk7XHJcbiAgICAgICAgICAgIG1lZGlhXzEuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlTWF0Y2hfMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZWRpYV8xLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZU1hdGNoXzEpOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFttYXRjaGVzLCBicmVha3BvaW50XSk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcztcclxufTtcblxudmFyIHNpZGViYXJDbGFzc2VzID0ge1xyXG4gICAgcm9vdDogJ3BzLXNpZGViYXItcm9vdCcsXHJcbiAgICBjb250YWluZXI6ICdwcy1zaWRlYmFyLWNvbnRhaW5lcicsXHJcbiAgICBpbWFnZTogJ3BzLXNpZGViYXItaW1hZ2UnLFxyXG4gICAgYmFja2Ryb3A6ICdwcy1zaWRlYmFyLWJhY2tkcm9wJyxcclxuICAgIGNvbGxhcHNlZDogJ3BzLWNvbGxhcHNlZCcsXHJcbiAgICB0b2dnbGVkOiAncHMtdG9nZ2xlZCcsXHJcbiAgICBydGw6ICdwcy1ydGwnLFxyXG4gICAgYnJva2VuOiAncHMtYnJva2VuJyxcclxufTtcclxudmFyIG1lbnVDbGFzc2VzID0ge1xyXG4gICAgcm9vdDogJ3BzLW1lbnUtcm9vdCcsXHJcbiAgICBtZW51SXRlbVJvb3Q6ICdwcy1tZW51aXRlbS1yb290JyxcclxuICAgIHN1Yk1lbnVSb290OiAncHMtc3VibWVudS1yb290JyxcclxuICAgIGJ1dHRvbjogJ3BzLW1lbnUtYnV0dG9uJyxcclxuICAgIHByZWZpeDogJ3BzLW1lbnUtcHJlZml4JyxcclxuICAgIHN1ZmZpeDogJ3BzLW1lbnUtc3VmZml4JyxcclxuICAgIGxhYmVsOiAncHMtbWVudS1sYWJlbCcsXHJcbiAgICBpY29uOiAncHMtbWVudS1pY29uJyxcclxuICAgIHN1Yk1lbnVDb250ZW50OiAncHMtc3VibWVudS1jb250ZW50JyxcclxuICAgIFN1Yk1lbnVFeHBhbmRJY29uOiAncHMtc3VibWVudS1leHBhbmQtaWNvbicsXHJcbiAgICBkaXNhYmxlZDogJ3BzLWRpc2FibGVkJyxcclxuICAgIGFjdGl2ZTogJ3BzLWFjdGl2ZScsXHJcbiAgICBvcGVuOiAncHMtb3BlbicsXHJcbn07XG5cbnZhciBTdHlsZWRCYWNrZHJvcCA9IG5ld1N0eWxlZC5kaXYodGVtcGxhdGVPYmplY3RfMSRiIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMHB4O1xcbiAgcmlnaHQ6IDBweDtcXG4gIGJvdHRvbTogMHB4O1xcbiAgbGVmdDogMHB4O1xcbiAgei1pbmRleDogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwLCAwLCAwLCAwLjMpO1xcblwiXSwgW1wiXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDBweDtcXG4gIHJpZ2h0OiAwcHg7XFxuICBib3R0b206IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHotaW5kZXg6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMCwgMCwgMC4zKTtcXG5cIl0pKSk7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGI7XG5cbnZhciBCUkVBS19QT0lOVFMgPSB7XHJcbiAgICB4czogJzQ4MHB4JyxcclxuICAgIHNtOiAnNTc2cHgnLFxyXG4gICAgbWQ6ICc3NjhweCcsXHJcbiAgICBsZzogJzk5MnB4JyxcclxuICAgIHhsOiAnMTIwMHB4JyxcclxuICAgIHh4bDogJzE2MDBweCcsXHJcbiAgICBhbHdheXM6ICdhbHdheXMnLFxyXG4gICAgYWxsOiAnYWxsJyxcclxufTtcclxudmFyIFN0eWxlZFNpZGViYXIgPSBuZXdTdHlsZWQuYXNpZGUodGVtcGxhdGVPYmplY3RfMSRhIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogMXB4O1xcbiAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1jb2xvcjogI2VmZWZlZjtcXG5cXG4gIHRyYW5zaXRpb246IFwiLCBcIjtcXG5cXG4gIHdpZHRoOiBcIiwgXCI7XFxuICBtaW4td2lkdGg6IFwiLCBcIjtcXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgd2lkdGg6IFwiLCBcIjtcXG4gICAgbWluLXdpZHRoOiBcIiwgXCI7XFxuICB9XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIGRpcmVjdGlvbjogcnRsO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IG5vbmU7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxuICAgIGJvcmRlci1yaWdodC1zdHlsZTogbm9uZTtcXG4gICAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgfVxcblxcbiAgJi5cIiwgXCIge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIHotaW5kZXg6IDEwMDtcXG5cXG4gICAgXCIsIFwiXFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICBcIiwgXCJcXG4gICAgfVxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgXCIsIFwiXFxuICAgIH1cXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIHJpZ2h0OiAtXCIsIFwiO1xcblxcbiAgICAgICYuXCIsIFwiIHtcXG4gICAgICAgIHJpZ2h0OiAtXCIsIFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICAmLlwiLCBcIiB7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIFwiLCBcIlxcblwiXSwgW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNlZmVmZWY7XFxuXFxuICB0cmFuc2l0aW9uOiBcIiwgXCI7XFxuXFxuICB3aWR0aDogXCIsIFwiO1xcbiAgbWluLXdpZHRoOiBcIiwgXCI7XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiBcIiwgXCI7XFxuICAgIG1pbi13aWR0aDogXCIsIFwiO1xcbiAgfVxcblxcbiAgJi5cIiwgXCIge1xcbiAgICBkaXJlY3Rpb246IHJ0bDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiBub25lO1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbiAgICBib3JkZXItcmlnaHQtc3R5bGU6IG5vbmU7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHRvcDogMHB4O1xcbiAgICB6LWluZGV4OiAxMDA7XFxuXFxuICAgIFwiLCBcIlxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgXCIsIFwiXFxuICAgIH1cXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIFwiLCBcIlxcbiAgICB9XFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICByaWdodDogLVwiLCBcIjtcXG5cXG4gICAgICAmLlwiLCBcIiB7XFxuICAgICAgICByaWdodDogLVwiLCBcIjtcXG4gICAgICB9XFxuXFxuICAgICAgJi5cIiwgXCIge1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBcIiwgXCJcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2EudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIFwid2lkdGgsIGxlZnQsIHJpZ2h0LCBcIi5jb25jYXQodHJhbnNpdGlvbkR1cmF0aW9uLCBcIm1zXCIpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy5jb2xsYXBzZWQsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNvbGxhcHNlZFdpZHRoID0gX2EuY29sbGFwc2VkV2lkdGg7XHJcbiAgICByZXR1cm4gY29sbGFwc2VkV2lkdGg7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNvbGxhcHNlZFdpZHRoID0gX2EuY29sbGFwc2VkV2lkdGg7XHJcbiAgICByZXR1cm4gY29sbGFwc2VkV2lkdGg7XHJcbn0sIHNpZGViYXJDbGFzc2VzLnJ0bCwgc2lkZWJhckNsYXNzZXMuYnJva2VuLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGwsIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICByZXR1cm4gKCFydGwgPyBcImxlZnQ6IC1cIi5jb25jYXQod2lkdGgsIFwiO1wiKSA6ICcnKTtcclxufSwgc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGwsIGNvbGxhcHNlZFdpZHRoID0gX2EuY29sbGFwc2VkV2lkdGg7XHJcbiAgICByZXR1cm4gKCFydGwgPyBcImxlZnQ6IC1cIi5jb25jYXQoY29sbGFwc2VkV2lkdGgsIFwiOyBcIikgOiAnJyk7XHJcbn0sIHNpZGViYXJDbGFzc2VzLnRvZ2dsZWQsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiAoIXJ0bCA/IFwibGVmdDogMDtcIiA6ICcnKTtcclxufSwgc2lkZWJhckNsYXNzZXMucnRsLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy5jb2xsYXBzZWQsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNvbGxhcHNlZFdpZHRoID0gX2EuY29sbGFwc2VkV2lkdGg7XHJcbiAgICByZXR1cm4gY29sbGFwc2VkV2lkdGg7XHJcbn0sIHNpZGViYXJDbGFzc2VzLnRvZ2dsZWQsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgU3R5bGVkU2lkZWJhckNvbnRhaW5lciA9IG5ld1N0eWxlZC5kaXYodGVtcGxhdGVPYmplY3RfMiQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB6LWluZGV4OiAzO1xcblxcbiAgXCIsIFwiXFxuXCJdLCBbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB6LWluZGV4OiAzO1xcblxcbiAgXCIsIFwiXFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IF9hLmJhY2tncm91bmRDb2xvcjtcclxuICAgIHJldHVybiAoYmFja2dyb3VuZENvbG9yID8gXCJiYWNrZ3JvdW5kLWNvbG9yOlwiLmNvbmNhdChiYWNrZ3JvdW5kQ29sb3IsIFwiO1wiKSA6ICcnKTtcclxufSk7XHJcbnZhciBTdHlsZWRTaWRlYmFySW1hZ2UgPSBuZXdTdHlsZWQuaW1nKHRlbXBsYXRlT2JqZWN0XzMkMSB8fCAodGVtcGxhdGVPYmplY3RfMyQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcbiAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHotaW5kZXg6IDI7XFxuICB9XFxuXCJdLCBbXCJcXG4gICYuXCIsIFwiIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgb2JqZWN0LWZpdDogY292ZXI7XFxuICAgIG9iamVjdC1wb3NpdGlvbjogY2VudGVyO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgei1pbmRleDogMjtcXG4gIH1cXG5cIl0pKSwgc2lkZWJhckNsYXNzZXMuaW1hZ2UpO1xyXG52YXIgU2lkZWJhckNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHtcclxuICAgIGNvbGxhcHNlZDogZmFsc2UsXHJcbiAgICB0b2dnbGVkOiBmYWxzZSxcclxuICAgIHJ0bDogZmFsc2UsXHJcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IDMwMCxcclxufSk7XHJcbnZhciBTaWRlYmFyID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiAoX2EsIHJlZikge1xyXG4gICAgdmFyIF9iO1xyXG4gICAgdmFyIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgdG9nZ2xlZCA9IF9hLnRvZ2dsZWQsIG9uQmFja2Ryb3BDbGljayA9IF9hLm9uQmFja2Ryb3BDbGljaywgb25CcmVha1BvaW50ID0gX2Eub25CcmVha1BvaW50LCBfYyA9IF9hLndpZHRoLCB3aWR0aCA9IF9jID09PSB2b2lkIDAgPyAnMjUwcHgnIDogX2MsIF9kID0gX2EuY29sbGFwc2VkV2lkdGgsIGNvbGxhcHNlZFdpZHRoID0gX2QgPT09IHZvaWQgMCA/ICc4MHB4JyA6IF9kLCBkZWZhdWx0Q29sbGFwc2VkID0gX2EuZGVmYXVsdENvbGxhcHNlZCwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBicmVha1BvaW50ID0gX2EuYnJlYWtQb2ludCwgY3VzdG9tQnJlYWtQb2ludCA9IF9hLmN1c3RvbUJyZWFrUG9pbnQsIF9lID0gX2EuYmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3IgPSBfZSA9PT0gdm9pZCAwID8gJ3JnYigyNDksIDI0OSwgMjQ5LCAwLjcpJyA6IF9lLCBfZiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbiwgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2YgPT09IHZvaWQgMCA/IDMwMCA6IF9mLCBpbWFnZSA9IF9hLmltYWdlLCBydGwgPSBfYS5ydGwsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjb2xsYXBzZWRcIiwgXCJ0b2dnbGVkXCIsIFwib25CYWNrZHJvcENsaWNrXCIsIFwib25CcmVha1BvaW50XCIsIFwid2lkdGhcIiwgXCJjb2xsYXBzZWRXaWR0aFwiLCBcImRlZmF1bHRDb2xsYXBzZWRcIiwgXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcImJyZWFrUG9pbnRcIiwgXCJjdXN0b21CcmVha1BvaW50XCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwiaW1hZ2VcIiwgXCJydGxcIiwgXCJyb290U3R5bGVzXCJdKTtcclxuICAgIHZhciBnZXRCcmVha3BvaW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGN1c3RvbUJyZWFrUG9pbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiKG1heC13aWR0aDogXCIuY29uY2F0KGN1c3RvbUJyZWFrUG9pbnQsIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJyZWFrUG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnLCAneHhsJ10uaW5jbHVkZXMoYnJlYWtQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChCUkVBS19QT0lOVFNbYnJlYWtQb2ludF0sIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gJ2Fsd2F5cycgfHwgYnJlYWtQb2ludCA9PT0gJ2FsbCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChicmVha1BvaW50ID09PSAnYWx3YXlzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIFwiYWx3YXlzXCIgYnJlYWtQb2ludCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2UuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIHVzZSB0aGUgXCJhbGxcIiBicmVha1BvaW50IGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzY3JlZW5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCIobWF4LXdpZHRoOiBcIi5jb25jYXQoYnJlYWtQb2ludCwgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgYnJlYWtwb2ludENhbGxiYWNrRm5SZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoKTtcclxuICAgIGJyZWFrcG9pbnRDYWxsYmFja0ZuUmVmLmN1cnJlbnQgPSBmdW5jdGlvbiAoYnJva2VuKSB7XHJcbiAgICAgICAgb25CcmVha1BvaW50ID09PSBudWxsIHx8IG9uQnJlYWtQb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CcmVha1BvaW50KGJyb2tlbik7XHJcbiAgICB9O1xyXG4gICAgdmFyIGJyb2tlbiA9IHVzZU1lZGlhUXVlcnkoZ2V0QnJlYWtwb2ludFZhbHVlKCkpO1xyXG4gICAgdmFyIF9nID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpLCBtb3VudGVkID0gX2dbMF0sIHNldE1vdW50ZWQgPSBfZ1sxXTtcclxuICAgIHZhciBsZWdhY3lTaWRlYmFyQ29udGV4dCA9IHVzZUxlZ2FjeVNpZGViYXIoKTtcclxuICAgIHZhciBjb2xsYXBzZWRWYWx1ZSA9IGNvbGxhcHNlZCAhPT0gbnVsbCAmJiBjb2xsYXBzZWQgIT09IHZvaWQgMCA/IGNvbGxhcHNlZCA6ICghbW91bnRlZCAmJiBkZWZhdWx0Q29sbGFwc2VkID8gdHJ1ZSA6IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC5jb2xsYXBzZWQpO1xyXG4gICAgdmFyIHRvZ2dsZWRWYWx1ZSA9IHRvZ2dsZWQgIT09IG51bGwgJiYgdG9nZ2xlZCAhPT0gdm9pZCAwID8gdG9nZ2xlZCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC50b2dnbGVkO1xyXG4gICAgdmFyIGhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb25CYWNrZHJvcENsaWNrID09PSBudWxsIHx8IG9uQmFja2Ryb3BDbGljayA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CYWNrZHJvcENsaWNrKCk7XHJcbiAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSh7IHRvZ2dsZWQ6IGZhbHNlIH0pO1xyXG4gICAgfTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IGJyZWFrcG9pbnRDYWxsYmFja0ZuUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGJyZWFrcG9pbnRDYWxsYmFja0ZuUmVmLCBicm9rZW4pO1xyXG4gICAgfSwgW2Jyb2tlbl0pO1xyXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvblxyXG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlKHsgYnJva2VuOiBicm9rZW4sIHJ0bDogcnRsLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiB9KTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbYnJva2VuLCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlLCBydGwsIHRyYW5zaXRpb25EdXJhdGlvbl0pO1xyXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvblxyXG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIW1vdW50ZWQpIHtcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWQ6IGRlZmF1bHRDb2xsYXBzZWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbZGVmYXVsdENvbGxhcHNlZCwgbW91bnRlZCwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZV0pO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNpZGViYXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGNvbGxhcHNlZDogY29sbGFwc2VkVmFsdWUsIHRvZ2dsZWQ6IHRvZ2dsZWRWYWx1ZSwgcnRsOiBydGwsIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uIH0gfSxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFNpZGViYXIsIF9fYXNzaWduKHsgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQoc2lkZWJhckNsYXNzZXMucm9vdCwgXCItdGVzdC1pZFwiKSwgcnRsOiBydGwsIHJvb3RTdHlsZXM6IHJvb3RTdHlsZXMsIHdpZHRoOiB3aWR0aCwgY29sbGFwc2VkV2lkdGg6IGNvbGxhcHNlZFdpZHRoLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHNpZGViYXJDbGFzc2VzLnJvb3QsIChfYiA9IHt9LFxyXG4gICAgICAgICAgICAgICAgX2Jbc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkXSA9IGNvbGxhcHNlZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgX2Jbc2lkZWJhckNsYXNzZXMudG9nZ2xlZF0gPSB0b2dnbGVkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBfYltzaWRlYmFyQ2xhc3Nlcy5icm9rZW5dID0gYnJva2VuLFxyXG4gICAgICAgICAgICAgICAgX2Jbc2lkZWJhckNsYXNzZXMucnRsXSA9IHJ0bCxcclxuICAgICAgICAgICAgICAgIF9iKSwgY2xhc3NOYW1lKSB9LCByZXN0KSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTaWRlYmFyQ29udGFpbmVyLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQoc2lkZWJhckNsYXNzZXMuY29udGFpbmVyLCBcIi10ZXN0LWlkXCIpLCBjbGFzc05hbWU6IHNpZGViYXJDbGFzc2VzLmNvbnRhaW5lciwgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IgfSwgY2hpbGRyZW4pLFxyXG4gICAgICAgICAgICBpbWFnZSAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTaWRlYmFySW1hZ2UsIHsgXCJkYXRhLXRlc3RpZFwiOiBcIlwiLmNvbmNhdChzaWRlYmFyQ2xhc3Nlcy5pbWFnZSwgXCItdGVzdC1pZFwiKSwgc3JjOiBpbWFnZSwgYWx0OiBcInNpZGViYXIgYmFja2dyb3VuZFwiLCBjbGFzc05hbWU6IHNpZGViYXJDbGFzc2VzLmltYWdlIH0pKSxcclxuICAgICAgICAgICAgYnJva2VuICYmIHRvZ2dsZWRWYWx1ZSAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRCYWNrZHJvcCwgeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KHNpZGViYXJDbGFzc2VzLmJhY2tkcm9wLCBcIi10ZXN0LWlkXCIpLCByb2xlOiBcImJ1dHRvblwiLCB0YWJJbmRleDogMCwgXCJhcmlhLWxhYmVsXCI6IFwiYmFja2Ryb3BcIiwgb25DbGljazogaGFuZGxlQmFja2Ryb3BDbGljaywgb25LZXlQcmVzczogaGFuZGxlQmFja2Ryb3BDbGljaywgY2xhc3NOYW1lOiBzaWRlYmFyQ2xhc3Nlcy5iYWNrZHJvcCB9KSkpKSk7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSRhLCB0ZW1wbGF0ZU9iamVjdF8yJDEsIHRlbXBsYXRlT2JqZWN0XzMkMTtcblxudmFyIFN0eWxlZFVsID0gbmV3U3R5bGVkLnVsKHRlbXBsYXRlT2JqZWN0XzEkOSB8fCAodGVtcGxhdGVPYmplY3RfMSQ5ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcblwiXSwgW1wiXFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcblwiXSkpKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkOTtcblxudmFyIFN0eWxlZE1lbnUgPSBuZXdTdHlsZWQubmF2KHRlbXBsYXRlT2JqZWN0XzEkOCB8fCAodGVtcGxhdGVPYmplY3RfMSQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAmLlwiLCBcIiB7XFxuICAgIFwiLCBcIlxcbiAgfVxcblwiXSwgW1wiXFxuICAmLlwiLCBcIiB7XFxuICAgIFwiLCBcIlxcbiAgfVxcblwiXSkpLCBtZW51Q2xhc3Nlcy5yb290LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIE1lbnVDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG52YXIgTGV2ZWxDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCgwKTtcclxudmFyIE1lbnVGUiA9IGZ1bmN0aW9uIChfYSwgcmVmKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBfYiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbiwgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2IgPT09IHZvaWQgMCA/IDMwMCA6IF9iLCBfYyA9IF9hLmNsb3NlT25DbGljaywgY2xvc2VPbkNsaWNrID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCBtZW51SXRlbVN0eWxlcyA9IF9hLm1lbnVJdGVtU3R5bGVzLCByZW5kZXJFeHBhbmRJY29uID0gX2EucmVuZGVyRXhwYW5kSWNvbiwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIiwgXCJjbG9zZU9uQ2xpY2tcIiwgXCJyb290U3R5bGVzXCIsIFwibWVudUl0ZW1TdHlsZXNcIiwgXCJyZW5kZXJFeHBhbmRJY29uXCJdKTtcclxuICAgIHZhciBwcm92aWRlclZhbHVlID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoeyB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgY2xvc2VPbkNsaWNrOiBjbG9zZU9uQ2xpY2ssIG1lbnVJdGVtU3R5bGVzOiBtZW51SXRlbVN0eWxlcywgcmVuZGVyRXhwYW5kSWNvbjogcmVuZGVyRXhwYW5kSWNvbiB9KTsgfSwgW3RyYW5zaXRpb25EdXJhdGlvbiwgY2xvc2VPbkNsaWNrLCBtZW51SXRlbVN0eWxlcywgcmVuZGVyRXhwYW5kSWNvbl0pO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lbnVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm92aWRlclZhbHVlIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMZXZlbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IDAgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51LCBfX2Fzc2lnbih7IHJlZjogcmVmLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSwgcm9vdFN0eWxlczogcm9vdFN0eWxlcyB9LCByZXN0KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkVWwsIG51bGwsIGNoaWxkcmVuKSkpKSk7XHJcbn07XHJcbnZhciBNZW51ID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihNZW51RlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ4O1xuXG52YXIgdXNlTWVudSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChNZW51Q29udGV4dCk7XHJcbiAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy9UT0RPOiBzZXQgYmV0dGVyIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lbnUgQ29tcG9uZW50IGlzIHJlcXVpcmVkIScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XG5cbnZhciBTdHlsZWRTdWJNZW51Q29udGVudCA9IG5ld1N0eWxlZC5kaXYodGVtcGxhdGVPYmplY3RfMSQ3IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIGhlaWdodDogMHB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIHRyYW5zaXRpb246IGhlaWdodCBcIiwgXCJtcztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIGhlaWdodDogMHB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIHRyYW5zaXRpb246IGhlaWdodCBcIiwgXCJtcztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGZpcnN0TGV2ZWwgPSBfYS5maXJzdExldmVsLCBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQ7XHJcbiAgICByZXR1cm4gZmlyc3RMZXZlbCAmJlxyXG4gICAgICAgIGNvbGxhcHNlZCAmJlxyXG4gICAgICAgIFwiXFxuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCAtNHB4ICMwMDAwMDAxZiwgMCA2cHggMTZweCAjMDAwMDAwMTQsIDAgOXB4IDI4cHggOHB4ICMwMDAwMDAwZDtcXG4gICAgIFwiO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBkZWZhdWx0T3BlbiA9IF9hLmRlZmF1bHRPcGVuO1xyXG4gICAgcmV0dXJuIGRlZmF1bHRPcGVuICYmICdoZWlnaHQ6IGF1dG87ZGlzcGxheTogYmxvY2s7JztcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkLCBmaXJzdExldmVsID0gX2EuZmlyc3RMZXZlbCwgb3BlbldoZW5Db2xsYXBzZWQgPSBfYS5vcGVuV2hlbkNvbGxhcHNlZDtcclxuICAgIHJldHVybiBjb2xsYXBzZWQgJiYgZmlyc3RMZXZlbFxyXG4gICAgICAgID8gXCJcXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAwcHg7XFxuICAgICAgd2lkdGg6IDIwMHB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICBoZWlnaHQ6IGF1dG8haW1wb3J0YW50O1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrIWltcG9ydGFudDsgICAgIFxcbiAgICAgIHRyYW5zaXRpb246IG5vbmUhaW1wb3J0YW50OyAgICAgXFxuICAgICAgdmlzaWJpbGl0eTogXCIuY29uY2F0KG9wZW5XaGVuQ29sbGFwc2VkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIFwiO1xcbiAgICAgXCIpXHJcbiAgICAgICAgOiBcIlxcbiAgICAgIHBvc2l0aW9uOiBzdGF0aWMhaW1wb3J0YW50O1xcbiAgICAgIHRyYW5zZm9ybTogbm9uZSFpbXBvcnRhbnQ7XFxuICAgICAgXCI7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgU3ViTWVudUNvbnRlbnRGUiA9IGZ1bmN0aW9uIChfYSwgcmVmKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgb3BlbiA9IF9hLm9wZW4sIG9wZW5XaGVuQ29sbGFwc2VkID0gX2Eub3BlbldoZW5Db2xsYXBzZWQsIGZpcnN0TGV2ZWwgPSBfYS5maXJzdExldmVsLCBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIGRlZmF1bHRPcGVuID0gX2EuZGVmYXVsdE9wZW4sIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwib3BlblwiLCBcIm9wZW5XaGVuQ29sbGFwc2VkXCIsIFwiZmlyc3RMZXZlbFwiLCBcImNvbGxhcHNlZFwiLCBcImRlZmF1bHRPcGVuXCJdKTtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB1c2VNZW51KCkudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIGRlZmF1bHRPcGVuU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShkZWZhdWx0T3BlbilbMF07XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkU3ViTWVudUNvbnRlbnQsIF9fYXNzaWduKHsgXCJkYXRhLXRlc3RpZFwiOiBcIlwiLmNvbmNhdChtZW51Q2xhc3Nlcy5zdWJNZW51Q29udGVudCwgXCItdGVzdC1pZFwiKSwgcmVmOiByZWYsIGZpcnN0TGV2ZWw6IGZpcnN0TGV2ZWwsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBvcGVuOiBvcGVuLCBvcGVuV2hlbkNvbGxhcHNlZDogb3BlbldoZW5Db2xsYXBzZWQsIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uLCBkZWZhdWx0T3BlbjogZGVmYXVsdE9wZW5TdGF0ZSB9LCByZXN0KSxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFVsLCBudWxsLCBjaGlsZHJlbikpKTtcclxufTtcclxudmFyIFN1Yk1lbnVDb250ZW50ID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihTdWJNZW51Q29udGVudEZSKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkNztcblxudmFyIFN0eWxlZE1lbnVMYWJlbCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzEkNiB8fCAodGVtcGxhdGVPYmplY3RfMSQ2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBmbGV4LWdyb3c6IDE7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcblxcbiAgXCIsIFwiO1xcblwiXSwgW1wiXFxuICBmbGV4LWdyb3c6IDE7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcblxcbiAgXCIsIFwiO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkNjtcblxudmFyIFN0eWxlZE1lbnVJY29uID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMSQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHdpZHRoOiAzNXB4O1xcbiAgbWluLXdpZHRoOiAzNXB4O1xcbiAgaGVpZ2h0OiAzNXB4O1xcbiAgbGluZS1oZWlnaHQ6IDM1cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIHdpZHRoOiAzNXB4O1xcbiAgbWluLXdpZHRoOiAzNXB4O1xcbiAgaGVpZ2h0OiAzNXB4O1xcbiAgbGluZS1oZWlnaHQ6IDM1cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiAocnRsID8gJ21hcmdpbi1sZWZ0OiAxMHB4OycgOiAnbWFyZ2luLXJpZ2h0OiAxMHB4OycpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkNTtcblxudmFyIFN0eWxlZE1lbnVQcmVmaXggPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgXCIsIFwiXFxuICBvcGFjaXR5OiBcIiwgXCI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IFwiLCBcIm1zO1xcblxcbiAgXCIsIFwiO1xcblwiXSwgW1wiXFxuICBcIiwgXCJcXG4gIG9wYWNpdHk6IFwiLCBcIjtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgXCIsIFwibXM7XFxuXFxuICBcIiwgXCI7XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiAocnRsID8gJ21hcmdpbi1sZWZ0OiA1cHg7JyA6ICdtYXJnaW4tcmlnaHQ6IDVweDsnKTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZDtcclxuICAgIHJldHVybiAoZmlyc3RMZXZlbCAmJiBjb2xsYXBzZWQgPyAnMCcgOiAnMScpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBfYS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkNDtcblxudmFyIFN0eWxlZE1lbnVTdWZmaXggPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDMgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgb3BhY2l0eTogXCIsIFwiO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSBcIiwgXCJtcztcXG5cXG4gIFwiLCBcIjtcXG5cIl0sIFtcIlxcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgb3BhY2l0eTogXCIsIFwiO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSBcIiwgXCJtcztcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZDtcclxuICAgIHJldHVybiAoZmlyc3RMZXZlbCAmJiBjb2xsYXBzZWQgPyAnMCcgOiAnMScpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBfYS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkMztcblxudmFyIFN0eWxlZEV4cGFuZEljb25XcmFwcGVyID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMSQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiO1xcblwiXSwgW1wiXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkLCBsZXZlbCA9IF9hLmxldmVsLCBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gY29sbGFwc2VkICYmXHJcbiAgICAgICAgbGV2ZWwgPT09IDAgJiZcclxuICAgICAgICBcIlxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIFwiLmNvbmNhdChydGwgPyAnbGVmdDogMTBweDsnIDogJ3JpZ2h0OiAxMHB4OycsIFwiXFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICAgIFxcbiAgICBcIik7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgU3R5bGVkRXhwYW5kSWNvbiA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzIgfHwgKHRlbXBsYXRlT2JqZWN0XzIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzO1xcbiAgXCIsIFwiXFxuXFxuICB3aWR0aDogNXB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZShcIiwgXCIpO1xcblwiXSwgW1wiXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zcztcXG4gIFwiLCBcIlxcblxcbiAgd2lkdGg6IDVweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoXCIsIFwiKTtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIHJ0bFxyXG4gICAgICAgID8gXCJcXG4gICAgICAgICAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICAgIGJvcmRlci10b3A6IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICBcIlxyXG4gICAgICAgIDogXCIgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgY3VycmVudGNvbG9yO1xcbiAgICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgY3VycmVudGNvbG9yO1xcbiAgICAgICAgXCI7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIG9wZW4gPSBfYS5vcGVuLCBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gKG9wZW4gPyAocnRsID8gJy0xMzVkZWcnIDogJzQ1ZGVnJykgOiAnLTQ1ZGVnJyk7XHJcbn0pO1xyXG52YXIgU3R5bGVkRXhwYW5kSWNvbkNvbGxhcHNlZCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzMgfHwgKHRlbXBsYXRlT2JqZWN0XzMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHdpZHRoOiA1cHg7XFxuICBoZWlnaHQ6IDVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IGN1cnJlbnRjb2xvcjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG5cIl0sIFtcIlxcbiAgd2lkdGg6IDVweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudGNvbG9yO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcblwiXSkpKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkMiwgdGVtcGxhdGVPYmplY3RfMiwgdGVtcGxhdGVPYmplY3RfMztcblxudmFyIHRvcCA9ICd0b3AnO1xudmFyIGJvdHRvbSA9ICdib3R0b20nO1xudmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbnZhciBsZWZ0ID0gJ2xlZnQnO1xudmFyIGF1dG8gPSAnYXV0byc7XG52YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbnZhciBzdGFydCA9ICdzdGFydCc7XG52YXIgZW5kID0gJ2VuZCc7XG52YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG52YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xudmFyIHBvcHBlciA9ICdwb3BwZXInO1xudmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xudmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbnZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbnZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xudmFyIHJlYWQgPSAncmVhZCc7XG52YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbnZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xudmFyIG1haW4gPSAnbWFpbic7XG52YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxudmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbnZhciB3cml0ZSA9ICd3cml0ZSc7XG52YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbnZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcblxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCQyKF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXBwbHlTdHlsZXMkMSA9IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QkMixcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59O1xuXG5mdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzTGF5b3V0Vmlld3BvcnQoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcbiAgICBzY2FsZVkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxIDogMTtcbiAgfVxuXG4gIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxuICAgICAgdmlzdWFsVmlld3BvcnQgPSBfcmVmLnZpc3VhbFZpZXdwb3J0O1xuXG4gIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcbiAgdmFyIHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvIHNjYWxlWTtcbiAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5mdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuXG5mdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xuICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG59XG5mdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufVxuXG5mdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcnJvdyQxID0ge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0JDEsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTtcblxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGNvbXB1dGVTdHlsZXMkMSA9IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59O1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgZXZlbnRMaXN0ZW5lcnMgPSB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59O1xuXG52YXIgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcbiAgfSk7XG59XG5cbnZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59XG5cbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufVxuXG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn1cblxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBwbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBmbGlwJDEgPSB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGhpZGUkMSA9IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTtcblxuZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBvZmZzZXQkMSA9IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTtcblxuZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluJDEgPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCQxID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcHJldmVudE92ZXJmbG93JDEgPSB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59O1xuXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcbiAgfSwgc3RyKTtcbn1cblxudmFyIElOVkFMSURfTU9ESUZJRVJfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcyc7XG52YXIgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJztcbnZhciBWQUxJRF9QUk9QRVJUSUVTID0gWyduYW1lJywgJ2VuYWJsZWQnLCAncGhhc2UnLCAnZm4nLCAnZWZmZWN0JywgJ3JlcXVpcmVzJywgJ29wdGlvbnMnXTtcbmZ1bmN0aW9uIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBbXS5jb25jYXQoT2JqZWN0LmtleXMobW9kaWZpZXIpLCBWQUxJRF9QUk9QRVJUSUVTKSAvLyBJRTExLWNvbXBhdGlibGUgcmVwbGFjZW1lbnQgZm9yIGBuZXcgU2V0KGl0ZXJhYmxlKWBcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5uYW1lKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmVuYWJsZWQpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwaGFzZSc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyUGhhc2VzLmluZGV4T2YobW9kaWZpZXIucGhhc2UpIDwgMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgbW9kaWZpZXJQaGFzZXMuam9pbignLCAnKSwgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucGhhc2UpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbic6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VmZmVjdCc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiBtb2RpZmllci5lZmZlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXMnOlxuICAgICAgICAgIGlmIChtb2RpZmllci5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlcykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzSWZFeGlzdHMnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcHRpb25zJzpcbiAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFxcXCJcIiArIG1vZGlmaWVyLm5hbWUgKyBcIlxcXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlIFwiICsgVkFMSURfUFJPUEVSVElFUy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIiArIHMgKyBcIlxcXCJcIjtcbiAgICAgICAgICB9KS5qb2luKCcsICcpICsgXCI7IGJ1dCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiYgbW9kaWZpZXIucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWlyZW1lbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICByZXR1cm4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50O1xuICAgICAgICB9KSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksIHJlcXVpcmVtZW50LCByZXF1aXJlbWVudCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZUJ5KGFyciwgZm4pIHtcbiAgdmFyIGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZGVudGlmaWVyID0gZm4oaXRlbSk7XG5cbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgaWRlbnRpZmllcnMuYWRkKGlkZW50aWZpZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59XG5cbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDEsIG9mZnNldCQxLCBmbGlwJDEsIHByZXZlbnRPdmVyZmxvdyQxLCBhcnJvdyQxLCBoaWRlJDFdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdXNlUG9wcGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwsIGJ1dHRvblJlZiA9IG9wdGlvbnMuYnV0dG9uUmVmLCBjb250ZW50UmVmID0gb3B0aW9ucy5jb250ZW50UmVmO1xyXG4gICAgdmFyIF9hID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChTaWRlYmFyQ29udGV4dCksIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgdG9nZ2xlZCA9IF9hLnRvZ2dsZWQsIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHZhciBwb3BwZXJJbnN0YW5jZVJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZigpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBjcmVhdGUgcG9wcGVyIGluc3RhbmNlIG9ubHkgb24gZmlyc3QgbGV2ZWwgc3VibWVudSBjb21wb25lbnRzIGFuZCB3aGVuIHNpZGViYXIgaXMgY29sbGFwc2VkXHJcbiAgICAgKi9cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID09PSAwICYmIGNvbGxhcHNlZCAmJiBjb250ZW50UmVmLmN1cnJlbnQgJiYgYnV0dG9uUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCA9IGNyZWF0ZVBvcHBlcihidXR0b25SZWYuY3VycmVudCwgY29udGVudFJlZi5jdXJyZW50LCB7XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXHJcbiAgICAgICAgICAgICAgICBzdHJhdGVneTogJ2ZpeGVkJyxcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTsgfTtcclxuICAgIH0sIFtsZXZlbCwgY29sbGFwc2VkLCBjb250ZW50UmVmLCBidXR0b25SZWZdKTtcclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlIHBvcHBlciBpbnN0YW5jZSAocG9zaXRpb24pIHdoZW4gYnV0dG9uUmVmIG9yIGNvbnRlbnRSZWYgY2hhbmdlc1xyXG4gICAgICovXHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb250ZW50UmVmLmN1cnJlbnQgJiYgYnV0dG9uUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHJvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIChfYSA9IHBvcHBlckluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJvLm9ic2VydmUoY29udGVudFJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgcm8ub2JzZXJ2ZShidXR0b25SZWYuY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHBvcHBlckluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGUoKTtcclxuICAgICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgfSwgW3RyYW5zaXRpb25EdXJhdGlvbiwgdG9nZ2xlZCwgY29udGVudFJlZiwgYnV0dG9uUmVmXSk7XHJcbiAgICByZXR1cm4geyBwb3BwZXJJbnN0YW5jZTogcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCB9O1xyXG59O1xuXG52YXIgbWVudUJ1dHRvblN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIHJ0bCA9IHByb3BzLnJ0bCwgbGV2ZWwgPSBwcm9wcy5sZXZlbCwgY29sbGFwc2VkID0gcHJvcHMuY29sbGFwc2VkLCBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLCBhY3RpdmUgPSBwcm9wcy5hY3RpdmU7XHJcbiAgICByZXR1cm4gXCJcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgaGVpZ2h0OiA1MHB4O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuXFxuICAgIFwiLmNvbmNhdChydGxcclxuICAgICAgICA/IFwicGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgICAgICAgICAgcGFkZGluZy1yaWdodDogXCIuY29uY2F0KGxldmVsID09PSAwID8gMjAgOiAoY29sbGFwc2VkID8gbGV2ZWwgOiBsZXZlbCArIDEpICogMjAsIFwicHg7XFxuICAgICAgICAgICAgXCIpXHJcbiAgICAgICAgOiBcInBhZGRpbmctcmlnaHQ6IDIwcHg7XFxuICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IFwiLmNvbmNhdChsZXZlbCA9PT0gMCA/IDIwIDogKGNvbGxhcHNlZCA/IGxldmVsIDogbGV2ZWwgKyAxKSAqIDIwLCBcInB4O1xcbiAgICAgICAgICAgXCIpLCBcIlxcblxcbiAgICAmOmhvdmVyIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2YzO1xcbiAgICB9XFxuXFxuICAgIFwiKS5jb25jYXQoZGlzYWJsZWQgJiZcclxuICAgICAgICBcIiBcXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgICAgY29sb3I6I2FkYWRhZDtcXG4gICAgICAgIFwiLCBcIlxcblxcbiAgICBcIikuY29uY2F0KGFjdGl2ZSAmJiAnYmFja2dyb3VuZC1jb2xvcjogI2UyZWVmOTsnLCBcIlxcbiAgXFxuICBcIik7XHJcbn07XHJcbnZhciBNZW51QnV0dG9uUmVmID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGNvbXBvbmVudCA9IF9hLmNvbXBvbmVudCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiY2hpbGRyZW5cIl0pO1xyXG4gICAgaWYgKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIF9fYXNzaWduKF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSkgfSwgcmVzdCksIHsgcmVmOiByZWYgfSksIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IGNvbXBvbmVudC5wcm9wcywgY2xhc3NOYW1lUHJvcCA9IF9iLmNsYXNzTmFtZSwgcHJvcHMgPSBfX3Jlc3QoX2IsIFtcImNsYXNzTmFtZVwiXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjbGFzc05hbWUsIGNsYXNzTmFtZVByb3ApIH0sIHJlc3QpLCBwcm9wcyksIHsgcmVmOiByZWYgfSksIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fYXNzaWduKHsgcmVmOiByZWYsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjbGFzc05hbWUpIH0sIHJlc3QpLCBjaGlsZHJlbikpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgTWVudUJ1dHRvbiA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoTWVudUJ1dHRvblJlZik7XG5cbnZhciBTdHlsZWRTdWJNZW51ID0gbmV3U3R5bGVkLmxpKHRlbXBsYXRlT2JqZWN0XzEkMSB8fCAodGVtcGxhdGVPYmplY3RfMSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTAwJTtcXG5cXG4gIFwiLCBcIjtcXG5cXG4gIFwiLCBcIjtcXG5cXG4gID4gLlwiLCBcIiB7XFxuICAgIFwiLCBcIjtcXG5cXG4gICAgXCIsIFwiO1xcbiAgfVxcblwiXSwgW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTAwJTtcXG5cXG4gIFwiLCBcIjtcXG5cXG4gIFwiLCBcIjtcXG5cXG4gID4gLlwiLCBcIiB7XFxuICAgIFwiLCBcIjtcXG5cXG4gICAgXCIsIFwiO1xcbiAgfVxcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBtZW51SXRlbVN0eWxlcyA9IF9hLm1lbnVJdGVtU3R5bGVzO1xyXG4gICAgcmV0dXJuIG1lbnVJdGVtU3R5bGVzO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59LCBtZW51Q2xhc3Nlcy5idXR0b24sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGxldmVsID0gX2EubGV2ZWwsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGFjdGl2ZSA9IF9hLmFjdGl2ZSwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkLCBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gbWVudUJ1dHRvblN0eWxlcyh7XHJcbiAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcclxuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcclxuICAgICAgICBjb2xsYXBzZWQ6IGNvbGxhcHNlZCxcclxuICAgICAgICBydGw6IHJ0bCxcclxuICAgIH0pO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBidXR0b25TdHlsZXMgPSBfYS5idXR0b25TdHlsZXM7XHJcbiAgICByZXR1cm4gYnV0dG9uU3R5bGVzO1xyXG59KTtcclxudmFyIFN1Yk1lbnVGUiA9IGZ1bmN0aW9uIChfYSwgcmVmKSB7XHJcbiAgICB2YXIgX2I7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBsYWJlbCA9IF9hLmxhYmVsLCBpY29uID0gX2EuaWNvbiwgdGl0bGUgPSBfYS50aXRsZSwgcHJlZml4ID0gX2EucHJlZml4LCBzdWZmaXggPSBfYS5zdWZmaXgsIG9wZW5Db250cm9sbGVkID0gX2Eub3BlbiwgZGVmYXVsdE9wZW4gPSBfYS5kZWZhdWx0T3BlbiwgX2MgPSBfYS5hY3RpdmUsIGFjdGl2ZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRpc2FibGVkLCBkaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBvbk9wZW5DaGFuZ2UgPSBfYS5vbk9wZW5DaGFuZ2UsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbktleVVwID0gX2Eub25LZXlVcCwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJsYWJlbFwiLCBcImljb25cIiwgXCJ0aXRsZVwiLCBcInByZWZpeFwiLCBcInN1ZmZpeFwiLCBcIm9wZW5cIiwgXCJkZWZhdWx0T3BlblwiLCBcImFjdGl2ZVwiLCBcImRpc2FibGVkXCIsIFwicm9vdFN0eWxlc1wiLCBcImNvbXBvbmVudFwiLCBcIm9uT3BlbkNoYW5nZVwiLCBcIm9uQ2xpY2tcIiwgXCJvbktleVVwXCJdKTtcclxuICAgIHZhciBsZXZlbCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTGV2ZWxDb250ZXh0KTtcclxuICAgIHZhciBfZSA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoU2lkZWJhckNvbnRleHQpLCBjb2xsYXBzZWQgPSBfZS5jb2xsYXBzZWQsIHJ0bCA9IF9lLnJ0bCwgc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiA9IF9lLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHZhciBfZiA9IHVzZU1lbnUoKSwgcmVuZGVyRXhwYW5kSWNvbiA9IF9mLnJlbmRlckV4cGFuZEljb24sIGNsb3NlT25DbGljayA9IF9mLmNsb3NlT25DbGljaywgbWVudUl0ZW1TdHlsZXMgPSBfZi5tZW51SXRlbVN0eWxlcywgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2YudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIF9nID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoISFkZWZhdWx0T3BlbiksIG9wZW4gPSBfZ1swXSwgc2V0T3BlbiA9IF9nWzFdO1xyXG4gICAgdmFyIF9oID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpLCBvcGVuV2hlbkNvbGxhcHNlZCA9IF9oWzBdLCBzZXRPcGVuV2hlbkNvbGxhcHNlZCA9IF9oWzFdO1xyXG4gICAgdmFyIF9qID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpLCBtb3VudGVkID0gX2pbMF0sIHNldE1vdW50ZWQgPSBfalsxXTtcclxuICAgIHZhciBidXR0b25SZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XHJcbiAgICB2YXIgY29udGVudFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcclxuICAgIHZhciB0aW1lciA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZigpO1xyXG4gICAgdmFyIHBvcHBlckluc3RhbmNlID0gdXNlUG9wcGVyKHtcclxuICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgYnV0dG9uUmVmOiBidXR0b25SZWYsXHJcbiAgICAgICAgY29udGVudFJlZjogY29udGVudFJlZixcclxuICAgIH0pLnBvcHBlckluc3RhbmNlO1xyXG4gICAgdmFyIGV4cGFuZENvbnRlbnQgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKF9hID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KG1lbnVDbGFzc2VzLnN1Yk1lbnVDb250ZW50LCBcIiA+IHVsXCIpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7XHJcbiAgICAgICAgICAgIHRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgICAgICAgICAgIH0sIHRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyYW5zaXRpb25EdXJhdGlvbl0pO1xyXG4gICAgdmFyIGNvbGxhcHNlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGNvbnRlbnRSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAoX2EgPSB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQobWVudUNsYXNzZXMuc3ViTWVudUNvbnRlbnQsIFwiID4gdWxcIikpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcclxuICAgICAgICAgICAgdGFyZ2V0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICcwcHgnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlU2xpZGVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEobGV2ZWwgPT09IDAgJiYgY29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wZW5Db250cm9sbGVkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KE51bWJlcih0aW1lci5jdXJyZW50KSk7XHJcbiAgICAgICAgICAgICAgICBvcGVuID8gY29sbGFwc2VDb250ZW50KCkgOiBleHBhbmRDb250ZW50KCk7XHJcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT09IG51bGwgfHwgb25PcGVuQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoIW9wZW4pO1xyXG4gICAgICAgICAgICAgICAgc2V0T3Blbighb3Blbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT09IG51bGwgfHwgb25PcGVuQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoIW9wZW5Db250cm9sbGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKGxldmVsID09PSAwICYmIGNvbGxhcHNlZCkgJiYgdHlwZW9mIG9wZW5Db250cm9sbGVkICE9PSAndW5kZWZpbmVkJyAmJiBtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChOdW1iZXIodGltZXIuY3VycmVudCkpO1xyXG4gICAgICAgICAgICAhb3BlbkNvbnRyb2xsZWQgPyBjb2xsYXBzZUNvbnRlbnQoKSA6IGV4cGFuZENvbnRlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW2NvbGxhcHNlZCwgZXhwYW5kQ29udGVudCwgbGFiZWwsIGxldmVsLCBvbk9wZW5DaGFuZ2UsIG9wZW5Db250cm9sbGVkXSk7XHJcbiAgICB2YXIgaGFuZGxlT25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIG9uQ2xpY2sgPT09IG51bGwgfHwgb25DbGljayA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DbGljayhldmVudCk7XHJcbiAgICAgICAgaGFuZGxlU2xpZGVUb2dnbGUoKTtcclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlT25LZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIG9uS2V5VXAgPT09IG51bGwgfHwgb25LZXlVcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25LZXlVcChldmVudCk7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xyXG4gICAgICAgICAgICBoYW5kbGVTbGlkZVRvZ2dsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgZ2V0U3ViTWVudUl0ZW1TdHlsZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChtZW51SXRlbVN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0geyBsZXZlbDogbGV2ZWwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGlzU3VibWVudTogdHJ1ZSwgb3Blbjogb3BlbkNvbnRyb2xsZWQgIT09IG51bGwgJiYgb3BlbkNvbnRyb2xsZWQgIT09IHZvaWQgMCA/IG9wZW5Db250cm9sbGVkIDogb3BlbiB9O1xyXG4gICAgICAgICAgICB2YXIgcm9vdEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMucm9vdCwgYnV0dG9uRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5idXR0b24sIGxhYmVsRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5sYWJlbCwgaWNvbkVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMuaWNvbiwgcHJlZml4RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5wcmVmaXgsIHN1ZmZpeEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMuc3VmZml4LCBzdWJNZW51Q29udGVudEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMuc3ViTWVudUNvbnRlbnQsIFN1Yk1lbnVFeHBhbmRJY29uRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5TdWJNZW51RXhwYW5kSWNvbjtcclxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyb290JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJvb3RFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IHJvb3RFbFN0eWxlcyhwYXJhbXMpIDogcm9vdEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGJ1dHRvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gYnV0dG9uRWxTdHlsZXMocGFyYW1zKSA6IGJ1dHRvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbGFiZWxFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGxhYmVsRWxTdHlsZXMocGFyYW1zKSA6IGxhYmVsRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpY29uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGljb25FbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGljb25FbFN0eWxlcyhwYXJhbXMpIDogaWNvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncHJlZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHByZWZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gcHJlZml4RWxTdHlsZXMocGFyYW1zKSA6IHByZWZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3VmZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1ZmZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gc3VmZml4RWxTdHlsZXMocGFyYW1zKSA6IHN1ZmZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnU3ViTWVudUV4cGFuZEljb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFN1Yk1lbnVFeHBhbmRJY29uRWxTdHlsZXMocGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN1Yk1lbnVFeHBhbmRJY29uRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdWJNZW51Q29udGVudCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdWJNZW51Q29udGVudEVsU3R5bGVzID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViTWVudUNvbnRlbnRFbFN0eWxlcyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3ViTWVudUNvbnRlbnRFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9wcGVySW5zdGFuY2UgPT09IG51bGwgfHwgcG9wcGVySW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHBlckluc3RhbmNlLnVwZGF0ZSgpOyB9LCBzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIGxldmVsID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNldE9wZW5XaGVuQ29sbGFwc2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gPyBpZiBpdHMgdXNlZnVsIHRvIGNsb3NlIGZpcnN0IGxldmVsIHN1Ym1lbnVzIG9uIGNvbGxhcHNlIHNpZGViYXIgdW5jb21tZW50IHRoZSBjb2RlIGJlbG93XHJcbiAgICAgICAgICAgIC8vIHNldE9wZW4oZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb2xsYXBzZWQsIGxldmVsLCBydGwsIHNpZGViYXJUcmFuc2l0aW9uRHVyYXRpb24sIHBvcHBlckluc3RhbmNlXSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoYW5kbGVUb2dnbGVQb3BwZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgICAgICBpZiAoIW9wZW5XaGVuQ29sbGFwc2VkICYmICgoX2EgPSBidXR0b25SZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKHRhcmdldCkpKVxyXG4gICAgICAgICAgICAgICAgc2V0T3BlbldoZW5Db2xsYXBzZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChjbG9zZU9uQ2xpY2sgJiZcclxuICAgICAgICAgICAgICAgICEoKF9iID0gdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgLmNsb3Nlc3QoXCIuXCIuY29uY2F0KG1lbnVDbGFzc2VzLm1lbnVJdGVtUm9vdCkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3NMaXN0LmNvbnRhaW5zKG1lbnVDbGFzc2VzLnN1Yk1lbnVSb290KSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoISgoX2MgPSBjb250ZW50UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jb250YWlucyh0YXJnZXQpKSAmJiBvcGVuV2hlbkNvbGxhcHNlZCkpIHtcclxuICAgICAgICAgICAgICAgIHNldE9wZW5XaGVuQ29sbGFwc2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGhhbmRsZURvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaGFuZGxlVG9nZ2xlUG9wcGVyKGV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRG9jdW1lbnRLZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVUb2dnbGVQb3BwZXIoZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuV2hlbkNvbGxhcHNlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVEb2N1bWVudENsaWNrKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVEb2N1bWVudEtleVVwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgaWYgKGNvbGxhcHNlZCAmJiBsZXZlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZURvY3VtZW50Q2xpY2ssIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVEb2N1bWVudEtleVVwLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtjb2xsYXBzZWQsIGxldmVsLCBjbG9zZU9uQ2xpY2ssIG9wZW5XaGVuQ29sbGFwc2VkXSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICB2YXIgc2hhcmVkQ2xhc3NlcyA9IChfYiA9IHt9LFxyXG4gICAgICAgIF9iW21lbnVDbGFzc2VzLmFjdGl2ZV0gPSBhY3RpdmUsXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuZGlzYWJsZWRdID0gZGlzYWJsZWQsXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMub3Blbl0gPSBvcGVuQ29udHJvbGxlZCAhPT0gbnVsbCAmJiBvcGVuQ29udHJvbGxlZCAhPT0gdm9pZCAwID8gb3BlbkNvbnRyb2xsZWQgOiBvcGVuLFxyXG4gICAgICAgIF9iKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTdWJNZW51LCB7IHJlZjogcmVmLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMubWVudUl0ZW1Sb290LCBtZW51Q2xhc3Nlcy5zdWJNZW51Um9vdCwgc2hhcmVkQ2xhc3NlcywgY2xhc3NOYW1lKSwgbWVudUl0ZW1TdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdyb290JyksIGxldmVsOiBsZXZlbCwgY29sbGFwc2VkOiBjb2xsYXBzZWQsIHJ0bDogcnRsLCBkaXNhYmxlZDogZGlzYWJsZWQsIGFjdGl2ZTogYWN0aXZlLCBidXR0b25TdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdidXR0b24nKSwgcm9vdFN0eWxlczogcm9vdFN0eWxlcyB9LFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTWVudUJ1dHRvbiwgX19hc3NpZ24oeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KG1lbnVDbGFzc2VzLmJ1dHRvbiwgXCItdGVzdC1pZFwiKSwgcmVmOiBidXR0b25SZWYsIHRpdGxlOiB0aXRsZSwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLmJ1dHRvbiwgc2hhcmVkQ2xhc3NlcyksIG9uQ2xpY2s6IGhhbmRsZU9uQ2xpY2ssIG9uS2V5VXA6IGhhbmRsZU9uS2V5VXAsIGNvbXBvbmVudDogY29tcG9uZW50LCB0YWJJbmRleDogMCB9LCByZXN0KSxcclxuICAgICAgICAgICAgaWNvbiAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51SWNvbiwgeyBydGw6IHJ0bCwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLmljb24sIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygnaWNvbicpIH0sIGljb24pKSxcclxuICAgICAgICAgICAgcHJlZml4ICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVQcmVmaXgsIHsgY29sbGFwc2VkOiBjb2xsYXBzZWQsIHRyYW5zaXRpb25EdXJhdGlvbjogc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5wcmVmaXgsIHNoYXJlZENsYXNzZXMpLCBydGw6IHJ0bCwgcm9vdFN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3ByZWZpeCcpIH0sIHByZWZpeCkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVMYWJlbCwgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMubGFiZWwsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygnbGFiZWwnKSB9LCBsYWJlbCksXHJcbiAgICAgICAgICAgIHN1ZmZpeCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51U3VmZml4LCB7IGNvbGxhcHNlZDogY29sbGFwc2VkLCB0cmFuc2l0aW9uRHVyYXRpb246IHNpZGViYXJUcmFuc2l0aW9uRHVyYXRpb24sIGZpcnN0TGV2ZWw6IGxldmVsID09PSAwLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuc3VmZml4LCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3N1ZmZpeCcpIH0sIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEV4cGFuZEljb25XcmFwcGVyLCB7IHJ0bDogcnRsLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuU3ViTWVudUV4cGFuZEljb24sIHNoYXJlZENsYXNzZXMpLCBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgbGV2ZWw6IGxldmVsLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygnU3ViTWVudUV4cGFuZEljb24nKSB9LCByZW5kZXJFeHBhbmRJY29uID8gKHJlbmRlckV4cGFuZEljb24oe1xyXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmUsXHJcbiAgICAgICAgICAgICAgICBvcGVuOiBvcGVuQ29udHJvbGxlZCAhPT0gbnVsbCAmJiBvcGVuQ29udHJvbGxlZCAhPT0gdm9pZCAwID8gb3BlbkNvbnRyb2xsZWQgOiBvcGVuLFxyXG4gICAgICAgICAgICB9KSkgOiBjb2xsYXBzZWQgJiYgbGV2ZWwgPT09IDAgPyAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRFeHBhbmRJY29uQ29sbGFwc2VkLCBudWxsKSkgOiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRFeHBhbmRJY29uLCB7IHJ0bDogcnRsLCBvcGVuOiBvcGVuQ29udHJvbGxlZCAhPT0gbnVsbCAmJiBvcGVuQ29udHJvbGxlZCAhPT0gdm9pZCAwID8gb3BlbkNvbnRyb2xsZWQgOiBvcGVuIH0pKSkpLFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3ViTWVudUNvbnRlbnQsIHsgcmVmOiBjb250ZW50UmVmLCBvcGVuV2hlbkNvbGxhcHNlZDogb3BlbldoZW5Db2xsYXBzZWQsIG9wZW46IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4sIGZpcnN0TGV2ZWw6IGxldmVsID09PSAwLCBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgZGVmYXVsdE9wZW46IChvcGVuQ29udHJvbGxlZCAmJiAhbW91bnRlZCkgfHwgZGVmYXVsdE9wZW4sIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5zdWJNZW51Q29udGVudCwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdzdWJNZW51Q29udGVudCcpIH0sXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGV2ZWxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBsZXZlbCArIDEgfSwgY2hpbGRyZW4pKSkpO1xyXG59O1xyXG52YXIgU3ViTWVudSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoU3ViTWVudUZSKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkMTtcblxudmFyIFN0eWxlZE1lbnVJdGVtID0gbmV3U3R5bGVkLmxpKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdLCBbXCJcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIG1lbnVJdGVtU3R5bGVzID0gX2EubWVudUl0ZW1TdHlsZXM7XHJcbiAgICByZXR1cm4gbWVudUl0ZW1TdHlsZXM7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0sIG1lbnVDbGFzc2VzLmJ1dHRvbiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgYWN0aXZlID0gX2EuYWN0aXZlLCBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiBtZW51QnV0dG9uU3R5bGVzKHtcclxuICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxyXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLFxyXG4gICAgICAgIGNvbGxhcHNlZDogY29sbGFwc2VkLFxyXG4gICAgICAgIHJ0bDogcnRsLFxyXG4gICAgfSk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGJ1dHRvblN0eWxlcyA9IF9hLmJ1dHRvblN0eWxlcztcclxuICAgIHJldHVybiBidXR0b25TdHlsZXM7XHJcbn0pO1xyXG52YXIgTWVudUl0ZW1GUiA9IGZ1bmN0aW9uIChfYSwgcmVmKSB7XHJcbiAgICB2YXIgX2I7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaWNvbiA9IF9hLmljb24sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgcHJlZml4ID0gX2EucHJlZml4LCBzdWZmaXggPSBfYS5zdWZmaXgsIF9jID0gX2EuYWN0aXZlLCBhY3RpdmUgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5kaXNhYmxlZCwgZGlzYWJsZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJpY29uXCIsIFwiY2xhc3NOYW1lXCIsIFwicHJlZml4XCIsIFwic3VmZml4XCIsIFwiYWN0aXZlXCIsIFwiZGlzYWJsZWRcIiwgXCJjb21wb25lbnRcIiwgXCJyb290U3R5bGVzXCJdKTtcclxuICAgIHZhciBsZXZlbCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTGV2ZWxDb250ZXh0KTtcclxuICAgIHZhciBfZSA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoU2lkZWJhckNvbnRleHQpLCBjb2xsYXBzZWQgPSBfZS5jb2xsYXBzZWQsIHJ0bCA9IF9lLnJ0bCwgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2UudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIG1lbnVJdGVtU3R5bGVzID0gdXNlTWVudSgpLm1lbnVJdGVtU3R5bGVzO1xyXG4gICAgdmFyIGdldE1lbnVJdGVtU3R5bGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAobWVudUl0ZW1TdHlsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHsgbGV2ZWw6IGxldmVsLCBkaXNhYmxlZDogZGlzYWJsZWQsIGFjdGl2ZTogYWN0aXZlLCBpc1N1Ym1lbnU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIHZhciByb290RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5yb290LCBidXR0b25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmJ1dHRvbiwgbGFiZWxFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmxhYmVsLCBpY29uRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5pY29uLCBwcmVmaXhFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnByZWZpeCwgc3VmZml4RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5zdWZmaXg7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByb290RWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyByb290RWxTdHlsZXMocGFyYW1zKSA6IHJvb3RFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2J1dHRvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBidXR0b25FbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkVsU3R5bGVzKHBhcmFtcykgOiBidXR0b25FbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGxhYmVsRWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBsYWJlbEVsU3R5bGVzKHBhcmFtcykgOiBsYWJlbEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaWNvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBpY29uRWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBpY29uRWxTdHlsZXMocGFyYW1zKSA6IGljb25FbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZWZpeCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwcmVmaXhFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IHByZWZpeEVsU3R5bGVzKHBhcmFtcykgOiBwcmVmaXhFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1ZmZpeCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdWZmaXhFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1ZmZpeEVsU3R5bGVzKHBhcmFtcykgOiBzdWZmaXhFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgc2hhcmVkQ2xhc3NlcyA9IChfYiA9IHt9LFxyXG4gICAgICAgIF9iW21lbnVDbGFzc2VzLmFjdGl2ZV0gPSBhY3RpdmUsXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuZGlzYWJsZWRdID0gZGlzYWJsZWQsXHJcbiAgICAgICAgX2IpO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVJdGVtLCB7IHJlZjogcmVmLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMubWVudUl0ZW1Sb290LCBzaGFyZWRDbGFzc2VzLCBjbGFzc05hbWUpLCBtZW51SXRlbVN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ3Jvb3QnKSwgbGV2ZWw6IGxldmVsLCBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgcnRsOiBydGwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGJ1dHRvblN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ2J1dHRvbicpLCByb290U3R5bGVzOiByb290U3R5bGVzIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZW51QnV0dG9uLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5idXR0b24sIHNoYXJlZENsYXNzZXMpLCBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KG1lbnVDbGFzc2VzLmJ1dHRvbiwgXCItdGVzdC1pZFwiKSwgY29tcG9uZW50OiBjb21wb25lbnQsIHRhYkluZGV4OiAwIH0sIHJlc3QpLFxyXG4gICAgICAgICAgICBpY29uICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVJY29uLCB7IHJ0bDogcnRsLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuaWNvbiwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldE1lbnVJdGVtU3R5bGVzKCdpY29uJykgfSwgaWNvbikpLFxyXG4gICAgICAgICAgICBwcmVmaXggJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudVByZWZpeCwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGZpcnN0TGV2ZWw6IGxldmVsID09PSAwLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMucHJlZml4LCBzaGFyZWRDbGFzc2VzKSwgcnRsOiBydGwsIHJvb3RTdHlsZXM6IGdldE1lbnVJdGVtU3R5bGVzKCdwcmVmaXgnKSB9LCBwcmVmaXgpKSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51TGFiZWwsIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLmxhYmVsLCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ2xhYmVsJykgfSwgY2hpbGRyZW4pLFxyXG4gICAgICAgICAgICBzdWZmaXggJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudVN1ZmZpeCwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGZpcnN0TGV2ZWw6IGxldmVsID09PSAwLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuc3VmZml4LCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ3N1ZmZpeCcpIH0sIHN1ZmZpeCkpKSkpO1xyXG59O1xyXG52YXIgTWVudUl0ZW0gPSBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKE1lbnVJdGVtRlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcblxuLyoqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqIGBQcm9TaWRlYmFyUHJvdmlkZXJgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxyXG4gKi9cclxudmFyIFByb1NpZGViYXJQcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XHJcbiAgICBjb25zb2xlLndhcm4oJ1Byb1NpZGViYXJQcm92aWRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4nKTtcclxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNpZGViYXJQcm92aWRlciwgbnVsbCwgY2hpbGRyZW4pO1xyXG59O1xuXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICogYHVzZVByb1NpZGViYXJgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxyXG4gKiAgcGxlYXNlIHVzZSBTaWRlYmFyIHByb3BzIGluc3RlYWQuXHJcbiAqL1xyXG52YXIgdXNlUHJvU2lkZWJhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBsZWdhY3lTaWRlYmFyQ29udGV4dCA9IHVzZUxlZ2FjeVNpZGViYXIoKTtcclxuICAgIGlmIChsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VQcm9TaWRlYmFyIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBQcm9TaWRlYmFyUHJvdmlkZXIuIFBsZWFzZSB3cmFwIHlvdXIgY29tcG9uZW50IHdpdGggYSBQcm9TaWRlYmFyUHJvdmlkZXIgdG8gdXNlIHRoaXMgaG9vay4nKTtcclxuICAgIH1cclxuICAgIHZhciBjb2xsYXBzZVNpZGViYXIgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlQ29sbGFwc2VTdGF0ZSgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlKHsgY29sbGFwc2VkOiB2YWx1ZSB9KTtcclxuICAgIH0sIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgW2xlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZUNvbGxhcHNlU3RhdGUsIGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZV0pO1xyXG4gICAgdmFyIHRvZ2dsZVNpZGViYXIgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlVG9nZ2xlU3RhdGUoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSh7IHRvZ2dsZWQ6IHZhbHVlIH0pO1xyXG4gICAgfSwgXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlVG9nZ2xlU3RhdGUsIGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZV0pO1xyXG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ3VzZVByb1NpZGViYXIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFBsZWFzZSB1c2UgU2lkZWJhciBwcm9wcyBpbnN0ZWFkLicpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb2xsYXBzZVNpZGViYXI6IGNvbGxhcHNlU2lkZWJhcixcclxuICAgICAgICB0b2dnbGVTaWRlYmFyOiB0b2dnbGVTaWRlYmFyLFxyXG4gICAgICAgIGNvbGxhcHNlZDogISFsZWdhY3lTaWRlYmFyQ29udGV4dC5jb2xsYXBzZWQsXHJcbiAgICAgICAgYnJva2VuOiAhIWxlZ2FjeVNpZGViYXJDb250ZXh0LmJyb2tlbixcclxuICAgICAgICB0b2dnbGVkOiAhIWxlZ2FjeVNpZGViYXJDb250ZXh0LnRvZ2dsZWQsXHJcbiAgICAgICAgcnRsOiAhIWxlZ2FjeVNpZGViYXJDb250ZXh0LnJ0bCxcclxuICAgIH07XHJcbn07XG5cbmV4cG9ydCB7IExldmVsQ29udGV4dCwgTWVudSwgTWVudUNvbnRleHQsIE1lbnVJdGVtLCBNZW51SXRlbUZSLCBQcm9TaWRlYmFyUHJvdmlkZXIsIFNpZGViYXIsIFNpZGViYXJDb250ZXh0LCBTdWJNZW51LCBTdWJNZW51RlIsIG1lbnVDbGFzc2VzLCBzaWRlYmFyQ2xhc3NlcywgdXNlUHJvU2lkZWJhciB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUmVhY3RfX2RlZmF1bHQiLCJmb3J3YXJkUmVmIiwidXNlQ29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVDb250ZXh0IiwiRnJhZ21lbnQiLCJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19tYWtlVGVtcGxhdGVPYmplY3QiLCJjb29rZWQiLCJyYXciLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2V4dGVuZHMiLCJiaW5kIiwidGFyZ2V0Iiwic291cmNlIiwia2V5IiwibWVtb2l6ZSIsImZuIiwiY2FjaGUiLCJjcmVhdGUiLCJhcmciLCJ1bmRlZmluZWQiLCJyZWFjdFByb3BzUmVnZXgiLCJpc1Byb3BWYWxpZCIsInByb3AiLCJ0ZXN0IiwiY2hhckNvZGVBdCIsInNoZWV0Rm9yVGFnIiwidGFnIiwic2hlZXQiLCJkb2N1bWVudCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiY3JlYXRlU3R5bGVFbGVtZW50Iiwib3B0aW9ucyIsInNldEF0dHJpYnV0ZSIsIm5vbmNlIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIlN0eWxlU2hlZXQiLCJfdGhpcyIsIl9pbnNlcnRUYWciLCJiZWZvcmUiLCJ0YWdzIiwiaW5zZXJ0aW9uUG9pbnQiLCJuZXh0U2libGluZyIsInByZXBlbmQiLCJjb250YWluZXIiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwicHVzaCIsImlzU3BlZWR5Iiwic3BlZWR5IiwicHJvY2VzcyIsImN0ciIsIl9wcm90byIsImh5ZHJhdGUiLCJub2RlcyIsImZvckVhY2giLCJpbnNlcnQiLCJydWxlIiwiaXNJbXBvcnRSdWxlIiwiX2FscmVhZHlJbnNlcnRlZE9yZGVySW5zZW5zaXRpdmVSdWxlIiwiY29uc29sZSIsImVycm9yIiwiaW5zZXJ0UnVsZSIsImNzc1J1bGVzIiwiZmx1c2giLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJNUyIsIk1PWiIsIldFQktJVCIsIkNPTU1FTlQiLCJSVUxFU0VUIiwiREVDTEFSQVRJT04iLCJJTVBPUlQiLCJLRVlGUkFNRVMiLCJhYnMiLCJNYXRoIiwiZnJvbSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImhhc2gkMiIsImNoYXJhdCIsInRyaW0iLCJtYXRjaCIsInBhdHRlcm4iLCJleGVjIiwicmVwbGFjZSIsInJlcGxhY2VtZW50IiwiaW5kZXhvZiIsInNlYXJjaCIsImluZGV4Iiwic3Vic3RyIiwiYmVnaW4iLCJlbmQiLCJzbGljZSIsInN0cmxlbiIsInNpemVvZiIsImFwcGVuZCIsImFycmF5IiwiY29tYmluZSIsImNhbGxiYWNrIiwibWFwIiwiam9pbiIsImxpbmUiLCJjb2x1bW4iLCJwb3NpdGlvbiIsImNoYXJhY3RlciIsImNoYXJhY3RlcnMiLCJub2RlIiwicm9vdCIsInBhcmVudCIsInR5cGUiLCJwcm9wcyIsImNoaWxkcmVuIiwicmV0dXJuIiwiY29weSIsImNoYXIiLCJwcmV2IiwibmV4dCIsInBlZWsiLCJjYXJldCIsInRva2VuIiwiYWxsb2MiLCJkZWFsbG9jIiwiZGVsaW1pdCIsImRlbGltaXRlciIsIndoaXRlc3BhY2UiLCJlc2NhcGluZyIsImNvdW50IiwiY29tbWVudGVyIiwiaWRlbnRpZmllciIsImNvbXBpbGUiLCJwYXJzZSIsInJ1bGVzIiwicnVsZXNldHMiLCJwc2V1ZG8iLCJwb2ludHMiLCJkZWNsYXJhdGlvbnMiLCJvZmZzZXQiLCJhdHJ1bGUiLCJwcm9wZXJ0eSIsInByZXZpb3VzIiwidmFyaWFibGUiLCJzY2FubmluZyIsImFtcGVyc2FuZCIsInJlZmVyZW5jZSIsImNvbW1lbnQiLCJkZWNsYXJhdGlvbiIsInJ1bGVzZXQiLCJwb3N0Iiwic2l6ZSIsImoiLCJrIiwieCIsInkiLCJ6Iiwic2VyaWFsaXplIiwib3V0cHV0Iiwic3RyaW5naWZ5IiwiZWxlbWVudCIsIm1pZGRsZXdhcmUiLCJjb2xsZWN0aW9uIiwicnVsZXNoZWV0Iiwid2Vha01lbW9pemUiLCJmdW5jIiwiV2Vha01hcCIsImhhcyIsImdldCIsInJldCIsInNldCIsImlkZW50aWZpZXJXaXRoUG9pbnRUcmFja2luZyIsInRvUnVsZXMiLCJwYXJzZWQiLCJnZXRSdWxlcyIsImZpeGVkRWxlbWVudHMiLCJjb21wYXQiLCJpc0ltcGxpY2l0UnVsZSIsInBhcmVudFJ1bGVzIiwicmVtb3ZlTGFiZWwiLCJpZ25vcmVGbGFnIiwiaXNJZ25vcmluZ0NvbW1lbnQiLCJjcmVhdGVVbnNhZmVTZWxlY3RvcnNBbGFybSIsInVuc2FmZVBzZXVkb0NsYXNzZXMiLCJpc05lc3RlZCIsImNvbW1lbnRDb250YWluZXIiLCJ1bnNhZmVQc2V1ZG9DbGFzcyIsInNwbGl0IiwiaXNQcmVwZW5kZWRXaXRoUmVndWxhclJ1bGVzIiwibnVsbGlmeUVsZW1lbnQiLCJpbmNvcnJlY3RJbXBvcnRBbGFybSIsInByZWZpeCIsInByZWZpeGVyIiwiaXNCcm93c2VyJDUiLCJnZXRTZXJ2ZXJTdHlsaXNDYWNoZSIsIm5hbWUiLCJkZWZhdWx0U3R5bGlzUGx1Z2lucyIsImNyZWF0ZUNhY2hlIiwiRXJyb3IiLCJzc3JTdHlsZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQXJyYXkiLCJkYXRhRW1vdGlvbkF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImhlYWQiLCJzdHlsaXNQbHVnaW5zIiwiaW5zZXJ0ZWQiLCJub2Rlc1RvSHlkcmF0ZSIsImF0dHJpYiIsIl9pbnNlcnQiLCJvbW5pcHJlc2VudFBsdWdpbnMiLCJjdXJyZW50U2hlZXQiLCJmaW5hbGl6aW5nUGx1Z2lucyIsInNlcmlhbGl6ZXIiLCJjb25jYXQiLCJzdHlsaXMiLCJzdHlsZXMiLCJzZWxlY3RvciIsInNlcmlhbGl6ZWQiLCJzaG91bGRDYWNoZSIsIl9maW5hbGl6aW5nUGx1Z2lucyIsIl9zZXJpYWxpemVyIiwiX3N0eWxpcyIsInNlcnZlclN0eWxpc0NhY2hlIiwicmVnaXN0ZXJlZCIsImlzQnJvd3NlciQ0IiwiZ2V0UmVnaXN0ZXJlZFN0eWxlcyQxIiwicmVnaXN0ZXJlZFN0eWxlcyIsImNsYXNzTmFtZXMiLCJyYXdDbGFzc05hbWUiLCJjbGFzc05hbWUiLCJyZWdpc3RlclN0eWxlcyQxIiwicmVnaXN0ZXJTdHlsZXMiLCJpc1N0cmluZ1RhZyIsImluc2VydFN0eWxlcyQxIiwiaW5zZXJ0U3R5bGVzIiwic3R5bGVzRm9yU1NSIiwiY3VycmVudCIsIm1heWJlU3R5bGVzIiwibXVybXVyMiQxIiwic3RyIiwiaCIsImxlbiIsInRvU3RyaW5nIiwidW5pdGxlc3NLZXlzJDEiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwibXNHcmlkUm93IiwibXNHcmlkUm93U3BhbiIsIm1zR3JpZENvbHVtbiIsIm1zR3JpZENvbHVtblNwYW4iLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsIldlYmtpdExpbmVDbGFtcCIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsIklMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDIiLCJVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiQxIiwiaHlwaGVuYXRlUmVnZXgkMSIsImFuaW1hdGlvblJlZ2V4JDEiLCJpc0N1c3RvbVByb3BlcnR5JDEiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNQcm9jZXNzYWJsZVZhbHVlJDEiLCJpc1Byb2Nlc3NhYmxlVmFsdWUiLCJwcm9jZXNzU3R5bGVOYW1lJDEiLCJzdHlsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInByb2Nlc3NTdHlsZVZhbHVlJDEiLCJwcm9jZXNzU3R5bGVWYWx1ZSIsInAxIiwicDIiLCJjdXJzb3IkMSIsImNvbnRlbnRWYWx1ZVBhdHRlcm4kMSIsImNvbnRlbnRWYWx1ZXMkMSIsIm9sZFByb2Nlc3NTdHlsZVZhbHVlJDEiLCJtc1BhdHRlcm4kMSIsImh5cGhlblBhdHRlcm4kMSIsImh5cGhlbmF0ZWRDYWNoZSQxIiwiY2hhckF0IiwicHJvY2Vzc2VkIiwiX2NoYXIiLCJ0b1VwcGVyQ2FzZSIsIm5vQ29tcG9uZW50U2VsZWN0b3JNZXNzYWdlJDEiLCJoYW5kbGVJbnRlcnBvbGF0aW9uJDEiLCJtZXJnZWRQcm9wcyIsImludGVycG9sYXRpb24iLCJfX2Vtb3Rpb25fc3R5bGVzIiwiYW5pbSIsImNyZWF0ZVN0cmluZ0Zyb21PYmplY3QkMSIsInByZXZpb3VzQ3Vyc29yIiwicmVzdWx0IiwibWF0Y2hlZCIsInJlcGxhY2VkIiwiZmFrZVZhck5hbWUiLCJjYWNoZWQiLCJvYmoiLCJzdHJpbmciLCJpc0FycmF5IiwiX2tleSIsIl9pIiwiaW50ZXJwb2xhdGVkIiwibGFiZWxQYXR0ZXJuJDEiLCJzb3VyY2VNYXBQYXR0ZXJuJDEiLCJzZXJpYWxpemVTdHlsZXMkMSIsInNlcmlhbGl6ZVN0eWxlcyIsImFyZ3MiLCJzdHJpbmdNb2RlIiwic3RyaW5ncyIsInNvdXJjZU1hcCIsImxhc3RJbmRleCIsImlkZW50aWZpZXJOYW1lIiwiaXNCcm93c2VyJDMiLCJzeW5jRmFsbGJhY2siLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3RBbHdheXNXaXRoU3luY0ZhbGxiYWNrIiwiaXNCcm93c2VyJDIiLCJFbW90aW9uQ2FjaGVDb250ZXh0IiwiSFRNTEVsZW1lbnQiLCJkaXNwbGF5TmFtZSIsIlByb3ZpZGVyIiwid2l0aEVtb3Rpb25DYWNoZSIsInJlZiIsIlRoZW1lQ29udGV4dCIsInR5cGVQcm9wTmFtZSIsImxhYmVsUHJvcE5hbWUiLCJJbnNlcnRpb24kMSIsIkluc2VydGlvbiIsIl9yZWYiLCJfcmVmMiIsInNlcmlhbGl6ZWROYW1lcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiRW1vdGlvbiIsImNzc1Byb3AiLCJjc3MiLCJXcmFwcGVkQ29tcG9uZW50IiwibGFiZWxGcm9tU3RhY2siLCJuZXdQcm9wcyIsImlzQnJvd3NlciQxIiwiZ2V0UmVnaXN0ZXJlZFN0eWxlcyIsIm11cm11cjIiLCJ1bml0bGVzc0tleXMiLCJJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQxIiwiVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IiLCJoeXBoZW5hdGVSZWdleCIsImFuaW1hdGlvblJlZ2V4IiwicHJvY2Vzc1N0eWxlTmFtZSIsImN1cnNvciIsImNvbnRlbnRWYWx1ZVBhdHRlcm4iLCJjb250ZW50VmFsdWVzIiwib2xkUHJvY2Vzc1N0eWxlVmFsdWUiLCJtc1BhdHRlcm4iLCJoeXBoZW5QYXR0ZXJuIiwiaHlwaGVuYXRlZENhY2hlIiwibm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UiLCJoYW5kbGVJbnRlcnBvbGF0aW9uIiwiY3JlYXRlU3RyaW5nRnJvbU9iamVjdCIsImxhYmVsUGF0dGVybiIsInNvdXJjZU1hcFBhdHRlcm4iLCJ0ZXN0T21pdFByb3BzT25TdHJpbmdUYWciLCJ0ZXN0T21pdFByb3BzT25Db21wb25lbnQiLCJnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AiLCJjb21wb3NlU2hvdWxkRm9yd2FyZFByb3BzIiwiaXNSZWFsIiwic2hvdWxkRm9yd2FyZFByb3AiLCJvcHRpb25zU2hvdWxkRm9yd2FyZFByb3AiLCJfX2Vtb3Rpb25fZm9yd2FyZFByb3AiLCJwcm9wTmFtZSIsIklMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SIiwiaXNCcm93c2VyIiwiY3JlYXRlU3R5bGVkIiwiX19lbW90aW9uX3JlYWwiLCJiYXNlVGFnIiwiX19lbW90aW9uX2Jhc2UiLCJ0YXJnZXRDbGFzc05hbWUiLCJsYWJlbCIsImRlZmF1bHRTaG91bGRGb3J3YXJkUHJvcCIsInNob3VsZFVzZUFzIiwiU3R5bGVkIiwiRmluYWxUYWciLCJhcyIsImNsYXNzSW50ZXJwb2xhdGlvbnMiLCJ0aGVtZSIsImZpbmFsU2hvdWxkRm9yd2FyZFByb3AiLCJkZWZhdWx0UHJvcHMiLCJ3aXRoQ29tcG9uZW50IiwibmV4dFRhZyIsIm5leHRPcHRpb25zIiwibmV3U3R5bGVkIiwidGFnTmFtZSIsImNsYXNzbmFtZXMkMSIsImV4cG9ydHMiLCJtb2R1bGUiLCJoYXNPd24iLCJjbGFzc2VzIiwiYXJnVHlwZSIsImlubmVyIiwiaW5jbHVkZXMiLCJkZWZhdWx0Iiwid2luZG93IiwiY2xhc3NuYW1lcyIsIkxlZ2FjeVNpZGViYXJDb250ZXh0IiwiU2lkZWJhclByb3ZpZGVyIiwiX2EiLCJfYiIsInVzZVN0YXRlIiwiY29sbGFwc2VkIiwidG9nZ2xlZCIsImJyb2tlbiIsInJ0bCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInNpZGViYXJTdGF0ZSIsInNldFNpZGViYXJTdGF0ZSIsInVwZGF0ZVNpZGViYXJTdGF0ZSIsInVzZUNhbGxiYWNrIiwidmFsdWVzIiwicHJldlN0YXRlIiwidXBkYXRlQ29sbGFwc2VTdGF0ZSIsIkJvb2xlYW4iLCJ1cGRhdGVUb2dnbGVTdGF0ZSIsInByb3ZpZGVyVmFsdWUiLCJ1c2VNZW1vIiwidXNlTGVnYWN5U2lkZWJhciIsImNvbnRleHQiLCJ1c2VNZWRpYVF1ZXJ5IiwiYnJlYWtwb2ludCIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwic2V0TWF0Y2hlcyIsInVzZUVmZmVjdCIsIm1lZGlhXzEiLCJoYW5kbGVNYXRjaF8xIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaWRlYmFyQ2xhc3NlcyIsImltYWdlIiwiYmFja2Ryb3AiLCJtZW51Q2xhc3NlcyIsIm1lbnVJdGVtUm9vdCIsInN1Yk1lbnVSb290IiwiYnV0dG9uIiwic3VmZml4IiwiaWNvbiIsInN1Yk1lbnVDb250ZW50IiwiU3ViTWVudUV4cGFuZEljb24iLCJkaXNhYmxlZCIsImFjdGl2ZSIsIm9wZW4iLCJTdHlsZWRCYWNrZHJvcCIsImRpdiIsInRlbXBsYXRlT2JqZWN0XzEkYiIsIkJSRUFLX1BPSU5UUyIsInhzIiwic20iLCJtZCIsImxnIiwieGwiLCJ4eGwiLCJhbHdheXMiLCJhbGwiLCJTdHlsZWRTaWRlYmFyIiwiYXNpZGUiLCJ0ZW1wbGF0ZU9iamVjdF8xJGEiLCJ3aWR0aCIsImNvbGxhcHNlZFdpZHRoIiwicm9vdFN0eWxlcyIsIlN0eWxlZFNpZGViYXJDb250YWluZXIiLCJ0ZW1wbGF0ZU9iamVjdF8yJDEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJTdHlsZWRTaWRlYmFySW1hZ2UiLCJpbWciLCJ0ZW1wbGF0ZU9iamVjdF8zJDEiLCJTaWRlYmFyQ29udGV4dCIsIlNpZGViYXIiLCJvbkJhY2tkcm9wQ2xpY2siLCJvbkJyZWFrUG9pbnQiLCJfYyIsIl9kIiwiZGVmYXVsdENvbGxhcHNlZCIsImJyZWFrUG9pbnQiLCJjdXN0b21CcmVha1BvaW50IiwiX2UiLCJfZiIsInJlc3QiLCJnZXRCcmVha3BvaW50VmFsdWUiLCJ3YXJuIiwiYnJlYWtwb2ludENhbGxiYWNrRm5SZWYiLCJ1c2VSZWYiLCJfZyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwibGVnYWN5U2lkZWJhckNvbnRleHQiLCJjb2xsYXBzZWRWYWx1ZSIsInRvZ2dsZWRWYWx1ZSIsImhhbmRsZUJhY2tkcm9wQ2xpY2siLCJzcmMiLCJhbHQiLCJyb2xlIiwidGFiSW5kZXgiLCJvbkNsaWNrIiwib25LZXlQcmVzcyIsIlN0eWxlZFVsIiwidWwiLCJ0ZW1wbGF0ZU9iamVjdF8xJDkiLCJTdHlsZWRNZW51IiwibmF2IiwidGVtcGxhdGVPYmplY3RfMSQ4IiwiTWVudUNvbnRleHQiLCJMZXZlbENvbnRleHQiLCJNZW51RlIiLCJjbG9zZU9uQ2xpY2siLCJtZW51SXRlbVN0eWxlcyIsInJlbmRlckV4cGFuZEljb24iLCJNZW51IiwidXNlTWVudSIsIlN0eWxlZFN1Yk1lbnVDb250ZW50IiwidGVtcGxhdGVPYmplY3RfMSQ3IiwiZmlyc3RMZXZlbCIsImRlZmF1bHRPcGVuIiwib3BlbldoZW5Db2xsYXBzZWQiLCJTdWJNZW51Q29udGVudEZSIiwiZGVmYXVsdE9wZW5TdGF0ZSIsIlN1Yk1lbnVDb250ZW50IiwiU3R5bGVkTWVudUxhYmVsIiwic3BhbiIsInRlbXBsYXRlT2JqZWN0XzEkNiIsIlN0eWxlZE1lbnVJY29uIiwidGVtcGxhdGVPYmplY3RfMSQ1IiwiU3R5bGVkTWVudVByZWZpeCIsInRlbXBsYXRlT2JqZWN0XzEkNCIsIlN0eWxlZE1lbnVTdWZmaXgiLCJ0ZW1wbGF0ZU9iamVjdF8xJDMiLCJTdHlsZWRFeHBhbmRJY29uV3JhcHBlciIsInRlbXBsYXRlT2JqZWN0XzEkMiIsImxldmVsIiwiU3R5bGVkRXhwYW5kSWNvbiIsInRlbXBsYXRlT2JqZWN0XzIiLCJTdHlsZWRFeHBhbmRJY29uQ29sbGFwc2VkIiwidGVtcGxhdGVPYmplY3RfMyIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsImdldFdpbmRvdyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzRWxlbWVudCIsIk93bkVsZW1lbnQiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJhcHBseVN0eWxlcyIsInN0YXRlIiwia2V5cyIsImVsZW1lbnRzIiwic3R5bGUiLCJhdHRyaWJ1dGVzIiwicmVtb3ZlQXR0cmlidXRlIiwiZWZmZWN0JDIiLCJpbml0aWFsU3R5bGVzIiwic3RyYXRlZ3kiLCJtYXJnaW4iLCJhcnJvdyIsInN0eWxlUHJvcGVydGllcyIsImF0dHJpYnV0ZSIsImFwcGx5U3R5bGVzJDEiLCJlbmFibGVkIiwicGhhc2UiLCJlZmZlY3QiLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJtYXgiLCJtaW4iLCJyb3VuZCIsImdldFVBU3RyaW5nIiwidWFEYXRhIiwibmF2aWdhdG9yIiwidXNlckFnZW50RGF0YSIsImJyYW5kcyIsIml0ZW0iLCJicmFuZCIsInZlcnNpb24iLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5IiwiY2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaGVpZ2h0IiwidmlzdWFsVmlld3BvcnQiLCJhZGRWaXN1YWxPZmZzZXRzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImdldExheW91dFJlY3QiLCJjb250YWlucyIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImlzU2FtZU5vZGUiLCJob3N0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzVGFibGVFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImZpbHRlciIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIndpdGhpbiIsIm1pbiQxIiwibWF4JDEiLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImFycm93JDEiLCJyZXF1aXJlc0lmRXhpc3RzIiwiZ2V0VmFyaWF0aW9uIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwid2luIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX09iamVjdCRhc3NpZ24yIiwicG9wcGVyUmVjdCIsInZhcmlhdGlvbiIsIm9mZnNldHMiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsImlzRml4ZWQiLCJfb2Zmc2V0cyR4IiwiX29mZnNldHMkeSIsIl9yZWYzIiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsIm9mZnNldFkiLCJvZmZzZXRYIiwiY29tbW9uU3R5bGVzIiwiX3JlZjQiLCJfT2JqZWN0JGFzc2lnbiIsImNvbXB1dGVTdHlsZXMiLCJfcmVmNSIsIl9vcHRpb25zJGdwdUFjY2VsZXJhdCIsIl9vcHRpb25zJGFkYXB0aXZlIiwiX29wdGlvbnMkcm91bmRPZmZzZXRzIiwidHJhbnNpdGlvblByb3BlcnR5Iiwic29tZSIsImNvbXB1dGVTdHlsZXMkMSIsImRhdGEiLCJwYXNzaXZlIiwiaW5zdGFuY2UiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwiZXZlbnRMaXN0ZW5lcnMiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImhhc2giLCJnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCIsImdldFdpbmRvd1Njcm9sbCIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldFZpZXdwb3J0UmVjdCIsImh0bWwiLCJsYXlvdXRWaWV3cG9ydCIsImdldERvY3VtZW50UmVjdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsIndpblNjcm9sbCIsImJvZHkiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJwbGFjZW1lbnRzJDEiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsInNvcnQiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiX3JldCIsInJlc2V0IiwiZmxpcCQxIiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJwb3BwZXJPZmZzZXRzJDEiLCJnZXRBbHRBeGlzIiwiX29wdGlvbnMkdGV0aGVyIiwidGV0aGVyIiwiX29wdGlvbnMkdGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUiLCJvZmZzZXRNb2RpZmllclN0YXRlIiwiX29mZnNldE1vZGlmaWVyU3RhdGUkIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIiwiX21haW5TaWRlIiwiX2FsdFNpZGUiLCJfb2Zmc2V0IiwiX2xlbiIsIl9taW4iLCJfbWF4IiwiaXNPcmlnaW5TaWRlIiwiX29mZnNldE1vZGlmaWVyVmFsdWUiLCJfdGV0aGVyTWluIiwiX3RldGhlck1heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJwcmV2ZW50T3ZlcmZsb3ckMSIsImdldEhUTUxFbGVtZW50U2Nyb2xsIiwiZ2V0Tm9kZVNjcm9sbCIsImlzRWxlbWVudFNjYWxlZCIsImdldENvbXBvc2l0ZVJlY3QiLCJlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50Iiwib2Zmc2V0UGFyZW50SXNTY2FsZWQiLCJtb2RpZmllcnMiLCJ2aXNpdGVkIiwiU2V0IiwibW9kaWZpZXIiLCJhZGQiLCJkZXAiLCJkZXBNb2RpZmllciIsIm9yZGVyTW9kaWZpZXJzIiwib3JkZXJlZE1vZGlmaWVycyIsImRlYm91bmNlIiwicGVuZGluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImZvcm1hdCIsImMiLCJJTlZBTElEX01PRElGSUVSX0VSUk9SIiwiTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SIiwiVkFMSURfUFJPUEVSVElFUyIsInZhbGlkYXRlTW9kaWZpZXJzIiwic2VsZiIsInJlcXVpcmVtZW50IiwibW9kIiwidW5pcXVlQnkiLCJhcnIiLCJpZGVudGlmaWVycyIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiZXhpc3RpbmciLCJJTlZBTElEX0VMRU1FTlRfRVJST1IiLCJJTkZJTklURV9MT09QX0VSUk9SIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwiZmxpcE1vZGlmaWVyIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwicGFyc2VGbG9hdCIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwiX19kZWJ1Z19sb29wc19fIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsInVzZVBvcHBlciIsImJ1dHRvblJlZiIsImNvbnRlbnRSZWYiLCJwb3BwZXJJbnN0YW5jZVJlZiIsInJvIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwic2V0VGltZW91dCIsInBvcHBlckluc3RhbmNlIiwibWVudUJ1dHRvblN0eWxlcyIsIk1lbnVCdXR0b25SZWYiLCJjb21wb25lbnQiLCJjbGFzc05hbWVQcm9wIiwiY2xvbmVFbGVtZW50IiwiTWVudUJ1dHRvbiIsIlN0eWxlZFN1Yk1lbnUiLCJsaSIsInRlbXBsYXRlT2JqZWN0XzEkMSIsImJ1dHRvblN0eWxlcyIsIlN1Yk1lbnVGUiIsInRpdGxlIiwib3BlbkNvbnRyb2xsZWQiLCJvbk9wZW5DaGFuZ2UiLCJvbktleVVwIiwic2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiIsInNldE9wZW4iLCJfaCIsInNldE9wZW5XaGVuQ29sbGFwc2VkIiwiX2oiLCJ0aW1lciIsImV4cGFuZENvbnRlbnQiLCJjb2xsYXBzZUNvbnRlbnQiLCJoYW5kbGVTbGlkZVRvZ2dsZSIsImNsZWFyVGltZW91dCIsIk51bWJlciIsImhhbmRsZU9uQ2xpY2siLCJldmVudCIsImhhbmRsZU9uS2V5VXAiLCJnZXRTdWJNZW51SXRlbVN0eWxlcyIsInBhcmFtcyIsImlzU3VibWVudSIsInJvb3RFbFN0eWxlcyIsImJ1dHRvbkVsU3R5bGVzIiwibGFiZWxFbFN0eWxlcyIsImljb25FbFN0eWxlcyIsInByZWZpeEVsU3R5bGVzIiwic3VmZml4RWxTdHlsZXMiLCJzdWJNZW51Q29udGVudEVsU3R5bGVzIiwiU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyIsImhhbmRsZVRvZ2dsZVBvcHBlciIsImNsb3Nlc3QiLCJjbGFzc0xpc3QiLCJoYW5kbGVEb2N1bWVudENsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlVcCIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwic2hhcmVkQ2xhc3NlcyIsIlN1Yk1lbnUiLCJTdHlsZWRNZW51SXRlbSIsInRlbXBsYXRlT2JqZWN0XzEiLCJNZW51SXRlbUZSIiwiZ2V0TWVudUl0ZW1TdHlsZXMiLCJNZW51SXRlbSIsIlByb1NpZGViYXJQcm92aWRlciIsInVzZVByb1NpZGViYXIiLCJjb2xsYXBzZVNpZGViYXIiLCJ0b2dnbGVTaWRlYmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pro-sidebar/dist/index.es.js\n");

/***/ })

};
;